{
  "id": "932e9f86-0bac-4236-82d3-6f4780d83c0c",
  "projectPath": "/home/ridgetop/projects/squire",
  "projectName": "squire",
  "status": "complete",
  "createdAt": "2026-01-17T03:21:54.318Z",
  "completedAt": "2026-01-17T03:22:05.840Z",
  "stats": {
    "totalFiles": 247,
    "totalFunctions": 1088,
    "totalClasses": 12,
    "totalConnections": 0,
    "totalWarnings": 204,
    "warningsByLevel": {
      "info": 194,
      "warning": 10,
      "error": 0
    },
    "nodesByType": {
      "file": 247,
      "function": 1088,
      "class": 12,
      "cluster": 0
    },
    "analyzedCount": 1060,
    "pendingAnalysis": 28
  },
  "nodes": {
    "file:src/cli.ts": {
      "id": "file:src/cli.ts",
      "type": "file",
      "name": "cli.ts",
      "filePath": "src/cli.ts",
      "line": 1,
      "endLine": 2711,
      "imports": [
        {
          "source": "commander",
          "items": [
            {
              "name": "Command",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "fs",
          "items": [
            {
              "name": "readFileSync",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/memories.js",
          "items": [
            {
              "name": "createMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/context.js",
          "items": [
            {
              "name": "generateContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listProfiles",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/entities.js",
          "items": [
            {
              "name": "listEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findEntityByName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countEntitiesByType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/consolidation.js",
          "items": [
            {
              "name": "consolidateAll",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getConsolidationStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/edges.js",
          "items": [
            {
              "name": "getRelatedMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEdgeStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/import.js",
          "items": [
            {
              "name": "parseImportFile",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "importMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getImportStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/summaries.js",
          "items": [
            {
              "name": "getAllSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateAllSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSummaryStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SUMMARY_CATEGORIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "classifyMemoryCategories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkMemoryToCategories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SummaryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/beliefs.js",
          "items": [
            {
              "name": "processMemoryForBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAllBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBelief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefEvidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUnresolvedConflicts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidBeliefType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BELIEF_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefTypeDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/patterns.js",
          "items": [
            {
              "name": "getAllPatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternEvidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidPatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PATTERN_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternTypeDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/insights.js",
          "items": [
            {
              "name": "getAllInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "actionInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidInsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "INSIGHT_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "INSIGHT_PRIORITIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightTypeDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightTypeEmoji",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPriorityEmoji",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightPriority",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/research.js",
          "items": [
            {
              "name": "getAllGaps",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGapSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGapStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fillGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAllQuestions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestionSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "askQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "answerQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GAP_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GAP_PRIORITIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QUESTION_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TIMING_HINTS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGapTypeEmoji",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestionTypeEmoji",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getTimingHintDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GapType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GapPriority",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QuestionType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TimingHint",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/graph.js",
          "items": [
            {
              "name": "findEntityNeighbors",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findSharedMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "traverseEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findPathBetweenEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntitySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGraphStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/entities.js",
          "items": [
            {
              "name": "getEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./services/objects.js",
          "items": [
            {
              "name": "createObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listObjects",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkToMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unlinkFromMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkToEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addTag",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "removeTag",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectTags",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAllTags",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCollectionById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listCollections",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addToCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "removeFromCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCollectionObjects",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "OBJECT_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ObjectType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "checkConnection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "closePool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./providers/embeddings.js",
          "items": [
            {
              "name": "checkEmbeddingHealth",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./providers/llm.js",
          "items": [
            {
              "name": "checkLLMHealth",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getLLMInfo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [],
      "functions": [
        "file:src/cli.ts:fn:formatBytes:2259"
      ],
      "classes": [],
      "topLevelReferences": [
        "program",
        "memory",
        "entities",
        "content",
        "options",
        "console",
        "e",
        "entityList",
        "classifications",
        "c",
        "categories",
        "beliefResult",
        "parts",
        "error",
        "process",
        "parseInt",
        "memories",
        "total",
        "Promise",
        "limit",
        "Date",
        "date",
        "preview",
        "parseFloat",
        "query",
        "minSimilarity",
        "results",
        "score",
        "similarity",
        "salience",
        "maxTokens",
        "JSON",
        "contextPackage",
        "profiles",
        "profile",
        "defaultTag",
        "weights",
        "counts",
        "Object",
        "a",
        "b",
        "totalCount",
        "entity",
        "lastSeen",
        "name",
        "result",
        "mem",
        "dbConnected",
        "embeddingConnected",
        "llmConnected",
        "llmInfo",
        "entityCounts",
        "consolidationStats",
        "edgeStats",
        "summaryStats",
        "entityTotal",
        "stats",
        "memoryId",
        "fullId",
        "related",
        "file",
        "tags",
        "minLength",
        "current",
        "err",
        "source",
        "count",
        "category",
        "summary",
        "cat",
        "summaries",
        "stale",
        "relevance",
        "unclassified",
        "classified",
        "totalCategories",
        "existing",
        "reclassified",
        "newLinks",
        "genResult",
        "conflicts",
        "beliefs",
        "status",
        "conf",
        "id",
        "belief",
        "all",
        "match",
        "evidence",
        "strength",
        "patterns",
        "p",
        "freq",
        "time",
        "day",
        "pattern",
        "insights",
        "i",
        "priorityEmoji",
        "emoji",
        "insight",
        "reason",
        "sources",
        "s",
        "gaps",
        "g",
        "surfaced",
        "severity",
        "gap",
        "questions",
        "q",
        "timing",
        "question",
        "entityArg",
        "matches",
        "minShared",
        "neighbors",
        "n",
        "entity1Arg",
        "entity1",
        "entity2Arg",
        "entity2",
        "shared",
        "m",
        "maxHops",
        "arrow",
        "Map",
        "byHops",
        "r",
        "hops",
        "memoryLimit",
        "entityLimit",
        "subgraph",
        "entityNodes",
        "attrs",
        "memoryNodes",
        "totalMemories",
        "edgeTypes",
        "objects",
        "obj",
        "formatBytes",
        "icon",
        "size",
        "desc",
        "idArg",
        "allObjects",
        "o",
        "t",
        "filePath",
        "filename",
        "mimeTypes",
        "ext",
        "Boolean",
        "mimeType",
        "data",
        "collections",
        "collection",
        "allCollections"
      ]
    },
    "file:src/cli.ts:fn:formatBytes:2259": {
      "id": "file:src/cli.ts:fn:formatBytes:2259",
      "type": "function",
      "name": "formatBytes",
      "filePath": "/home/ridgetop/projects/squire/src/cli.ts",
      "line": 2259,
      "endLine": 2265,
      "parentFileId": "file:src/cli.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "bytes",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts bytes to human-readable format like '1.2 MB'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;\n}",
      "references": [
        "Math",
        "k",
        "i",
        "sizes"
      ]
    },
    "file:src/index.ts": {
      "id": "file:src/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/index.ts",
      "line": 1,
      "endLine": 7,
      "imports": [],
      "exports": [
        {
          "name": "createMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "Memory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateMemoryInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateMemoryResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListMemoriesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchMemoriesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "checkConnection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "closePool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "config",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "Config",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./services/memories.js"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./db/pool.js"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./config/index.js"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/next.config.ts": {
      "id": "file:web/next.config.ts",
      "type": "file",
      "name": "next.config.ts",
      "filePath": "web/next.config.ts",
      "line": 1,
      "endLine": 32,
      "imports": [
        {
          "source": "next",
          "items": [
            {
              "name": "NextConfig",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "nextConfig",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:src/api/server.ts": {
      "id": "file:src/api/server.ts",
      "type": "file",
      "name": "server.ts",
      "filePath": "src/api/server.ts",
      "line": 1,
      "endLine": 152,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "express",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "http",
          "items": [
            {
              "name": "createServer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "socket.io",
          "items": [
            {
              "name": "Server",
              "alias": "SocketIOServer",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./socket/index.js",
          "items": [
            {
              "name": "registerSocketHandlers",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "setSocketServer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/memories.js",
          "items": [
            {
              "name": "memoriesRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/health.js",
          "items": [
            {
              "name": "healthRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/context.js",
          "items": [
            {
              "name": "contextRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/entities.js",
          "items": [
            {
              "name": "entitiesRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/consolidation.js",
          "items": [
            {
              "name": "consolidationRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/summaries.js",
          "items": [
            {
              "name": "summariesRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/beliefs.js",
          "items": [
            {
              "name": "beliefsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/patterns.js",
          "items": [
            {
              "name": "patternsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/insights.js",
          "items": [
            {
              "name": "insightsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/research.js",
          "items": [
            {
              "name": "researchRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/graph.js",
          "items": [
            {
              "name": "graphRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/objects.js",
          "items": [
            {
              "name": "objectsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/chat.js",
          "items": [
            {
              "name": "chatRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/commitments.js",
          "items": [
            {
              "name": "commitmentsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/reminders.js",
          "items": [
            {
              "name": "remindersRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/notifications.js",
          "items": [
            {
              "name": "notificationsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/google.js",
          "items": [
            {
              "name": "googleRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/calendar.js",
          "items": [
            {
              "name": "calendarRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/notes.js",
          "items": [
            {
              "name": "notesRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/lists.js",
          "items": [
            {
              "name": "listsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/identity.js",
          "items": [
            {
              "name": "identityRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./routes/documents.js",
          "items": [
            {
              "name": "documentsRouter",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/scheduler.js",
          "items": [
            {
              "name": "initScheduler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "shutdownScheduler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/identity.js",
          "items": [
            {
              "name": "migrateFromPersonalitySummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/google/sync.js",
          "items": [
            {
              "name": "syncAllAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "app",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/api/server.ts:fn:shutdown:135"
      ],
      "classes": [],
      "topLevelReferences": [
        "app",
        "httpServer",
        "io",
        "res",
        "console",
        "err",
        "port",
        "identity",
        "error",
        "results",
        "totalEvents",
        "r",
        "accountCount",
        "setTimeout",
        "runCalendarSync",
        "calendarSyncTimer",
        "setInterval",
        "CALENDAR_SYNC_INTERVAL_MS",
        "process",
        "shutdown"
      ]
    },
    "file:src/api/server.ts:fn:shutdown:135": {
      "id": "file:src/api/server.ts:fn:shutdown:135",
      "type": "function",
      "name": "shutdown",
      "filePath": "/home/ridgetop/projects/squire/src/api/server.ts",
      "line": 135,
      "endLine": 146,
      "parentFileId": "file:src/api/server.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Gracefully shuts down server: stops scheduler/timer, closes HTTP server, exits process.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "const shutdown = () => {\n  console.log('Shutting down gracefully...');\n  shutdownScheduler();\n  if (calendarSyncTimer) {\n    clearInterval(calendarSyncTimer);\n    calendarSyncTimer = null;\n  }\n  httpServer.close(() => {\n    console.log('Server closed');\n    process.exit(0);\n  });\n};",
      "references": [
        "console",
        "shutdownScheduler",
        "calendarSyncTimer",
        "clearInterval",
        "httpServer",
        "process"
      ]
    },
    "file:src/config/index.ts": {
      "id": "file:src/config/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/config/index.ts",
      "line": 1,
      "endLine": 51,
      "imports": [
        {
          "source": "dotenv",
          "items": [
            {
              "name": "dotenv",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "config",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "Config",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        }
      ],
      "functions": [
        "file:src/config/index.ts:fn:required:5",
        "file:src/config/index.ts:fn:optional:13"
      ],
      "classes": [],
      "topLevelReferences": [
        "Intl",
        "required",
        "parseInt",
        "optional",
        "process",
        "parseFloat"
      ]
    },
    "file:src/config/index.ts:fn:required:5": {
      "id": "file:src/config/index.ts:fn:required:5",
      "type": "function",
      "name": "required",
      "filePath": "/home/ridgetop/projects/squire/src/config/index.ts",
      "line": 5,
      "endLine": 11,
      "parentFileId": "file:src/config/index.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves required environment variable by name, throws error if missing",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function required(name: string): string {\n  const value = process.env[name];\n  if (!value) {\n    throw new Error(`Missing required environment variable: ${name}`);\n  }\n  return value;\n}",
      "references": [
        "process",
        "value",
        "Error"
      ]
    },
    "file:src/config/index.ts:fn:optional:13": {
      "id": "file:src/config/index.ts:fn:optional:13",
      "type": "function",
      "name": "optional",
      "filePath": "/home/ridgetop/projects/squire/src/config/index.ts",
      "line": 13,
      "endLine": 15,
      "parentFileId": "file:src/config/index.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "defaultValue",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves environment variable by name or returns default value",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function optional(name: string, defaultValue: string): string {\n  return process.env[name] ?? defaultValue;\n}",
      "references": [
        "process"
      ]
    },
    "file:src/db/migrate.ts": {
      "id": "file:src/db/migrate.ts",
      "type": "file",
      "name": "migrate.ts",
      "filePath": "src/db/migrate.ts",
      "line": 1,
      "endLine": 82,
      "imports": [
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "readdir",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "readFile",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "path",
          "items": [
            {
              "name": "join",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dirname",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "url",
          "items": [
            {
              "name": "fileURLToPath",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "closePool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [],
      "functions": [
        "file:src/db/migrate.ts:fn:ensureMigrationsTable:9",
        "file:src/db/migrate.ts:fn:getAppliedMigrations:19",
        "file:src/db/migrate.ts:fn:applyMigration:24",
        "file:src/db/migrate.ts:fn:migrate:43"
      ],
      "classes": [],
      "topLevelReferences": [
        "meta",
        "__dirname",
        "migrate"
      ]
    },
    "file:src/db/migrate.ts:fn:ensureMigrationsTable:9": {
      "id": "file:src/db/migrate.ts:fn:ensureMigrationsTable:9",
      "type": "function",
      "name": "ensureMigrationsTable",
      "filePath": "/home/ridgetop/projects/squire/src/db/migrate.ts",
      "line": 9,
      "endLine": 17,
      "parentFileId": "file:src/db/migrate.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates schema_migrations table if not exists via pool.query.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function ensureMigrationsTable(): Promise<void> {\n  await pool.query(`\n    CREATE TABLE IF NOT EXISTS schema_migrations (\n      id SERIAL PRIMARY KEY,\n      filename VARCHAR(255) NOT NULL UNIQUE,\n      applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n    )\n  `);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/db/migrate.ts:fn:getAppliedMigrations:19": {
      "id": "file:src/db/migrate.ts:fn:getAppliedMigrations:19",
      "type": "function",
      "name": "getAppliedMigrations",
      "filePath": "/home/ridgetop/projects/squire/src/db/migrate.ts",
      "line": 19,
      "endLine": 22,
      "parentFileId": "file:src/db/migrate.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<Set<string>>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves set of applied migration filenames from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getAppliedMigrations(): Promise<Set<string>> {\n  const result = await pool.query('SELECT filename FROM schema_migrations ORDER BY id');\n  return new Set(result.rows.map((row: { filename: string }) => row.filename));\n}",
      "references": [
        "pool",
        "Set",
        "result",
        "row"
      ]
    },
    "file:src/db/migrate.ts:fn:applyMigration:24": {
      "id": "file:src/db/migrate.ts:fn:applyMigration:24",
      "type": "function",
      "name": "applyMigration",
      "filePath": "/home/ridgetop/projects/squire/src/db/migrate.ts",
      "line": 24,
      "endLine": 41,
      "parentFileId": "file:src/db/migrate.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "filename",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sql",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Applies SQL migration to database and records filename in schema_migrations table.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function applyMigration(filename: string, sql: string): Promise<void> {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n    await client.query(sql);\n    await client.query(\n      'INSERT INTO schema_migrations (filename) VALUES ($1)',\n      [filename]\n    );\n    await client.query('COMMIT');\n    console.log(`  Applied: ${filename}`);\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}",
      "references": [
        "pool",
        "client",
        "console",
        "error"
      ]
    },
    "file:src/db/migrate.ts:fn:migrate:43": {
      "id": "file:src/db/migrate.ts:fn:migrate:43",
      "type": "function",
      "name": "migrate",
      "filePath": "/home/ridgetop/projects/squire/src/db/migrate.ts",
      "line": 43,
      "endLine": 79,
      "parentFileId": "file:src/db/migrate.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Runs database migrations by applying unapplied SQL files from SCHEMA_DIR",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": true,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "async function migrate(): Promise<void> {\n  console.log('Running database migrations...\\n');\n\n  try {\n    await ensureMigrationsTable();\n    const applied = await getAppliedMigrations();\n\n    const files = await readdir(SCHEMA_DIR);\n    const sqlFiles = files\n      .filter((f) => f.endsWith('.sql'))\n      .sort();\n\n    let appliedCount = 0;\n\n    for (const file of sqlFiles) {\n      if (applied.has(file)) {\n        console.log(`  Skipped: ${file} (already applied)`);\n        continue;\n      }\n\n      const sql = await readFile(join(SCHEMA_DIR, file), 'utf-8');\n      await applyMigration(file, sql);\n      appliedCount++;\n    }\n\n    if (appliedCount === 0) {\n      console.log('\\nNo new migrations to apply.');\n    } else {\n      console.log(`\\nApplied ${appliedCount} migration(s).`);\n    }\n  } catch (error) {\n    console.error('Migration failed:', error);\n    process.exit(1);\n  } finally {\n    await closePool();\n  }\n}",
      "references": [
        "console",
        "ensureMigrationsTable",
        "getAppliedMigrations",
        "readdir",
        "SCHEMA_DIR",
        "files",
        "f",
        "sqlFiles",
        "applied",
        "file",
        "readFile",
        "join",
        "applyMigration",
        "sql",
        "appliedCount",
        "error",
        "process",
        "closePool"
      ]
    },
    "file:src/db/pool.ts": {
      "id": "file:src/db/pool.ts",
      "type": "file",
      "name": "pool.ts",
      "filePath": "src/db/pool.ts",
      "line": 1,
      "endLine": 32,
      "imports": [
        {
          "source": "pg",
          "items": [
            {
              "name": "pg",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "checkConnection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "closePool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/db/pool.ts:fn:checkConnection:17",
        "file:src/db/pool.ts:fn:closePool:29"
      ],
      "classes": [],
      "topLevelReferences": [
        "Pool",
        "pool",
        "console",
        "err"
      ]
    },
    "file:src/db/pool.ts:fn:checkConnection:17": {
      "id": "file:src/db/pool.ts:fn:checkConnection:17",
      "type": "function",
      "name": "checkConnection",
      "filePath": "/home/ridgetop/projects/squire/src/db/pool.ts",
      "line": 17,
      "endLine": 27,
      "parentFileId": "file:src/db/pool.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks database connection by executing SELECT 1 query, returns true if successful.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function checkConnection(): Promise<boolean> {\n  try {\n    const client = await pool.connect();\n    await client.query('SELECT 1');\n    client.release();\n    return true;\n  } catch (error) {\n    console.error('Database connection check failed:', error);\n    return false;\n  }\n}",
      "references": [
        "pool",
        "client",
        "console",
        "error"
      ]
    },
    "file:src/db/pool.ts:fn:closePool:29": {
      "id": "file:src/db/pool.ts:fn:closePool:29",
      "type": "function",
      "name": "closePool",
      "filePath": "/home/ridgetop/projects/squire/src/db/pool.ts",
      "line": 29,
      "endLine": 31,
      "parentFileId": "file:src/db/pool.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Closes the database connection pool asynchronously.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export async function closePool(): Promise<void> {\n  await pool.end();\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/providers/embeddings.ts": {
      "id": "file:src/providers/embeddings.ts",
      "type": "file",
      "name": "embeddings.ts",
      "filePath": "src/providers/embeddings.ts",
      "line": 1,
      "endLine": 94,
      "imports": [
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "generateEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "checkEmbeddingHealth",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EmbeddingProvider",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/providers/embeddings.ts:fn:getEmbeddingProvider:53",
        "file:src/providers/embeddings.ts:fn:generateEmbedding:69",
        "file:src/providers/embeddings.ts:fn:generateEmbeddings:77",
        "file:src/providers/embeddings.ts:fn:checkEmbeddingHealth:85"
      ],
      "classes": [
        "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12"
      ],
      "topLevelReferences": []
    },
    "file:src/providers/embeddings.ts:fn:getEmbeddingProvider:53": {
      "id": "file:src/providers/embeddings.ts:fn:getEmbeddingProvider:53",
      "type": "function",
      "name": "getEmbeddingProvider",
      "filePath": "/home/ridgetop/projects/squire/src/providers/embeddings.ts",
      "line": 53,
      "endLine": 64,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/providers/embeddings\").EmbeddingProvider",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns singleton EmbeddingProvider based on config, initializing if needed",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function getEmbeddingProvider(): EmbeddingProvider {\n  if (!provider) {\n    switch (config.embedding.provider) {\n      case 'ollama':\n        provider = new OllamaEmbeddingProvider();\n        break;\n      default:\n        throw new Error(`Unknown embedding provider: ${config.embedding.provider}`);\n    }\n  }\n  return provider;\n}",
      "references": [
        "provider",
        "config",
        "OllamaEmbeddingProvider",
        "Error"
      ]
    },
    "file:src/providers/embeddings.ts:fn:generateEmbedding:69": {
      "id": "file:src/providers/embeddings.ts:fn:generateEmbedding:69",
      "type": "function",
      "name": "generateEmbedding",
      "filePath": "/home/ridgetop/projects/squire/src/providers/embeddings.ts",
      "line": 69,
      "endLine": 72,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates an embedding vector for the given text using the embedding provider.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateEmbedding(text: string): Promise<number[]> {\n  const embedder = getEmbeddingProvider();\n  return embedder.embed(text);\n}",
      "references": [
        "getEmbeddingProvider",
        "embedder"
      ]
    },
    "file:src/providers/embeddings.ts:fn:generateEmbeddings:77": {
      "id": "file:src/providers/embeddings.ts:fn:generateEmbeddings:77",
      "type": "function",
      "name": "generateEmbeddings",
      "filePath": "/home/ridgetop/projects/squire/src/providers/embeddings.ts",
      "line": 77,
      "endLine": 80,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "texts",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number[][]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embeddings for a batch of texts using an embedding provider.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateEmbeddings(texts: string[]): Promise<number[][]> {\n  const embedder = getEmbeddingProvider();\n  return embedder.embedBatch(texts);\n}",
      "references": [
        "getEmbeddingProvider",
        "embedder"
      ]
    },
    "file:src/providers/embeddings.ts:fn:checkEmbeddingHealth:85": {
      "id": "file:src/providers/embeddings.ts:fn:checkEmbeddingHealth:85",
      "type": "function",
      "name": "checkEmbeddingHealth",
      "filePath": "/home/ridgetop/projects/squire/src/providers/embeddings.ts",
      "line": 85,
      "endLine": 93,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks embedding provider health by embedding text and verifying dimension.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function checkEmbeddingHealth(): Promise<boolean> {\n  try {\n    const embedder = getEmbeddingProvider();\n    const result = await embedder.embed('health check');\n    return result.length === config.embedding.dimension;\n  } catch {\n    return false;\n  }\n}",
      "references": [
        "getEmbeddingProvider",
        "embedder",
        "result",
        "config"
      ]
    },
    "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embed:21": {
      "id": "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embed:21",
      "type": "function",
      "name": "embed",
      "filePath": "src/providers/embeddings.ts",
      "line": 21,
      "endLine": 38,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12",
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async embed(text: string): Promise<number[]> {\n    const response = await fetch(`${this.baseUrl}/api/embeddings`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        model: this.model,\n        prompt: text,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama embedding failed: ${response.status} - ${error}`);\n    }\n\n    const data = await response.json() as { embedding: number[] };\n    return data.embedding;\n  }",
      "references": [
        "fetch",
        "JSON",
        "response",
        "Error",
        "error",
        "data"
      ]
    },
    "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embedBatch:40": {
      "id": "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embedBatch:40",
      "type": "function",
      "name": "embedBatch",
      "filePath": "src/providers/embeddings.ts",
      "line": 40,
      "endLine": 44,
      "parentFileId": "file:src/providers/embeddings.ts",
      "parentClassId": "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12",
      "params": [
        {
          "name": "texts",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number[][]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async embedBatch(texts: string[]): Promise<number[][]> {\n    // Ollama doesn't have native batch support, so we parallelize\n    const results = await Promise.all(texts.map((text) => this.embed(text)));\n    return results;\n  }",
      "references": [
        "Promise",
        "text",
        "results"
      ]
    },
    "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12": {
      "id": "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12",
      "type": "class",
      "name": "OllamaEmbeddingProvider",
      "filePath": "src/providers/embeddings.ts",
      "line": 12,
      "endLine": 45,
      "parentFileId": "file:src/providers/embeddings.ts",
      "methods": [
        "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embed:21",
        "file:src/providers/embeddings.ts:class:OllamaEmbeddingProvider:12:method:embedBatch:40"
      ],
      "properties": [
        {
          "name": "baseUrl",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "model",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "EmbeddingProvider"
      ]
    },
    "file:src/providers/llm.ts": {
      "id": "file:src/providers/llm.ts",
      "type": "file",
      "name": "llm.ts",
      "filePath": "src/providers/llm.ts",
      "line": 1,
      "endLine": 524,
      "imports": [
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../tools/types.js",
          "items": [
            {
              "name": "ToolDefinition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolCall",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "complete",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "completeText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "checkLLMHealth",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getLLMInfo",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ToolDefinition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolCall",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "LLMMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "LLMCompletionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "LLMCompletionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "LLMProvider",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolDefinition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "../tools/types.js"
        },
        {
          "name": "ToolCall",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "../tools/types.js"
        }
      ],
      "functions": [
        "file:src/providers/llm.ts:fn:getLLMProvider:450",
        "file:src/providers/llm.ts:fn:complete:475",
        "file:src/providers/llm.ts:fn:completeText:486",
        "file:src/providers/llm.ts:fn:checkLLMHealth:505",
        "file:src/providers/llm.ts:fn:getLLMInfo:517"
      ],
      "classes": [
        "file:src/providers/llm.ts:class:GroqLLMProvider:63",
        "file:src/providers/llm.ts:class:XAILLMProvider:169",
        "file:src/providers/llm.ts:class:GeminiLLMProvider:274",
        "file:src/providers/llm.ts:class:OllamaLLMProvider:379"
      ],
      "topLevelReferences": []
    },
    "file:src/providers/llm.ts:fn:getLLMProvider:450": {
      "id": "file:src/providers/llm.ts:fn:getLLMProvider:450",
      "type": "function",
      "name": "getLLMProvider",
      "filePath": "/home/ridgetop/projects/squire/src/providers/llm.ts",
      "line": 450,
      "endLine": 470,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMProvider",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns singleton LLMProvider based on config, initializing if needed",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function getLLMProvider(): LLMProvider {\n  if (!provider) {\n    switch (config.llm.provider) {\n      case 'groq':\n        provider = new GroqLLMProvider();\n        break;\n      case 'xai':\n        provider = new XAILLMProvider();\n        break;\n      case 'gemini':\n        provider = new GeminiLLMProvider();\n        break;\n      case 'ollama':\n        provider = new OllamaLLMProvider();\n        break;\n      default:\n        throw new Error(`Unknown LLM provider: ${config.llm.provider}`);\n    }\n  }\n  return provider;\n}",
      "references": [
        "provider",
        "config",
        "GroqLLMProvider",
        "XAILLMProvider",
        "GeminiLLMProvider",
        "OllamaLLMProvider",
        "Error"
      ]
    },
    "file:src/providers/llm.ts:fn:complete:475": {
      "id": "file:src/providers/llm.ts:fn:complete:475",
      "type": "function",
      "name": "complete",
      "filePath": "/home/ridgetop/projects/squire/src/providers/llm.ts",
      "line": 475,
      "endLine": 481,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Delegates LLM message completion to the current provider.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function complete(\n  messages: LLMMessage[],\n  options?: LLMCompletionOptions\n): Promise<LLMCompletionResult> {\n  const llm = getLLMProvider();\n  return llm.complete(messages, options);\n}",
      "references": [
        "getLLMProvider",
        "llm"
      ]
    },
    "file:src/providers/llm.ts:fn:completeText:486": {
      "id": "file:src/providers/llm.ts:fn:completeText:486",
      "type": "function",
      "name": "completeText",
      "filePath": "/home/ridgetop/projects/squire/src/providers/llm.ts",
      "line": 486,
      "endLine": 500,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "prompt",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "systemPrompt",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Formats optional system and user prompts into messages and calls complete() for LLM text generation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.005Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function completeText(\n  prompt: string,\n  systemPrompt?: string,\n  options?: LLMCompletionOptions\n): Promise<string> {\n  const messages: LLMMessage[] = [];\n\n  if (systemPrompt) {\n    messages.push({ role: 'system', content: systemPrompt });\n  }\n  messages.push({ role: 'user', content: prompt });\n\n  const result = await complete(messages, options);\n  return result.content;\n}",
      "references": [
        "messages",
        "complete",
        "result"
      ]
    },
    "file:src/providers/llm.ts:fn:checkLLMHealth:505": {
      "id": "file:src/providers/llm.ts:fn:checkLLMHealth:505",
      "type": "function",
      "name": "checkLLMHealth",
      "filePath": "/home/ridgetop/projects/squire/src/providers/llm.ts",
      "line": 505,
      "endLine": 512,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks if the LLM provider is available by calling isAvailable() on it.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function checkLLMHealth(): Promise<boolean> {\n  try {\n    const llm = getLLMProvider();\n    return await llm.isAvailable();\n  } catch {\n    return false;\n  }\n}",
      "references": [
        "getLLMProvider",
        "llm"
      ]
    },
    "file:src/providers/llm.ts:fn:getLLMInfo:517": {
      "id": "file:src/providers/llm.ts:fn:getLLMInfo:517",
      "type": "function",
      "name": "getLLMInfo",
      "filePath": "/home/ridgetop/projects/squire/src/providers/llm.ts",
      "line": 517,
      "endLine": 523,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ provider: string; model: string; configured: boolean; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns LLM config info: provider, model, and configured status.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getLLMInfo(): { provider: string; model: string; configured: boolean } {\n  return {\n    provider: config.llm.provider,\n    model: config.llm.model,\n    configured: config.llm.provider === 'groq' ? !!config.llm.groqApiKey : true,\n  };\n}",
      "references": [
        "config"
      ]
    },
    "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:complete:73": {
      "id": "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:complete:73",
      "type": "function",
      "name": "complete",
      "filePath": "src/providers/llm.ts",
      "line": 73,
      "endLine": 142,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:GroqLLMProvider:63",
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async complete(\n    messages: LLMMessage[],\n    options: LLMCompletionOptions = {}\n  ): Promise<LLMCompletionResult> {\n    if (!this.apiKey) {\n      throw new Error('GROQ_API_KEY not configured');\n    }\n\n    // Build request body\n    const requestBody: Record<string, unknown> = {\n      model: this.model,\n      messages,\n      max_tokens: options.maxTokens ?? config.llm.maxTokens,\n      temperature: options.temperature ?? config.llm.temperature,\n      stop: options.stopSequences,\n    };\n\n    // Add tools if provided\n    if (options.tools && options.tools.length > 0) {\n      requestBody.tools = options.tools;\n      requestBody.tool_choice = options.toolChoice ?? 'auto';\n    }\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify(requestBody),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Groq API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      choices: Array<{\n        message: {\n          content: string | null;\n          tool_calls?: ToolCall[];\n        };\n        finish_reason: string;\n      }>;\n      usage: {\n        prompt_tokens: number;\n        completion_tokens: number;\n        total_tokens: number;\n      };\n      model: string;\n    };\n\n    const choice = data.choices[0];\n    const finishReason = choice?.finish_reason === 'tool_calls' ? 'tool_calls' :\n                         choice?.finish_reason === 'length' ? 'length' : 'stop';\n\n    return {\n      content: choice?.message?.content ?? '',\n      usage: {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens,\n      },\n      model: data.model,\n      provider: 'groq',\n      toolCalls: choice?.message?.tool_calls,\n      finishReason,\n    };\n  }",
      "references": [
        "Error",
        "config",
        "requestBody",
        "fetch",
        "JSON",
        "response",
        "error",
        "data",
        "choice",
        "finishReason"
      ]
    },
    "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:isAvailable:144": {
      "id": "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:isAvailable:144",
      "type": "function",
      "name": "isAvailable",
      "filePath": "src/providers/llm.ts",
      "line": 144,
      "endLine": 160,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:GroqLLMProvider:63",
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async isAvailable(): Promise<boolean> {\n    if (!this.apiKey) {\n      return false;\n    }\n\n    try {\n      // Simple health check - list models\n      const response = await fetch(`${this.baseUrl}/models`, {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n      });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }",
      "references": [
        "fetch",
        "response"
      ]
    },
    "file:src/providers/llm.ts:class:XAILLMProvider:169:method:complete:179": {
      "id": "file:src/providers/llm.ts:class:XAILLMProvider:169:method:complete:179",
      "type": "function",
      "name": "complete",
      "filePath": "src/providers/llm.ts",
      "line": 179,
      "endLine": 248,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:XAILLMProvider:169",
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async complete(\n    messages: LLMMessage[],\n    options: LLMCompletionOptions = {}\n  ): Promise<LLMCompletionResult> {\n    if (!this.apiKey) {\n      throw new Error('XAI_API_KEY not configured');\n    }\n\n    // Build request body\n    const requestBody: Record<string, unknown> = {\n      model: this.model,\n      messages,\n      max_tokens: options.maxTokens ?? config.llm.maxTokens,\n      temperature: options.temperature ?? config.llm.temperature,\n      stop: options.stopSequences,\n    };\n\n    // Add tools if provided\n    if (options.tools && options.tools.length > 0) {\n      requestBody.tools = options.tools;\n      requestBody.tool_choice = options.toolChoice ?? 'auto';\n    }\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify(requestBody),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`xAI API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      choices: Array<{\n        message: {\n          content: string | null;\n          tool_calls?: ToolCall[];\n        };\n        finish_reason: string;\n      }>;\n      usage: {\n        prompt_tokens: number;\n        completion_tokens: number;\n        total_tokens: number;\n      };\n      model: string;\n    };\n\n    const choice = data.choices[0];\n    const finishReason = choice?.finish_reason === 'tool_calls' ? 'tool_calls' :\n                         choice?.finish_reason === 'length' ? 'length' : 'stop';\n\n    return {\n      content: choice?.message?.content ?? '',\n      usage: {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens,\n      },\n      model: data.model,\n      provider: 'xai',\n      toolCalls: choice?.message?.tool_calls,\n      finishReason,\n    };\n  }",
      "references": [
        "Error",
        "config",
        "requestBody",
        "fetch",
        "JSON",
        "response",
        "error",
        "data",
        "choice",
        "finishReason"
      ]
    },
    "file:src/providers/llm.ts:class:XAILLMProvider:169:method:isAvailable:250": {
      "id": "file:src/providers/llm.ts:class:XAILLMProvider:169:method:isAvailable:250",
      "type": "function",
      "name": "isAvailable",
      "filePath": "src/providers/llm.ts",
      "line": 250,
      "endLine": 265,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:XAILLMProvider:169",
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async isAvailable(): Promise<boolean> {\n    if (!this.apiKey) {\n      return false;\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/models`, {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n      });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }",
      "references": [
        "fetch",
        "response"
      ]
    },
    "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:complete:284": {
      "id": "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:complete:284",
      "type": "function",
      "name": "complete",
      "filePath": "src/providers/llm.ts",
      "line": 284,
      "endLine": 353,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:GeminiLLMProvider:274",
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async complete(\n    messages: LLMMessage[],\n    options: LLMCompletionOptions = {}\n  ): Promise<LLMCompletionResult> {\n    if (!this.apiKey) {\n      throw new Error('GEMINI_API_KEY not configured');\n    }\n\n    // Build request body (OpenAI-compatible format)\n    const requestBody: Record<string, unknown> = {\n      model: this.model,\n      messages,\n      max_tokens: options.maxTokens ?? config.llm.maxTokens,\n      temperature: options.temperature ?? config.llm.temperature,\n      stop: options.stopSequences,\n    };\n\n    // Add tools if provided\n    if (options.tools && options.tools.length > 0) {\n      requestBody.tools = options.tools;\n      requestBody.tool_choice = options.toolChoice ?? 'auto';\n    }\n\n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n      body: JSON.stringify(requestBody),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Gemini API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      choices: Array<{\n        message: {\n          content: string | null;\n          tool_calls?: ToolCall[];\n        };\n        finish_reason: string;\n      }>;\n      usage: {\n        prompt_tokens: number;\n        completion_tokens: number;\n        total_tokens: number;\n      };\n      model: string;\n    };\n\n    const choice = data.choices[0];\n    const finishReason = choice?.finish_reason === 'tool_calls' ? 'tool_calls' :\n                         choice?.finish_reason === 'length' ? 'length' : 'stop';\n\n    return {\n      content: choice?.message?.content ?? '',\n      usage: {\n        promptTokens: data.usage.prompt_tokens,\n        completionTokens: data.usage.completion_tokens,\n        totalTokens: data.usage.total_tokens,\n      },\n      model: data.model,\n      provider: 'gemini',\n      toolCalls: choice?.message?.tool_calls,\n      finishReason,\n    };\n  }",
      "references": [
        "Error",
        "config",
        "requestBody",
        "fetch",
        "JSON",
        "response",
        "error",
        "data",
        "choice",
        "finishReason"
      ]
    },
    "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:isAvailable:355": {
      "id": "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:isAvailable:355",
      "type": "function",
      "name": "isAvailable",
      "filePath": "src/providers/llm.ts",
      "line": 355,
      "endLine": 370,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:GeminiLLMProvider:274",
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async isAvailable(): Promise<boolean> {\n    if (!this.apiKey) {\n      return false;\n    }\n\n    try {\n      const response = await fetch(`${this.baseUrl}/models`, {\n        headers: {\n          Authorization: `Bearer ${this.apiKey}`,\n        },\n      });\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }",
      "references": [
        "fetch",
        "response"
      ]
    },
    "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:complete:388": {
      "id": "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:complete:388",
      "type": "function",
      "name": "complete",
      "filePath": "src/providers/llm.ts",
      "line": 388,
      "endLine": 431,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:OllamaLLMProvider:379",
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMCompletionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async complete(\n    messages: LLMMessage[],\n    options: LLMCompletionOptions = {}\n  ): Promise<LLMCompletionResult> {\n    // Convert to Ollama's chat format\n    const response = await fetch(`${this.baseUrl}/api/chat`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        model: this.model,\n        messages,\n        stream: false,\n        options: {\n          num_predict: options.maxTokens ?? config.llm.maxTokens,\n          temperature: options.temperature ?? config.llm.temperature,\n          stop: options.stopSequences,\n        },\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Ollama API error: ${response.status} - ${error}`);\n    }\n\n    const data = (await response.json()) as {\n      message: { content: string };\n      model: string;\n      prompt_eval_count?: number;\n      eval_count?: number;\n    };\n\n    return {\n      content: data.message?.content ?? '',\n      usage: {\n        promptTokens: data.prompt_eval_count ?? 0,\n        completionTokens: data.eval_count ?? 0,\n        totalTokens: (data.prompt_eval_count ?? 0) + (data.eval_count ?? 0),\n      },\n      model: data.model,\n      provider: 'ollama',\n      finishReason: 'stop', // Ollama doesn't support tool calling yet\n    };\n  }",
      "references": [
        "fetch",
        "JSON",
        "config",
        "response",
        "Error",
        "error",
        "data"
      ]
    },
    "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:isAvailable:433": {
      "id": "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:isAvailable:433",
      "type": "function",
      "name": "isAvailable",
      "filePath": "src/providers/llm.ts",
      "line": 433,
      "endLine": 440,
      "parentFileId": "file:src/providers/llm.ts",
      "parentClassId": "file:src/providers/llm.ts:class:OllamaLLMProvider:379",
      "params": [],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async isAvailable(): Promise<boolean> {\n    try {\n      const response = await fetch(`${this.baseUrl}/api/tags`);\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }",
      "references": [
        "fetch",
        "response"
      ]
    },
    "file:src/providers/llm.ts:class:GroqLLMProvider:63": {
      "id": "file:src/providers/llm.ts:class:GroqLLMProvider:63",
      "type": "class",
      "name": "GroqLLMProvider",
      "filePath": "src/providers/llm.ts",
      "line": 63,
      "endLine": 161,
      "parentFileId": "file:src/providers/llm.ts",
      "methods": [
        "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:complete:73",
        "file:src/providers/llm.ts:class:GroqLLMProvider:63:method:isAvailable:144"
      ],
      "properties": [
        {
          "name": "apiKey",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "model",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "baseUrl",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "LLMProvider"
      ]
    },
    "file:src/providers/llm.ts:class:XAILLMProvider:169": {
      "id": "file:src/providers/llm.ts:class:XAILLMProvider:169",
      "type": "class",
      "name": "XAILLMProvider",
      "filePath": "src/providers/llm.ts",
      "line": 169,
      "endLine": 266,
      "parentFileId": "file:src/providers/llm.ts",
      "methods": [
        "file:src/providers/llm.ts:class:XAILLMProvider:169:method:complete:179",
        "file:src/providers/llm.ts:class:XAILLMProvider:169:method:isAvailable:250"
      ],
      "properties": [
        {
          "name": "apiKey",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "model",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "baseUrl",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "LLMProvider"
      ]
    },
    "file:src/providers/llm.ts:class:GeminiLLMProvider:274": {
      "id": "file:src/providers/llm.ts:class:GeminiLLMProvider:274",
      "type": "class",
      "name": "GeminiLLMProvider",
      "filePath": "src/providers/llm.ts",
      "line": 274,
      "endLine": 371,
      "parentFileId": "file:src/providers/llm.ts",
      "methods": [
        "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:complete:284",
        "file:src/providers/llm.ts:class:GeminiLLMProvider:274:method:isAvailable:355"
      ],
      "properties": [
        {
          "name": "apiKey",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "model",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "baseUrl",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "LLMProvider"
      ]
    },
    "file:src/providers/llm.ts:class:OllamaLLMProvider:379": {
      "id": "file:src/providers/llm.ts:class:OllamaLLMProvider:379",
      "type": "class",
      "name": "OllamaLLMProvider",
      "filePath": "src/providers/llm.ts",
      "line": 379,
      "endLine": 441,
      "parentFileId": "file:src/providers/llm.ts",
      "methods": [
        "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:complete:388",
        "file:src/providers/llm.ts:class:OllamaLLMProvider:379:method:isAvailable:433"
      ],
      "properties": [
        {
          "name": "baseUrl",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "model",
          "type": "string",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "LLMProvider"
      ]
    },
    "file:src/services/beliefs.ts": {
      "id": "file:src/services/beliefs.ts",
      "type": "file",
      "name": "beliefs.ts",
      "filePath": "src/services/beliefs.ts",
      "line": 1,
      "endLine": 686,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "completeText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getBelief",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBeliefsByType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBeliefsByEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBeliefEvidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getUnresolvedConflicts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "resolveConflict",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBeliefStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isValidBeliefType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBeliefTypeDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "processMemoryForBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BELIEF_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "BeliefType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Belief",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BeliefEvidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BeliefConflict",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BeliefExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/beliefs.ts:fn:extractBeliefsFromContent:78",
        "file:src/services/beliefs.ts:fn:findSimilarBelief:151",
        "file:src/services/beliefs.ts:fn:createBelief:182",
        "file:src/services/beliefs.ts:fn:getBelief:204",
        "file:src/services/beliefs.ts:fn:getAllBeliefs:215",
        "file:src/services/beliefs.ts:fn:getBeliefsByType:266",
        "file:src/services/beliefs.ts:fn:getBeliefsByEntity:273",
        "file:src/services/beliefs.ts:fn:reinforceBelief:286",
        "file:src/services/beliefs.ts:fn:supersedeBelief:310",
        "file:src/services/beliefs.ts:fn:linkEvidence:329",
        "file:src/services/beliefs.ts:fn:getBeliefEvidence:361",
        "file:src/services/beliefs.ts:fn:detectConflicts:380",
        "file:src/services/beliefs.ts:fn:getUnresolvedConflicts:473",
        "file:src/services/beliefs.ts:fn:resolveConflict:494",
        "file:src/services/beliefs.ts:fn:getBeliefStats:549",
        "file:src/services/beliefs.ts:fn:isValidBeliefType:607",
        "file:src/services/beliefs.ts:fn:getBeliefTypeDescription:614",
        "file:src/services/beliefs.ts:fn:processMemoryForBeliefs:640"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/beliefs.ts:fn:extractBeliefsFromContent:78": {
      "id": "file:src/services/beliefs.ts:fn:extractBeliefsFromContent:78",
      "type": "function",
      "name": "extractBeliefsFromContent",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 78,
      "endLine": 143,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ExtractedBelief[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts beliefs from content via AI completion API, parses and filters JSON response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function extractBeliefsFromContent(\n  content: string\n): Promise<ExtractedBelief[]> {\n  const systemPrompt = `You are a belief extractor. Given a memory/observation, identify any beliefs the person holds.\n\nA belief is a persistent conviction or understanding, NOT just a fact or observation.\n\nBelief types:\n- value: Core values (\"I value honesty\", \"Family is important to me\")\n- preference: Preferences (\"I prefer working in the morning\", \"I like remote work\")\n- self_knowledge: Self-understanding (\"I work best under pressure\", \"I'm an introvert\")\n- prediction: Expectations (\"This project will succeed\", \"The market will recover\")\n- about_person: Beliefs about others (\"Sarah is reliable\", \"Tom is ambitious\")\n- about_project: Beliefs about work/projects (\"This codebase is well-designed\")\n- about_world: General beliefs (\"Remote work is the future\", \"AI will transform work\")\n- should: Normative beliefs (\"I should prioritize health\", \"One should always be honest\")\n\nReturn ONLY a JSON array of beliefs found. Include confidence (0.0-1.0).\nIf no beliefs are present, return an empty array: []\n\nFormat: [{\"content\": \"belief statement\", \"belief_type\": \"type\", \"confidence\": 0.X, \"entity_name\": \"name if about_person/about_project\", \"reason\": \"why this is a belief\"}]`;\n\n  const prompt = `Memory: \"${content}\"\n\nWhat beliefs does this memory reveal? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.2,\n      maxTokens: 500,\n    });\n\n    // Parse JSON response\n    const jsonMatch = response.match(/\\[[\\s\\S]*?\\]/);\n    if (!jsonMatch) {\n      return [];\n    }\n\n    const extracted = JSON.parse(jsonMatch[0]) as Array<{\n      content: string;\n      belief_type: string;\n      confidence: number;\n      entity_name?: string;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    return extracted\n      .filter(\n        (b) =>\n          BELIEF_TYPES.includes(b.belief_type as BeliefType) &&\n          b.content &&\n          b.confidence >= 0.3\n      )\n      .map((b) => ({\n        content: b.content,\n        belief_type: b.belief_type as BeliefType,\n        confidence: Math.min(1.0, Math.max(0.0, b.confidence)),\n        entity_name: b.entity_name,\n        reason: b.reason || '',\n      }));\n  } catch (error) {\n    console.error('Belief extraction failed:', error);\n    return [];\n  }\n}",
      "references": [
        "completeText",
        "prompt",
        "systemPrompt",
        "response",
        "jsonMatch",
        "JSON",
        "extracted",
        "BELIEF_TYPES",
        "b",
        "Math",
        "console",
        "error"
      ]
    },
    "file:src/services/beliefs.ts:fn:findSimilarBelief:151": {
      "id": "file:src/services/beliefs.ts:fn:findSimilarBelief:151",
      "type": "function",
      "name": "findSimilarBelief",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 151,
      "endLine": 175,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "beliefType",
          "type": "\"value\" | \"preference\" | \"self_knowledge\" | \"prediction\" | \"about_person\" | \"about_project\" | \"about_world\" | \"should\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for active belief matching normalized content and type exactly.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findSimilarBelief(\n  content: string,\n  beliefType: BeliefType\n): Promise<Belief | null> {\n  // Normalize for comparison\n  const normalized = content.toLowerCase().trim();\n\n  // Look for beliefs of same type with similar content\n  const result = await pool.query<Belief>(\n    `SELECT * FROM beliefs\n     WHERE belief_type = $1\n       AND status = 'active'\n       AND LOWER(content) = $2\n     LIMIT 1`,\n    [beliefType, normalized]\n  );\n\n  if (result.rows[0]) {\n    return result.rows[0];\n  }\n\n  // TODO: Add embedding-based similarity search\n  // For now, exact match only\n  return null;\n}",
      "references": [
        "pool",
        "normalized",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:createBelief:182": {
      "id": "file:src/services/beliefs.ts:fn:createBelief:182",
      "type": "function",
      "name": "createBelief",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 182,
      "endLine": 199,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "beliefType",
          "type": "\"value\" | \"preference\" | \"self_knowledge\" | \"prediction\" | \"about_person\" | \"about_project\" | \"about_world\" | \"should\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "confidence",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "relatedEntityId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new belief into the database and returns the created record",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function createBelief(\n  content: string,\n  beliefType: BeliefType,\n  confidence: number,\n  relatedEntityId?: string,\n  model?: string\n): Promise<Belief> {\n  const result = await pool.query<Belief>(\n    `INSERT INTO beliefs (\n       content, belief_type, related_entity_id, confidence,\n       extracted_by_model, extraction_prompt_version\n     )\n     VALUES ($1, $2, $3, $4, $5, 'v1')\n     RETURNING *`,\n    [content, beliefType, relatedEntityId || null, confidence, model || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBelief:204": {
      "id": "file:src/services/beliefs.ts:fn:getBelief:204",
      "type": "function",
      "name": "getBelief",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 204,
      "endLine": 210,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a belief by ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBelief(id: string): Promise<Belief | null> {\n  const result = await pool.query<Belief>(\n    `SELECT * FROM beliefs WHERE id = $1`,\n    [id]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:getAllBeliefs:215": {
      "id": "file:src/services/beliefs.ts:fn:getAllBeliefs:215",
      "type": "function",
      "name": "getAllBeliefs",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 215,
      "endLine": 261,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ type?: \"value\" | \"preference\" | \"self_knowledge\" | \"prediction\" | \"about_person\" | \"about_project\" | \"about_world\" | \"should\"; status?: string; minConfidence?: number; limit?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for beliefs with optional filters on type, status, confidence, and limit",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllBeliefs(options?: {\n  type?: BeliefType;\n  status?: string;\n  minConfidence?: number;\n  limit?: number;\n}): Promise<Belief[]> {\n  const conditions: string[] = [];\n  const params: (string | number)[] = [];\n  let paramCount = 0;\n\n  if (options?.type) {\n    paramCount++;\n    conditions.push(`belief_type = $${paramCount}`);\n    params.push(options.type);\n  }\n\n  if (options?.status) {\n    paramCount++;\n    conditions.push(`status = $${paramCount}`);\n    params.push(options.status);\n  } else {\n    conditions.push(`status = 'active'`);\n  }\n\n  if (options?.minConfidence) {\n    paramCount++;\n    conditions.push(`confidence >= $${paramCount}`);\n    params.push(options.minConfidence);\n  }\n\n  const whereClause = conditions.length > 0\n    ? `WHERE ${conditions.join(' AND ')}`\n    : '';\n\n  const limit = options?.limit || 100;\n  paramCount++;\n  params.push(limit);\n\n  const result = await pool.query<Belief>(\n    `SELECT * FROM beliefs\n     ${whereClause}\n     ORDER BY confidence DESC, reinforcement_count DESC\n     LIMIT $${paramCount}`,\n    params\n  );\n  return result.rows;\n}",
      "references": [
        "paramCount",
        "conditions",
        "params",
        "limit",
        "pool",
        "whereClause",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBeliefsByType:266": {
      "id": "file:src/services/beliefs.ts:fn:getBeliefsByType:266",
      "type": "function",
      "name": "getBeliefsByType",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 266,
      "endLine": 268,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"value\" | \"preference\" | \"self_knowledge\" | \"prediction\" | \"about_person\" | \"about_project\" | \"about_world\" | \"should\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves beliefs filtered by the specified type via getAllBeliefs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBeliefsByType(type: BeliefType): Promise<Belief[]> {\n  return getAllBeliefs({ type });\n}",
      "references": [
        "getAllBeliefs"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBeliefsByEntity:273": {
      "id": "file:src/services/beliefs.ts:fn:getBeliefsByEntity:273",
      "type": "function",
      "name": "getBeliefsByEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 273,
      "endLine": 281,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active beliefs for a given entity ID from database, ordered by confidence DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBeliefsByEntity(entityId: string): Promise<Belief[]> {\n  const result = await pool.query<Belief>(\n    `SELECT * FROM beliefs\n     WHERE related_entity_id = $1 AND status = 'active'\n     ORDER BY confidence DESC`,\n    [entityId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:reinforceBelief:286": {
      "id": "file:src/services/beliefs.ts:fn:reinforceBelief:286",
      "type": "function",
      "name": "reinforceBelief",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 286,
      "endLine": 305,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "beliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "confidenceBoost",
          "type": "number",
          "isOptional": true,
          "defaultValue": "0.1"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").Belief>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates belief confidence, reinforcement count, and timestamps via SQL UPDATE",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function reinforceBelief(\n  beliefId: string,\n  confidenceBoost: number = 0.1\n): Promise<Belief> {\n  const result = await pool.query<Belief>(\n    `UPDATE beliefs\n     SET confidence = LEAST(1.0, confidence + $2),\n         reinforcement_count = reinforcement_count + 1,\n         last_reinforced_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [beliefId, confidenceBoost]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Belief not found: ${beliefId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/beliefs.ts:fn:supersedeBelief:310": {
      "id": "file:src/services/beliefs.ts:fn:supersedeBelief:310",
      "type": "function",
      "name": "supersedeBelief",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 310,
      "endLine": 322,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "oldBeliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "newBeliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates belief status to superseded with new belief ID in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function supersedeBelief(\n  oldBeliefId: string,\n  newBeliefId: string\n): Promise<void> {\n  await pool.query(\n    `UPDATE beliefs\n     SET status = 'superseded',\n         superseded_by = $2,\n         updated_at = NOW()\n     WHERE id = $1`,\n    [oldBeliefId, newBeliefId]\n  );\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/beliefs.ts:fn:linkEvidence:329": {
      "id": "file:src/services/beliefs.ts:fn:linkEvidence:329",
      "type": "function",
      "name": "linkEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 329,
      "endLine": 356,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "beliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "supportStrength",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "evidenceType",
          "type": "\"supports\" | \"contradicts\" | \"nuances\"",
          "isOptional": true,
          "defaultValue": "'supports'"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefEvidence>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Upserts evidence link between belief and memory, updates belief's source memory count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function linkEvidence(\n  beliefId: string,\n  memoryId: string,\n  supportStrength: number,\n  evidenceType: 'supports' | 'contradicts' | 'nuances' = 'supports'\n): Promise<BeliefEvidence> {\n  const result = await pool.query<BeliefEvidence>(\n    `INSERT INTO belief_evidence (belief_id, memory_id, support_strength, evidence_type)\n     VALUES ($1, $2, $3, $4)\n     ON CONFLICT (belief_id, memory_id)\n     DO UPDATE SET support_strength = $3, evidence_type = $4\n     RETURNING *`,\n    [beliefId, memoryId, supportStrength, evidenceType]\n  );\n\n  // Update source memory count\n  await pool.query(\n    `UPDATE beliefs\n     SET source_memory_count = (\n       SELECT COUNT(*) FROM belief_evidence WHERE belief_id = $1\n     ),\n     updated_at = NOW()\n     WHERE id = $1`,\n    [beliefId]\n  );\n\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBeliefEvidence:361": {
      "id": "file:src/services/beliefs.ts:fn:getBeliefEvidence:361",
      "type": "function",
      "name": "getBeliefEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 361,
      "endLine": 373,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "beliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefEvidence & { memory_content: string; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves belief evidence with memory content for a given belief ID from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBeliefEvidence(\n  beliefId: string\n): Promise<Array<BeliefEvidence & { memory_content: string }>> {\n  const result = await pool.query<BeliefEvidence & { memory_content: string }>(\n    `SELECT be.*, m.content as memory_content\n     FROM belief_evidence be\n     JOIN memories m ON m.id = be.memory_id\n     WHERE be.belief_id = $1\n     ORDER BY be.support_strength DESC`,\n    [beliefId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:detectConflicts:380": {
      "id": "file:src/services/beliefs.ts:fn:detectConflicts:380",
      "type": "function",
      "name": "detectConflicts",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 380,
      "endLine": 468,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "beliefId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefConflict[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects conflicts between a belief and other active beliefs using LLM, creates DB conflict records",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectConflicts(\n  beliefId: string\n): Promise<BeliefConflict[]> {\n  const belief = await getBelief(beliefId);\n  if (!belief) return [];\n\n  // Get other active beliefs of the same type\n  const otherBeliefs = await pool.query<Belief>(\n    `SELECT * FROM beliefs\n     WHERE id != $1\n       AND status = 'active'\n       AND belief_type = $2`,\n    [beliefId, belief.belief_type]\n  );\n\n  if (otherBeliefs.rows.length === 0) return [];\n\n  // Use LLM to detect conflicts\n  const systemPrompt = `You are a belief conflict detector. Given a new belief and a list of existing beliefs, identify any conflicts.\n\nConflict types:\n- direct_contradiction: The beliefs cannot both be true\n- tension: The beliefs are in tension but could coexist in different contexts\n- evolution: The new belief appears to be an update/evolution of an older belief\n\nReturn ONLY a JSON array of conflicts found.\nFormat: [{\"existing_belief_id\": \"...\", \"conflict_type\": \"...\", \"description\": \"brief explanation\"}]\n\nIf no conflicts, return: []`;\n\n  const existingList = otherBeliefs.rows\n    .map((b) => `- ID: ${b.id}, Content: \"${b.content}\"`)\n    .join('\\n');\n\n  const prompt = `New belief: \"${belief.content}\"\n\nExisting beliefs of type \"${belief.belief_type}\":\n${existingList}\n\nIdentify any conflicts. Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.1,\n      maxTokens: 500,\n    });\n\n    const jsonMatch = response.match(/\\[[\\s\\S]*?\\]/);\n    if (!jsonMatch) return [];\n\n    const conflicts = JSON.parse(jsonMatch[0]) as Array<{\n      existing_belief_id: string;\n      conflict_type: string;\n      description: string;\n    }>;\n\n    // Create conflict records\n    const createdConflicts: BeliefConflict[] = [];\n    for (const c of conflicts) {\n      if (!['direct_contradiction', 'tension', 'evolution'].includes(c.conflict_type)) {\n        continue;\n      }\n\n      const result = await pool.query<BeliefConflict>(\n        `INSERT INTO belief_conflicts (belief_a_id, belief_b_id, conflict_type, conflict_description)\n         VALUES ($1, $2, $3, $4)\n         ON CONFLICT (belief_a_id, belief_b_id) DO NOTHING\n         RETURNING *`,\n        [beliefId, c.existing_belief_id, c.conflict_type, c.description]\n      );\n\n      if (result.rows[0]) {\n        createdConflicts.push(result.rows[0]);\n\n        // Mark beliefs as conflicted\n        await pool.query(\n          `UPDATE beliefs SET status = 'conflicted', updated_at = NOW()\n           WHERE id IN ($1, $2) AND status = 'active'`,\n          [beliefId, c.existing_belief_id]\n        );\n      }\n    }\n\n    return createdConflicts;\n  } catch (error) {\n    console.error('Conflict detection failed:', error);\n    return [];\n  }\n}",
      "references": [
        "getBelief",
        "belief",
        "pool",
        "otherBeliefs",
        "b",
        "existingList",
        "completeText",
        "prompt",
        "systemPrompt",
        "response",
        "jsonMatch",
        "JSON",
        "conflicts",
        "c",
        "result",
        "createdConflicts",
        "console",
        "error"
      ]
    },
    "file:src/services/beliefs.ts:fn:getUnresolvedConflicts:473": {
      "id": "file:src/services/beliefs.ts:fn:getUnresolvedConflicts:473",
      "type": "function",
      "name": "getUnresolvedConflicts",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 473,
      "endLine": 489,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefConflict & { belief_a_content: string; belief_b_content: string; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves unresolved belief conflicts with belief contents from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getUnresolvedConflicts(): Promise<\n  Array<BeliefConflict & { belief_a_content: string; belief_b_content: string }>\n> {\n  const result = await pool.query<\n    BeliefConflict & { belief_a_content: string; belief_b_content: string }\n  >(\n    `SELECT bc.*,\n            ba.content as belief_a_content,\n            bb.content as belief_b_content\n     FROM belief_conflicts bc\n     JOIN beliefs ba ON ba.id = bc.belief_a_id\n     JOIN beliefs bb ON bb.id = bc.belief_b_id\n     WHERE bc.resolution_status = 'unresolved'\n     ORDER BY bc.detected_at DESC`\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:resolveConflict:494": {
      "id": "file:src/services/beliefs.ts:fn:resolveConflict:494",
      "type": "function",
      "name": "resolveConflict",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 494,
      "endLine": 542,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conflictId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "resolution",
          "type": "\"belief_a_active\" | \"belief_b_active\" | \"both_valid\" | \"merged\" | \"user_resolved\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefConflict>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Resolves belief conflict by updating status in DB and adjusting belief statuses",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function resolveConflict(\n  conflictId: string,\n  resolution: 'belief_a_active' | 'belief_b_active' | 'both_valid' | 'merged' | 'user_resolved',\n  notes?: string\n): Promise<BeliefConflict> {\n  const conflict = await pool.query<BeliefConflict>(\n    `SELECT * FROM belief_conflicts WHERE id = $1`,\n    [conflictId]\n  );\n\n  if (!conflict.rows[0]) {\n    throw new Error(`Conflict not found: ${conflictId}`);\n  }\n\n  const c = conflict.rows[0];\n\n  // Update conflict status\n  const result = await pool.query<BeliefConflict>(\n    `UPDATE belief_conflicts\n     SET resolution_status = $2,\n         resolution_notes = $3,\n         resolved_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [conflictId, resolution, notes || null]\n  );\n\n  // Update belief statuses based on resolution\n  if (resolution === 'belief_a_active') {\n    await supersedeBelief(c.belief_b_id, c.belief_a_id);\n    await pool.query(\n      `UPDATE beliefs SET status = 'active', updated_at = NOW() WHERE id = $1`,\n      [c.belief_a_id]\n    );\n  } else if (resolution === 'belief_b_active') {\n    await supersedeBelief(c.belief_a_id, c.belief_b_id);\n    await pool.query(\n      `UPDATE beliefs SET status = 'active', updated_at = NOW() WHERE id = $1`,\n      [c.belief_b_id]\n    );\n  } else if (resolution === 'both_valid') {\n    await pool.query(\n      `UPDATE beliefs SET status = 'active', updated_at = NOW() WHERE id IN ($1, $2)`,\n      [c.belief_a_id, c.belief_b_id]\n    );\n  }\n\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "conflict",
        "Error",
        "supersedeBelief",
        "c",
        "result"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBeliefStats:549": {
      "id": "file:src/services/beliefs.ts:fn:getBeliefStats:549",
      "type": "function",
      "name": "getBeliefStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 549,
      "endLine": 600,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; conflicted: number; superseded: number; byType: Record<string, number>; avgConfidence: number; unresolvedConflicts: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves belief statistics: counts by status/type, avg confidence, unresolved conflicts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBeliefStats(): Promise<{\n  total: number;\n  active: number;\n  conflicted: number;\n  superseded: number;\n  byType: Record<string, number>;\n  avgConfidence: number;\n  unresolvedConflicts: number;\n}> {\n  const result = await pool.query<{\n    total: string;\n    active: string;\n    conflicted: string;\n    superseded: string;\n    avg_confidence: string;\n  }>(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE status = 'active') as active,\n      COUNT(*) FILTER (WHERE status = 'conflicted') as conflicted,\n      COUNT(*) FILTER (WHERE status = 'superseded') as superseded,\n      AVG(confidence) as avg_confidence\n    FROM beliefs\n  `);\n\n  const byTypeResult = await pool.query<{ belief_type: string; count: string }>(`\n    SELECT belief_type, COUNT(*) as count\n    FROM beliefs\n    WHERE status = 'active'\n    GROUP BY belief_type\n  `);\n\n  const conflictResult = await pool.query<{ count: string }>(`\n    SELECT COUNT(*) as count FROM belief_conflicts WHERE resolution_status = 'unresolved'\n  `);\n\n  const row = result.rows[0]!;\n  const byType: Record<string, number> = {};\n  for (const r of byTypeResult.rows) {\n    byType[r.belief_type] = parseInt(r.count, 10);\n  }\n\n  return {\n    total: parseInt(row.total, 10),\n    active: parseInt(row.active, 10),\n    conflicted: parseInt(row.conflicted, 10),\n    superseded: parseInt(row.superseded, 10),\n    byType,\n    avgConfidence: parseFloat(row.avg_confidence) || 0,\n    unresolvedConflicts: parseInt(conflictResult.rows[0]?.count || '0', 10),\n  };\n}",
      "references": [
        "pool",
        "result",
        "byTypeResult",
        "byType",
        "r",
        "parseInt",
        "row",
        "parseFloat",
        "conflictResult"
      ]
    },
    "file:src/services/beliefs.ts:fn:isValidBeliefType:607": {
      "id": "file:src/services/beliefs.ts:fn:isValidBeliefType:607",
      "type": "function",
      "name": "isValidBeliefType",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 607,
      "endLine": 609,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if a string is a valid BeliefType by checking inclusion in BELIEF_TYPES array.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isValidBeliefType(type: string): type is BeliefType {\n  return BELIEF_TYPES.includes(type as BeliefType);\n}",
      "references": [
        "BELIEF_TYPES"
      ]
    },
    "file:src/services/beliefs.ts:fn:getBeliefTypeDescription:614": {
      "id": "file:src/services/beliefs.ts:fn:getBeliefTypeDescription:614",
      "type": "function",
      "name": "getBeliefTypeDescription",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 614,
      "endLine": 626,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"value\" | \"preference\" | \"self_knowledge\" | \"prediction\" | \"about_person\" | \"about_project\" | \"about_world\" | \"should\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a description string for a given BeliefType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getBeliefTypeDescription(type: BeliefType): string {\n  const descriptions: Record<BeliefType, string> = {\n    value: 'Core values and principles',\n    preference: 'Personal preferences',\n    self_knowledge: 'Self-understanding and traits',\n    prediction: 'Expectations and predictions',\n    about_person: 'Beliefs about other people',\n    about_project: 'Beliefs about work and projects',\n    about_world: 'General world beliefs',\n    should: 'Normative beliefs (what should be)',\n  };\n  return descriptions[type];\n}",
      "references": [
        "descriptions"
      ]
    },
    "file:src/services/beliefs.ts:fn:processMemoryForBeliefs:640": {
      "id": "file:src/services/beliefs.ts:fn:processMemoryForBeliefs:640",
      "type": "function",
      "name": "processMemoryForBeliefs",
      "filePath": "/home/ridgetop/projects/squire/src/services/beliefs.ts",
      "line": 640,
      "endLine": 685,
      "parentFileId": "file:src/services/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/beliefs\").BeliefExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts beliefs from memory content, creates/reinforces them in DB, links evidence, detects conflicts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.006Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processMemoryForBeliefs(\n  memoryId: string,\n  content: string,\n  model?: string\n): Promise<BeliefExtractionResult> {\n  const result: BeliefExtractionResult = {\n    created: [],\n    reinforced: [],\n    conflicts: [],\n  };\n\n  // Extract beliefs from content\n  const extracted = await extractBeliefsFromContent(content);\n  if (extracted.length === 0) {\n    return result;\n  }\n\n  for (const ext of extracted) {\n    // Check if similar belief already exists\n    const existing = await findSimilarBelief(ext.content, ext.belief_type);\n\n    if (existing) {\n      // Reinforce existing belief\n      const reinforced = await reinforceBelief(existing.id, 0.05);\n      await linkEvidence(existing.id, memoryId, ext.confidence, 'supports');\n      result.reinforced.push({ belief: reinforced, wasReinforced: true });\n    } else {\n      // Create new belief\n      const belief = await createBelief(\n        ext.content,\n        ext.belief_type,\n        ext.confidence,\n        undefined, // TODO: resolve entity_name to entity_id\n        model\n      );\n      await linkEvidence(belief.id, memoryId, ext.confidence, 'supports');\n      result.created.push(belief);\n\n      // Check for conflicts with existing beliefs\n      const conflicts = await detectConflicts(belief.id);\n      result.conflicts.push(...conflicts);\n    }\n  }\n\n  return result;\n}",
      "references": [
        "extractBeliefsFromContent",
        "extracted",
        "result",
        "findSimilarBelief",
        "ext",
        "existing",
        "reinforceBelief",
        "linkEvidence",
        "reinforced",
        "createBelief",
        "belief",
        "detectConflicts",
        "conflicts"
      ]
    },
    "file:src/services/chat.ts": {
      "id": "file:src/services/chat.ts",
      "type": "file",
      "name": "chat.ts",
      "filePath": "src/services/chat.ts",
      "line": 1,
      "endLine": 271,
      "imports": [
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMCompletionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./context.js",
          "items": [
            {
              "name": "generateContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ContextPackage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../tools/index.js",
          "items": [
            {
              "name": "getToolDefinitions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "executeTools",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "hasTools",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "chat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "chatSimple",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ChatMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatRequest",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/chat.ts:fn:getCurrentDateTimeString:55",
        "file:src/services/chat.ts:fn:buildMessages:128",
        "file:src/services/chat.ts:fn:chat:160",
        "file:src/services/chat.ts:fn:chatSimple:259"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/chat.ts:fn:getCurrentDateTimeString:55": {
      "id": "file:src/services/chat.ts:fn:getCurrentDateTimeString:55",
      "type": "function",
      "name": "getCurrentDateTimeString",
      "filePath": "/home/ridgetop/projects/squire/src/services/chat.ts",
      "line": 55,
      "endLine": 71,
      "parentFileId": "file:src/services/chat.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns current date and time as a formatted string using specified timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCurrentDateTimeString(): string {\n  const now = new Date();\n\n  // Format: \"Monday, December 29, 2025 at 8:14 AM EST\"\n  const options: Intl.DateTimeFormatOptions = {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZoneName: 'short',\n    timeZone: config.timezone, // Auto-detected from system\n  };\n\n  return now.toLocaleString('en-US', options);\n}",
      "references": [
        "Date",
        "config",
        "now",
        "options"
      ]
    },
    "file:src/services/chat.ts:fn:buildMessages:128": {
      "id": "file:src/services/chat.ts:fn:buildMessages:128",
      "type": "function",
      "name": "buildMessages",
      "filePath": "/home/ridgetop/projects/squire/src/services/chat.ts",
      "line": 128,
      "endLine": 153,
      "parentFileId": "file:src/services/chat.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "userMessage",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationHistory",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chat\").ChatMessage[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "contextMarkdown",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/providers/llm\").LLMMessage[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Builds LLM message array with system prompt, recent history, and user message",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function buildMessages(\n  userMessage: string,\n  conversationHistory: ChatMessage[],\n  contextMarkdown?: string\n): LLMMessage[] {\n  const messages: LLMMessage[] = [];\n\n  // System prompt with date/time grounding and optional context\n  const dateTimeGrounding = `**Current date and time**: ${getCurrentDateTimeString()}\\n\\n`;\n  let systemContent = dateTimeGrounding + SQUIRE_SYSTEM_PROMPT;\n  if (contextMarkdown) {\n    systemContent += `\\n\\n---\\n\\n${contextMarkdown}`;\n  }\n  messages.push({ role: 'system', content: systemContent });\n\n  // Add conversation history (last N messages to fit context)\n  const recentHistory = conversationHistory.slice(-10); // Keep last 10 exchanges\n  for (const msg of recentHistory) {\n    messages.push({ role: msg.role, content: msg.content });\n  }\n\n  // Add current user message\n  messages.push({ role: 'user', content: userMessage });\n\n  return messages;\n}",
      "references": [
        "getCurrentDateTimeString",
        "dateTimeGrounding",
        "SQUIRE_SYSTEM_PROMPT",
        "systemContent",
        "messages",
        "recentHistory",
        "msg"
      ]
    },
    "file:src/services/chat.ts:fn:chat:160": {
      "id": "file:src/services/chat.ts:fn:chat:160",
      "type": "function",
      "name": "chat",
      "filePath": "/home/ridgetop/projects/squire/src/services/chat.ts",
      "line": 160,
      "endLine": 254,
      "parentFileId": "file:src/services/chat.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "request",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chat\").ChatRequest",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chat\").ChatResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Handles chat requests by generating context, calling LLM with tools, and looping tool executions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function chat(request: ChatRequest): Promise<ChatResponse> {\n  const {\n    message,\n    conversationHistory = [],\n    includeContext = true,\n    contextQuery,\n    contextProfile,\n    maxContextTokens,\n  } = request;\n\n  let contextPackage: ContextPackage | undefined;\n  let contextMarkdown: string | undefined;\n\n  // Fetch context if requested\n  if (includeContext) {\n    try {\n      contextPackage = await generateContext({\n        query: contextQuery ?? message,\n        profile: contextProfile,\n        maxTokens: maxContextTokens,\n      });\n      contextMarkdown = contextPackage.markdown;\n    } catch (error) {\n      console.error('Failed to generate context:', error);\n      // Continue without context rather than failing\n    }\n  }\n\n  // Build messages for LLM\n  const messages = buildMessages(message, conversationHistory, contextMarkdown);\n\n  // Get available tools\n  const tools = hasTools() ? getToolDefinitions() : undefined;\n\n  // Call LLM with tools\n  let result: LLMCompletionResult = await complete(messages, { tools });\n\n  // Tool calling loop - handle tool calls until we get a final response\n  const maxToolIterations = 5; // Prevent infinite loops\n  let iterations = 0;\n\n  while (result.finishReason === 'tool_calls' && result.toolCalls?.length && iterations < maxToolIterations) {\n    iterations++;\n    console.log(`Tool call iteration ${iterations}: ${result.toolCalls.map((t) => t.function.name).join(', ')}`);\n\n    // Execute all tool calls in parallel\n    const toolResults = await executeTools(result.toolCalls);\n\n    // Add assistant message with tool calls to conversation\n    messages.push({\n      role: 'assistant',\n      content: result.content,\n      tool_calls: result.toolCalls,\n    });\n\n    // Add tool results to conversation\n    for (const tr of toolResults) {\n      messages.push({\n        role: 'tool',\n        tool_call_id: tr.toolCallId,\n        content: tr.result,\n      });\n      console.log(`Tool ${tr.name} result: ${tr.success ? 'success' : 'failed'}`);\n    }\n\n    // Re-prompt LLM with tool results\n    result = await complete(messages, { tools });\n  }\n\n  if (iterations >= maxToolIterations) {\n    console.warn(`Tool calling reached max iterations (${maxToolIterations})`);\n  }\n\n  // Build response\n  const response: ChatResponse = {\n    message: result.content,\n    role: 'assistant',\n    usage: result.usage,\n    model: result.model,\n    provider: result.provider,\n  };\n\n  // Add context metadata if available\n  if (contextPackage) {\n    response.context = {\n      memoryCount: contextPackage.memories.length,\n      entityCount: contextPackage.entities.length,\n      summaryCount: contextPackage.summaries.length,\n      tokenCount: contextPackage.token_count,\n      disclosureId: contextPackage.disclosure_id,\n    };\n  }\n\n  return response;\n}",
      "references": [
        "message",
        "conversationHistory",
        "includeContext",
        "contextQuery",
        "contextProfile",
        "maxContextTokens",
        "contextPackage",
        "generateContext",
        "contextMarkdown",
        "console",
        "error",
        "buildMessages",
        "hasTools",
        "getToolDefinitions",
        "complete",
        "messages",
        "tools",
        "result",
        "iterations",
        "maxToolIterations",
        "t",
        "executeTools",
        "toolResults",
        "tr",
        "response"
      ]
    },
    "file:src/services/chat.ts:fn:chatSimple:259": {
      "id": "file:src/services/chat.ts:fn:chatSimple:259",
      "type": "function",
      "name": "chatSimple",
      "filePath": "/home/ridgetop/projects/squire/src/services/chat.ts",
      "line": 259,
      "endLine": 269,
      "parentFileId": "file:src/services/chat.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "history",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chat\").ChatMessage[]",
          "isOptional": true,
          "defaultValue": "[]"
        }
      ],
      "returnType": "Promise<string>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Wrapper that calls chat() with message, history, includeContext:false and returns response.message",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function chatSimple(\n  message: string,\n  history: ChatMessage[] = []\n): Promise<string> {\n  const response = await chat({\n    message,\n    conversationHistory: history,\n    includeContext: false,\n  });\n  return response.message;\n}",
      "references": [
        "chat",
        "response"
      ]
    },
    "file:src/services/chatExtraction.ts": {
      "id": "file:src/services/chatExtraction.ts",
      "type": "file",
      "name": "chatExtraction.ts",
      "filePath": "src/services/chatExtraction.ts",
      "line": 1,
      "endLine": 1992,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "createMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./beliefs.js",
          "items": [
            {
              "name": "processMemoryForBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./summaries.js",
          "items": [
            {
              "name": "classifyMemoryCategories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkMemoryToCategories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CategoryClassification",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./commitments.js",
          "items": [
            {
              "name": "createCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./reminders.js",
          "items": [
            {
              "name": "createStandaloneReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createScheduledReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./resolution.js",
          "items": [
            {
              "name": "processMessagesForResolutions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ResolutionCandidate",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./identity.js",
          "items": [
            {
              "name": "getUserIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "setInitialIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./storyEngine.js",
          "items": [
            {
              "name": "invalidateStoryCache",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./reinforcement.js",
          "items": [
            {
              "name": "checkReinforcement",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "extractMemoriesFromChat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "processMessageRealTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExtractedMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationForExtraction",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PendingMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ConversationModeResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/chatExtraction.ts:fn:calibrateSalienceForBiographical:45",
        "file:src/services/chatExtraction.ts:fn:extractEventDate:141",
        "file:src/services/chatExtraction.ts:fn:formatDateInTimezone:348",
        "file:src/services/chatExtraction.ts:fn:getDayOfWeekInTimezone:365",
        "file:src/services/chatExtraction.ts:fn:getDateForDayOfWeek:379",
        "file:src/services/chatExtraction.ts:fn:getDateTimeContext:399",
        "file:src/services/chatExtraction.ts:fn:classifyConversationMode:490",
        "file:src/services/chatExtraction.ts:fn:getCommitmentDetectionPrompt:566",
        "file:src/services/chatExtraction.ts:fn:getReminderDetectionPrompt:638",
        "file:src/services/chatExtraction.ts:fn:safeParseJSON:762",
        "file:src/services/chatExtraction.ts:fn:detectReminderRequest:793",
        "file:src/services/chatExtraction.ts:fn:detectCommitment:827",
        "file:src/services/chatExtraction.ts:fn:getPendingConversations:936",
        "file:src/services/chatExtraction.ts:fn:getPendingMessages:953",
        "file:src/services/chatExtraction.ts:fn:buildTranscript:971",
        "file:src/services/chatExtraction.ts:fn:extractFromTranscript:980",
        "file:src/services/chatExtraction.ts:fn:markMessagesExtracted:1043",
        "file:src/services/chatExtraction.ts:fn:markMessagesSkipped:1061",
        "file:src/services/chatExtraction.ts:fn:extractFromConversation:1079",
        "file:src/services/chatExtraction.ts:fn:extractMemoriesFromChat:1384",
        "file:src/services/chatExtraction.ts:fn:processMessageRealTime:1444",
        "file:src/services/chatExtraction.ts:fn:detectIdentityWithLLM:1733",
        "file:src/services/chatExtraction.ts:fn:extractIdentityRealTime:1773",
        "file:src/services/chatExtraction.ts:fn:extractRelationshipsRealTime:1867"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/chatExtraction.ts:fn:calibrateSalienceForBiographical:45": {
      "id": "file:src/services/chatExtraction.ts:fn:calibrateSalienceForBiographical:45",
      "type": "function",
      "name": "calibrateSalienceForBiographical",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 45,
      "endLine": 131,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mem",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ExtractedMemory",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "classifications",
          "type": "{ category: string; relevance: number; }[]",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calibrates salience score for memories based on biographical relevance like personality, origins, and dates.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calibrateSalienceForBiographical(\n  mem: ExtractedMemory,\n  classifications?: Array<{ category: string; relevance: number }>\n): number {\n  const base = mem.salience_hint ?? 5;\n  const content = mem.content.toLowerCase();\n\n  // Check classifications if provided\n  const hasPersonality = classifications?.some(\n    (c) => c.category === 'personality' && c.relevance >= 0.6\n  ) ?? false;\n  const hasRelationships = classifications?.some(\n    (c) => c.category === 'relationships' && c.relevance >= 0.6\n  ) ?? false;\n\n  // Identity and core personality facts  highest salience\n  if (hasPersonality && (mem.type === 'fact' || mem.type === 'event')) {\n    // User's name, core identity  10\n    if (content.includes(\"user's name is\") || content.includes('name is')) {\n      return 10;\n    }\n    return Math.max(base, 9);\n  }\n\n  // Origin story patterns - these should NEVER be filtered out\n  const originPatterns = [\n    'first time',\n    'where it all started',\n    'origin story',\n    'this is how',\n    'this is why',\n    'changed my life',\n    'life-changing',\n    'pivotal moment',\n    'turning point',\n    'when i realized',\n    'when i decided',\n    'the day i',\n    'the moment i',\n    'began my journey',\n    'started my',\n    'how i got into',\n    'how it all began',\n  ];\n\n  const hasOriginPattern = originPatterns.some((p) => content.includes(p));\n  if (hasOriginPattern && (mem.type === 'event' || mem.type === 'fact')) {\n    return Math.max(base, 9);\n  }\n\n  // Significant dates with emotional/biographical meaning\n  const datePatterns = [\n    /\\b(january|february|march|april|may|june|july|august|september|october|november|december)\\s+\\d{1,2}/i,\n    /\\b\\d{1,2}\\/\\d{1,2}\\/\\d{2,4}\\b/,\n    /\\b(birthday|anniversary|wedding|graduation|funeral|passed away|died)\\b/i,\n  ];\n  \n  const hasSignificantDate = datePatterns.some((p) => p.test(content));\n  if (hasSignificantDate && (mem.type === 'event' || mem.type === 'fact')) {\n    return Math.max(base, 8);\n  }\n\n  // Relationship-defining content  high salience\n  if (hasRelationships && mem.type === 'event') {\n    return Math.max(base, 8);\n  }\n\n  // Key life facts: age, occupation, location\n  const lifeFactPatterns = [\n    /\\b\\d+\\s*years?\\s*old\\b/i,\n    /works?\\s+(at|for)\\b/i,\n    /lives?\\s+in\\b/i,\n    /(wife|husband|spouse|partner|daughter|son|child|mother|father|parent)/i,\n  ];\n  \n  const hasLifeFact = lifeFactPatterns.some((p) => p.test(content));\n  if (hasLifeFact && mem.type === 'fact') {\n    return Math.max(base, 8);\n  }\n\n  // Goals and aspirations  moderately high\n  if (mem.type === 'goal') {\n    return Math.max(base, 7);\n  }\n\n  return base;\n}",
      "references": [
        "c",
        "hasPersonality",
        "content",
        "Math",
        "base",
        "originPatterns",
        "p",
        "hasOriginPattern",
        "datePatterns",
        "hasSignificantDate",
        "hasRelationships",
        "lifeFactPatterns",
        "hasLifeFact"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractEventDate:141": {
      "id": "file:src/services/chatExtraction.ts:fn:extractEventDate:141",
      "type": "function",
      "name": "extractEventDate",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 141,
      "endLine": 196,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Date",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Extracts date from text using regex for month-day-year, MM/DD/YYYY, and ISO formats",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.007Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function extractEventDate(content: string): Date | null {\n  const text = content.toLowerCase();\n\n  // Month names and abbreviations\n  const months: Record<string, number> = {\n    january: 0, jan: 0,\n    february: 1, feb: 1,\n    march: 2, mar: 2,\n    april: 3, apr: 3,\n    may: 4,\n    june: 5, jun: 5,\n    july: 6, jul: 6,\n    august: 7, aug: 7,\n    september: 8, sep: 8, sept: 8,\n    october: 9, oct: 9,\n    november: 10, nov: 10,\n    december: 11, dec: 11,\n  };\n\n  // Pattern: \"Month Day, Year\" or \"Month Day Year\" (e.g., \"February 16, 2025\")\n  const fullDateMatch = text.match(\n    /\\b(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|jun|jul|aug|sep|sept|oct|nov|dec)\\s+(\\d{1,2})(?:st|nd|rd|th)?,?\\s*(\\d{4})\\b/i\n  );\n  if (fullDateMatch && fullDateMatch[1] && fullDateMatch[2] && fullDateMatch[3]) {\n    const month = months[fullDateMatch[1].toLowerCase()];\n    const day = parseInt(fullDateMatch[2], 10);\n    const year = parseInt(fullDateMatch[3], 10);\n    if (month !== undefined && day >= 1 && day <= 31 && year >= 1900 && year <= 2100) {\n      return new Date(year, month, day);\n    }\n  }\n\n  // Pattern: \"MM/DD/YYYY\" or \"M/D/YYYY\"\n  const numericMatch = text.match(/\\b(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})\\b/);\n  if (numericMatch && numericMatch[1] && numericMatch[2] && numericMatch[3]) {\n    const month = parseInt(numericMatch[1], 10) - 1;\n    const day = parseInt(numericMatch[2], 10);\n    const year = parseInt(numericMatch[3], 10);\n    if (month >= 0 && month <= 11 && day >= 1 && day <= 31 && year >= 1900 && year <= 2100) {\n      return new Date(year, month, day);\n    }\n  }\n\n  // Pattern: \"YYYY-MM-DD\" (ISO format)\n  const isoMatch = text.match(/\\b(\\d{4})-(\\d{2})-(\\d{2})\\b/);\n  if (isoMatch && isoMatch[1] && isoMatch[2] && isoMatch[3]) {\n    const year = parseInt(isoMatch[1], 10);\n    const month = parseInt(isoMatch[2], 10) - 1;\n    const day = parseInt(isoMatch[3], 10);\n    if (month >= 0 && month <= 11 && day >= 1 && day <= 31 && year >= 1900 && year <= 2100) {\n      return new Date(year, month, day);\n    }\n  }\n\n  return null;\n}",
      "references": [
        "text",
        "fullDateMatch",
        "months",
        "parseInt",
        "month",
        "day",
        "year",
        "Date",
        "numericMatch",
        "isoMatch"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:formatDateInTimezone:348": {
      "id": "file:src/services/chatExtraction.ts:fn:formatDateInTimezone:348",
      "type": "function",
      "name": "formatDateInTimezone",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 348,
      "endLine": 360,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "timezone",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a Date to YYYY-MM-DD string using specified timezone via Intl.DateTimeFormat.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.008Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDateInTimezone(date: Date, timezone: string): string {\n  const parts = new Intl.DateTimeFormat('en-CA', {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    timeZone: timezone,\n  }).formatToParts(date);\n\n  const year = parts.find(p => p.type === 'year')?.value;\n  const month = parts.find(p => p.type === 'month')?.value;\n  const day = parts.find(p => p.type === 'day')?.value;\n  return `${year}-${month}-${day}`;\n}",
      "references": [
        "Intl",
        "parts",
        "p",
        "year",
        "month",
        "day"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getDayOfWeekInTimezone:365": {
      "id": "file:src/services/chatExtraction.ts:fn:getDayOfWeekInTimezone:365",
      "type": "function",
      "name": "getDayOfWeekInTimezone",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 365,
      "endLine": 373,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "timezone",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns day of week index (0=Sunday) for a date in specified timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.008Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDayOfWeekInTimezone(date: Date, timezone: string): number {\n  const dayName = new Intl.DateTimeFormat('en-US', {\n    weekday: 'long',\n    timeZone: timezone,\n  }).format(date);\n\n  const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  return days.indexOf(dayName);\n}",
      "references": [
        "Intl",
        "days",
        "dayName"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getDateForDayOfWeek:379": {
      "id": "file:src/services/chatExtraction.ts:fn:getDateForDayOfWeek:379",
      "type": "function",
      "name": "getDateForDayOfWeek",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 379,
      "endLine": 393,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "dayOfWeek",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "timezone",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Gets date for given day of week (0-6) in timezone, this/next week from now.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.008Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDateForDayOfWeek(dayOfWeek: number, timezone: string): string {\n  const now = new Date();\n  const todayDow = getDayOfWeekInTimezone(now, timezone);\n\n  // Calculate days until the target day (this week)\n  let daysUntil = dayOfWeek - todayDow;\n  if (daysUntil < 0) {\n    daysUntil += 7; // Target is next week\n  }\n\n  const targetDate = new Date(now);\n  targetDate.setDate(targetDate.getDate() + daysUntil);\n\n  return formatDateInTimezone(targetDate, timezone);\n}",
      "references": [
        "Date",
        "getDayOfWeekInTimezone",
        "now",
        "todayDow",
        "daysUntil",
        "targetDate",
        "formatDateInTimezone"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getDateTimeContext:399": {
      "id": "file:src/services/chatExtraction.ts:fn:getDateTimeContext:399",
      "type": "function",
      "name": "getDateTimeContext",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 399,
      "endLine": 443,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ iso: string; formatted: string; dayOfWeek: string; todayIso: string; tomorrowIso: string; weekdayDates: Record<string, string>; }",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns current date/time context with ISO, formatted, day of week, today/tomorrow ISO, and weekday dates.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.009Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDateTimeContext(): {\n  iso: string;\n  formatted: string;\n  dayOfWeek: string;\n  todayIso: string;\n  tomorrowIso: string;\n  weekdayDates: Record<string, string>;\n} {\n  const now = new Date();\n  const timezone = config.timezone;\n\n  const options: Intl.DateTimeFormatOptions = {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZone: timezone,\n  };\n\n  // Calculate tomorrow in local timezone\n  const tomorrow = new Date(now);\n  tomorrow.setDate(tomorrow.getDate() + 1);\n\n  // Pre-calculate dates for each day of the week\n  const weekdayDates: Record<string, string> = {\n    sunday: getDateForDayOfWeek(0, timezone),\n    monday: getDateForDayOfWeek(1, timezone),\n    tuesday: getDateForDayOfWeek(2, timezone),\n    wednesday: getDateForDayOfWeek(3, timezone),\n    thursday: getDateForDayOfWeek(4, timezone),\n    friday: getDateForDayOfWeek(5, timezone),\n    saturday: getDateForDayOfWeek(6, timezone),\n  };\n\n  return {\n    iso: now.toISOString(),\n    formatted: now.toLocaleString('en-US', options),\n    dayOfWeek: now.toLocaleDateString('en-US', { weekday: 'long', timeZone: timezone }),\n    todayIso: formatDateInTimezone(now, timezone),\n    tomorrowIso: formatDateInTimezone(tomorrow, timezone),\n    weekdayDates,\n  };\n}",
      "references": [
        "Date",
        "config",
        "timezone",
        "now",
        "tomorrow",
        "getDateForDayOfWeek",
        "options",
        "formatDateInTimezone",
        "weekdayDates"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:classifyConversationMode:490": {
      "id": "file:src/services/chatExtraction.ts:fn:classifyConversationMode:490",
      "type": "function",
      "name": "classifyConversationMode",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 490,
      "endLine": 562,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "transcript",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ConversationModeResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Classifies conversation transcript mode using regex heuristics or LLM API call.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.009Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function classifyConversationMode(\n  transcript: string\n): Promise<ConversationModeResult> {\n  const defaultResult: ConversationModeResult = {\n    mode: 'other',\n    confidence: 0.5,\n    reasoning: 'Default classification',\n  };\n\n  if (!transcript || transcript.trim().length < 10) {\n    return defaultResult;\n  }\n\n  // Quick heuristic checks for obvious meta_ai conversations\n  const lowerTranscript = transcript.toLowerCase();\n  const metaAiPatterns = [\n    /\\b(fix|debug|implement|refactor|test|build|compile|deploy)\\b.*\\b(bug|error|issue|code|function|component|service)\\b/i,\n    /\\b(typescript|javascript|react|node|sql|api|endpoint|schema|migration)\\b/i,\n    /\\b(npm|yarn|git|commit|push|pull|branch|merge)\\b/i,\n    /\\bsquire\\b.*\\b(app|project|feature|memory|extraction)\\b/i,\n    /\\b(look at|read|check|update|modify)\\b.*\\.(ts|js|tsx|jsx|sql|json)\\b/i,\n  ];\n\n  const isLikelyMetaAi = metaAiPatterns.some((p) => p.test(lowerTranscript));\n  \n  // If obviously meta_ai, skip LLM call\n  if (isLikelyMetaAi) {\n    return {\n      mode: 'meta_ai',\n      confidence: 0.85,\n      reasoning: 'Heuristic: contains development/coding terminology',\n    };\n  }\n\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: CONVERSATION_MODE_PROMPT },\n      { role: 'user', content: `Classify this transcript:\\n\\n${transcript.slice(0, 2000)}` },\n    ];\n\n    const response = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 150,\n    });\n\n    const content = response.content?.trim();\n    if (!content) return defaultResult;\n\n    // Parse JSON response\n    let jsonStr = content;\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n\n    const parsed = JSON.parse(jsonStr) as ConversationModeResult;\n\n    // Validate mode\n    const validModes: ConversationMode[] = ['personal', 'work', 'meta_ai', 'other'];\n    if (!validModes.includes(parsed.mode)) {\n      return defaultResult;\n    }\n\n    return {\n      mode: parsed.mode,\n      confidence: Math.min(1, Math.max(0, parsed.confidence ?? 0.5)),\n      reasoning: parsed.reasoning ?? 'LLM classification',\n    };\n  } catch (error) {\n    console.error('[ChatExtraction] Mode classification failed:', error);\n    return defaultResult;\n  }\n}",
      "references": [
        "defaultResult",
        "metaAiPatterns",
        "p",
        "lowerTranscript",
        "isLikelyMetaAi",
        "CONVERSATION_MODE_PROMPT",
        "complete",
        "messages",
        "response",
        "content",
        "jsonMatch",
        "jsonStr",
        "JSON",
        "validModes",
        "parsed",
        "Math",
        "console",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getCommitmentDetectionPrompt:566": {
      "id": "file:src/services/chatExtraction.ts:fn:getCommitmentDetectionPrompt:566",
      "type": "function",
      "name": "getCommitmentDetectionPrompt",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 566,
      "endLine": 626,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates prompt string for detecting actionable commitments with date/time context",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.009Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCommitmentDetectionPrompt(): string {\n  const dt = getDateTimeContext();\n\n  return `Analyze this memory content and determine if it represents an actionable commitment.\n\nA commitment is something the user:\n- Needs to do, should do, wants to do, or has promised to do\n- Has a deadline or timeframe (explicit or implied)\n- Is actionable (not just a wish or abstract goal)\n\nReturn JSON with:\n- is_commitment: boolean - true if this is an actionable commitment\n- title: string - short actionable title (imperative form, e.g., \"Finish report\", \"Call mom\")\n- description: string | null - additional context if any\n- due_at: string | null - ISO 8601 date if deadline mentioned\n- all_day: boolean - true if no specific time mentioned\n\nCURRENT DATE/TIME: ${dt.formatted}\nTODAY IS: ${dt.dayOfWeek}, ${dt.todayIso}\nTOMORROW: ${dt.tomorrowIso}\n\nDAY-OF-WEEK TO DATE MAPPING (CRITICAL - use these exact dates):\n- \"this Sunday\" or \"on Sunday\" = ${dt.weekdayDates.sunday}\n- \"this Monday\" or \"on Monday\" = ${dt.weekdayDates.monday}\n- \"this Tuesday\" or \"on Tuesday\" = ${dt.weekdayDates.tuesday}\n- \"this Wednesday\" or \"on Wednesday\" = ${dt.weekdayDates.wednesday}\n- \"this Thursday\" or \"on Thursday\" = ${dt.weekdayDates.thursday}\n- \"this Friday\" or \"on Friday\" = ${dt.weekdayDates.friday}\n- \"this Saturday\" or \"on Saturday\" = ${dt.weekdayDates.saturday}\n\nISO 8601 DATE FORMAT (CRITICAL):\n- Format: YYYY-MM-DDTHH:MM:SSZ\n- Month uses numbers 01-12 (NOT 0-11): January=01, February=02, March=03, April=04, May=05, June=06, July=07, August=08, September=09, October=10, November=11, December=12\n- Examples:\n  * January 5, 2026 at 9:00 AM  \"2026-01-05T09:00:00Z\"\n  * December 31, 2025 at noon  \"2025-12-31T12:00:00Z\"\n  * March 15, 2026 at 3:30 PM  \"2026-03-15T15:30:00Z\"\n\nFor relative dates, calculate from current date:\n- \"tomorrow\" = ${dt.tomorrowIso}\n- \"next week\" = 7 days from today\n- \"in 3 days\" = add 3 days to ${dt.todayIso}\n\nExamples:\nInput: \"I need to finish the report by Friday\"\nOutput: {\"is_commitment\": true, \"title\": \"Finish the report\", \"description\": null, \"due_at\": \"${dt.weekdayDates.friday}T23:59:59Z\", \"all_day\": true}\n\nInput: \"House chores this Wednesday from 2pm to 5pm\"\nOutput: {\"is_commitment\": true, \"title\": \"House chores\", \"description\": null, \"due_at\": \"${dt.weekdayDates.wednesday}T14:00:00Z\", \"all_day\": false}\n\nInput: \"Call mom tomorrow at 3pm\"\nOutput: {\"is_commitment\": true, \"title\": \"Call mom\", \"description\": null, \"due_at\": \"${dt.tomorrowIso}T15:00:00Z\", \"all_day\": false}\n\nInput: \"Meeting on January 15, 2026 at 2pm\"\nOutput: {\"is_commitment\": true, \"title\": \"Meeting\", \"description\": null, \"due_at\": \"2026-01-15T14:00:00Z\", \"all_day\": false}\n\nInput: \"My wife's name is Sarah\"\nOutput: {\"is_commitment\": false, \"title\": null, \"description\": null, \"due_at\": null, \"all_day\": false}\n\nIMPORTANT: Return ONLY valid JSON object, no markdown, no explanation.`;\n}",
      "references": [
        "getDateTimeContext",
        "dt"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getReminderDetectionPrompt:638": {
      "id": "file:src/services/chatExtraction.ts:fn:getReminderDetectionPrompt:638",
      "type": "function",
      "name": "getReminderDetectionPrompt",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 638,
      "endLine": 746,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a prompt string for AI to detect reminder requests in messages with date context",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.009Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getReminderDetectionPrompt(): string {\n  const dt = getDateTimeContext();\n\n  // Calculate minutes until 9am tomorrow for example\n  const now = new Date();\n  const tomorrow9am = new Date(now);\n  tomorrow9am.setDate(tomorrow9am.getDate() + 1);\n  tomorrow9am.setHours(9, 0, 0, 0);\n  const minutesUntilTomorrow9am = Math.round((tomorrow9am.getTime() - now.getTime()) / 60000);\n\n  return `Analyze this message and detect if the user is requesting a reminder.\n\nLook for patterns like:\n- \"remind me in X minutes/hours/days\"\n- \"remind me to X\"\n- \"set a reminder for X\"\n- \"don't let me forget to X\"\n- \"ping me about X in Y\"\n- \"remind me tomorrow/tonight/this evening\"\n- \"remind me on [specific date]\"\n- \"remind me on Wednesday\" (day of week)\n\nCURRENT DATE/TIME: ${dt.formatted}\nTODAY IS: ${dt.dayOfWeek}, ${dt.todayIso}\nTOMORROW: ${dt.tomorrowIso}\n\nDAY-OF-WEEK TO DATE MAPPING (CRITICAL - use these exact dates for scheduled_at):\n- \"this Sunday\" or \"on Sunday\" = ${dt.weekdayDates.sunday}\n- \"this Monday\" or \"on Monday\" = ${dt.weekdayDates.monday}\n- \"this Tuesday\" or \"on Tuesday\" = ${dt.weekdayDates.tuesday}\n- \"this Wednesday\" or \"on Wednesday\" = ${dt.weekdayDates.wednesday}\n- \"this Thursday\" or \"on Thursday\" = ${dt.weekdayDates.thursday}\n- \"this Friday\" or \"on Friday\" = ${dt.weekdayDates.friday}\n- \"this Saturday\" or \"on Saturday\" = ${dt.weekdayDates.saturday}\n\nReturn JSON with:\n- is_reminder: boolean - true if this is a reminder request\n- title: string | null - what to remind about (extracted from message)\n- delay_minutes: number | null - for RELATIVE times AND same-day times\n- scheduled_at: string | null - ONLY for future dates (not today)\n\nCRITICAL TIMEZONE RULES - The user is in Eastern Time (EST/EDT, UTC-5):\n- ALWAYS use delay_minutes for SAME-DAY reminders (e.g., \"at 10:30\", \"at 2pm today\")\n- ONLY use scheduled_at for FUTURE DATES (tomorrow or later)\n- Calculate delay_minutes from the current time shown above\n\n**CRITICAL: Converting Local Time to UTC for scheduled_at:**\nThe user speaks in Eastern Time (EST). You must convert to UTC by ADDING 5 hours.\n- 9:00 AM EST = 14:00 UTC (add 5 hours)\n- 2:00 PM EST (14:00 local) = 19:00 UTC (add 5 hours)\n- 10:00 AM EST = 15:00 UTC (add 5 hours)\n- Midnight (12:00 AM) EST = 05:00 UTC (add 5 hours)\n\n**CRITICAL: Default Time When No Time Specified:**\nWhen the user gives a DATE but NO TIME (e.g., \"Friday the 16th\", \"on January 20\"):\n- Default to 9:00 AM in the user's local time (EST)\n- 9:00 AM EST = 14:00 UTC\n- So scheduled_at should use T14:00:00Z for date-only reminders\n\nFor same-day times, calculate delay_minutes like this:\n- Current time is ${dt.formatted}\n- If user says \"at 2:30 PM\" and it's currently 10:20 AM, that's 4 hours 10 minutes = 250 minutes\n- If the requested time has already passed today, the reminder is invalid\n\nTime calculations for delay_minutes:\n- \"in 2 hours\" = 120 minutes\n- \"tomorrow\" = ${minutesUntilTomorrow9am} minutes (until 9am tomorrow)\n- \"tomorrow morning\" = minutes until 9am tomorrow\n- \"tomorrow afternoon\" = minutes until 2pm tomorrow\n- \"tonight\" = minutes until 8pm today (or tomorrow if past 8pm)\n- \"this evening\" = minutes until 6pm today\n- \"next week\" = 7 days = 10080 minutes\n\nExamples:\nInput: \"remind me in 2 hours to call mom\"\nOutput: {\"is_reminder\": true, \"title\": \"Call mom\", \"delay_minutes\": 120, \"scheduled_at\": null}\n\nInput: \"remind me tomorrow to pick up groceries\"\nOutput: {\"is_reminder\": true, \"title\": \"Pick up groceries\", \"delay_minutes\": ${minutesUntilTomorrow9am}, \"scheduled_at\": null}\n\nInput: \"set a reminder for 30 minutes to take a break\"\nOutput: {\"is_reminder\": true, \"title\": \"Take a break\", \"delay_minutes\": 30, \"scheduled_at\": null}\n\nInput: \"set a reminder for 2:30 PM to call the office\" (SAME-DAY - use delay_minutes!)\nOutput: {\"is_reminder\": true, \"title\": \"Call the office\", \"delay_minutes\": 250, \"scheduled_at\": null}\n\nInput: \"remind me at 10:30 to check the oven\" (SAME-DAY - use delay_minutes!)\nOutput: {\"is_reminder\": true, \"title\": \"Check the oven\", \"delay_minutes\": 10, \"scheduled_at\": null}\n\nInput: \"remind me on Wednesday at 2pm about the meeting\" (FUTURE DATE with time - convert 2pm EST to 19:00 UTC)\nOutput: {\"is_reminder\": true, \"title\": \"Meeting\", \"delay_minutes\": null, \"scheduled_at\": \"${dt.weekdayDates.wednesday}T19:00:00Z\"}\n\nInput: \"remind me on Wednesday about the meeting\" (FUTURE DATE, NO time - default to 9am EST = 14:00 UTC)\nOutput: {\"is_reminder\": true, \"title\": \"Meeting\", \"delay_minutes\": null, \"scheduled_at\": \"${dt.weekdayDates.wednesday}T14:00:00Z\"}\n\nInput: \"remind me on Friday the 16th to check the job\" (FUTURE DATE, NO time - default to 9am EST = 14:00 UTC)\nOutput: {\"is_reminder\": true, \"title\": \"Check the job\", \"delay_minutes\": null, \"scheduled_at\": \"2026-01-16T14:00:00Z\"}\n\nInput: \"remind me on January 15, 2026 at 9am about the appointment\" (FUTURE DATE with time - 9am EST = 14:00 UTC)\nOutput: {\"is_reminder\": true, \"title\": \"Appointment\", \"delay_minutes\": null, \"scheduled_at\": \"2026-01-15T14:00:00Z\"}\n\nInput: \"remind me on January 20\" (FUTURE DATE, NO time - default to 9am EST = 14:00 UTC)\nOutput: {\"is_reminder\": true, \"title\": \"Reminder for January 20\", \"delay_minutes\": null, \"scheduled_at\": \"2026-01-20T14:00:00Z\"}\n\nInput: \"I need to remember my dentist appointment\"\nOutput: {\"is_reminder\": false, \"title\": null, \"delay_minutes\": null, \"scheduled_at\": null}\n\nIMPORTANT: Return ONLY valid JSON object, no markdown, no explanation.`;\n}",
      "references": [
        "getDateTimeContext",
        "Date",
        "now",
        "tomorrow9am",
        "Math",
        "dt",
        "minutesUntilTomorrow9am"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:safeParseJSON:762": {
      "id": "file:src/services/chatExtraction.ts:fn:safeParseJSON:762",
      "type": "function",
      "name": "safeParseJSON",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 762,
      "endLine": 788,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "T",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Safely parses JSON from string, cleaning markdown and fixing common errors.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.010Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function safeParseJSON<T>(content: string): T | null {\n  // Clean up the content\n  let jsonStr = content.trim();\n\n  // Remove markdown code blocks if present\n  jsonStr = jsonStr.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '');\n\n  // Try to extract JSON object\n  const jsonMatch = jsonStr.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[0];\n  }\n\n  // Try parsing\n  try {\n    return JSON.parse(jsonStr) as T;\n  } catch {\n    // Try fixing common issues: trailing commas, unquoted keys\n    try {\n      // Remove trailing commas before } or ]\n      const fixed = jsonStr.replace(/,\\s*([}\\]])/g, '$1');\n      return JSON.parse(fixed) as T;\n    } catch {\n      return null;\n    }\n  }\n}",
      "references": [
        "jsonStr",
        "jsonMatch",
        "JSON",
        "fixed"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:detectReminderRequest:793": {
      "id": "file:src/services/chatExtraction.ts:fn:detectReminderRequest:793",
      "type": "function",
      "name": "detectReminderRequest",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 793,
      "endLine": 822,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ReminderDetection>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects reminder requests in messages using LLM completion and parses JSON response.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.010Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectReminderRequest(message: string): Promise<ReminderDetection | null> {\n  // Quick check - skip if no reminder-related keywords\n  const reminderKeywords = /remind|ping|alert|don't forget|dont forget|set.+reminder/i;\n  if (!reminderKeywords.test(message)) {\n    return null;\n  }\n\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: getReminderDetectionPrompt() },\n      { role: 'user', content: message },\n    ];\n\n    const result = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 300,\n    });\n\n    const parsed = safeParseJSON<ReminderDetection>(result.content);\n    if (!parsed) {\n      console.error('[ChatExtraction] Failed to parse reminder JSON:', result.content.substring(0, 200));\n      return null;\n    }\n\n    return parsed;\n  } catch (error) {\n    console.error('[ChatExtraction] Reminder detection failed:', error);\n    return null;\n  }\n}",
      "references": [
        "reminderKeywords",
        "getReminderDetectionPrompt",
        "complete",
        "messages",
        "safeParseJSON",
        "result",
        "parsed",
        "console",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:detectCommitment:827": {
      "id": "file:src/services/chatExtraction.ts:fn:detectCommitment:827",
      "type": "function",
      "name": "detectCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 827,
      "endLine": 850,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryContent",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<CommitmentDetection>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects commitment in memory content using LLM API and parses JSON response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.010Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectCommitment(memoryContent: string): Promise<CommitmentDetection | null> {\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: getCommitmentDetectionPrompt() },\n      { role: 'user', content: memoryContent },\n    ];\n\n    const result = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 500,\n    });\n\n    const parsed = safeParseJSON<CommitmentDetection>(result.content);\n    if (!parsed) {\n      console.error('[ChatExtraction] Failed to parse commitment JSON:', result.content.substring(0, 200));\n      return null;\n    }\n\n    return parsed;\n  } catch (error) {\n    console.error('[ChatExtraction] Commitment detection failed:', error);\n    return null;\n  }\n}",
      "references": [
        "getCommitmentDetectionPrompt",
        "complete",
        "messages",
        "safeParseJSON",
        "result",
        "parsed",
        "console",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getPendingConversations:936": {
      "id": "file:src/services/chatExtraction.ts:fn:getPendingConversations:936",
      "type": "function",
      "name": "getPendingConversations",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 936,
      "endLine": 948,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ConversationForExtraction[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for active conversations with pending user message extractions, ordered by created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.011Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getPendingConversations(): Promise<ConversationForExtraction[]> {\n  const result = await pool.query<ConversationForExtraction>(`\n    SELECT DISTINCT c.id, c.client_id, c.message_count, c.created_at\n    FROM conversations c\n    JOIN chat_messages cm ON cm.conversation_id = c.id\n    WHERE cm.extraction_status = 'pending'\n      AND cm.role = 'user'  -- Only consider user messages\n      AND c.status = 'active'\n    ORDER BY c.created_at DESC\n  `);\n\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:getPendingMessages:953": {
      "id": "file:src/services/chatExtraction.ts:fn:getPendingMessages:953",
      "type": "function",
      "name": "getPendingMessages",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 953,
      "endLine": 966,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").PendingMessage[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pending user messages for a conversation from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.011Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getPendingMessages(\n  conversationId: string\n): Promise<PendingMessage[]> {\n  const result = await pool.query<PendingMessage>(`\n    SELECT id, conversation_id, role, content, sequence_number, created_at\n    FROM chat_messages\n    WHERE conversation_id = $1\n      AND extraction_status = 'pending'\n      AND role = 'user'\n    ORDER BY sequence_number ASC\n  `, [conversationId]);\n\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:buildTranscript:971": {
      "id": "file:src/services/chatExtraction.ts:fn:buildTranscript:971",
      "type": "function",
      "name": "buildTranscript",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 971,
      "endLine": 975,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "messages",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").PendingMessage[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts array of pending messages to a newline-separated transcript prefixed with 'User:'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.011Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function buildTranscript(messages: PendingMessage[]): string {\n  return messages\n    .map((m) => `User: ${m.content}`)\n    .join('\\n');\n}",
      "references": [
        "m"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractFromTranscript:980": {
      "id": "file:src/services/chatExtraction.ts:fn:extractFromTranscript:980",
      "type": "function",
      "name": "extractFromTranscript",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 980,
      "endLine": 1038,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "transcript",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ExtractedMemory[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts and validates memories from chat transcript using LLM API, limits to top 3 by salience.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.011Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function extractFromTranscript(\n  transcript: string\n): Promise<ExtractedMemory[]> {\n  if (!transcript.trim()) {\n    return [];\n  }\n\n  const messages: LLMMessage[] = [\n    { role: 'system', content: EXTRACTION_SYSTEM_PROMPT },\n    { role: 'user', content: transcript },\n  ];\n\n  try {\n    const result = await complete(messages, {\n      temperature: 0.2, // Low temperature for consistent extraction\n      maxTokens: 2000,\n    });\n\n    // Parse JSON response\n    const content = result.content.trim();\n\n    // Handle empty response\n    if (!content || content === '[]') {\n      return [];\n    }\n\n    // Try to extract JSON from response (in case of markdown wrapping)\n    let jsonStr = content;\n    const jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n\n    const parsed = JSON.parse(jsonStr) as ExtractedMemory[];\n\n    // Validate and filter\n    const validated = parsed.filter((m) =>\n      m.content &&\n      typeof m.content === 'string' &&\n      m.content.length > 5 &&\n      m.salience_hint >= 1 &&\n      m.salience_hint <= 10\n    );\n\n    // Phase 2: Episodic Consolidation - enforce hard cap of 3 memories per episode\n    // Sort by salience (highest first) to keep the most important ones\n    const sorted = validated.sort((a, b) => b.salience_hint - a.salience_hint);\n    const limited = sorted.slice(0, 3);\n\n    if (validated.length > 3) {\n      console.log(`[ChatExtraction] Episodic limit applied: ${validated.length}  3 memories (dropped ${validated.length - 3})`);\n    }\n\n    return limited;\n  } catch (error) {\n    console.error('[ChatExtraction] Failed to parse LLM response:', error);\n    return [];\n  }\n}",
      "references": [
        "EXTRACTION_SYSTEM_PROMPT",
        "complete",
        "messages",
        "result",
        "content",
        "jsonMatch",
        "jsonStr",
        "JSON",
        "parsed",
        "m",
        "validated",
        "b",
        "a",
        "sorted",
        "console",
        "limited",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:markMessagesExtracted:1043": {
      "id": "file:src/services/chatExtraction.ts:fn:markMessagesExtracted:1043",
      "type": "function",
      "name": "markMessagesExtracted",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1043,
      "endLine": 1056,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "messageIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates chat messages as extracted in database for given conversation and IDs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.012Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function markMessagesExtracted(\n  conversationId: string,\n  messageIds: string[]\n): Promise<void> {\n  if (messageIds.length === 0) return;\n\n  await pool.query(`\n    UPDATE chat_messages\n    SET extraction_status = 'extracted',\n        extracted_at = NOW()\n    WHERE conversation_id = $1\n      AND id = ANY($2)\n  `, [conversationId, messageIds]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:markMessagesSkipped:1061": {
      "id": "file:src/services/chatExtraction.ts:fn:markMessagesSkipped:1061",
      "type": "function",
      "name": "markMessagesSkipped",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1061,
      "endLine": 1074,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "messageIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates chat messages to 'skipped' extraction status for given conversation and message IDs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.012Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function markMessagesSkipped(\n  conversationId: string,\n  messageIds: string[]\n): Promise<void> {\n  if (messageIds.length === 0) return;\n\n  await pool.query(`\n    UPDATE chat_messages\n    SET extraction_status = 'skipped',\n        extracted_at = NOW()\n    WHERE conversation_id = $1\n      AND id = ANY($2)\n  `, [conversationId, messageIds]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractFromConversation:1079": {
      "id": "file:src/services/chatExtraction.ts:fn:extractFromConversation:1079",
      "type": "function",
      "name": "extractFromConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1079,
      "endLine": 1378,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversation",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ConversationForExtraction",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ memoriesCreated: number; commitmentsCreated: number; commitmentsResolved: number; resolutionsPending: import(\"/home/ridgetop/projects/squire/src/services/resolution\").ResolutionCandidate[]; remindersCreated: number; beliefsCreated: number; beliefsReinforced: number; messagesProcessed: number; skipped: boolean; error?: string; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts memories, commitments, reminders from conversation messages via LLM and creates them in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.012Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function extractFromConversation(\n  conversation: ConversationForExtraction\n): Promise<{\n  memoriesCreated: number;\n  commitmentsCreated: number;\n  commitmentsResolved: number;\n  resolutionsPending: ResolutionCandidate[];\n  remindersCreated: number;\n  beliefsCreated: number;\n  beliefsReinforced: number;\n  messagesProcessed: number;\n  skipped: boolean;\n  error?: string;\n}> {\n  const messages = await getPendingMessages(conversation.id);\n\n  if (messages.length === 0) {\n    return {\n      memoriesCreated: 0,\n      commitmentsCreated: 0,\n      commitmentsResolved: 0,\n      resolutionsPending: [],\n      remindersCreated: 0,\n      beliefsCreated: 0,\n      beliefsReinforced: 0,\n      messagesProcessed: 0,\n      skipped: true,\n    };\n  }\n\n  const messageIds = messages.map((m) => m.id);\n  const transcript = buildTranscript(messages);\n\n  try {\n    // Phase 1: Classify conversation mode before extraction\n    const modeResult = await classifyConversationMode(transcript);\n    const conversationMode = modeResult.mode;\n    console.log(`[ChatExtraction] Conversation mode: ${conversationMode} (${(modeResult.confidence * 100).toFixed(0)}% - ${modeResult.reasoning})`);\n\n    // Extract memories via LLM\n    const extracted = await extractFromTranscript(transcript);\n\n    // First, check raw messages for reminder requests (before memory extraction)\n    let remindersCreated = 0;\n    for (const msg of messages) {\n      try {\n        const reminderInfo = await detectReminderRequest(msg.content);\n        if (reminderInfo?.is_reminder && reminderInfo.title) {\n          const bodyText = `Reminder from chat: \"${msg.content}\"`;\n\n          if (reminderInfo.scheduled_at) {\n            // Explicit date scheduling\n            const scheduledDate = new Date(reminderInfo.scheduled_at);\n            await createScheduledReminder(\n              reminderInfo.title,\n              scheduledDate,\n              { body: bodyText }\n            );\n            remindersCreated++;\n            console.log(`[ChatExtraction] Created reminder: ${reminderInfo.title} scheduled for ${scheduledDate.toISOString()}`);\n          } else if (reminderInfo.delay_minutes) {\n            // Relative time scheduling\n            await createStandaloneReminder(\n              reminderInfo.title,\n              reminderInfo.delay_minutes,\n              { body: bodyText }\n            );\n            remindersCreated++;\n            console.log(`[ChatExtraction] Created reminder: ${reminderInfo.title} in ${reminderInfo.delay_minutes} minutes`);\n          }\n        }\n      } catch (reminderError) {\n        console.error('[ChatExtraction] Reminder creation failed:', reminderError);\n      }\n    }\n\n    // Check for resolution of existing commitments\n    let commitmentsResolved = 0;\n    const resolutionsPending: ResolutionCandidate[] = [];\n    try {\n      const resolutionResult = await processMessagesForResolutions(\n        messages.map((m) => ({ id: m.id, content: m.content }))\n      );\n      commitmentsResolved = resolutionResult.resolved.length;\n      resolutionsPending.push(...resolutionResult.pendingConfirmation.map((p) => p.candidate));\n\n      if (resolutionResult.resolved.length > 0) {\n        console.log(`[ChatExtraction] Auto-resolved ${resolutionResult.resolved.length} commitment(s)`);\n      }\n      if (resolutionResult.pendingConfirmation.length > 0) {\n        console.log(`[ChatExtraction] ${resolutionResult.pendingConfirmation.length} resolution(s) need confirmation`);\n      }\n    } catch (resolutionError) {\n      console.error('[ChatExtraction] Resolution detection failed:', resolutionError);\n    }\n\n    if (extracted.length === 0) {\n      // Nothing worth remembering - mark as skipped (but we may have created reminders/resolutions)\n      await markMessagesSkipped(conversation.id, messageIds);\n      return {\n        memoriesCreated: 0,\n        commitmentsCreated: 0,\n        commitmentsResolved,\n        resolutionsPending,\n        remindersCreated,\n        beliefsCreated: 0,\n        beliefsReinforced: 0,\n        messagesProcessed: messages.length,\n        skipped: remindersCreated === 0 && commitmentsResolved === 0,\n      };\n    }\n\n    let memoriesCreated = 0;\n    let commitmentsCreated = 0;\n    let beliefsCreated = 0;\n    let beliefsReinforced = 0;\n\n    // Create memories from extracted content\n    for (const mem of extracted) {\n      try {\n        // Create the memory with conversation mode\n        const { memory } = await createMemory({\n          content: mem.content,\n          source: 'chat',\n          source_metadata: {\n            conversation_id: conversation.id,\n            extraction_type: mem.type,\n            salience_hint: mem.salience_hint,\n            conversation_mode: conversationMode,\n          },\n        });\n\n        // Update conversation_mode column (Phase 1)\n        await pool.query(\n          `UPDATE memories SET conversation_mode = $1 WHERE id = $2`,\n          [conversationMode, memory.id]\n        );\n\n        // Phase 3: Set tier and confidence\n        // High confidence (0.75)  solid tier immediately\n        // Lower confidence  hypothesis tier (needs reinforcement to promote)\n        const confidence = mem.confidence ?? 0.5;\n        const tier = confidence >= 0.75 ? 'solid' : 'hypothesis';\n        await pool.query(\n          `UPDATE memories SET tier = $1, confidence = $2 WHERE id = $3`,\n          [tier, confidence, memory.id]\n        );\n        if (tier === 'solid') {\n          console.log(`[ChatExtraction] Memory created as SOLID (confidence: ${confidence.toFixed(2)}): \"${mem.content.substring(0, 50)}...\"`);\n        }\n\n        // Phase 3: Check for reinforcement from similar existing memories\n        // If similar memories exist, boost confidence and potentially promote to solid\n        if (tier === 'hypothesis') {\n          try {\n            const reinforcement = await checkReinforcement(memory.id, mem.content, confidence);\n            if (reinforcement.wasPromoted) {\n              console.log(`[ChatExtraction] Memory promoted via reinforcement: hypothesis  solid`);\n            } else if (reinforcement.reinforcedBy.length > 0) {\n              console.log(`[ChatExtraction] Memory reinforced by ${reinforcement.reinforcedBy.length} similar memories (confidence: ${confidence.toFixed(2)}  ${reinforcement.newConfidence.toFixed(2)})`);\n            }\n          } catch (reinforceError) {\n            console.error('[ChatExtraction] Reinforcement check failed:', reinforceError);\n          }\n        }\n\n        memoriesCreated++;\n\n        // Invalidate relevant story cache entries (Phase 4)\n        // Smart invalidation based on memory content\n        try {\n          invalidateStoryCache(mem.content);\n        } catch {\n          // Silent - cache invalidation is non-critical\n        }\n\n        // Classify memory for living summaries\n        let classifications: CategoryClassification[] = [];\n        try {\n          classifications = await classifyMemoryCategories(mem.content);\n          if (classifications.length > 0) {\n            await linkMemoryToCategories(memory.id, classifications);\n          }\n        } catch (classifyError) {\n          // Log but don't fail - summary classification is secondary\n          console.error('[ChatExtraction] Summary classification failed:', classifyError);\n        }\n\n        // Apply salience calibration for biographical content (Phase 0)\n        // This ensures origin stories, life-changing moments, and key facts\n        // are never filtered out by min_salience thresholds\n        try {\n          const calibratedSalience = calibrateSalienceForBiographical(mem, classifications);\n          if (calibratedSalience > memory.salience_score) {\n            await pool.query(\n              `UPDATE memories SET salience_score = $1 WHERE id = $2`,\n              [calibratedSalience, memory.id]\n            );\n            console.log(`[ChatExtraction] Boosted salience for biographical content: ${mem.salience_hint}  ${calibratedSalience}`);\n          }\n        } catch (calibrationError) {\n          console.error('[ChatExtraction] Salience calibration failed:', calibrationError);\n        }\n\n        // Extract event_date for event-type memories (Phase 2)\n        // Enables date-based graph traversal for Story Engine\n        if (mem.type === 'event') {\n          try {\n            const eventDate = extractEventDate(mem.content);\n            if (eventDate) {\n              await pool.query(\n                `UPDATE memories SET event_date = $1 WHERE id = $2`,\n                [eventDate, memory.id]\n              );\n              console.log(`[ChatExtraction] Extracted event_date: ${eventDate.toISOString().split('T')[0]}`);\n            }\n          } catch (dateError) {\n            console.error('[ChatExtraction] Event date extraction failed:', dateError);\n          }\n        }\n\n        // Process for beliefs (decisions, preferences often become beliefs)\n        if (mem.type === 'decision' || mem.type === 'preference' || mem.type === 'goal') {\n          try {\n            const beliefResult = await processMemoryForBeliefs(memory.id, mem.content);\n            beliefsCreated += beliefResult.created.length;\n            beliefsReinforced += beliefResult.reinforced.filter((r) => r.wasReinforced).length;\n          } catch (beliefError) {\n            // Log but don't fail - beliefs are secondary\n            console.error('[ChatExtraction] Belief extraction failed:', beliefError);\n          }\n        }\n\n        // Detect and create commitments from goals and decisions\n        // Phase 1: Skip commitment creation for meta_ai mode (dev chatter)\n        // \"Fix the bug\" in meta_ai mode should NOT become a tracked commitment\n        if ((mem.type === 'goal' || mem.type === 'decision') && conversationMode !== 'meta_ai') {\n          try {\n            const commitmentInfo = await detectCommitment(mem.content);\n            if (commitmentInfo?.is_commitment && commitmentInfo.title) {\n              await createCommitment({\n                title: commitmentInfo.title,\n                description: commitmentInfo.description ?? mem.content,\n                memory_id: memory.id,\n                source_type: 'chat',\n                due_at: commitmentInfo.due_at ? new Date(commitmentInfo.due_at) : undefined,\n                all_day: commitmentInfo.all_day,\n              });\n              // Update commitment conversation_mode\n              await pool.query(\n                `UPDATE commitments SET conversation_mode = $1 WHERE memory_id = $2`,\n                [conversationMode, memory.id]\n              );\n              commitmentsCreated++;\n              console.log(`[ChatExtraction] Created commitment: ${commitmentInfo.title}`);\n            }\n          } catch (commitmentError) {\n            // Log but don't fail - commitment creation is secondary\n            console.error('[ChatExtraction] Commitment creation failed:', commitmentError);\n          }\n        } else if ((mem.type === 'goal' || mem.type === 'decision') && conversationMode === 'meta_ai') {\n          console.log(`[ChatExtraction] Skipping commitment for meta_ai mode: ${mem.content.slice(0, 50)}...`);\n        }\n      } catch (memError) {\n        console.error('[ChatExtraction] Failed to create memory:', memError);\n      }\n    }\n\n    // Mark messages as extracted\n    await markMessagesExtracted(conversation.id, messageIds);\n\n    return {\n      memoriesCreated,\n      commitmentsCreated,\n      commitmentsResolved,\n      resolutionsPending,\n      remindersCreated,\n      beliefsCreated,\n      beliefsReinforced,\n      messagesProcessed: messages.length,\n      skipped: false,\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    console.error(`[ChatExtraction] Error processing conversation ${conversation.id}:`, error);\n\n    return {\n      memoriesCreated: 0,\n      commitmentsCreated: 0,\n      commitmentsResolved: 0,\n      resolutionsPending: [],\n      remindersCreated: 0,\n      beliefsCreated: 0,\n      beliefsReinforced: 0,\n      messagesProcessed: 0,\n      skipped: false,\n      error: errorMsg,\n    };\n  }\n}",
      "references": [
        "getPendingMessages",
        "messages",
        "m",
        "buildTranscript",
        "classifyConversationMode",
        "transcript",
        "modeResult",
        "console",
        "conversationMode",
        "extractFromTranscript",
        "detectReminderRequest",
        "msg",
        "reminderInfo",
        "Date",
        "createScheduledReminder",
        "scheduledDate",
        "bodyText",
        "remindersCreated",
        "createStandaloneReminder",
        "reminderError",
        "processMessagesForResolutions",
        "commitmentsResolved",
        "resolutionResult",
        "resolutionsPending",
        "p",
        "resolutionError",
        "extracted",
        "markMessagesSkipped",
        "messageIds",
        "memory",
        "createMemory",
        "mem",
        "pool",
        "confidence",
        "tier",
        "checkReinforcement",
        "reinforcement",
        "reinforceError",
        "memoriesCreated",
        "invalidateStoryCache",
        "classifications",
        "classifyMemoryCategories",
        "linkMemoryToCategories",
        "classifyError",
        "calibrateSalienceForBiographical",
        "calibratedSalience",
        "calibrationError",
        "extractEventDate",
        "eventDate",
        "dateError",
        "processMemoryForBeliefs",
        "beliefsCreated",
        "beliefResult",
        "beliefsReinforced",
        "r",
        "beliefError",
        "detectCommitment",
        "commitmentInfo",
        "createCommitment",
        "commitmentsCreated",
        "commitmentError",
        "memError",
        "markMessagesExtracted",
        "error",
        "Error",
        "String",
        "errorMsg"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractMemoriesFromChat:1384": {
      "id": "file:src/services/chatExtraction.ts:fn:extractMemoriesFromChat:1384",
      "type": "function",
      "name": "extractMemoriesFromChat",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1384,
      "endLine": 1437,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/chatExtraction\").ExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes pending conversations to extract memories, commitments, beliefs, and aggregates results",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.013Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractMemoriesFromChat(): Promise<ExtractionResult> {\n  const result: ExtractionResult = {\n    conversationsProcessed: 0,\n    messagesProcessed: 0,\n    memoriesCreated: 0,\n    commitmentsCreated: 0,\n    commitmentsResolved: 0,\n    resolutionsPending: [],\n    remindersCreated: 0,\n    beliefsCreated: 0,\n    beliefsReinforced: 0,\n    skippedEmpty: 0,\n    errors: [],\n  };\n\n  const conversations = await getPendingConversations();\n\n  if (conversations.length === 0) {\n    console.log('[ChatExtraction] No pending conversations to process');\n    return result;\n  }\n\n  console.log(`[ChatExtraction] Processing ${conversations.length} conversation(s)...`);\n\n  for (const conversation of conversations) {\n    const convResult = await extractFromConversation(conversation);\n\n    result.conversationsProcessed++;\n    result.messagesProcessed += convResult.messagesProcessed;\n    result.memoriesCreated += convResult.memoriesCreated;\n    result.commitmentsCreated += convResult.commitmentsCreated;\n    result.commitmentsResolved += convResult.commitmentsResolved;\n    result.resolutionsPending.push(...convResult.resolutionsPending);\n    result.remindersCreated += convResult.remindersCreated;\n    result.beliefsCreated += convResult.beliefsCreated;\n    result.beliefsReinforced += convResult.beliefsReinforced;\n\n    if (convResult.skipped) {\n      result.skippedEmpty++;\n    }\n\n    if (convResult.error) {\n      result.errors.push(`Conversation ${conversation.id}: ${convResult.error}`);\n    }\n  }\n\n  console.log(\n    `[ChatExtraction] Complete: ${result.memoriesCreated} memories, ` +\n    `${result.commitmentsCreated} commitments created, ${result.commitmentsResolved} resolved, ` +\n    `${result.remindersCreated} reminders, ${result.beliefsCreated} beliefs, ${result.skippedEmpty} skipped`\n  );\n\n  return result;\n}",
      "references": [
        "getPendingConversations",
        "conversations",
        "console",
        "result",
        "extractFromConversation",
        "conversation",
        "convResult"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:processMessageRealTime:1444": {
      "id": "file:src/services/chatExtraction.ts:fn:processMessageRealTime:1444",
      "type": "function",
      "name": "processMessageRealTime",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1444,
      "endLine": 1667,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ commitmentCreated: { id: string; title: string; }; reminderCreated: { id: string; title: string; remind_at: string; }; noteCreated: { id: string; title: string; content: string; }; listCreated: { id: string; name: string; }; listItemCreated: { id: string; list_id: string; list_name: string; content: string; }; identityExtracted: { name: string; memoryId: string; }; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes chat message real-time to extract identities/relationships and create commitments/reminders/notes/lists",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.013Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processMessageRealTime(message: string): Promise<{\n  commitmentCreated: { id: string; title: string } | null;\n  reminderCreated: { id: string; title: string; remind_at: string } | null;\n  noteCreated: { id: string; title: string | null; content: string } | null;\n  listCreated: { id: string; name: string } | null;\n  listItemCreated: { id: string; list_id: string; list_name: string; content: string } | null;\n  identityExtracted: { name: string; memoryId: string } | null;\n}> {\n  const result = {\n    commitmentCreated: null as { id: string; title: string } | null,\n    reminderCreated: null as { id: string; title: string; remind_at: string } | null,\n    noteCreated: null as { id: string; title: string | null; content: string } | null,\n    listCreated: null as { id: string; name: string } | null,\n    listItemCreated: null as { id: string; list_id: string; list_name: string; content: string } | null,\n    identityExtracted: null as { name: string; memoryId: string } | null,\n  };\n\n  // === IDENTITY & RELATIONSHIP DETECTION (HIGHEST PRIORITY) ===\n  // Detect self-introductions and key relationships immediately\n  await extractIdentityRealTime(message, result);\n  await extractRelationshipsRealTime(message);\n\n  // Quick keyword checks to avoid unnecessary LLM calls\n  const commitmentKeywords = /\\b(need to|have to|should|must|want to|going to|will|promise|commit|schedule|plan to|deadline|by|due|tomorrow|next week|today)\\b/i;\n  const reminderKeywords = /remind|ping|alert|don't forget|dont forget|set.+reminder/i;\n  // NOTE: noteKeywords and listKeywords removed - LLM tools handle notes/lists now\n  // Decision: 99e91b23-c5b9-4482-a01f-65be94e7f362\n\n  // Check for reminder requests first (more specific pattern)\n  if (reminderKeywords.test(message)) {\n    try {\n      const reminderResult = await detectReminderRequest(message);\n      console.log(`[RealTimeExtraction] Reminder detection result:`, JSON.stringify(reminderResult, null, 2));\n\n      if (reminderResult?.is_reminder && reminderResult.title) {\n        let reminder = null;\n\n        if (reminderResult.scheduled_at) {\n          // Explicit date scheduling\n          const scheduledDate = new Date(reminderResult.scheduled_at);\n          reminder = await createScheduledReminder(\n            reminderResult.title,\n            scheduledDate\n          );\n          console.log(`[RealTimeExtraction] Created reminder: \"${reminderResult.title}\" scheduled for ${scheduledDate.toISOString()}`);\n        } else if (reminderResult.delay_minutes) {\n          // Relative time scheduling\n          reminder = await createStandaloneReminder(\n            reminderResult.title,\n            reminderResult.delay_minutes\n          );\n          console.log(`[RealTimeExtraction] Created reminder: \"${reminderResult.title}\" in ${reminderResult.delay_minutes} minutes`);\n        }\n\n        if (reminder) {\n          result.reminderCreated = {\n            id: reminder.id,\n            title: reminderResult.title,\n            remind_at: reminder.scheduled_for.toISOString(),\n          };\n          console.log(`[RealTimeExtraction] Reminder created successfully, returning early`);\n          return result; // Return early - reminder takes precedence\n        } else {\n          console.log(`[RealTimeExtraction] WARNING: is_reminder=true but reminder is null. scheduled_at=${reminderResult.scheduled_at}, delay_minutes=${reminderResult.delay_minutes}`);\n        }\n      } else {\n        console.log(`[RealTimeExtraction] Reminder detection returned is_reminder=${reminderResult?.is_reminder}, title=${reminderResult?.title}`);\n      }\n    } catch (error) {\n      console.error('[RealTimeExtraction] Reminder detection error:', error);\n    }\n  }\n\n  // DISABLED: Note and list extraction - LLM tools handle this now\n  // Decision: 99e91b23-c5b9-4482-a01f-65be94e7f362\n  // To re-enable: uncomment the blocks below and restore noteKeywords/listKeywords above\n\n  /*\n  // Check for note creation\n  if (noteKeywords.test(message)) {\n    try {\n      const noteResult = await detectNoteIntent(message);\n      if (noteResult?.is_note && noteResult.content) {\n        // Resolve entity if mentioned\n        let entityId: string | null = null;\n        if (noteResult.entity_name) {\n          entityId = await resolveEntityName(noteResult.entity_name);\n        }\n\n        const note = await createNote({\n          title: noteResult.title ?? undefined,\n          content: noteResult.content,\n          source_type: 'chat',\n          category: noteResult.category ?? undefined,\n          primary_entity_id: entityId ?? undefined,\n        });\n\n        result.noteCreated = {\n          id: note.id,\n          title: note.title,\n          content: note.content,\n        };\n        console.log(`[RealTimeExtraction] Created note: \"${noteResult.title ?? noteResult.content.substring(0, 50)}\"`);\n        return result; // Return early\n      }\n    } catch (error) {\n      console.error('[RealTimeExtraction] Note detection error:', error);\n    }\n  }\n\n  // Check for list operations\n  if (listKeywords.test(message)) {\n    try {\n      const listResult = await detectListIntent(message);\n      if (listResult?.is_list_action) {\n        if (listResult.action === 'create' && listResult.list_name) {\n          // Resolve entity if mentioned\n          let entityId: string | null = null;\n          if (listResult.entity_name) {\n            entityId = await resolveEntityName(listResult.entity_name);\n          }\n\n          const list = await createList({\n            name: listResult.list_name,\n            description: listResult.description ?? undefined,\n            list_type: listResult.list_type ?? 'checklist',\n            primary_entity_id: entityId ?? undefined,\n          });\n\n          // Add initial items if provided\n          if (listResult.initial_items && listResult.initial_items.length > 0) {\n            for (const itemContent of listResult.initial_items) {\n              await addItem(list.id, { content: itemContent });\n            }\n            console.log(`[RealTimeExtraction] Added ${listResult.initial_items.length} initial items to list`);\n          }\n\n          result.listCreated = {\n            id: list.id,\n            name: list.name,\n          };\n          console.log(`[RealTimeExtraction] Created list: \"${listResult.list_name}\"`);\n          return result;\n        } else if (listResult.action === 'add_item' && listResult.list_name && listResult.item_content) {\n          // Find the list by name\n          const existingList = await findListByName(listResult.list_name);\n          if (existingList) {\n            const item = await addItem(existingList.id, {\n              content: listResult.item_content,\n            });\n\n            result.listItemCreated = {\n              id: item.id,\n              list_id: existingList.id,\n              list_name: existingList.name,\n              content: item.content,\n            };\n            console.log(`[RealTimeExtraction] Added item to list \"${existingList.name}\": \"${listResult.item_content}\"`);\n            return result;\n          } else {\n            // List doesn't exist - create it with the item\n            let entityId: string | null = null;\n            if (listResult.entity_name) {\n              entityId = await resolveEntityName(listResult.entity_name);\n            }\n\n            const newList = await createList({\n              name: listResult.list_name,\n              list_type: 'checklist',\n              primary_entity_id: entityId ?? undefined,\n            });\n\n            const item = await addItem(newList.id, {\n              content: listResult.item_content,\n            });\n\n            result.listCreated = {\n              id: newList.id,\n              name: newList.name,\n            };\n            result.listItemCreated = {\n              id: item.id,\n              list_id: newList.id,\n              list_name: newList.name,\n              content: item.content,\n            };\n            console.log(`[RealTimeExtraction] Created list \"${newList.name}\" and added item: \"${listResult.item_content}\"`);\n            return result;\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[RealTimeExtraction] List detection error:', error);\n    }\n  }\n  */\n\n  // Check for commitment (lower priority - check last)\n  if (commitmentKeywords.test(message)) {\n    console.log(`[RealTimeExtraction] Commitment keywords matched - this means reminder early return did NOT happen`);\n    try {\n      const commitmentResult = await detectCommitment(message);\n      console.log(`[RealTimeExtraction] Commitment detection result:`, JSON.stringify(commitmentResult, null, 2));\n      if (commitmentResult?.is_commitment && commitmentResult.title) {\n        const commitment = await createCommitment({\n          title: commitmentResult.title,\n          description: commitmentResult.description || undefined,\n          due_at: commitmentResult.due_at ? new Date(commitmentResult.due_at) : undefined,\n          all_day: commitmentResult.all_day,\n          source_type: 'chat',\n        });\n        result.commitmentCreated = {\n          id: commitment.id,\n          title: commitmentResult.title,\n        };\n        console.log(`[RealTimeExtraction] Created commitment: \"${commitmentResult.title}\"`);\n      }\n    } catch (error) {\n      console.error('[RealTimeExtraction] Commitment detection error:', error);\n    }\n  }\n\n  return result;\n}",
      "references": [
        "extractIdentityRealTime",
        "result",
        "extractRelationshipsRealTime",
        "reminderKeywords",
        "detectReminderRequest",
        "console",
        "JSON",
        "reminderResult",
        "Date",
        "reminder",
        "createScheduledReminder",
        "scheduledDate",
        "createStandaloneReminder",
        "error",
        "commitmentKeywords",
        "detectCommitment",
        "commitmentResult",
        "createCommitment",
        "commitment"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:detectIdentityWithLLM:1733": {
      "id": "file:src/services/chatExtraction.ts:fn:detectIdentityWithLLM:1733",
      "type": "function",
      "name": "detectIdentityWithLLM",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1733,
      "endLine": 1764,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<IdentityDetectionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects identity info like name from message using LLM API, returns null if unlikely or fails",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.013Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectIdentityWithLLM(message: string): Promise<IdentityDetectionResult | null> {\n  // Quick pre-filter: skip messages that definitely don't contain identity patterns\n  // This saves LLM calls for messages like \"show me my notes\" or \"what's the weather\"\n  const mightContainIdentity = /\\b(i'?m|i am|my name|call me|this is)\\b/i.test(message);\n  if (!mightContainIdentity) {\n    return null;\n  }\n\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: IDENTITY_DETECTION_PROMPT },\n      { role: 'user', content: message },\n    ];\n\n    const result = await complete(messages, {\n      temperature: 0.1, // Low temperature for consistent detection\n      maxTokens: 200,\n    });\n\n    const parsed = safeParseJSON<IdentityDetectionResult>(result.content);\n    if (!parsed) {\n      console.error('[IdentityDetection] Failed to parse LLM response:', result.content.substring(0, 200));\n      return null;\n    }\n\n    console.log(`[IdentityDetection] LLM result: is_intro=${parsed.is_self_introduction}, name=${parsed.name}, confidence=${parsed.confidence}, reason=\"${parsed.reasoning}\"`);\n    return parsed;\n  } catch (error) {\n    console.error('[IdentityDetection] LLM detection failed:', error);\n    return null;\n  }\n}",
      "references": [
        "mightContainIdentity",
        "IDENTITY_DETECTION_PROMPT",
        "complete",
        "messages",
        "safeParseJSON",
        "result",
        "parsed",
        "console",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractIdentityRealTime:1773": {
      "id": "file:src/services/chatExtraction.ts:fn:extractIdentityRealTime:1773",
      "type": "function",
      "name": "extractIdentityRealTime",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1773,
      "endLine": 1861,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "result",
          "type": "{ identityExtracted: { name: string; memoryId: string; }; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts user identity from chat message via LLM, sets/locks if first-time and confident",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.013Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function extractIdentityRealTime(\n  message: string,\n  result: { identityExtracted: { name: string; memoryId: string } | null }\n): Promise<void> {\n  // CRITICAL: Check if identity is already locked\n  // If locked, skip ALL identity detection - name is immutable\n  const existingIdentity = await getUserIdentity();\n  if (existingIdentity?.is_locked) {\n    // Identity is locked - do not attempt to detect or change name\n    // This is the core protection against accidental name changes\n    return;\n  }\n\n  // Use LLM to detect identity - this is the robust approach\n  const detection = await detectIdentityWithLLM(message);\n\n  // No identity detected or LLM call failed\n  if (!detection || !detection.is_self_introduction || !detection.name) {\n    return;\n  }\n\n  // Require high confidence to prevent false positives\n  if (detection.confidence < 0.8) {\n    console.log(`[RealTimeExtraction] Low confidence (${detection.confidence}) for name \"${detection.name}\", skipping`);\n    return;\n  }\n\n  const newName = detection.name;\n\n  try {\n    // If we already have an identity (but it wasn't locked), don't override\n    // This is a safety check - normally identity should be locked\n    if (existingIdentity) {\n      console.log(`[RealTimeExtraction] Identity exists but unlocked: \"${existingIdentity.name}\" - not overriding`);\n      return;\n    }\n\n    // First-time identity detection - set and lock it\n    console.log(`[RealTimeExtraction] First-time identity detected: \"${newName}\" (confidence: ${detection.confidence})`);\n\n    // Create the locked identity record\n    await setInitialIdentity(newName, 'auto_detection');\n\n    // Create identity memory\n    const memoryContent = `The user's name is ${newName}`;\n    const { memory } = await createMemory({\n      content: memoryContent,\n      source: 'chat',\n      content_type: 'identity',\n      source_metadata: {\n        extraction_type: 'identity',\n        real_time: true,\n        salience_hint: 10,\n        llm_validated: true,\n        llm_confidence: detection.confidence,\n        llm_reasoning: detection.reasoning,\n        identity_locked: true,\n      },\n    });\n\n    // Force high salience\n    await pool.query(\n      `UPDATE memories SET salience_score = 10.0 WHERE id = $1`,\n      [memory.id]\n    );\n\n    // Link to personality category\n    await linkMemoryToCategories(memory.id, [{\n      category: 'personality',\n      relevance: 1.0,\n      reason: 'User self-introduction - core identity (locked)',\n    }]);\n\n    // Update personality summary with the name\n    const personalitySummary = await getSummary('personality');\n    if (personalitySummary) {\n      const summaryContent = personalitySummary.content || '';\n      if (!summaryContent.toLowerCase().includes(newName.toLowerCase())) {\n        const updatedContent = `Your name is ${newName}. ${summaryContent}`;\n        await updateSummary('personality', updatedContent.trim(), 'real-time-extraction', 0);\n      }\n    }\n\n    result.identityExtracted = { name: newName, memoryId: memory.id };\n    console.log(`[RealTimeExtraction] Identity locked: \"${newName}\" - will never auto-change again`);\n  } catch (error) {\n    console.error('[RealTimeExtraction] Identity extraction error:', error);\n  }\n}",
      "references": [
        "getUserIdentity",
        "existingIdentity",
        "detectIdentityWithLLM",
        "detection",
        "console",
        "newName",
        "setInitialIdentity",
        "memory",
        "createMemory",
        "memoryContent",
        "pool",
        "linkMemoryToCategories",
        "getSummary",
        "personalitySummary",
        "summaryContent",
        "updateSummary",
        "updatedContent",
        "error"
      ]
    },
    "file:src/services/chatExtraction.ts:fn:extractRelationshipsRealTime:1867": {
      "id": "file:src/services/chatExtraction.ts:fn:extractRelationshipsRealTime:1867",
      "type": "function",
      "name": "extractRelationshipsRealTime",
      "filePath": "/home/ridgetop/projects/squire/src/services/chatExtraction.ts",
      "line": 1867,
      "endLine": 1990,
      "parentFileId": "file:src/services/chatExtraction.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts user relationships and personal info from chat messages using regex patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "async function extractRelationshipsRealTime(message: string): Promise<void> {\n  const relationshipPatterns: Array<{\n    pattern: RegExp;\n    template: (match: RegExpMatchArray) => string;\n    categories: Array<{ category: 'personality' | 'relationships'; relevance: number }>;\n  }> = [\n    // Spouse patterns\n    {\n      pattern: /my (?:wife|spouse|partner)(?:'s name)? is (\\w+)/i,\n      template: (m) => `The user's wife/partner is named ${m[1]}`,\n      categories: [\n        { category: 'personality', relevance: 0.9 },\n        { category: 'relationships', relevance: 1.0 },\n      ],\n    },\n    {\n      pattern: /my (?:husband|spouse|partner)(?:'s name)? is (\\w+)/i,\n      template: (m) => `The user's husband/partner is named ${m[1]}`,\n      categories: [\n        { category: 'personality', relevance: 0.9 },\n        { category: 'relationships', relevance: 1.0 },\n      ],\n    },\n    {\n      pattern: /(?:i'm|i am) married to (\\w+)/i,\n      template: (m) => `The user is married to ${m[1]}`,\n      categories: [\n        { category: 'personality', relevance: 0.9 },\n        { category: 'relationships', relevance: 1.0 },\n      ],\n    },\n    // Children patterns\n    {\n      pattern: /my (?:son|daughter|child)(?:'s name)? is (\\w+)/i,\n      template: (m) => `The user has a child named ${m[1]}`,\n      categories: [\n        { category: 'personality', relevance: 0.8 },\n        { category: 'relationships', relevance: 1.0 },\n      ],\n    },\n    {\n      pattern: /i have (?:a )?(\\d+) (?:kids?|children)/i,\n      template: (m) => `The user has ${m[1]} children`,\n      categories: [\n        { category: 'personality', relevance: 0.9 },\n        { category: 'relationships', relevance: 0.8 },\n      ],\n    },\n    // Job patterns\n    {\n      pattern: /i (?:work|am employed) (?:at|for) (.+?)(?:\\.|,|$)/i,\n      template: (m) => `The user works at ${(m[1] || '').trim()}`,\n      categories: [{ category: 'personality', relevance: 1.0 }],\n    },\n    {\n      pattern: /(?:i'm|i am) (?:a|an) (.+?) (?:at|for|by profession)/i,\n      template: (m) => `The user is a ${(m[1] || '').trim()}`,\n      categories: [{ category: 'personality', relevance: 1.0 }],\n    },\n    // Age patterns\n    {\n      pattern: /(?:i'm|i am) (\\d+) (?:years? old)?/i,\n      template: (m) => `The user is ${m[1] || ''} years old`,\n      categories: [{ category: 'personality', relevance: 1.0 }],\n    },\n    // Location patterns\n    {\n      pattern: /i live in (.+?)(?:\\.|,|$)/i,\n      template: (m) => `The user lives in ${(m[1] || '').trim()}`,\n      categories: [{ category: 'personality', relevance: 0.9 }],\n    },\n  ];\n\n  for (const { pattern, template, categories } of relationshipPatterns) {\n    const match = message.match(pattern);\n    if (match) {\n      const content = template(match);\n\n      try {\n        // Check if we already have this info stored\n        const existing = await pool.query(\n          `SELECT id FROM memories\n           WHERE content ILIKE $1\n           AND created_at > NOW() - INTERVAL '30 days'\n           LIMIT 1`,\n          [`%${content.substring(0, 30)}%`]\n        );\n\n        if (existing.rows.length > 0) {\n          console.log(`[RealTimeExtraction] Relationship already known: \"${content.substring(0, 40)}...\"`);\n          continue;\n        }\n\n        // Create memory\n        const { memory } = await createMemory({\n          content,\n          source: 'chat',\n          content_type: 'identity',\n          source_metadata: {\n            extraction_type: 'relationship',\n            real_time: true,\n            salience_hint: 8,\n          },\n        });\n\n        // Set high salience\n        await pool.query(\n          `UPDATE memories SET salience_score = 8.0 WHERE id = $1`,\n          [memory.id]\n        );\n\n        // Link to categories\n        await linkMemoryToCategories(\n          memory.id,\n          categories.map((c) => ({ ...c, reason: 'Real-time relationship extraction' }))\n        );\n\n        console.log(`[RealTimeExtraction] Extracted relationship: \"${content}\"`);\n      } catch (error) {\n        console.error('[RealTimeExtraction] Relationship extraction error:', error);\n      }\n    }\n  }\n}",
      "references": [
        "m",
        "pattern",
        "template",
        "categories",
        "relationshipPatterns",
        "match",
        "pool",
        "content",
        "existing",
        "console",
        "memory",
        "createMemory",
        "linkMemoryToCategories",
        "c",
        "error"
      ]
    },
    "file:src/services/commitments.ts": {
      "id": "file:src/services/commitments.ts",
      "type": "file",
      "name": "commitments.ts",
      "filePath": "src/services/commitments.ts",
      "line": 1,
      "endLine": 948,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./recurrence.js",
          "items": [
            {
              "name": "expandRecurrence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNextOccurrence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./google/auth.js",
          "items": [
            {
              "name": "listSyncEnabledAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./summaries.js",
          "items": [
            {
              "name": "refreshCommitmentsSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listCommitments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "resolveCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "snoozeCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unsnoozeCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findMatchingCommitments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getUpcomingCommitments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getOverdueCommitments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countCommitmentsByStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "setGoogleSync",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "expandCommitmentOccurrences",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listCommitmentsExpanded",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getNextCommitmentOccurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isRecurring",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "parseOccurrenceId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingCandidates",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markConfirmationOffered",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "confirmCandidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "dismissCandidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "expireCandidates",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getLastOfferedCandidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "CommitmentStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ResolutionType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "SourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GoogleSyncStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Commitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateCommitmentInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateCommitmentInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListCommitmentsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ResolveCommitmentInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SnoozeCommitmentInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExpandedCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListExpandedOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/commitments.ts:fn:createCommitment:101",
        "file:src/services/commitments.ts:fn:getCommitment:218",
        "file:src/services/commitments.ts:fn:listCommitments:229",
        "file:src/services/commitments.ts:fn:updateCommitment:298",
        "file:src/services/commitments.ts:fn:deleteCommitment:401",
        "file:src/services/commitments.ts:fn:resolveCommitment:410",
        "file:src/services/commitments.ts:fn:snoozeCommitment:452",
        "file:src/services/commitments.ts:fn:unsnoozeCommitment:474",
        "file:src/services/commitments.ts:fn:findMatchingCommitments:491",
        "file:src/services/commitments.ts:fn:getUpcomingCommitments:518",
        "file:src/services/commitments.ts:fn:getOverdueCommitments:540",
        "file:src/services/commitments.ts:fn:countCommitmentsByStatus:555",
        "file:src/services/commitments.ts:fn:setGoogleSync:580",
        "file:src/services/commitments.ts:fn:expandCommitmentOccurrences:646",
        "file:src/services/commitments.ts:fn:listCommitmentsExpanded:690",
        "file:src/services/commitments.ts:fn:getNextCommitmentOccurrence:772",
        "file:src/services/commitments.ts:fn:isRecurring:787",
        "file:src/services/commitments.ts:fn:parseOccurrenceId:795",
        "file:src/services/commitments.ts:fn:getPendingCandidates:837",
        "file:src/services/commitments.ts:fn:markConfirmationOffered:854",
        "file:src/services/commitments.ts:fn:confirmCandidate:867",
        "file:src/services/commitments.ts:fn:dismissCandidate:893",
        "file:src/services/commitments.ts:fn:expireCandidates:913",
        "file:src/services/commitments.ts:fn:getLastOfferedCandidate:937"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/commitments.ts:fn:createCommitment:101": {
      "id": "file:src/services/commitments.ts:fn:createCommitment:101",
      "type": "function",
      "name": "createCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 101,
      "endLine": 213,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").CreateCommitmentInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates commitment after DB duplicate check and embedding generation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createCommitment(input: CreateCommitmentInput): Promise<Commitment> {\n  const {\n    title,\n    description,\n    memory_id,\n    source_type = 'manual',\n    due_at,\n    timezone = config.timezone,\n    all_day = false,\n    duration_minutes,\n    rrule,\n    recurrence_end_at,\n    tags = [],\n    metadata = {},\n  } = input;\n\n  // Deduplication: check for existing commitment with same title and same date\n  // This prevents duplicates when extraction runs on both real-time and consolidation paths\n  if (due_at) {\n    const existing = await pool.query(\n      `SELECT * FROM commitments\n       WHERE title = $1 AND DATE(due_at) = DATE($2)\n       AND status NOT IN ('completed', 'canceled')`,\n      [title, due_at]\n    );\n    if (existing.rows.length > 0) {\n      console.log(`[Commitments] Skipping duplicate commitment: \"${title}\" on ${due_at.toDateString()}`);\n      return existing.rows[0] as Commitment;\n    }\n  } else {\n    // No due date - check for exact title match within last hour (to catch rapid duplicates)\n    const existing = await pool.query(\n      `SELECT * FROM commitments\n       WHERE title = $1 AND due_at IS NULL\n       AND status NOT IN ('completed', 'canceled')\n       AND created_at > NOW() - INTERVAL '1 hour'`,\n      [title]\n    );\n    if (existing.rows.length > 0) {\n      console.log(`[Commitments] Skipping duplicate commitment (no date): \"${title}\"`);\n      return existing.rows[0] as Commitment;\n    }\n  }\n\n  // Generate embedding for resolution matching (combine title + description)\n  const textForEmbedding = description ? `${title}. ${description}` : title;\n  const embedding = await generateEmbedding(textForEmbedding);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  // Phase 4: Commitments from chat start as 'candidate', others start as 'open'\n  // Candidates auto-expire after 24 hours if not confirmed\n  const initialStatus = source_type === 'chat' ? 'candidate' : 'open';\n  const autoExpiresAt = source_type === 'chat' \n    ? new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n    : null;\n\n  const result = await pool.query(\n    `INSERT INTO commitments (\n      title, description, memory_id, source_type,\n      due_at, timezone, all_day, duration_minutes,\n      rrule, recurrence_end_at, original_due_at,\n      tags, metadata, embedding, status, auto_expires_at\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $5, $11, $12, $13, $14, $15)\n    RETURNING *`,\n    [\n      title,\n      description ?? null,\n      memory_id ?? null,\n      source_type,\n      due_at ?? null,\n      timezone,\n      all_day,\n      duration_minutes ?? null,\n      rrule ?? null,\n      recurrence_end_at ?? null,\n      tags,\n      JSON.stringify(metadata),\n      embeddingStr,\n      initialStatus,\n      autoExpiresAt,\n    ]\n  );\n\n  if (initialStatus === 'candidate') {\n    console.log(`[Commitments] Created CANDIDATE: \"${title}\" (expires in 24h)`);\n  }\n\n  const commitment = result.rows[0] as Commitment;\n\n  // Auto-mark for Google sync if there's a sync-enabled account and commitment has a due date\n  if (due_at && source_type !== 'google_sync') {\n    try {\n      const accounts = await listSyncEnabledAccounts();\n      const firstAccount = accounts[0];\n      if (firstAccount) {\n        await pool.query(\n          `UPDATE commitments SET\n            google_account_id = $1,\n            google_sync_status = 'pending_push'\n          WHERE id = $2`,\n          [firstAccount.id, commitment.id]\n        );\n        console.log(`[Commitments] Marked \"${title}\" for Google sync`);\n      }\n    } catch (err) {\n      // Don't fail commitment creation if sync marking fails\n      console.error('[Commitments] Failed to mark for Google sync:', err);\n    }\n  }\n\n  return commitment;\n}",
      "references": [
        "title",
        "description",
        "memory_id",
        "source_type",
        "due_at",
        "timezone",
        "config",
        "all_day",
        "duration_minutes",
        "rrule",
        "recurrence_end_at",
        "tags",
        "metadata",
        "pool",
        "existing",
        "console",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "Date",
        "JSON",
        "embeddingStr",
        "initialStatus",
        "autoExpiresAt",
        "result",
        "listSyncEnabledAccounts",
        "accounts",
        "firstAccount",
        "commitment",
        "err"
      ]
    },
    "file:src/services/commitments.ts:fn:getCommitment:218": {
      "id": "file:src/services/commitments.ts:fn:getCommitment:218",
      "type": "function",
      "name": "getCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 218,
      "endLine": 224,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a commitment by ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCommitment(id: string): Promise<Commitment | null> {\n  const result = await pool.query(\n    'SELECT * FROM commitments WHERE id = $1',\n    [id]\n  );\n  return (result.rows[0] as Commitment) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:listCommitments:229": {
      "id": "file:src/services/commitments.ts:fn:listCommitments:229",
      "type": "function",
      "name": "listCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 229,
      "endLine": 293,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").ListCommitmentsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for commitments with filters, pagination, and sorting by due date.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listCommitments(options: ListCommitmentsOptions = {}): Promise<Commitment[]> {\n  const {\n    limit = 50,\n    offset = 0,\n    status,\n    due_before,\n    due_after,\n    include_resolved = false,\n    parent_commitment_id,\n  } = options;\n\n  const conditions: string[] = [];\n  const params: (string | number | Date | string[])[] = [];\n  let paramIndex = 1;\n\n  // Filter by status\n  if (status) {\n    if (Array.isArray(status)) {\n      conditions.push(`status = ANY($${paramIndex})`);\n      params.push(status);\n    } else {\n      conditions.push(`status = $${paramIndex}`);\n      params.push(status);\n    }\n    paramIndex++;\n  } else if (!include_resolved) {\n    // Default: exclude resolved commitments\n    conditions.push(`status NOT IN ('completed', 'canceled')`);\n  }\n\n  // Filter by due date range\n  if (due_before) {\n    conditions.push(`due_at <= $${paramIndex}`);\n    params.push(due_before);\n    paramIndex++;\n  }\n\n  if (due_after) {\n    conditions.push(`due_at >= $${paramIndex}`);\n    params.push(due_after);\n    paramIndex++;\n  }\n\n  // Filter by parent (for recurring instances)\n  if (parent_commitment_id) {\n    conditions.push(`parent_commitment_id = $${paramIndex}`);\n    params.push(parent_commitment_id);\n    paramIndex++;\n  }\n\n  let query = 'SELECT * FROM commitments';\n  if (conditions.length > 0) {\n    query += ' WHERE ' + conditions.join(' AND ');\n  }\n\n  query += ` ORDER BY\n    CASE WHEN due_at IS NULL THEN 1 ELSE 0 END,\n    due_at ASC,\n    created_at DESC`;\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as Commitment[];\n}",
      "references": [
        "limit",
        "offset",
        "status",
        "due_before",
        "due_after",
        "include_resolved",
        "parent_commitment_id",
        "Array",
        "conditions",
        "paramIndex",
        "params",
        "query",
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:updateCommitment:298": {
      "id": "file:src/services/commitments.ts:fn:updateCommitment:298",
      "type": "function",
      "name": "updateCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 298,
      "endLine": 396,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").UpdateCommitmentInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Dynamically builds and prepares SQL UPDATE query for commitment with given input",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateCommitment(\n  id: string,\n  input: UpdateCommitmentInput\n): Promise<Commitment | null> {\n  const updates: string[] = [];\n  const params: (string | number | Date | boolean | string[] | null)[] = [];\n  let paramIndex = 1;\n\n  // Build dynamic update query\n  if (input.title !== undefined) {\n    updates.push(`title = $${paramIndex}`);\n    params.push(input.title);\n    paramIndex++;\n  }\n  if (input.description !== undefined) {\n    updates.push(`description = $${paramIndex}`);\n    params.push(input.description);\n    paramIndex++;\n  }\n  if (input.due_at !== undefined) {\n    updates.push(`due_at = $${paramIndex}`);\n    params.push(input.due_at);\n    paramIndex++;\n  }\n  if (input.timezone !== undefined) {\n    updates.push(`timezone = $${paramIndex}`);\n    params.push(input.timezone);\n    paramIndex++;\n  }\n  if (input.all_day !== undefined) {\n    updates.push(`all_day = $${paramIndex}`);\n    params.push(input.all_day);\n    paramIndex++;\n  }\n  if (input.duration_minutes !== undefined) {\n    updates.push(`duration_minutes = $${paramIndex}`);\n    params.push(input.duration_minutes);\n    paramIndex++;\n  }\n  if (input.rrule !== undefined) {\n    updates.push(`rrule = $${paramIndex}`);\n    params.push(input.rrule);\n    paramIndex++;\n  }\n  if (input.recurrence_end_at !== undefined) {\n    updates.push(`recurrence_end_at = $${paramIndex}`);\n    params.push(input.recurrence_end_at);\n    paramIndex++;\n  }\n  if (input.status !== undefined) {\n    updates.push(`status = $${paramIndex}`);\n    params.push(input.status);\n    paramIndex++;\n  }\n  if (input.tags !== undefined) {\n    updates.push(`tags = $${paramIndex}`);\n    params.push(input.tags);\n    paramIndex++;\n  }\n  if (input.metadata !== undefined) {\n    updates.push(`metadata = $${paramIndex}`);\n    params.push(JSON.stringify(input.metadata));\n    paramIndex++;\n  }\n  if (input.google_sync_status !== undefined) {\n    updates.push(`google_sync_status = $${paramIndex}`);\n    params.push(input.google_sync_status);\n    paramIndex++;\n  }\n\n  if (updates.length === 0) {\n    return getCommitment(id);\n  }\n\n  // Always update updated_at\n  updates.push('updated_at = NOW()');\n\n  // Re-generate embedding if title or description changed\n  if (input.title !== undefined || input.description !== undefined) {\n    // Fetch current to merge with updates\n    const current = await getCommitment(id);\n    if (current) {\n      const newTitle = input.title ?? current.title;\n      const newDesc = input.description ?? current.description;\n      const textForEmbedding = newDesc ? `${newTitle}. ${newDesc}` : newTitle;\n      const embedding = await generateEmbedding(textForEmbedding);\n      const embeddingStr = `[${embedding.join(',')}]`;\n      updates.push(`embedding = $${paramIndex}`);\n      params.push(embeddingStr);\n      paramIndex++;\n    }\n  }\n\n  params.push(id);\n  const query = `UPDATE commitments SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`;\n\n  const result = await pool.query(query, params);\n  return (result.rows[0] as Commitment) ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "JSON",
        "getCommitment",
        "current",
        "newDesc",
        "newTitle",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "embeddingStr",
        "pool",
        "query",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:deleteCommitment:401": {
      "id": "file:src/services/commitments.ts:fn:deleteCommitment:401",
      "type": "function",
      "name": "deleteCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 401,
      "endLine": 404,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a commitment from the database by ID and returns true if row was deleted",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteCommitment(id: string): Promise<boolean> {\n  const result = await pool.query('DELETE FROM commitments WHERE id = $1', [id]);\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:resolveCommitment:410": {
      "id": "file:src/services/commitments.ts:fn:resolveCommitment:410",
      "type": "function",
      "name": "resolveCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 410,
      "endLine": 447,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").ResolveCommitmentInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates commitment status to resolved in DB and triggers summary refresh",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function resolveCommitment(\n  id: string,\n  input: ResolveCommitmentInput\n): Promise<Commitment | null> {\n  const { resolution_type, resolution_memory_id } = input;\n\n  // Map resolution type to status\n  const statusMap: Record<ResolutionType, CommitmentStatus> = {\n    completed: 'completed',\n    canceled: 'canceled',\n    no_longer_relevant: 'canceled',\n    superseded: 'canceled',\n  };\n\n  const result = await pool.query(\n    `UPDATE commitments\n     SET status = $1,\n         resolved_at = NOW(),\n         resolution_type = $2,\n         resolution_memory_id = $3,\n         updated_at = NOW()\n     WHERE id = $4\n     RETURNING *`,\n    [statusMap[resolution_type], resolution_type, resolution_memory_id ?? null, id]\n  );\n\n  const resolved = (result.rows[0] as Commitment) ?? null;\n\n  // Trigger background refresh of commitments summary to prevent staleness\n  // Fire-and-forget to not slow down the resolution\n  if (resolved) {\n    refreshCommitmentsSummary().catch((err) => {\n      console.error('[Commitments] Failed to refresh summary after resolution:', err);\n    });\n  }\n\n  return resolved;\n}",
      "references": [
        "resolution_type",
        "resolution_memory_id",
        "pool",
        "statusMap",
        "result",
        "resolved",
        "refreshCommitmentsSummary",
        "console",
        "err"
      ]
    },
    "file:src/services/commitments.ts:fn:snoozeCommitment:452": {
      "id": "file:src/services/commitments.ts:fn:snoozeCommitment:452",
      "type": "function",
      "name": "snoozeCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 452,
      "endLine": 469,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").SnoozeCommitmentInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates commitment to snoozed status with new due date and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function snoozeCommitment(\n  id: string,\n  input: SnoozeCommitmentInput\n): Promise<Commitment | null> {\n  const { snooze_until } = input;\n\n  const result = await pool.query(\n    `UPDATE commitments\n     SET status = 'snoozed',\n         due_at = $1,\n         updated_at = NOW()\n     WHERE id = $2\n     RETURNING *`,\n    [snooze_until, id]\n  );\n\n  return (result.rows[0] as Commitment) ?? null;\n}",
      "references": [
        "snooze_until",
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:unsnoozeCommitment:474": {
      "id": "file:src/services/commitments.ts:fn:unsnoozeCommitment:474",
      "type": "function",
      "name": "unsnoozeCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 474,
      "endLine": 485,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates snoozed commitment to open status and returns the updated row",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unsnoozeCommitment(id: string): Promise<Commitment | null> {\n  const result = await pool.query(\n    `UPDATE commitments\n     SET status = 'open',\n         updated_at = NOW()\n     WHERE id = $1 AND status = 'snoozed'\n     RETURNING *`,\n    [id]\n  );\n\n  return (result.rows[0] as Commitment) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:findMatchingCommitments:491": {
      "id": "file:src/services/commitments.ts:fn:findMatchingCommitments:491",
      "type": "function",
      "name": "findMatchingCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 491,
      "endLine": 513,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSimilarity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment & { similarity: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for commitments matching text embedding by vector similarity",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findMatchingCommitments(\n  text: string,\n  options: { limit?: number; minSimilarity?: number } = {}\n): Promise<(Commitment & { similarity: number })[]> {\n  const { limit = 5, minSimilarity = 0.5 } = options;\n\n  const embedding = await generateEmbedding(text);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query(\n    `SELECT *,\n       1 - (embedding <=> $1::vector) as similarity\n     FROM commitments\n     WHERE status IN ('open', 'in_progress')\n       AND embedding IS NOT NULL\n       AND 1 - (embedding <=> $1::vector) >= $2\n     ORDER BY embedding <=> $1::vector\n     LIMIT $3`,\n    [embeddingStr, minSimilarity, limit]\n  );\n\n  return result.rows as (Commitment & { similarity: number })[];\n}",
      "references": [
        "limit",
        "minSimilarity",
        "generateEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:getUpcomingCommitments:518": {
      "id": "file:src/services/commitments.ts:fn:getUpcomingCommitments:518",
      "type": "function",
      "name": "getUpcomingCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 518,
      "endLine": 535,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "withinMinutes",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ status?: import(\"/home/ridgetop/projects/squire/src/services/commitments\").CommitmentStatus[]; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches upcoming commitments due within specified minutes by status from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getUpcomingCommitments(\n  withinMinutes: number,\n  options: { status?: CommitmentStatus[] } = {}\n): Promise<Commitment[]> {\n  const { status = ['open', 'in_progress'] } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM commitments\n     WHERE status = ANY($1)\n       AND due_at IS NOT NULL\n       AND due_at <= NOW() + INTERVAL '1 minute' * $2\n       AND due_at >= NOW()\n     ORDER BY due_at ASC`,\n    [status, withinMinutes]\n  );\n\n  return result.rows as Commitment[];\n}",
      "references": [
        "status",
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:getOverdueCommitments:540": {
      "id": "file:src/services/commitments.ts:fn:getOverdueCommitments:540",
      "type": "function",
      "name": "getOverdueCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 540,
      "endLine": 550,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for overdue commitments (open/in_progress, due_at < NOW()) ordered by due_at ASC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getOverdueCommitments(): Promise<Commitment[]> {\n  const result = await pool.query(\n    `SELECT * FROM commitments\n     WHERE status IN ('open', 'in_progress')\n       AND due_at IS NOT NULL\n       AND due_at < NOW()\n     ORDER BY due_at ASC`\n  );\n\n  return result.rows as Commitment[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:countCommitmentsByStatus:555": {
      "id": "file:src/services/commitments.ts:fn:countCommitmentsByStatus:555",
      "type": "function",
      "name": "countCommitmentsByStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 555,
      "endLine": 575,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<Record<import(\"/home/ridgetop/projects/squire/src/services/commitments\").CommitmentStatus, number>>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Counts commitments by status from database using SQL query.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function countCommitmentsByStatus(): Promise<Record<CommitmentStatus, number>> {\n  const result = await pool.query(\n    `SELECT status, COUNT(*) as count\n     FROM commitments\n     GROUP BY status`\n  );\n\n  const counts: Record<string, number> = {\n    open: 0,\n    in_progress: 0,\n    completed: 0,\n    canceled: 0,\n    snoozed: 0,\n  };\n\n  for (const row of result.rows) {\n    counts[row.status] = parseInt(row.count, 10);\n  }\n\n  return counts as Record<CommitmentStatus, number>;\n}",
      "references": [
        "pool",
        "result",
        "counts",
        "row",
        "parseInt"
      ]
    },
    "file:src/services/commitments.ts:fn:setGoogleSync:580": {
      "id": "file:src/services/commitments.ts:fn:setGoogleSync:580",
      "type": "function",
      "name": "setGoogleSync",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 580,
      "endLine": 612,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "googleData",
          "type": "{ google_account_id: string; google_calendar_id: string; google_event_id: string; google_etag?: string; google_sync_status?: import(\"/home/ridgetop/projects/squire/src/services/commitments\").GoogleSyncStatus; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates commitment with Google sync data, timestamps, returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function setGoogleSync(\n  id: string,\n  googleData: {\n    google_account_id: string;\n    google_calendar_id: string;\n    google_event_id: string;\n    google_etag?: string;\n    google_sync_status?: GoogleSyncStatus;\n  }\n): Promise<Commitment | null> {\n  const result = await pool.query(\n    `UPDATE commitments\n     SET google_account_id = $1,\n         google_calendar_id = $2,\n         google_event_id = $3,\n         google_etag = $4,\n         google_sync_status = $5,\n         last_synced_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $6\n     RETURNING *`,\n    [\n      googleData.google_account_id,\n      googleData.google_calendar_id,\n      googleData.google_event_id,\n      googleData.google_etag ?? null,\n      googleData.google_sync_status ?? 'synced',\n      id,\n    ]\n  );\n\n  return (result.rows[0] as Commitment) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:expandCommitmentOccurrences:646": {
      "id": "file:src/services/commitments.ts:fn:expandCommitmentOccurrences:646",
      "type": "function",
      "name": "expandCommitmentOccurrences",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 646,
      "endLine": 684,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitment",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ after?: Date; before: Date; limit?: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").ExpandedCommitment[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Expands recurring commitment into occurrences using rrule within date range",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function expandCommitmentOccurrences(\n  commitment: Commitment,\n  options: { after?: Date; before: Date; limit?: number }\n): ExpandedCommitment[] {\n  const { after = new Date(), before, limit = 50 } = options;\n\n  // Non-recurring commitments return as-is (single occurrence)\n  if (!commitment.rrule || !commitment.due_at) {\n    return [{\n      ...commitment,\n      is_occurrence: false,\n      occurrence_index: 0,\n      recurring_commitment_id: commitment.id,\n      template_due_at: commitment.due_at,\n    }];\n  }\n\n  // Expand the recurrence rule\n  const expansion = expandRecurrence(commitment.rrule, commitment.due_at, {\n    after,\n    before,\n    limit,\n  });\n\n  // Create an ExpandedCommitment for each occurrence\n  return expansion.occurrences.map((occurrenceDate, index) => {\n    return {\n      ...commitment,\n      // Override the due_at with the occurrence date\n      due_at: occurrenceDate,\n      // Generate a unique ID for this occurrence (commitment_id:occurrence_date)\n      id: `${commitment.id}:${occurrenceDate.toISOString()}`,\n      is_occurrence: true,\n      occurrence_index: index,\n      recurring_commitment_id: commitment.id,\n      template_due_at: commitment.due_at,\n    };\n  });\n}",
      "references": [
        "after",
        "Date",
        "before",
        "limit",
        "expandRecurrence",
        "expansion",
        "occurrenceDate",
        "index"
      ]
    },
    "file:src/services/commitments.ts:fn:listCommitmentsExpanded:690": {
      "id": "file:src/services/commitments.ts:fn:listCommitmentsExpanded:690",
      "type": "function",
      "name": "listCommitmentsExpanded",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 690,
      "endLine": 767,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").ListExpandedOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").ExpandedCommitment[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Lists commitments, expanding recurring ones into date-range occurrences",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listCommitmentsExpanded(\n  options: ListExpandedOptions = {}\n): Promise<ExpandedCommitment[]> {\n  const {\n    expand_recurring = true,\n    max_occurrences = 50,\n    due_before,\n    due_after,\n    ...listOptions\n  } = options;\n\n  // Fetch base commitments (including recurring templates)\n  const commitments = await listCommitments({\n    ...listOptions,\n    // For recurring, we need all templates regardless of due_at filter\n    // (their rrule may generate occurrences in the range)\n    due_before: undefined,\n    due_after: undefined,\n  });\n\n  if (!expand_recurring) {\n    // Return as ExpandedCommitment without expansion\n    return commitments.map(c => ({\n      ...c,\n      is_occurrence: false,\n      occurrence_index: 0,\n      recurring_commitment_id: c.id,\n      template_due_at: c.due_at,\n    }));\n  }\n\n  // Expand each commitment\n  const expanded: ExpandedCommitment[] = [];\n  const now = new Date();\n  const rangeStart = due_after ?? now;\n  const rangeEnd = due_before ?? new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000); // Default 90 days ahead\n\n  for (const commitment of commitments) {\n    if (commitment.rrule && commitment.due_at) {\n      // Recurring: expand into occurrences\n      const occurrences = expandCommitmentOccurrences(commitment, {\n        after: rangeStart,\n        before: rangeEnd,\n        limit: max_occurrences,\n      });\n      expanded.push(...occurrences);\n    } else {\n      // Non-recurring: include if within date range (or no due date)\n      const inRange = !commitment.due_at ||\n        (commitment.due_at >= rangeStart && commitment.due_at <= rangeEnd);\n\n      if (inRange) {\n        expanded.push({\n          ...commitment,\n          is_occurrence: false,\n          occurrence_index: 0,\n          recurring_commitment_id: commitment.id,\n          template_due_at: commitment.due_at,\n        });\n      }\n    }\n  }\n\n  // Sort by due_at\n  expanded.sort((a, b) => {\n    if (!a.due_at && !b.due_at) return 0;\n    if (!a.due_at) return 1;\n    if (!b.due_at) return -1;\n    return a.due_at.getTime() - b.due_at.getTime();\n  });\n\n  // Apply limit if specified\n  if (listOptions.limit) {\n    return expanded.slice(0, listOptions.limit);\n  }\n\n  return expanded;\n}",
      "references": [
        "expand_recurring",
        "max_occurrences",
        "due_before",
        "due_after",
        "listOptions",
        "listCommitments",
        "commitments",
        "c",
        "Date",
        "now",
        "commitment",
        "expandCommitmentOccurrences",
        "rangeStart",
        "rangeEnd",
        "expanded",
        "occurrences",
        "inRange",
        "a",
        "b"
      ]
    },
    "file:src/services/commitments.ts:fn:getNextCommitmentOccurrence:772": {
      "id": "file:src/services/commitments.ts:fn:getNextCommitmentOccurrence:772",
      "type": "function",
      "name": "getNextCommitmentOccurrence",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 772,
      "endLine": 782,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "after",
          "type": "Date",
          "isOptional": true,
          "defaultValue": "new Date()"
        }
      ],
      "returnType": "Promise<Date>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Gets the next occurrence date of a recurring commitment after a given date",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getNextCommitmentOccurrence(\n  id: string,\n  after: Date = new Date()\n): Promise<Date | null> {\n  const commitment = await getCommitment(id);\n  if (!commitment || !commitment.rrule || !commitment.due_at) {\n    return null;\n  }\n\n  return getNextOccurrence(commitment.rrule, commitment.due_at, after);\n}",
      "references": [
        "getCommitment",
        "commitment",
        "getNextOccurrence"
      ]
    },
    "file:src/services/commitments.ts:fn:isRecurring:787": {
      "id": "file:src/services/commitments.ts:fn:isRecurring:787",
      "type": "function",
      "name": "isRecurring",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 787,
      "endLine": 789,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitment",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if a commitment is recurring by verifying rrule and due_at properties.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.014Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isRecurring(commitment: Commitment): boolean {\n  return !!commitment.rrule && !!commitment.due_at;\n}",
      "references": []
    },
    "file:src/services/commitments.ts:fn:parseOccurrenceId:795": {
      "id": "file:src/services/commitments.ts:fn:parseOccurrenceId:795",
      "type": "function",
      "name": "parseOccurrenceId",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 795,
      "endLine": 827,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "occurrenceId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ commitmentId: string; occurrenceDate: Date; isOccurrence: boolean; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses occurrence ID string to extract commitment ID and optional date from UUID:ISO format.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.015Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function parseOccurrenceId(occurrenceId: string): {\n  commitmentId: string;\n  occurrenceDate: Date | null;\n  isOccurrence: boolean;\n} {\n  const parts = occurrenceId.split(':');\n\n  // Check if this looks like an occurrence ID (UUID:ISO date)\n  if (parts.length >= 2) {\n    // UUID has 5 parts separated by -, so reconstruct\n    const uuidParts = parts.slice(0, 5);\n    const datePart = parts.slice(5).join(':');\n\n    // Try to parse as UUID:date format\n    const potentialUuid = uuidParts.join('-');\n    const potentialDate = new Date(datePart);\n\n    if (!isNaN(potentialDate.getTime()) && potentialUuid.length === 36) {\n      return {\n        commitmentId: potentialUuid,\n        occurrenceDate: potentialDate,\n        isOccurrence: true,\n      };\n    }\n  }\n\n  // Not an occurrence ID, return as regular commitment ID\n  return {\n    commitmentId: occurrenceId,\n    occurrenceDate: null,\n    isOccurrence: false,\n  };\n}",
      "references": [
        "parts",
        "uuidParts",
        "Date",
        "datePart",
        "isNaN",
        "potentialDate",
        "potentialUuid"
      ]
    },
    "file:src/services/commitments.ts:fn:getPendingCandidates:837": {
      "id": "file:src/services/commitments.ts:fn:getPendingCandidates:837",
      "type": "function",
      "name": "getPendingCandidates",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 837,
      "endLine": 848,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "1"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pending candidate commitments from DB with optional limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.021Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPendingCandidates(limit: number = 1): Promise<Commitment[]> {\n  const result = await pool.query(\n    `SELECT * FROM commitments\n     WHERE status = 'candidate'\n       AND confirmation_offered_at IS NULL\n       AND (auto_expires_at IS NULL OR auto_expires_at > NOW())\n     ORDER BY created_at ASC\n     LIMIT $1`,\n    [limit]\n  );\n  return result.rows as Commitment[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/commitments.ts:fn:markConfirmationOffered:854": {
      "id": "file:src/services/commitments.ts:fn:markConfirmationOffered:854",
      "type": "function",
      "name": "markConfirmationOffered",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 854,
      "endLine": 861,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates commitments table to set confirmation_offered_at=NOW() for candidate by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markConfirmationOffered(commitmentId: string): Promise<void> {\n  await pool.query(\n    `UPDATE commitments \n     SET confirmation_offered_at = NOW()\n     WHERE id = $1 AND status = 'candidate'`,\n    [commitmentId]\n  );\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/commitments.ts:fn:confirmCandidate:867": {
      "id": "file:src/services/commitments.ts:fn:confirmCandidate:867",
      "type": "function",
      "name": "confirmCandidate",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 867,
      "endLine": 887,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates candidate commitment to 'open' status via DB, logs, refreshes summaries, returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export async function confirmCandidate(commitmentId: string): Promise<Commitment | null> {\n  const result = await pool.query(\n    `UPDATE commitments \n     SET status = 'open', auto_expires_at = NULL, updated_at = NOW()\n     WHERE id = $1 AND status = 'candidate'\n     RETURNING *`,\n    [commitmentId]\n  );\n  \n  if (result.rows.length > 0) {\n    console.log(`[Commitments] Candidate CONFIRMED: \"${result.rows[0].title}\"`);\n    // Refresh summaries since we have a new active commitment\n    try {\n      await refreshCommitmentsSummary();\n    } catch {\n      // Non-critical\n    }\n    return result.rows[0] as Commitment;\n  }\n  return null;\n}",
      "references": [
        "pool",
        "result",
        "console",
        "refreshCommitmentsSummary"
      ]
    },
    "file:src/services/commitments.ts:fn:dismissCandidate:893": {
      "id": "file:src/services/commitments.ts:fn:dismissCandidate:893",
      "type": "function",
      "name": "dismissCandidate",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 893,
      "endLine": 907,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates candidate commitment to dismissed status and returns it or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function dismissCandidate(commitmentId: string): Promise<Commitment | null> {\n  const result = await pool.query(\n    `UPDATE commitments \n     SET status = 'dismissed', auto_expires_at = NULL, updated_at = NOW()\n     WHERE id = $1 AND status = 'candidate'\n     RETURNING *`,\n    [commitmentId]\n  );\n  \n  if (result.rows.length > 0) {\n    console.log(`[Commitments] Candidate DISMISSED: \"${result.rows[0].title}\"`);\n    return result.rows[0] as Commitment;\n  }\n  return null;\n}",
      "references": [
        "pool",
        "result",
        "console"
      ]
    },
    "file:src/services/commitments.ts:fn:expireCandidates:913": {
      "id": "file:src/services/commitments.ts:fn:expireCandidates:913",
      "type": "function",
      "name": "expireCandidates",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 913,
      "endLine": 931,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates expired candidate commitments to 'expired' status and returns count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function expireCandidates(): Promise<number> {\n  const result = await pool.query(\n    `UPDATE commitments \n     SET status = 'expired', updated_at = NOW()\n     WHERE status = 'candidate'\n       AND auto_expires_at IS NOT NULL\n       AND auto_expires_at < NOW()\n     RETURNING id, title`\n  );\n  \n  const count = result.rowCount ?? 0;\n  if (count > 0) {\n    console.log(`[Commitments] Expired ${count} unconfirmed candidates`);\n    for (const row of result.rows) {\n      console.log(`  - \"${row.title}\"`);\n    }\n  }\n  return count;\n}",
      "references": [
        "pool",
        "result",
        "count",
        "console",
        "row"
      ]
    },
    "file:src/services/commitments.ts:fn:getLastOfferedCandidate:937": {
      "id": "file:src/services/commitments.ts:fn:getLastOfferedCandidate:937",
      "type": "function",
      "name": "getLastOfferedCandidate",
      "filePath": "/home/ridgetop/projects/squire/src/services/commitments.ts",
      "line": 937,
      "endLine": 947,
      "parentFileId": "file:src/services/commitments.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for most recent non-expired candidate commitment offered for confirmation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getLastOfferedCandidate(): Promise<Commitment | null> {\n  const result = await pool.query(\n    `SELECT * FROM commitments\n     WHERE status = 'candidate'\n       AND confirmation_offered_at IS NOT NULL\n       AND (auto_expires_at IS NULL OR auto_expires_at > NOW())\n     ORDER BY confirmation_offered_at DESC\n     LIMIT 1`\n  );\n  return result.rows[0] as Commitment | null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/consolidation.ts": {
      "id": "file:src/services/consolidation.ts",
      "type": "file",
      "name": "consolidation.ts",
      "filePath": "src/services/consolidation.ts",
      "line": 1,
      "endLine": 558,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./sessions.js",
          "items": [
            {
              "name": "Session",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SessionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPendingConsolidationSessions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateConsolidationStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./patterns.js",
          "items": [
            {
              "name": "processMemoryForPatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markStalePatternsDormant",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./insights.js",
          "items": [
            {
              "name": "processInsightsForConsolidation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./research.js",
          "items": [
            {
              "name": "processResearchForConsolidation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chatExtraction.js",
          "items": [
            {
              "name": "extractMemoriesFromChat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./summaries.js",
          "items": [
            {
              "name": "updateAllSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "consolidateAll",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "consolidatePendingSessions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConsolidationStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "CONSOLIDATION_CONFIG",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ConsolidationResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/consolidation.ts:fn:calculateDecay:104",
        "file:src/services/consolidation.ts:fn:calculateStrengthen:146",
        "file:src/services/consolidation.ts:fn:processMemoryStrength:181",
        "file:src/services/consolidation.ts:fn:processSimilarEdges:226",
        "file:src/services/consolidation.ts:fn:processEdgeDecay:288",
        "file:src/services/consolidation.ts:fn:processPatterns:316",
        "file:src/services/consolidation.ts:fn:consolidateSession:355",
        "file:src/services/consolidation.ts:fn:consolidateAll:442",
        "file:src/services/consolidation.ts:fn:consolidatePendingSessions:519",
        "file:src/services/consolidation.ts:fn:getConsolidationStats:534"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/consolidation.ts:fn:calculateDecay:104": {
      "id": "file:src/services/consolidation.ts:fn:calculateDecay:104",
      "type": "function",
      "name": "calculateDecay",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 104,
      "endLine": 136,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates memory decay rate based on salience, access, and frequency protections",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateDecay(memory: Memory): number {\n  const { baseRate, accessDecayDays, unaccessed_multiplier, minStrength } = CONSOLIDATION_CONFIG.decay;\n  const { highSalienceThreshold } = CONSOLIDATION_CONFIG.strengthen;\n\n  // Salience protection (0-1): higher salience = more protection\n  const salienceFactor = memory.salience_score / 10.0;\n  const salienceProtection = salienceFactor * 0.5; // Up to 50% reduction\n\n  // Access protection: recent access protects\n  let accessProtection = 0;\n  if (memory.last_accessed_at) {\n    const daysSinceAccess = (Date.now() - new Date(memory.last_accessed_at).getTime()) / (1000 * 60 * 60 * 24);\n    accessProtection = daysSinceAccess < accessDecayDays ? 0.3 : 0;\n  }\n\n  // Frequency protection: high access count protects\n  const frequencyProtection = Math.min(memory.access_count / 10, 0.2);\n\n  // Total protection (0-1)\n  const totalProtection = Math.min(salienceProtection + accessProtection + frequencyProtection, 0.9);\n\n  // Calculate final decay rate\n  let decayRate = baseRate * (1 - totalProtection);\n\n  // Accelerate decay for unaccessed, low-salience memories\n  if (!memory.last_accessed_at && memory.salience_score < highSalienceThreshold) {\n    decayRate *= unaccessed_multiplier;\n  }\n\n  // Don't decay below minimum\n  const maxDecay = memory.current_strength - minStrength;\n  return Math.min(decayRate, Math.max(0, maxDecay));\n}",
      "references": [
        "baseRate",
        "accessDecayDays",
        "unaccessed_multiplier",
        "minStrength",
        "CONSOLIDATION_CONFIG",
        "highSalienceThreshold",
        "salienceFactor",
        "Date",
        "accessProtection",
        "daysSinceAccess",
        "Math",
        "salienceProtection",
        "frequencyProtection",
        "totalProtection",
        "decayRate",
        "maxDecay"
      ]
    },
    "file:src/services/consolidation.ts:fn:calculateStrengthen:146": {
      "id": "file:src/services/consolidation.ts:fn:calculateStrengthen:146",
      "type": "function",
      "name": "calculateStrengthen",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 146,
      "endLine": 173,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates capped strength gain for memory based on recent access, salience, and frequency bonuses",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateStrengthen(memory: Memory): number {\n  const { baseGain, maxStrength, frequentAccessThreshold, highSalienceThreshold } = CONSOLIDATION_CONFIG.strengthen;\n  const { accessDecayDays } = CONSOLIDATION_CONFIG.decay;\n\n  let strengthGain = 0;\n\n  // Recent access bonus\n  if (memory.last_accessed_at) {\n    const daysSinceAccess = (Date.now() - new Date(memory.last_accessed_at).getTime()) / (1000 * 60 * 60 * 24);\n    if (daysSinceAccess < accessDecayDays) {\n      strengthGain += baseGain * 0.5;\n    }\n  }\n\n  // High salience bonus\n  if (memory.salience_score >= highSalienceThreshold) {\n    strengthGain += baseGain * 0.3;\n  }\n\n  // Frequent access bonus\n  if (memory.access_count >= frequentAccessThreshold) {\n    strengthGain += baseGain * 0.2;\n  }\n\n  // Don't exceed maximum strength\n  const maxGain = maxStrength - memory.current_strength;\n  return Math.min(strengthGain, Math.max(0, maxGain));\n}",
      "references": [
        "baseGain",
        "maxStrength",
        "frequentAccessThreshold",
        "highSalienceThreshold",
        "CONSOLIDATION_CONFIG",
        "accessDecayDays",
        "Date",
        "daysSinceAccess",
        "strengthGain",
        "Math",
        "maxGain"
      ]
    },
    "file:src/services/consolidation.ts:fn:processMemoryStrength:181": {
      "id": "file:src/services/consolidation.ts:fn:processMemoryStrength:181",
      "type": "function",
      "name": "processMemoryStrength",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 181,
      "endLine": 218,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ decayed: number; strengthened: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates memory strengths by calculating decay/strengthen, persists changes to DB, returns decayed/strengthened counts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processMemoryStrength(): Promise<{ decayed: number; strengthened: number }> {\n  const { minStrength } = CONSOLIDATION_CONFIG.decay;\n\n  // Get all memories with their current state\n  const result = await pool.query(\n    `SELECT id, salience_score, last_accessed_at, access_count, current_strength\n     FROM memories\n     WHERE current_strength > $1`,\n    [minStrength]\n  );\n\n  const memories = result.rows as Memory[];\n  let decayed = 0;\n  let strengthened = 0;\n\n  for (const memory of memories) {\n    const decay = calculateDecay(memory);\n    const strengthen = calculateStrengthen(memory);\n    const netChange = strengthen - decay;\n\n    if (Math.abs(netChange) > 0.001) {\n      const newStrength = Math.max(minStrength, Math.min(1.0, memory.current_strength + netChange));\n\n      await pool.query(\n        `UPDATE memories SET current_strength = $2 WHERE id = $1`,\n        [memory.id, newStrength]\n      );\n\n      if (netChange < 0) {\n        decayed++;\n      } else {\n        strengthened++;\n      }\n    }\n  }\n\n  return { decayed, strengthened };\n}",
      "references": [
        "minStrength",
        "CONSOLIDATION_CONFIG",
        "pool",
        "result",
        "memories",
        "calculateDecay",
        "memory",
        "calculateStrengthen",
        "strengthen",
        "decay",
        "Math",
        "netChange",
        "newStrength",
        "decayed",
        "strengthened"
      ]
    },
    "file:src/services/consolidation.ts:fn:processSimilarEdges:226": {
      "id": "file:src/services/consolidation.ts:fn:processSimilarEdges:226",
      "type": "function",
      "name": "processSimilarEdges",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 226,
      "endLine": 282,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ created: number; reinforced: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates or reinforces SIMILAR edges between memories based on embedding similarity.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processSimilarEdges(): Promise<{ created: number; reinforced: number }> {\n  const { similarityThreshold, maxEdgesPerMemory } = CONSOLIDATION_CONFIG.edges;\n\n  let created = 0;\n  let reinforced = 0;\n\n  // Get memories with embeddings that don't have maximum edges yet\n  const memoriesResult = await pool.query(\n    `SELECT m.id, m.embedding\n     FROM memories m\n     WHERE m.embedding IS NOT NULL\n       AND (\n         SELECT COUNT(*) FROM memory_edges e\n         WHERE e.source_memory_id = m.id AND e.edge_type = 'SIMILAR'\n       ) < $1`,\n    [maxEdgesPerMemory]\n  );\n\n  for (const memory of memoriesResult.rows) {\n    // Find similar memories\n    const similarResult = await pool.query(\n      `SELECT\n         m2.id as target_id,\n         1 - (m2.embedding <=> $1::vector) as similarity\n       FROM memories m2\n       WHERE m2.id != $2\n         AND m2.embedding IS NOT NULL\n         AND 1 - (m2.embedding <=> $1::vector) >= $3\n       ORDER BY similarity DESC\n       LIMIT $4`,\n      [memory.embedding, memory.id, similarityThreshold, maxEdgesPerMemory]\n    );\n\n    for (const similar of similarResult.rows) {\n      // Try to insert or update the edge\n      const edgeResult = await pool.query(\n        `INSERT INTO memory_edges (source_memory_id, target_memory_id, edge_type, similarity, weight)\n         VALUES ($1, $2, 'SIMILAR', $3, 1.0)\n         ON CONFLICT (source_memory_id, target_memory_id, edge_type)\n         DO UPDATE SET\n           last_reinforced_at = NOW(),\n           reinforcement_count = memory_edges.reinforcement_count + 1,\n           weight = LEAST(1.0, memory_edges.weight + 0.1)\n         RETURNING (xmax = 0) as is_new`,\n        [memory.id, similar.target_id, similar.similarity]\n      );\n\n      if (edgeResult.rows[0]?.is_new) {\n        created++;\n      } else {\n        reinforced++;\n      }\n    }\n  }\n\n  return { created, reinforced };\n}",
      "references": [
        "similarityThreshold",
        "maxEdgesPerMemory",
        "CONSOLIDATION_CONFIG",
        "pool",
        "memoriesResult",
        "memory",
        "similarResult",
        "similar",
        "edgeResult",
        "created",
        "reinforced"
      ]
    },
    "file:src/services/consolidation.ts:fn:processEdgeDecay:288": {
      "id": "file:src/services/consolidation.ts:fn:processEdgeDecay:288",
      "type": "function",
      "name": "processEdgeDecay",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 288,
      "endLine": 308,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ pruned: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Decays weights of unreinforced memory edges and prunes those below min weight",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processEdgeDecay(): Promise<{ pruned: number }> {\n  const { edgeDecayRate, minEdgeWeight } = CONSOLIDATION_CONFIG.edges;\n\n  // Decay edges that weren't reinforced in this consolidation cycle\n  await pool.query(\n    `UPDATE memory_edges\n     SET weight = GREATEST($2, weight - $1)\n     WHERE last_reinforced_at < NOW() - INTERVAL '1 hour'`,\n    [edgeDecayRate, minEdgeWeight]\n  );\n\n  // Prune edges below minimum weight\n  const pruneResult = await pool.query(\n    `DELETE FROM memory_edges\n     WHERE weight <= $1\n     RETURNING id`,\n    [minEdgeWeight]\n  );\n\n  return { pruned: pruneResult.rowCount ?? 0 };\n}",
      "references": [
        "edgeDecayRate",
        "minEdgeWeight",
        "CONSOLIDATION_CONFIG",
        "pool",
        "pruneResult"
      ]
    },
    "file:src/services/consolidation.ts:fn:processPatterns:316": {
      "id": "file:src/services/consolidation.ts:fn:processPatterns:316",
      "type": "function",
      "name": "processPatterns",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 316,
      "endLine": 350,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "10"
        }
      ],
      "returnType": "Promise<{ created: number; reinforced: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes up to N unanalyzed memories for patterns, counts created and reinforced.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processPatterns(limit: number = 10): Promise<{\n  created: number;\n  reinforced: number;\n}> {\n  let created = 0;\n  let reinforced = 0;\n\n  // Find memories without pattern evidence (not yet analyzed)\n  const result = await pool.query<{ id: string; content: string; created_at: Date }>(\n    `SELECT m.id, m.content, m.created_at\n     FROM memories m\n     WHERE NOT EXISTS (\n       SELECT 1 FROM pattern_evidence pe WHERE pe.memory_id = m.id\n     )\n     ORDER BY m.created_at DESC\n     LIMIT $1`,\n    [limit]\n  );\n\n  for (const memory of result.rows) {\n    try {\n      const patternResult = await processMemoryForPatterns(\n        memory.id,\n        memory.content,\n        memory.created_at\n      );\n      created += patternResult.created.length;\n      reinforced += patternResult.reinforced.length;\n    } catch (error) {\n      console.error(`Pattern extraction failed for memory ${memory.id}:`, error);\n    }\n  }\n\n  return { created, reinforced };\n}",
      "references": [
        "pool",
        "result",
        "processMemoryForPatterns",
        "memory",
        "created",
        "patternResult",
        "reinforced",
        "console",
        "error"
      ]
    },
    "file:src/services/consolidation.ts:fn:consolidateSession:355": {
      "id": "file:src/services/consolidation.ts:fn:consolidateSession:355",
      "type": "function",
      "name": "consolidateSession",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 355,
      "endLine": 436,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "session",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/consolidation\").ConsolidationResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Orchestrates session consolidation: processes memories, edges, patterns, insights, updates DB status and summaries",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function consolidateSession(session: Session): Promise<ConsolidationResult> {\n  const startTime = Date.now();\n\n  // Mark session as in progress\n  await updateConsolidationStatus(session.id, 'in_progress');\n\n  try {\n    // 0. Extract memories from chat conversations\n    const chatResult = await extractMemoriesFromChat();\n\n    // 1. Process memory strength (decay and strengthen)\n    const strengthResult = await processMemoryStrength();\n\n    // 2. Process SIMILAR edges\n    const edgeResult = await processSimilarEdges();\n\n    // 3. Process edge decay\n    const decayResult = await processEdgeDecay();\n\n    // 4. Process patterns (detect new patterns from unanalyzed memories)\n    const patternResult = await processPatterns(10);\n\n    // 5. Mark stale patterns as dormant\n    const dormantCount = await markStalePatternsDormant(30);\n\n    // 6. Process insights (cross-analyze beliefs, patterns, memories)\n    const insightResult = await processInsightsForConsolidation();\n\n    // 7. Process active research (detect gaps, generate questions)\n    const researchResult = await processResearchForConsolidation();\n\n    // 8. Update living summaries (generate summaries from pending memories)\n    const summaryResult = await updateAllSummaries();\n\n    // Count total memories processed\n    const countResult = await pool.query(`SELECT COUNT(*) as count FROM memories`);\n    const memoriesProcessed = parseInt(countResult.rows[0]?.count ?? '0', 10);\n\n    const stats: SessionStats = {\n      memories_decayed: strengthResult.decayed,\n      memories_strengthened: strengthResult.strengthened,\n      edges_created: edgeResult.created,\n      edges_reinforced: edgeResult.reinforced,\n      edges_pruned: decayResult.pruned,\n    };\n\n    // Mark session as completed\n    await updateConsolidationStatus(session.id, 'completed', stats);\n\n    return {\n      sessionId: session.id,\n      // Chat extraction results\n      chatConversationsProcessed: chatResult.conversationsProcessed,\n      chatMessagesProcessed: chatResult.messagesProcessed,\n      chatMemoriesCreated: chatResult.memoriesCreated,\n      chatBeliefsCreated: chatResult.beliefsCreated,\n      // Memory processing results\n      memoriesProcessed,\n      memoriesDecayed: strengthResult.decayed,\n      memoriesStrengthened: strengthResult.strengthened,\n      edgesCreated: edgeResult.created,\n      edgesReinforced: edgeResult.reinforced,\n      edgesPruned: decayResult.pruned,\n      patternsCreated: patternResult.created,\n      patternsReinforced: patternResult.reinforced,\n      patternsDormant: dormantCount,\n      insightsCreated: insightResult.created.length,\n      insightsValidated: insightResult.validated.length,\n      insightsStale: insightResult.staleMarked,\n      gapsCreated: researchResult.gapsCreated.length,\n      gapsSurfaced: researchResult.gapsSurfaced.length,\n      questionsCreated: researchResult.questionsCreated.length,\n      questionsExpired: researchResult.questionsExpired,\n      summariesUpdated: summaryResult.updated.length,\n      summaryMemoriesProcessed: summaryResult.memoriesProcessed,\n      durationMs: Date.now() - startTime,\n    };\n  } catch (error) {\n    await updateConsolidationStatus(session.id, 'failed');\n    throw error;\n  }\n}",
      "references": [
        "Date",
        "updateConsolidationStatus",
        "extractMemoriesFromChat",
        "processMemoryStrength",
        "processSimilarEdges",
        "processEdgeDecay",
        "processPatterns",
        "markStalePatternsDormant",
        "processInsightsForConsolidation",
        "processResearchForConsolidation",
        "updateAllSummaries",
        "pool",
        "parseInt",
        "countResult",
        "strengthResult",
        "edgeResult",
        "decayResult",
        "stats",
        "chatResult",
        "memoriesProcessed",
        "patternResult",
        "dormantCount",
        "insightResult",
        "researchResult",
        "summaryResult",
        "startTime",
        "error"
      ]
    },
    "file:src/services/consolidation.ts:fn:consolidateAll:442": {
      "id": "file:src/services/consolidation.ts:fn:consolidateAll:442",
      "type": "function",
      "name": "consolidateAll",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 442,
      "endLine": 514,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/consolidation\").ConsolidationResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Orchestrates memory consolidation: extracts, processes strengths/edges/patterns/insights/summaries",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function consolidateAll(): Promise<ConsolidationResult> {\n  const startTime = Date.now();\n\n  // 0. Extract memories from chat conversations (NEW)\n  console.log('[Consolidation] Step 0: Extracting memories from chat...');\n  const chatResult = await extractMemoriesFromChat();\n\n  // 1. Process memory strength (decay and strengthen)\n  console.log('[Consolidation] Step 1: Processing memory strength...');\n  const strengthResult = await processMemoryStrength();\n\n  // 2. Process SIMILAR edges\n  console.log('[Consolidation] Step 2: Processing SIMILAR edges...');\n  const edgeResult = await processSimilarEdges();\n\n  // 3. Process edge decay\n  console.log('[Consolidation] Step 3: Processing edge decay...');\n  const decayResult = await processEdgeDecay();\n\n  // 4. Process patterns (detect new patterns from unanalyzed memories)\n  console.log('[Consolidation] Step 4: Processing patterns...');\n  const patternResult = await processPatterns(10);\n\n  // 5. Mark stale patterns as dormant\n  console.log('[Consolidation] Step 5: Marking stale patterns dormant...');\n  const dormantCount = await markStalePatternsDormant(30);\n\n  // 6. Process insights (cross-analyze beliefs, patterns, memories)\n  console.log('[Consolidation] Step 6: Processing insights...');\n  const insightResult = await processInsightsForConsolidation();\n\n  // 7. Process active research (detect gaps, generate questions)\n  console.log('[Consolidation] Step 7: Processing research...');\n  const researchResult = await processResearchForConsolidation();\n\n  // 8. Update living summaries (generate summaries from pending memories)\n  console.log('[Consolidation] Step 8: Updating living summaries...');\n  const summaryResult = await updateAllSummaries();\n\n  // Count total memories processed\n  const countResult = await pool.query(`SELECT COUNT(*) as count FROM memories`);\n  const memoriesProcessed = parseInt(countResult.rows[0]?.count ?? '0', 10);\n\n  console.log(`[Consolidation] Complete in ${Date.now() - startTime}ms`);\n\n  return {\n    // Chat extraction results\n    chatConversationsProcessed: chatResult.conversationsProcessed,\n    chatMessagesProcessed: chatResult.messagesProcessed,\n    chatMemoriesCreated: chatResult.memoriesCreated,\n    chatBeliefsCreated: chatResult.beliefsCreated,\n    // Memory processing results\n    memoriesProcessed,\n    memoriesDecayed: strengthResult.decayed,\n    memoriesStrengthened: strengthResult.strengthened,\n    edgesCreated: edgeResult.created,\n    edgesReinforced: edgeResult.reinforced,\n    edgesPruned: decayResult.pruned,\n    patternsCreated: patternResult.created,\n    patternsReinforced: patternResult.reinforced,\n    patternsDormant: dormantCount,\n    insightsCreated: insightResult.created.length,\n    insightsValidated: insightResult.validated.length,\n    insightsStale: insightResult.staleMarked,\n    gapsCreated: researchResult.gapsCreated.length,\n    gapsSurfaced: researchResult.gapsSurfaced.length,\n    questionsCreated: researchResult.questionsCreated.length,\n    questionsExpired: researchResult.questionsExpired,\n    summariesUpdated: summaryResult.updated.length,\n    summaryMemoriesProcessed: summaryResult.memoriesProcessed,\n    durationMs: Date.now() - startTime,\n  };\n}",
      "references": [
        "Date",
        "console",
        "extractMemoriesFromChat",
        "processMemoryStrength",
        "processSimilarEdges",
        "processEdgeDecay",
        "processPatterns",
        "markStalePatternsDormant",
        "processInsightsForConsolidation",
        "processResearchForConsolidation",
        "updateAllSummaries",
        "pool",
        "parseInt",
        "countResult",
        "startTime",
        "chatResult",
        "memoriesProcessed",
        "strengthResult",
        "edgeResult",
        "decayResult",
        "patternResult",
        "dormantCount",
        "insightResult",
        "researchResult",
        "summaryResult"
      ]
    },
    "file:src/services/consolidation.ts:fn:consolidatePendingSessions:519": {
      "id": "file:src/services/consolidation.ts:fn:consolidatePendingSessions:519",
      "type": "function",
      "name": "consolidatePendingSessions",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 519,
      "endLine": 529,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/consolidation\").ConsolidationResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves pending consolidation sessions and consolidates each, returning results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function consolidatePendingSessions(): Promise<ConsolidationResult[]> {\n  const pendingSessions = await getPendingConsolidationSessions();\n  const results: ConsolidationResult[] = [];\n\n  for (const session of pendingSessions) {\n    const result = await consolidateSession(session);\n    results.push(result);\n  }\n\n  return results;\n}",
      "references": [
        "getPendingConsolidationSessions",
        "pendingSessions",
        "consolidateSession",
        "session",
        "results",
        "result"
      ]
    },
    "file:src/services/consolidation.ts:fn:getConsolidationStats:534": {
      "id": "file:src/services/consolidation.ts:fn:getConsolidationStats:534",
      "type": "function",
      "name": "getConsolidationStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/consolidation.ts",
      "line": 534,
      "endLine": 557,
      "parentFileId": "file:src/services/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ totalEdges: number; averageWeight: number; dormantMemories: number; activeMemories: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for consolidation stats: total similar edges, avg weight, dormant/active memories",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConsolidationStats(): Promise<{\n  totalEdges: number;\n  averageWeight: number;\n  dormantMemories: number;\n  activeMemories: number;\n}> {\n  const { minStrength } = CONSOLIDATION_CONFIG.decay;\n\n  const result = await pool.query(`\n    SELECT\n      (SELECT COUNT(*) FROM memory_edges WHERE edge_type = 'SIMILAR') as total_edges,\n      (SELECT AVG(weight) FROM memory_edges WHERE edge_type = 'SIMILAR') as avg_weight,\n      (SELECT COUNT(*) FROM memories WHERE current_strength <= $1) as dormant,\n      (SELECT COUNT(*) FROM memories WHERE current_strength > $1) as active\n  `, [minStrength]);\n\n  const row = result.rows[0];\n  return {\n    totalEdges: parseInt(row.total_edges ?? '0', 10),\n    averageWeight: parseFloat(row.avg_weight ?? '1.0'),\n    dormantMemories: parseInt(row.dormant ?? '0', 10),\n    activeMemories: parseInt(row.active ?? '0', 10),\n  };\n}",
      "references": [
        "minStrength",
        "CONSOLIDATION_CONFIG",
        "pool",
        "result",
        "parseInt",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/context.ts": {
      "id": "file:src/services/context.ts",
      "type": "file",
      "name": "context.ts",
      "filePath": "src/services/context.ts",
      "line": 1,
      "endLine": 890,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./entities.js",
          "items": [
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./summaries.js",
          "items": [
            {
              "name": "getNonEmptySummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./notes.js",
          "items": [
            {
              "name": "searchNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./lists.js",
          "items": [
            {
              "name": "searchLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./documents/search.js",
          "items": [
            {
              "name": "searchForContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./expressionFilter.js",
          "items": [
            {
              "name": "filterMemoriesOptimized",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "listProfiles",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDisclosureLog",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ContextProfile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ScoringWeights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BudgetCaps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ScoredMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntitySummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarySnapshot",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "NoteSnapshot",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListSnapshot",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentSnapshot",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextPackage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GenerateContextOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/context.ts:fn:getProfile:139",
        "file:src/services/context.ts:fn:getDefaultProfile:150",
        "file:src/services/context.ts:fn:listProfiles:163",
        "file:src/services/context.ts:fn:calculateRecencyScore:176",
        "file:src/services/context.ts:fn:estimateTokens:193",
        "file:src/services/context.ts:fn:calculateFinalScore:200",
        "file:src/services/context.ts:fn:applyTokenBudget:230",
        "file:src/services/context.ts:fn:logDisclosure:276",
        "file:src/services/context.ts:fn:getEntitiesForMemories:312",
        "file:src/services/context.ts:fn:formatMarkdown:345",
        "file:src/services/context.ts:fn:formatNotesMarkdown:409",
        "file:src/services/context.ts:fn:formatListsMarkdown:431",
        "file:src/services/context.ts:fn:formatDocumentsMarkdown:454",
        "file:src/services/context.ts:fn:formatJson:497",
        "file:src/services/context.ts:fn:generateContext:576",
        "file:src/services/context.ts:fn:getDisclosureLog:870"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/context.ts:fn:getProfile:139": {
      "id": "file:src/services/context.ts:fn:getProfile:139",
      "type": "function",
      "name": "getProfile",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 139,
      "endLine": 145,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/context\").ContextProfile>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a context profile from database by name",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.022Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getProfile(name: string): Promise<ContextProfile | null> {\n  const result = await pool.query(\n    'SELECT * FROM context_profiles WHERE name = $1',\n    [name]\n  );\n  return (result.rows[0] as ContextProfile) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/context.ts:fn:getDefaultProfile:150": {
      "id": "file:src/services/context.ts:fn:getDefaultProfile:150",
      "type": "function",
      "name": "getDefaultProfile",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 150,
      "endLine": 158,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/context\").ContextProfile>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves the default context profile from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getDefaultProfile(): Promise<ContextProfile> {\n  const result = await pool.query(\n    'SELECT * FROM context_profiles WHERE is_default = TRUE LIMIT 1'\n  );\n  if (!result.rows[0]) {\n    throw new Error('No default profile found');\n  }\n  return result.rows[0] as ContextProfile;\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/context.ts:fn:listProfiles:163": {
      "id": "file:src/services/context.ts:fn:listProfiles:163",
      "type": "function",
      "name": "listProfiles",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 163,
      "endLine": 168,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/context\").ContextProfile[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves all context profiles from database ordered by is_default DESC and name ASC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listProfiles(): Promise<ContextProfile[]> {\n  const result = await pool.query(\n    'SELECT * FROM context_profiles ORDER BY is_default DESC, name ASC'\n  );\n  return result.rows as ContextProfile[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/context.ts:fn:calculateRecencyScore:176": {
      "id": "file:src/services/context.ts:fn:calculateRecencyScore:176",
      "type": "function",
      "name": "calculateRecencyScore",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 176,
      "endLine": 187,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "createdAt",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "lookbackDays",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates recency score (0-1) via exponential decay from creation date.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateRecencyScore(createdAt: Date, lookbackDays: number): number {\n  const now = Date.now();\n  const memoryTime = new Date(createdAt).getTime();\n  const daysSince = (now - memoryTime) / (1000 * 60 * 60 * 24);\n\n  // Exponential decay with half-life based on lookback days\n  // At lookbackDays, score is ~0.5\n  const halfLife = lookbackDays / 2;\n  const score = Math.exp(-daysSince / halfLife);\n\n  return Math.max(0, Math.min(1, score));\n}",
      "references": [
        "Date",
        "now",
        "memoryTime",
        "Math",
        "daysSince",
        "halfLife",
        "score"
      ]
    },
    "file:src/services/context.ts:fn:estimateTokens:193": {
      "id": "file:src/services/context.ts:fn:estimateTokens:193",
      "type": "function",
      "name": "estimateTokens",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 193,
      "endLine": 195,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Estimates tokens in a string by ceiling length divided by 4.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function estimateTokens(text: string): number {\n  return Math.ceil(text.length / 4);\n}",
      "references": [
        "Math"
      ]
    },
    "file:src/services/context.ts:fn:calculateFinalScore:200": {
      "id": "file:src/services/context.ts:fn:calculateFinalScore:200",
      "type": "function",
      "name": "calculateFinalScore",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 200,
      "endLine": 222,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "{ salience_score: number; current_strength: number; created_at: Date; similarity?: number; }",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "weights",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoringWeights",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "lookbackDays",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates weighted final score from memory salience, strength, recency, and relevance.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateFinalScore(\n  memory: {\n    salience_score: number;\n    current_strength: number;\n    created_at: Date;\n    similarity?: number;\n  },\n  weights: ScoringWeights,\n  lookbackDays: number\n): number {\n  const normalizedSalience = memory.salience_score / 10;\n  const normalizedStrength = memory.current_strength;\n  const recencyScore = calculateRecencyScore(memory.created_at, lookbackDays);\n  const relevanceScore = memory.similarity ?? 0.5; // Default if no query\n\n  const score =\n    weights.salience * normalizedSalience +\n    weights.relevance * relevanceScore +\n    weights.recency * recencyScore +\n    weights.strength * normalizedStrength;\n\n  return Math.max(0, Math.min(1, score));\n}",
      "references": [
        "calculateRecencyScore",
        "normalizedSalience",
        "relevanceScore",
        "recencyScore",
        "normalizedStrength",
        "Math",
        "score"
      ]
    },
    "file:src/services/context.ts:fn:applyTokenBudget:230": {
      "id": "file:src/services/context.ts:fn:applyTokenBudget:230",
      "type": "function",
      "name": "applyTokenBudget",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 230,
      "endLine": 269,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoredMemory[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "maxTokens",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "budgetCaps",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").BudgetCaps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoredMemory[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Selects top scored memories per category within token budgets, sorted by score",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function applyTokenBudget(\n  memories: ScoredMemory[],\n  maxTokens: number,\n  budgetCaps: BudgetCaps\n): ScoredMemory[] {\n  const budgets = {\n    high_salience: Math.floor(maxTokens * budgetCaps.high_salience),\n    relevant: Math.floor(maxTokens * budgetCaps.relevant),\n    recent: Math.floor(maxTokens * budgetCaps.recent),\n  };\n\n  const used = { high_salience: 0, relevant: 0, recent: 0 };\n  const selected: ScoredMemory[] = [];\n\n  // Sort by final score within each category\n  const byCategory = {\n    high_salience: memories\n      .filter((m) => m.category === 'high_salience')\n      .sort((a, b) => b.final_score - a.final_score),\n    relevant: memories\n      .filter((m) => m.category === 'relevant')\n      .sort((a, b) => b.final_score - a.final_score),\n    recent: memories\n      .filter((m) => m.category === 'recent')\n      .sort((a, b) => b.final_score - a.final_score),\n  };\n\n  // Fill each category up to its budget\n  for (const category of ['high_salience', 'relevant', 'recent'] as const) {\n    for (const memory of byCategory[category]) {\n      if (used[category] + memory.token_estimate <= budgets[category]) {\n        selected.push(memory);\n        used[category] += memory.token_estimate;\n      }\n    }\n  }\n\n  // Sort final selection by score\n  return selected.sort((a, b) => b.final_score - a.final_score);\n}",
      "references": [
        "Math",
        "m",
        "b",
        "a",
        "byCategory",
        "category",
        "used",
        "memory",
        "budgets",
        "selected"
      ]
    },
    "file:src/services/context.ts:fn:logDisclosure:276": {
      "id": "file:src/services/context.ts:fn:logDisclosure:276",
      "type": "function",
      "name": "logDisclosure",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 276,
      "endLine": 304,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "profileName",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tokenCount",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "format",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "scoringWeights",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoringWeights",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts disclosure log entry into database and returns the new ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function logDisclosure(\n  profileName: string,\n  query: string | undefined,\n  memoryIds: string[],\n  tokenCount: number,\n  format: string,\n  scoringWeights: ScoringWeights,\n  conversationId?: string\n): Promise<string> {\n  const result = await pool.query(\n    `INSERT INTO disclosure_log (\n      conversation_id, profile_used, query_text,\n      disclosed_memory_ids, disclosed_memory_count,\n      scoring_weights, token_count, format\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n    RETURNING id`,\n    [\n      conversationId,\n      profileName,\n      query,\n      memoryIds,\n      memoryIds.length,\n      JSON.stringify(scoringWeights),\n      tokenCount,\n      format,\n    ]\n  );\n  return result.rows[0]?.id as string;\n}",
      "references": [
        "pool",
        "JSON",
        "result"
      ]
    },
    "file:src/services/context.ts:fn:getEntitiesForMemories:312": {
      "id": "file:src/services/context.ts:fn:getEntitiesForMemories:312",
      "type": "function",
      "name": "getEntitiesForMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 312,
      "endLine": 333,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/context\").EntitySummary[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches top 20 non-merged entities mentioned in given memories with mention counts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getEntitiesForMemories(memoryIds: string[]): Promise<EntitySummary[]> {\n  if (memoryIds.length === 0) return [];\n\n  const result = await pool.query(\n    `SELECT e.id, e.name, e.entity_type as type, COUNT(em.id) as mention_count\n     FROM entities e\n     JOIN entity_mentions em ON em.entity_id = e.id\n     WHERE em.memory_id = ANY($1)\n       AND e.is_merged = FALSE\n     GROUP BY e.id, e.name, e.entity_type\n     ORDER BY mention_count DESC, e.name ASC\n     LIMIT 20`,\n    [memoryIds]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    name: row.name,\n    type: row.type as EntityType,\n    mention_count: parseInt(row.mention_count, 10),\n  }));\n}",
      "references": [
        "pool",
        "result",
        "row",
        "parseInt"
      ]
    },
    "file:src/services/context.ts:fn:formatMarkdown:345": {
      "id": "file:src/services/context.ts:fn:formatMarkdown:345",
      "type": "function",
      "name": "formatMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 345,
      "endLine": 404,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoredMemory[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").EntitySummary[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "summaries",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").SummarySnapshot[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_profile",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ContextProfile",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_query",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats memories, entities, and summaries into structured markdown string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatMarkdown(\n  memories: ScoredMemory[],\n  entities: EntitySummary[],\n  summaries: SummarySnapshot[],\n  _profile: ContextProfile,\n  _query?: string\n): string {\n  const lines: string[] = [];\n\n  // Living Summaries - present as knowledge about the person\n  if (summaries.length > 0) {\n    lines.push('# What You Know About Them');\n    lines.push('');\n    for (const s of summaries) {\n      const title = s.category.charAt(0).toUpperCase() + s.category.slice(1);\n      lines.push(`**${title}**: ${s.content}`);\n      lines.push('');\n    }\n  }\n\n  // Combine all memories, already sorted by relevance\n  const allMemories = [...memories];\n\n  if (allMemories.length > 0) {\n    lines.push('# Relevant Context');\n    lines.push('');\n    for (const m of allMemories) {\n      // Simple bullet, no scores or dates - just the knowledge\n      lines.push(`- ${m.content}`);\n    }\n    lines.push('');\n  }\n\n  // Key people and things they've mentioned\n  if (entities.length > 0) {\n    const byType: Record<string, EntitySummary[]> = {};\n    for (const e of entities) {\n      const arr = byType[e.type] ?? [];\n      arr.push(e);\n      byType[e.type] = arr;\n    }\n\n    const parts: string[] = [];\n    const typeOrder = ['person', 'project', 'organization', 'place', 'concept'];\n    for (const type of typeOrder) {\n      const typeEntities = byType[type];\n      if (typeEntities && typeEntities.length > 0) {\n        const names = typeEntities.map((e) => e.name).join(', ');\n        parts.push(`${type}s: ${names}`);\n      }\n    }\n\n    if (parts.length > 0) {\n      lines.push(`**People & things mentioned**: ${parts.join(' | ')}`);\n      lines.push('');\n    }\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "s",
        "title",
        "allMemories",
        "m",
        "byType",
        "e",
        "arr",
        "typeOrder",
        "typeEntities",
        "parts",
        "names"
      ]
    },
    "file:src/services/context.ts:fn:formatNotesMarkdown:409": {
      "id": "file:src/services/context.ts:fn:formatNotesMarkdown:409",
      "type": "function",
      "name": "formatNotesMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 409,
      "endLine": 426,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "notes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").NoteSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats an array of notes into a Markdown string with titles, entity info, similarity, and content.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatNotesMarkdown(notes: NoteSnapshot[]): string {\n  if (notes.length === 0) return '';\n\n  const lines: string[] = [];\n  lines.push('## Relevant Notes');\n  lines.push('');\n\n  for (const note of notes) {\n    const title = note.title ?? 'Untitled Note';\n    const entityInfo = note.entity_name ? ` (${note.entity_name})` : '';\n    const similarity = note.similarity ? ` [${(note.similarity * 100).toFixed(0)}% match]` : '';\n    lines.push(`### ${title}${entityInfo}${similarity}`);\n    lines.push(note.content);\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "note",
        "title",
        "entityInfo",
        "similarity"
      ]
    },
    "file:src/services/context.ts:fn:formatListsMarkdown:431": {
      "id": "file:src/services/context.ts:fn:formatListsMarkdown:431",
      "type": "function",
      "name": "formatListsMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 431,
      "endLine": 446,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "lists",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ListSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats list snapshots into Markdown bullet points with name, entity, similarity, and description.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatListsMarkdown(lists: ListSnapshot[]): string {\n  if (lists.length === 0) return '';\n\n  const lines: string[] = [];\n  lines.push('## Relevant Lists');\n  lines.push('');\n\n  for (const list of lists) {\n    const entityInfo = list.entity_name ? ` (${list.entity_name})` : '';\n    const similarity = list.similarity ? ` [${(list.similarity * 100).toFixed(0)}% match]` : '';\n    lines.push(`- **${list.name}**${entityInfo}${similarity}: ${list.description ?? list.list_type}`);\n  }\n  lines.push('');\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "list",
        "entityInfo",
        "similarity"
      ]
    },
    "file:src/services/context.ts:fn:formatDocumentsMarkdown:454": {
      "id": "file:src/services/context.ts:fn:formatDocumentsMarkdown:454",
      "type": "function",
      "name": "formatDocumentsMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 454,
      "endLine": 492,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "documents",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").DocumentSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats document snapshots into Markdown with grouped citations and references.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDocumentsMarkdown(documents: DocumentSnapshot[]): string {\n  if (documents.length === 0) return '';\n\n  const lines: string[] = [];\n  lines.push('## Relevant Documents');\n  lines.push('');\n  lines.push('*When using information from these documents, cite the source.*');\n  lines.push('');\n\n  // Group by document name for cleaner output\n  const byDocument = new Map<string, DocumentSnapshot[]>();\n  for (const doc of documents) {\n    const existing = byDocument.get(doc.documentName) ?? [];\n    existing.push(doc);\n    byDocument.set(doc.documentName, existing);\n  }\n\n  let sourceIndex = 1;\n  for (const [docName, chunks] of byDocument) {\n    lines.push(`### ${docName}`);\n    lines.push('');\n    for (const chunk of chunks) {\n      // Build citation reference\n      const pageRef = chunk.pageNumber ? `p.${chunk.pageNumber}` : null;\n      const sectionRef = chunk.sectionTitle ?? null;\n      const locationParts = [pageRef, sectionRef].filter(Boolean);\n      const location = locationParts.length > 0 ? locationParts.join(', ') : `chunk ${sourceIndex}`;\n\n      // Format: [DOC-1: filename, p.5] Content...\n      const citation = `[DOC-${sourceIndex}: ${docName}${location ? ', ' + location : ''}]`;\n      lines.push(`${citation}`);\n      lines.push(chunk.content);\n      lines.push('');\n      sourceIndex++;\n    }\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "Map",
        "byDocument",
        "doc",
        "existing",
        "docName",
        "chunks",
        "chunk",
        "pageRef",
        "sectionRef",
        "Boolean",
        "locationParts",
        "sourceIndex",
        "location",
        "citation"
      ]
    },
    "file:src/services/context.ts:fn:formatJson:497": {
      "id": "file:src/services/context.ts:fn:formatJson:497",
      "type": "function",
      "name": "formatJson",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 497,
      "endLine": 565,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ScoredMemory[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").EntitySummary[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "summaries",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").SummarySnapshot[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").NoteSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "lists",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ListSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "documents",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").DocumentSnapshot[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "profile",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").ContextProfile",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "query",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "object",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats context data into JSON object with selected fields from inputs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.023Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatJson(\n  memories: ScoredMemory[],\n  entities: EntitySummary[],\n  summaries: SummarySnapshot[],\n  notes: NoteSnapshot[],\n  lists: ListSnapshot[],\n  documents: DocumentSnapshot[],\n  profile: ContextProfile,\n  query?: string\n): object {\n  return {\n    profile: profile.name,\n    generated_at: new Date().toISOString(),\n    query,\n    scoring_weights: profile.scoring_weights,\n    summaries: summaries.map((s) => ({\n      category: s.category,\n      content: s.content,\n      version: s.version,\n      memory_count: s.memory_count,\n    })),\n    entities: entities.map((e) => ({\n      id: e.id,\n      name: e.name,\n      type: e.type,\n      mention_count: e.mention_count,\n    })),\n    memories: memories.map((m) => ({\n      id: m.id,\n      content: m.content,\n      created_at: m.created_at,\n      category: m.category,\n      scores: {\n        salience: m.salience_score,\n        strength: m.current_strength,\n        recency: m.recency_score,\n        similarity: m.similarity,\n        final: m.final_score,\n      },\n      token_estimate: m.token_estimate,\n    })),\n    notes: notes.map((n) => ({\n      id: n.id,\n      title: n.title,\n      content: n.content,\n      category: n.category,\n      entity_name: n.entity_name,\n      similarity: n.similarity,\n    })),\n    lists: lists.map((l) => ({\n      id: l.id,\n      name: l.name,\n      description: l.description,\n      list_type: l.list_type,\n      entity_name: l.entity_name,\n      similarity: l.similarity,\n    })),\n    documents: documents.map((d) => ({\n      id: d.id,\n      chunkId: d.chunkId,\n      documentName: d.documentName,\n      content: d.content,\n      pageNumber: d.pageNumber,\n      sectionTitle: d.sectionTitle,\n      similarity: d.similarity,\n      tokenCount: d.tokenCount,\n    })),\n  };\n}",
      "references": [
        "Date",
        "s",
        "e",
        "m",
        "n",
        "l",
        "d"
      ]
    },
    "file:src/services/context.ts:fn:generateContext:576": {
      "id": "file:src/services/context.ts:fn:generateContext:576",
      "type": "function",
      "name": "generateContext",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 576,
      "endLine": 865,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/context\").GenerateContextOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/context\").ContextPackage>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates context by fetching profile, embedding query if provided, and querying relevant memories from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateContext(\n  options: GenerateContextOptions = {}\n): Promise<ContextPackage> {\n  const { query, maxTokens, conversationId, includeDocuments = true, maxDocumentTokens = 2000 } = options;\n\n  // Get profile\n  let profile: ContextProfile;\n  if (options.profile) {\n    const found = await getProfile(options.profile);\n    if (!found) {\n      throw new Error(`Profile not found: ${options.profile}`);\n    }\n    profile = found;\n  } else {\n    profile = await getDefaultProfile();\n  }\n\n  const effectiveMaxTokens = maxTokens ?? profile.max_tokens;\n  const weights = profile.scoring_weights as ScoringWeights;\n  const budgetCaps = profile.budget_caps as BudgetCaps;\n\n  // Generate query embedding if query provided\n  let queryEmbedding: number[] | null = null;\n  if (query) {\n    queryEmbedding = await generateEmbedding(query);\n  }\n\n  // Fetch candidate memories\n  const lookbackDate = new Date();\n  lookbackDate.setDate(lookbackDate.getDate() - profile.lookback_days);\n\n  let memoriesQuery: string;\n  let queryParams: (string | number | Date)[];\n\n  if (queryEmbedding) {\n    const embeddingStr = `[${queryEmbedding.join(',')}]`;\n    // When we have a query, ORDER BY SIMILARITY to get truly relevant memories\n    // \n    // Phase 0 Enhancement: For personal-story profile or high-salience memories,\n    // use a much lower similarity threshold (0.15) to avoid filtering out\n    // biographical content that may use different vocabulary than the query.\n    // High-salience memories (>= 6.0) bypass the similarity filter entirely.\n    //\n    // Phase 1 Enhancement: Exclude meta_ai conversations from context injection.\n    // Dev chatter like \"fix the bug\" should not appear in personal context.\n    const isStoryMode = profile.name === 'personal-story';\n    const similarityThreshold = isStoryMode ? 0.15 : 0.25;\n    \n    memoriesQuery = `\n      SELECT\n        id, content, created_at, salience_score, current_strength,\n        1 - (embedding <=> $1::vector) as similarity\n      FROM memories\n      WHERE embedding IS NOT NULL\n        AND salience_score >= $2\n        AND current_strength >= $3\n        AND created_at >= $4\n        AND (\n          -- High-salience memories bypass similarity filter (biographical content)\n          salience_score >= 6.0\n          OR 1 - (embedding <=> $1::vector) >= $5\n        )\n        AND (conversation_mode IS NULL OR conversation_mode != 'meta_ai')\n        AND (tier IS NULL OR tier = 'solid')\n      ORDER BY similarity DESC, salience_score DESC\n      LIMIT 100\n    `;\n    queryParams = [embeddingStr, profile.min_salience, profile.min_strength, lookbackDate, similarityThreshold];\n  } else {\n    memoriesQuery = `\n      SELECT\n        id, content, created_at, salience_score, current_strength,\n        NULL as similarity\n      FROM memories\n      WHERE salience_score >= $1\n        AND current_strength >= $2\n        AND created_at >= $3\n        AND (conversation_mode IS NULL OR conversation_mode != 'meta_ai')\n        AND (tier IS NULL OR tier = 'solid')\n      ORDER BY salience_score DESC, created_at DESC\n      LIMIT 100\n    `;\n    queryParams = [profile.min_salience, profile.min_strength, lookbackDate];\n  }\n\n  const result = await pool.query(memoriesQuery, queryParams);\n\n  // Score and categorize memories\n  const scoredMemories: ScoredMemory[] = result.rows.map((row) => {\n    const recencyScore = calculateRecencyScore(row.created_at, profile.lookback_days);\n    const finalScore = calculateFinalScore(\n      {\n        salience_score: row.salience_score,\n        current_strength: row.current_strength,\n        created_at: row.created_at,\n        similarity: row.similarity,\n      },\n      weights,\n      profile.lookback_days\n    );\n\n    // Categorize based on primary characteristic\n    // Phase 0 Enhancement: High-salience memories (biographical content) are \n    // always categorized as high_salience, regardless of similarity score.\n    // This ensures origin stories and key life facts are never deprioritized.\n    let category: 'high_salience' | 'relevant' | 'recent';\n    const hasHighSalience = row.salience_score >= 6.0;\n    const hasVeryHighSalience = row.salience_score >= 8.0;\n    const hasGoodSimilarity = row.similarity && row.similarity >= 0.35;\n    const hasAnySimilarity = row.similarity && row.similarity >= 0.15;\n\n    if (hasVeryHighSalience) {\n      // Very high salience (8+) = biographical/origin content  always high_salience\n      category = 'high_salience';\n    } else if (hasHighSalience && (hasAnySimilarity || !row.similarity)) {\n      // High salience (6+) with any relevance  high_salience\n      category = 'high_salience';\n    } else if (row.similarity && row.similarity >= 0.4) {\n      // Good semantic match\n      category = 'relevant';\n    } else if (hasGoodSimilarity) {\n      // Moderate semantic match\n      category = 'relevant';\n    } else {\n      category = 'recent';\n    }\n\n    return {\n      id: row.id,\n      content: row.content,\n      created_at: row.created_at,\n      salience_score: row.salience_score,\n      current_strength: row.current_strength,\n      similarity: row.similarity,\n      recency_score: recencyScore,\n      final_score: finalScore,\n      token_estimate: estimateTokens(row.content),\n      category,\n    };\n  });\n\n  // Apply token budgeting\n  const budgetedMemories = applyTokenBudget(\n    scoredMemories,\n    effectiveMaxTokens,\n    budgetCaps\n  );\n\n  // Phase 5: Expression-Time Safety Filter\n  // Last line of defense - filter out memories that would feel unnatural to mention\n  const filterResult = await filterMemoriesOptimized(\n    budgetedMemories.map((m) => ({ id: m.id, content: m.content })),\n    query // Use query as conversation context hint\n  );\n\n  // Keep only memories that passed the filter\n  const filteredMemories = budgetedMemories.filter((m) =>\n    filterResult.passedIds.includes(m.id)\n  );\n\n  // Calculate total tokens (from filtered memories)\n  const totalTokens = filteredMemories.reduce((sum, m) => sum + m.token_estimate, 0);\n\n  // Get entities mentioned in disclosed memories\n  const memoryIds = filteredMemories.map((m) => m.id);\n  const entities = await getEntitiesForMemories(memoryIds);\n\n  // Get living summaries (non-empty ones)\n  const livingSummaries = await getNonEmptySummaries();\n  const summaries: SummarySnapshot[] = livingSummaries.map((s: LivingSummary) => ({\n    category: s.category,\n    content: s.content,\n    version: s.version,\n    memory_count: s.memory_count,\n  }));\n\n  // Get relevant notes and lists\n  let notes: NoteSnapshot[] = [];\n  let lists: ListSnapshot[] = [];\n\n  // Always include pinned notes\n  const pinnedNotes = await getPinnedNotes();\n  for (const note of pinnedNotes) {\n    notes.push({\n      id: note.id,\n      title: note.title,\n      content: note.content,\n      category: note.category,\n      entity_name: null, // Could be enriched with entity lookup\n    });\n  }\n\n  // If query provided, also search for relevant notes/lists\n  if (query) {\n    try {\n      const relevantNotes = await searchNotes(query, { limit: 5, threshold: 0.4 });\n      for (const note of relevantNotes) {\n        // Avoid duplicates from pinned notes\n        if (!notes.some(n => n.id === note.id)) {\n          notes.push({\n            id: note.id,\n            title: note.title,\n            content: note.content,\n            category: note.category,\n            entity_name: null,\n            similarity: note.similarity,\n          });\n        }\n      }\n\n      const relevantLists = await searchLists(query, 5);\n      for (const list of relevantLists) {\n        lists.push({\n          id: list.id,\n          name: list.name,\n          description: list.description,\n          list_type: list.list_type,\n          entity_name: null,\n          similarity: list.similarity,\n        });\n      }\n    } catch (error) {\n      console.error('[Context] Error fetching notes/lists:', error);\n    }\n  }\n\n  // Get relevant document chunks\n  let documents: DocumentSnapshot[] = [];\n  if (includeDocuments && query) {\n    try {\n      const docResults = await searchForContext(query, {\n        maxTokens: maxDocumentTokens,\n        threshold: 0.4,\n        limit: 10,\n      });\n      documents = docResults.chunks.map((chunk) => ({\n        id: chunk.sourceId.split(':')[0] ?? chunk.sourceId,\n        chunkId: chunk.sourceId,\n        documentName: chunk.documentName,\n        content: chunk.content,\n        pageNumber: chunk.pageNumber,\n        sectionTitle: chunk.sectionTitle,\n        similarity: chunk.similarity,\n        tokenCount: chunk.tokenCount,\n      }));\n    } catch (error) {\n      console.error('[Context] Error fetching documents:', error);\n    }\n  }\n\n  // Log disclosure\n  const disclosureId = await logDisclosure(\n    profile.name,\n    query,\n    memoryIds,\n    totalTokens,\n    profile.format,\n    weights,\n    conversationId\n  );\n\n  // Format output\n  let markdown = formatMarkdown(filteredMemories, entities, summaries, profile, query);\n  if (notes.length > 0) {\n    markdown += '\\n' + formatNotesMarkdown(notes);\n  }\n  if (lists.length > 0) {\n    markdown += '\\n' + formatListsMarkdown(lists);\n  }\n  if (documents.length > 0) {\n    markdown += '\\n' + formatDocumentsMarkdown(documents);\n  }\n  const json = formatJson(filteredMemories, entities, summaries, notes, lists, documents, profile, query);\n\n  return {\n    generated_at: new Date().toISOString(),\n    profile: profile.name,\n    query,\n    memories: filteredMemories,\n    entities,\n    summaries,\n    notes,\n    lists,\n    documents,\n    token_count: totalTokens,\n    disclosure_id: disclosureId,\n    markdown,\n    json,\n  };\n}",
      "references": [
        "query",
        "maxTokens",
        "conversationId",
        "includeDocuments",
        "maxDocumentTokens",
        "getProfile",
        "found",
        "Error",
        "profile",
        "getDefaultProfile",
        "queryEmbedding",
        "generateEmbedding",
        "Date",
        "lookbackDate",
        "isStoryMode",
        "memoriesQuery",
        "queryParams",
        "embeddingStr",
        "similarityThreshold",
        "pool",
        "result",
        "calculateRecencyScore",
        "row",
        "calculateFinalScore",
        "weights",
        "hasVeryHighSalience",
        "category",
        "hasHighSalience",
        "hasAnySimilarity",
        "hasGoodSimilarity",
        "recencyScore",
        "finalScore",
        "estimateTokens",
        "applyTokenBudget",
        "scoredMemories",
        "effectiveMaxTokens",
        "budgetCaps",
        "filterMemoriesOptimized",
        "budgetedMemories",
        "m",
        "filterResult",
        "filteredMemories",
        "sum",
        "getEntitiesForMemories",
        "memoryIds",
        "getNonEmptySummaries",
        "livingSummaries",
        "s",
        "getPinnedNotes",
        "pinnedNotes",
        "notes",
        "note",
        "searchNotes",
        "relevantNotes",
        "n",
        "searchLists",
        "relevantLists",
        "lists",
        "list",
        "console",
        "error",
        "searchForContext",
        "documents",
        "docResults",
        "chunk",
        "logDisclosure",
        "totalTokens",
        "formatMarkdown",
        "entities",
        "summaries",
        "markdown",
        "formatNotesMarkdown",
        "formatListsMarkdown",
        "formatDocumentsMarkdown",
        "formatJson",
        "disclosureId",
        "json"
      ]
    },
    "file:src/services/context.ts:fn:getDisclosureLog:870": {
      "id": "file:src/services/context.ts:fn:getDisclosureLog:870",
      "type": "function",
      "name": "getDisclosureLog",
      "filePath": "/home/ridgetop/projects/squire/src/services/context.ts",
      "line": 870,
      "endLine": 889,
      "parentFileId": "file:src/services/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "20"
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<object[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches disclosure log from DB, optionally by conversation ID, ordered DESC by created_at, limited.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDisclosureLog(\n  limit = 20,\n  conversationId?: string\n): Promise<object[]> {\n  let query = 'SELECT * FROM disclosure_log';\n  const params: (string | number)[] = [];\n\n  if (conversationId) {\n    query += ' WHERE conversation_id = $1';\n    params.push(conversationId);\n    query += ' ORDER BY created_at DESC LIMIT $2';\n    params.push(limit);\n  } else {\n    query += ' ORDER BY created_at DESC LIMIT $1';\n    params.push(limit);\n  }\n\n  const result = await pool.query(query, params);\n  return result.rows;\n}",
      "references": [
        "query",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts": {
      "id": "file:src/services/conversations.ts",
      "type": "file",
      "name": "conversations.ts",
      "filePath": "src/services/conversations.ts",
      "line": 1,
      "endLine": 374,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./sessions.js",
          "items": [
            {
              "name": "getOrCreateSession",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConversationByClientId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getOrCreateConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listConversations",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateConversationTitle",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "addMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMessages",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getRecentConversationWithMessages",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMessagesUsingMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemoriesUsedInConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConversationStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "Conversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatMessageDB",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateConversationInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AddMessageInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/conversations.ts:fn:createConversation:60",
        "file:src/services/conversations.ts:fn:getConversation:78",
        "file:src/services/conversations.ts:fn:getConversationByClientId:89",
        "file:src/services/conversations.ts:fn:getOrCreateConversation:103",
        "file:src/services/conversations.ts:fn:listConversations:114",
        "file:src/services/conversations.ts:fn:archiveConversation:135",
        "file:src/services/conversations.ts:fn:deleteConversation:149",
        "file:src/services/conversations.ts:fn:updateConversationTitle:163",
        "file:src/services/conversations.ts:fn:addMessage:185",
        "file:src/services/conversations.ts:fn:getMessages:272",
        "file:src/services/conversations.ts:fn:getRecentConversationWithMessages:293",
        "file:src/services/conversations.ts:fn:getMessagesUsingMemory:315",
        "file:src/services/conversations.ts:fn:getMemoriesUsedInConversation:332",
        "file:src/services/conversations.ts:fn:getConversationStats:348"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/conversations.ts:fn:createConversation:60": {
      "id": "file:src/services/conversations.ts:fn:createConversation:60",
      "type": "function",
      "name": "createConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 60,
      "endLine": 73,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/conversations\").CreateConversationInput",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new conversation into the database with client_id, session_id, and title.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createConversation(\n  input: CreateConversationInput = {}\n): Promise<Conversation> {\n  const session = await getOrCreateSession();\n\n  const result = await pool.query(\n    `INSERT INTO conversations (client_id, session_id, title)\n     VALUES ($1, $2, $3)\n     RETURNING *`,\n    [input.clientId ?? null, session.id, input.title ?? null]\n  );\n\n  return result.rows[0] as Conversation;\n}",
      "references": [
        "getOrCreateSession",
        "pool",
        "session",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:getConversation:78": {
      "id": "file:src/services/conversations.ts:fn:getConversation:78",
      "type": "function",
      "name": "getConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 78,
      "endLine": 84,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a conversation by ID from database, excluding deleted ones",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConversation(id: string): Promise<Conversation | null> {\n  const result = await pool.query(\n    `SELECT * FROM conversations WHERE id = $1 AND status != 'deleted'`,\n    [id]\n  );\n  return (result.rows[0] as Conversation) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:getConversationByClientId:89": {
      "id": "file:src/services/conversations.ts:fn:getConversationByClientId:89",
      "type": "function",
      "name": "getConversationByClientId",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 89,
      "endLine": 97,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "clientId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves conversation by client ID from DB, excluding deleted status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConversationByClientId(\n  clientId: string\n): Promise<Conversation | null> {\n  const result = await pool.query(\n    `SELECT * FROM conversations WHERE client_id = $1 AND status != 'deleted'`,\n    [clientId]\n  );\n  return (result.rows[0] as Conversation) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:getOrCreateConversation:103": {
      "id": "file:src/services/conversations.ts:fn:getOrCreateConversation:103",
      "type": "function",
      "name": "getOrCreateConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 103,
      "endLine": 109,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "clientId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves existing conversation by clientId or creates a new one if none exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getOrCreateConversation(\n  clientId: string\n): Promise<Conversation> {\n  const existing = await getConversationByClientId(clientId);\n  if (existing) return existing;\n  return createConversation({ clientId });\n}",
      "references": [
        "getConversationByClientId",
        "existing",
        "createConversation"
      ]
    },
    "file:src/services/conversations.ts:fn:listConversations:114": {
      "id": "file:src/services/conversations.ts:fn:listConversations:114",
      "type": "function",
      "name": "listConversations",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 114,
      "endLine": 130,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ limit?: number; offset?: number; status?: \"active\" | \"archived\"; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches paginated conversations by status from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listConversations(options: {\n  limit?: number;\n  offset?: number;\n  status?: 'active' | 'archived';\n} = {}): Promise<Conversation[]> {\n  const { limit = 20, offset = 0, status = 'active' } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM conversations\n     WHERE status = $1\n     ORDER BY COALESCE(last_message_at, created_at) DESC\n     LIMIT $2 OFFSET $3`,\n    [status, limit, offset]\n  );\n\n  return result.rows as Conversation[];\n}",
      "references": [
        "limit",
        "offset",
        "status",
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:archiveConversation:135": {
      "id": "file:src/services/conversations.ts:fn:archiveConversation:135",
      "type": "function",
      "name": "archiveConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 135,
      "endLine": 144,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a conversation by updating its status to 'archived' in the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveConversation(id: string): Promise<boolean> {\n  const result = await pool.query(\n    `UPDATE conversations\n     SET status = 'archived', updated_at = NOW()\n     WHERE id = $1\n     RETURNING id`,\n    [id]\n  );\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:deleteConversation:149": {
      "id": "file:src/services/conversations.ts:fn:deleteConversation:149",
      "type": "function",
      "name": "deleteConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 149,
      "endLine": 158,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Soft-deletes a conversation by updating status to 'deleted' and returns success.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteConversation(id: string): Promise<boolean> {\n  const result = await pool.query(\n    `UPDATE conversations\n     SET status = 'deleted', updated_at = NOW()\n     WHERE id = $1\n     RETURNING id`,\n    [id]\n  );\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:updateConversationTitle:163": {
      "id": "file:src/services/conversations.ts:fn:updateConversationTitle:163",
      "type": "function",
      "name": "updateConversationTitle",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 163,
      "endLine": 175,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates conversation title in database and returns updated conversation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateConversationTitle(\n  id: string,\n  title: string\n): Promise<Conversation | null> {\n  const result = await pool.query(\n    `UPDATE conversations\n     SET title = $2, updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id, title]\n  );\n  return (result.rows[0] as Conversation) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:addMessage:185": {
      "id": "file:src/services/conversations.ts:fn:addMessage:185",
      "type": "function",
      "name": "addMessage",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 185,
      "endLine": 267,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/conversations\").AddMessageInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").ChatMessageDB>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Adds message to conversation DB, assigns sequence, links memories, updates stats",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function addMessage(input: AddMessageInput): Promise<ChatMessageDB> {\n  const {\n    conversationId,\n    role,\n    content,\n    memoryIds = [],\n    disclosureId,\n    contextProfile,\n    promptTokens,\n    completionTokens,\n  } = input;\n\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Get next sequence number\n    const seqResult = await client.query(\n      `SELECT COALESCE(MAX(sequence_number), 0) + 1 as next_seq\n       FROM chat_messages WHERE conversation_id = $1`,\n      [conversationId]\n    );\n    const sequenceNumber = seqResult.rows[0].next_seq;\n\n    // Insert message\n    const messageResult = await client.query(\n      `INSERT INTO chat_messages (\n        conversation_id, role, content, context_memory_ids,\n        disclosure_id, context_profile, prompt_tokens, completion_tokens,\n        sequence_number\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n      RETURNING *`,\n      [\n        conversationId,\n        role,\n        content,\n        memoryIds,\n        disclosureId ?? null,\n        contextProfile ?? null,\n        promptTokens ?? null,\n        completionTokens ?? null,\n        sequenceNumber,\n      ]\n    );\n\n    const message = messageResult.rows[0] as ChatMessageDB;\n\n    // Insert junction table entries for memory linkage\n    if (memoryIds.length > 0) {\n      const values = memoryIds\n        .map((_, i) => `($1, $${i + 2}, 'context')`)\n        .join(', ');\n\n      await client.query(\n        `INSERT INTO chat_message_memories (message_id, memory_id, usage_type)\n         VALUES ${values}\n         ON CONFLICT (message_id, memory_id) DO NOTHING`,\n        [message.id, ...memoryIds]\n      );\n    }\n\n    // Update conversation stats\n    const tokens = (promptTokens ?? 0) + (completionTokens ?? 0);\n    await client.query(\n      `UPDATE conversations SET\n        message_count = message_count + 1,\n        total_tokens = total_tokens + $2,\n        last_message_at = NOW(),\n        updated_at = NOW()\n       WHERE id = $1`,\n      [conversationId, tokens]\n    );\n\n    await client.query('COMMIT');\n    return message;\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}",
      "references": [
        "conversationId",
        "role",
        "content",
        "memoryIds",
        "disclosureId",
        "contextProfile",
        "promptTokens",
        "completionTokens",
        "pool",
        "client",
        "seqResult",
        "sequenceNumber",
        "messageResult",
        "i",
        "values",
        "message",
        "tokens",
        "error"
      ]
    },
    "file:src/services/conversations.ts:fn:getMessages:272": {
      "id": "file:src/services/conversations.ts:fn:getMessages:272",
      "type": "function",
      "name": "getMessages",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 272,
      "endLine": 287,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; offset?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").ChatMessageDB[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves paginated chat messages for a conversation from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMessages(\n  conversationId: string,\n  options: { limit?: number; offset?: number } = {}\n): Promise<ChatMessageDB[]> {\n  const { limit = 100, offset = 0 } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM chat_messages\n     WHERE conversation_id = $1\n     ORDER BY sequence_number ASC\n     LIMIT $2 OFFSET $3`,\n    [conversationId, limit, offset]\n  );\n\n  return result.rows as ChatMessageDB[];\n}",
      "references": [
        "limit",
        "offset",
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:getRecentConversationWithMessages:293": {
      "id": "file:src/services/conversations.ts:fn:getRecentConversationWithMessages:293",
      "type": "function",
      "name": "getRecentConversationWithMessages",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 293,
      "endLine": 306,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ conversation: import(\"/home/ridgetop/projects/squire/src/services/conversations\").Conversation; messages: import(\"/home/ridgetop/projects/squire/src/services/conversations\").ChatMessageDB[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches the most recent conversation and its messages (up to 10000).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getRecentConversationWithMessages(): Promise<{\n  conversation: Conversation;\n  messages: ChatMessageDB[];\n} | null> {\n  const conversations = await listConversations({ limit: 1 });\n  const conversation = conversations[0];\n  if (!conversation) return null;\n\n  // Load ALL messages for the current conversation (no limit)\n  // We need the complete history for the chat UI\n  const messages = await getMessages(conversation.id, { limit: 10000 });\n\n  return { conversation, messages };\n}",
      "references": [
        "listConversations",
        "conversations",
        "conversation",
        "getMessages",
        "messages"
      ]
    },
    "file:src/services/conversations.ts:fn:getMessagesUsingMemory:315": {
      "id": "file:src/services/conversations.ts:fn:getMessagesUsingMemory:315",
      "type": "function",
      "name": "getMessagesUsingMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 315,
      "endLine": 327,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/conversations\").ChatMessageDB[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves chat messages linked to a memory ID via database query.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMessagesUsingMemory(\n  memoryId: string\n): Promise<ChatMessageDB[]> {\n  const result = await pool.query(\n    `SELECT cm.* FROM chat_messages cm\n     JOIN chat_message_memories cmm ON cmm.message_id = cm.id\n     WHERE cmm.memory_id = $1\n     ORDER BY cm.created_at DESC`,\n    [memoryId]\n  );\n\n  return result.rows as ChatMessageDB[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/conversations.ts:fn:getMemoriesUsedInConversation:332": {
      "id": "file:src/services/conversations.ts:fn:getMemoriesUsedInConversation:332",
      "type": "function",
      "name": "getMemoriesUsedInConversation",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 332,
      "endLine": 343,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves distinct memory IDs used in a conversation's messages via DB query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMemoriesUsedInConversation(\n  conversationId: string\n): Promise<string[]> {\n  const result = await pool.query(\n    `SELECT DISTINCT cmm.memory_id FROM chat_message_memories cmm\n     JOIN chat_messages cm ON cm.id = cmm.message_id\n     WHERE cm.conversation_id = $1`,\n    [conversationId]\n  );\n\n  return result.rows.map((r) => r.memory_id);\n}",
      "references": [
        "pool",
        "result",
        "r"
      ]
    },
    "file:src/services/conversations.ts:fn:getConversationStats:348": {
      "id": "file:src/services/conversations.ts:fn:getConversationStats:348",
      "type": "function",
      "name": "getConversationStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/conversations.ts",
      "line": 348,
      "endLine": 373,
      "parentFileId": "file:src/services/conversations.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; archived: number; totalMessages: number; totalTokens: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves conversation stats: total, active, archived, messages, and tokens from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConversationStats(): Promise<{\n  total: number;\n  active: number;\n  archived: number;\n  totalMessages: number;\n  totalTokens: number;\n}> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) FILTER (WHERE status != 'deleted') as total,\n      COUNT(*) FILTER (WHERE status = 'active') as active,\n      COUNT(*) FILTER (WHERE status = 'archived') as archived,\n      COALESCE(SUM(message_count) FILTER (WHERE status != 'deleted'), 0) as total_messages,\n      COALESCE(SUM(total_tokens) FILTER (WHERE status != 'deleted'), 0) as total_tokens\n    FROM conversations\n  `);\n\n  const row = result.rows[0];\n  return {\n    total: parseInt(row.total ?? '0', 10),\n    active: parseInt(row.active ?? '0', 10),\n    archived: parseInt(row.archived ?? '0', 10),\n    totalMessages: parseInt(row.total_messages ?? '0', 10),\n    totalTokens: parseInt(row.total_tokens ?? '0', 10),\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row"
      ]
    },
    "file:src/services/edges.ts": {
      "id": "file:src/services/edges.ts",
      "type": "file",
      "name": "edges.ts",
      "filePath": "src/services/edges.ts",
      "line": 1,
      "endLine": 243,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getRelatedMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEdgesForMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEdgeStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countEdgesForMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findConnectedCluster",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EdgeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "CreateEdgeInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RelatedMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/edges.ts:fn:createEdge:19",
        "file:src/services/edges.ts:fn:getRelatedMemories:80",
        "file:src/services/edges.ts:fn:getEdgesForMemory:125",
        "file:src/services/edges.ts:fn:getEdgeStats:151",
        "file:src/services/edges.ts:fn:countEdgesForMemory:195",
        "file:src/services/edges.ts:fn:findConnectedCluster:208"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/edges.ts:fn:createEdge:19": {
      "id": "file:src/services/edges.ts:fn:createEdge:19",
      "type": "function",
      "name": "createEdge",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 19,
      "endLine": 55,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/edges\").CreateEdgeInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/edges\").MemoryEdge>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates or updates a memory edge in the database using INSERT with ON CONFLICT.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createEdge(input: CreateEdgeInput): Promise<MemoryEdge> {\n  const {\n    source_memory_id,\n    target_memory_id,\n    edge_type,\n    weight = 1.0,\n    similarity,\n    metadata = {},\n  } = input;\n\n  const result = await pool.query<MemoryEdge>(\n    `INSERT INTO memory_edges (source_memory_id, target_memory_id, edge_type, weight, similarity, metadata)\n     VALUES ($1, $2, $3, $4, $5, $6)\n     ON CONFLICT (source_memory_id, target_memory_id, edge_type)\n     DO UPDATE SET\n       weight = GREATEST(memory_edges.weight, EXCLUDED.weight),\n       similarity = COALESCE(EXCLUDED.similarity, memory_edges.similarity),\n       metadata = memory_edges.metadata || EXCLUDED.metadata,\n       last_reinforced_at = NOW(),\n       reinforcement_count = memory_edges.reinforcement_count + 1\n     RETURNING *`,\n    [\n      source_memory_id,\n      target_memory_id,\n      edge_type,\n      weight,\n      similarity ?? null,\n      JSON.stringify(metadata),\n    ]\n  );\n\n  const edge = result.rows[0];\n  if (!edge) {\n    throw new Error('Failed to create edge - no row returned');\n  }\n  return edge;\n}",
      "references": [
        "source_memory_id",
        "target_memory_id",
        "edge_type",
        "weight",
        "similarity",
        "metadata",
        "pool",
        "JSON",
        "result",
        "edge",
        "Error"
      ]
    },
    "file:src/services/edges.ts:fn:getRelatedMemories:80": {
      "id": "file:src/services/edges.ts:fn:getRelatedMemories:80",
      "type": "function",
      "name": "getRelatedMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 80,
      "endLine": 120,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ edgeType?: import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType; minWeight?: number; limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/edges\").RelatedMemory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches related memories from DB via edges, filtered by type/weight, deduped, sorted, limited.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getRelatedMemories(\n  memoryId: string,\n  options: {\n    edgeType?: EdgeType;\n    minWeight?: number;\n    limit?: number;\n  } = {}\n): Promise<RelatedMemory[]> {\n  const { edgeType = 'SIMILAR', minWeight = 0.2, limit = 10 } = options;\n\n  // Use DISTINCT ON to deduplicate when both directions of an edge exist\n  const result = await pool.query(\n    `SELECT DISTINCT ON (m.id)\n       m.*,\n       e.edge_type,\n       e.weight as edge_weight,\n       e.similarity as edge_similarity\n     FROM memory_edges e\n     JOIN memories m ON (\n       CASE\n         WHEN e.source_memory_id = $1 THEN e.target_memory_id\n         ELSE e.source_memory_id\n       END = m.id\n     )\n     WHERE (e.source_memory_id = $1 OR e.target_memory_id = $1)\n       AND e.edge_type = $2\n       AND e.weight >= $3\n     ORDER BY m.id, e.weight DESC, e.similarity DESC NULLS LAST`,\n    [memoryId, edgeType, minWeight]\n  );\n\n  // Re-sort by weight/similarity after deduplication and apply limit\n  const sorted = (result.rows as RelatedMemory[]).sort((a, b) => {\n    if (b.edge_weight !== a.edge_weight) return b.edge_weight - a.edge_weight;\n    const aSim = a.edge_similarity ?? 0;\n    const bSim = b.edge_similarity ?? 0;\n    return bSim - aSim;\n  });\n\n  return sorted.slice(0, limit);\n}",
      "references": [
        "edgeType",
        "minWeight",
        "limit",
        "pool",
        "result",
        "b",
        "a",
        "bSim",
        "aSim",
        "sorted"
      ]
    },
    "file:src/services/edges.ts:fn:getEdgesForMemory:125": {
      "id": "file:src/services/edges.ts:fn:getEdgesForMemory:125",
      "type": "function",
      "name": "getEdgesForMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 125,
      "endLine": 146,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ edgeType?: import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/edges\").MemoryEdge[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves memory edges connected to a given memory ID, optionally filtered by edge type.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEdgesForMemory(\n  memoryId: string,\n  options: { edgeType?: EdgeType } = {}\n): Promise<MemoryEdge[]> {\n  const { edgeType } = options;\n\n  let query = `\n    SELECT * FROM memory_edges\n    WHERE source_memory_id = $1 OR target_memory_id = $1\n  `;\n  const params: (string | EdgeType)[] = [memoryId];\n\n  if (edgeType) {\n    query += ` AND edge_type = $2`;\n    params.push(edgeType);\n  }\n\n  query += ` ORDER BY weight DESC`;\n\n  const result = await pool.query(query, params);\n  return result.rows as MemoryEdge[];\n}",
      "references": [
        "edgeType",
        "query",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/edges.ts:fn:getEdgeStats:151": {
      "id": "file:src/services/edges.ts:fn:getEdgeStats:151",
      "type": "function",
      "name": "getEdgeStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 151,
      "endLine": 190,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; byType: Record<import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType, number>; averageWeight: number; averageSimilarity: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves edge statistics: total count, by type, average weight and similarity from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEdgeStats(): Promise<{\n  total: number;\n  byType: Record<EdgeType, number>;\n  averageWeight: number;\n  averageSimilarity: number;\n}> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) as total,\n      AVG(weight) as avg_weight,\n      AVG(similarity) FILTER (WHERE similarity IS NOT NULL) as avg_similarity\n    FROM memory_edges\n  `);\n\n  const typeResult = await pool.query(`\n    SELECT edge_type, COUNT(*) as count\n    FROM memory_edges\n    GROUP BY edge_type\n  `);\n\n  const byType: Record<EdgeType, number> = {\n    SIMILAR: 0,\n    FOLLOWS: 0,\n    CONTRADICTS: 0,\n    ELABORATES: 0,\n    RESOLVES: 0,\n  };\n\n  for (const row of typeResult.rows) {\n    byType[row.edge_type as EdgeType] = parseInt(row.count, 10);\n  }\n\n  const stats = result.rows[0];\n  return {\n    total: parseInt(stats.total ?? '0', 10),\n    byType,\n    averageWeight: parseFloat(stats.avg_weight ?? '1.0'),\n    averageSimilarity: parseFloat(stats.avg_similarity ?? '0.0'),\n  };\n}",
      "references": [
        "pool",
        "typeResult",
        "byType",
        "row",
        "parseInt",
        "result",
        "stats",
        "parseFloat"
      ]
    },
    "file:src/services/edges.ts:fn:countEdgesForMemory:195": {
      "id": "file:src/services/edges.ts:fn:countEdgesForMemory:195",
      "type": "function",
      "name": "countEdgesForMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 195,
      "endLine": 202,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Counts edges connected to a memory ID via SQL query on memory_edges table.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function countEdgesForMemory(memoryId: string): Promise<number> {\n  const result = await pool.query(\n    `SELECT COUNT(*) as count FROM memory_edges\n     WHERE source_memory_id = $1 OR target_memory_id = $1`,\n    [memoryId]\n  );\n  return parseInt(result.rows[0]?.count ?? '0', 10);\n}",
      "references": [
        "pool",
        "parseInt",
        "result"
      ]
    },
    "file:src/services/edges.ts:fn:findConnectedCluster:208": {
      "id": "file:src/services/edges.ts:fn:findConnectedCluster:208",
      "type": "function",
      "name": "findConnectedCluster",
      "filePath": "/home/ridgetop/projects/squire/src/services/edges.ts",
      "line": 208,
      "endLine": 242,
      "parentFileId": "file:src/services/edges.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "depth",
          "type": "number",
          "isOptional": true,
          "defaultValue": "2"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "BFS queries DB for connected memories up to depth, excludes seed, top 20 by salience.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.024Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findConnectedCluster(\n  memoryId: string,\n  depth: number = 2\n): Promise<Memory[]> {\n  // BFS traversal to find connected memories up to specified depth\n  const result = await pool.query(\n    `WITH RECURSIVE connected AS (\n       -- Start with the seed memory\n       SELECT $1::uuid as memory_id, 0 as depth\n\n       UNION ALL\n\n       -- Find connected memories\n       SELECT\n         CASE\n           WHEN e.source_memory_id = c.memory_id THEN e.target_memory_id\n           ELSE e.source_memory_id\n         END as memory_id,\n         c.depth + 1 as depth\n       FROM connected c\n       JOIN memory_edges e ON (e.source_memory_id = c.memory_id OR e.target_memory_id = c.memory_id)\n       WHERE c.depth < $2\n         AND e.weight >= 0.5\n     )\n     SELECT DISTINCT m.*\n     FROM connected c\n     JOIN memories m ON m.id = c.memory_id\n     WHERE c.memory_id != $1\n     ORDER BY m.salience_score DESC\n     LIMIT 20`,\n    [memoryId, depth]\n  );\n\n  return result.rows as Memory[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/entities.ts": {
      "id": "file:src/services/entities.ts",
      "type": "file",
      "name": "entities.ts",
      "filePath": "src/services/entities.ts",
      "line": 1,
      "endLine": 1191,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "extractEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "validateEntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractEntitiesWithLLM",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getOrCreateEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createMention",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createMentionWithRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractAndStoreEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntityWithMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findEntityByName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemoryEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countEntitiesByType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Entity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityMention",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "LLMExtractedEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedEntityWithRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListEntitiesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityMemoryMention",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectedEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityWithMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/entities.ts:fn:extractEntities:196",
        "file:src/services/entities.ts:fn:calculateExtractionConfidence:249",
        "file:src/services/entities.ts:fn:deduplicateEntities:282",
        "file:src/services/entities.ts:fn:validateEntityType:346",
        "file:src/services/entities.ts:fn:llmDisambiguate:401",
        "file:src/services/entities.ts:fn:disambiguateEntity:468",
        "file:src/services/entities.ts:fn:extractEntitiesWithLLM:545",
        "file:src/services/entities.ts:fn:shouldInvokeLLM:618",
        "file:src/services/entities.ts:fn:mergeExtractionResults:659",
        "file:src/services/entities.ts:fn:canonicalize:724",
        "file:src/services/entities.ts:fn:getOrCreateEntity:739",
        "file:src/services/entities.ts:fn:createMention:834",
        "file:src/services/entities.ts:fn:createMentionWithRelationship:875",
        "file:src/services/entities.ts:fn:extractAndStoreEntities:923",
        "file:src/services/entities.ts:fn:listEntities:980",
        "file:src/services/entities.ts:fn:getEntity:1015",
        "file:src/services/entities.ts:fn:searchEntities:1026",
        "file:src/services/entities.ts:fn:getEntityWithMemories:1081",
        "file:src/services/entities.ts:fn:findEntityByName:1141",
        "file:src/services/entities.ts:fn:getMemoryEntities:1155",
        "file:src/services/entities.ts:fn:countEntitiesByType:1169"
      ],
      "classes": [],
      "topLevelReferences": [
        "Set"
      ]
    },
    "file:src/services/entities.ts:fn:extractEntities:196": {
      "id": "file:src/services/entities.ts:fn:extractEntities:196",
      "type": "function",
      "name": "extractEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 196,
      "endLine": 244,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Extracts entities from text using regex patterns, filters, dedupes by position",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function extractEntities(text: string): ExtractedEntity[] {\n  const entities: ExtractedEntity[] = [];\n  const seen = new Set<string>(); // Dedupe by position\n\n  for (const [type, patterns] of Object.entries(PATTERNS)) {\n    for (const pattern of patterns) {\n      // Reset regex state\n      pattern.lastIndex = 0;\n\n      let match;\n      while ((match = pattern.exec(text)) !== null) {\n        const name = match[1]?.trim();\n        if (!name) continue;\n\n        // Skip stop words\n        if (STOP_WORDS.has(name)) continue;\n        if (name.split(/\\s+/).every((w) => STOP_WORDS.has(w))) continue;\n\n        // Skip very short names (likely false positives)\n        // Projects need 3+ chars to avoid \"an\", \"my\", etc. matching with /gi flag\n        const minLength = type === 'project' ? 3 : 2;\n        if (name.length < minLength) continue;\n\n        // Skip if already seen at this position\n        const posKey = `${match.index}-${name}`;\n        if (seen.has(posKey)) continue;\n        seen.add(posKey);\n\n        // Calculate context snippet\n        const contextStart = Math.max(0, match.index - 30);\n        const contextEnd = Math.min(text.length, match.index + name.length + 30);\n        const context = text.slice(contextStart, contextEnd);\n\n        entities.push({\n          name,\n          type: type as EntityType,\n          mentionText: match[0],\n          positionStart: match.index,\n          positionEnd: match.index + match[0].length,\n          confidence: calculateExtractionConfidence(name, type as EntityType, text),\n          context,\n        });\n      }\n    }\n  }\n\n  // Sort by position and remove overlapping extractions (prefer longer matches)\n  return deduplicateEntities(entities);\n}",
      "references": [
        "Set",
        "patterns",
        "Object",
        "PATTERNS",
        "pattern",
        "match",
        "name",
        "STOP_WORDS",
        "w",
        "minLength",
        "seen",
        "posKey",
        "Math",
        "contextStart",
        "contextEnd",
        "entities",
        "calculateExtractionConfidence",
        "context",
        "deduplicateEntities"
      ]
    },
    "file:src/services/entities.ts:fn:calculateExtractionConfidence:249": {
      "id": "file:src/services/entities.ts:fn:calculateExtractionConfidence:249",
      "type": "function",
      "name": "calculateExtractionConfidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 249,
      "endLine": 277,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "type",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityType",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates confidence score for entity extraction based on name, type, and text context.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateExtractionConfidence(\n  name: string,\n  type: EntityType,\n  text: string\n): number {\n  let confidence = 0.7; // Base confidence for regex match\n\n  // Boost for multi-word names (more likely to be real entities)\n  if (name.includes(' ')) {\n    confidence += 0.1;\n  }\n\n  // Boost for names that appear multiple times\n  const occurrences = (text.match(new RegExp(name, 'gi')) || []).length;\n  if (occurrences > 1) {\n    confidence += Math.min(0.1, occurrences * 0.02);\n  }\n\n  // Type-specific adjustments\n  if (type === 'person' && /^[A-Z][a-z]+\\s+[A-Z][a-z]+$/.test(name)) {\n    confidence += 0.1; // Two-word proper names are likely people\n  }\n\n  if (type === 'project' && text.toLowerCase().includes('project')) {\n    confidence += 0.05; // Explicit project mention\n  }\n\n  return Math.min(1.0, confidence);\n}",
      "references": [
        "confidence",
        "RegExp",
        "occurrences",
        "Math"
      ]
    },
    "file:src/services/entities.ts:fn:deduplicateEntities:282": {
      "id": "file:src/services/entities.ts:fn:deduplicateEntities:282",
      "type": "function",
      "name": "deduplicateEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 282,
      "endLine": 305,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Deduplicates entities by position, preferring longer matches and skipping overlaps",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function deduplicateEntities(entities: ExtractedEntity[]): ExtractedEntity[] {\n  if (entities.length === 0) return entities;\n\n  // Sort by position, then by length (longer first)\n  entities.sort((a, b) => {\n    if (a.positionStart !== b.positionStart) {\n      return a.positionStart - b.positionStart;\n    }\n    return b.name.length - a.name.length;\n  });\n\n  const result: ExtractedEntity[] = [];\n  let lastEnd = -1;\n\n  for (const entity of entities) {\n    // Skip if overlaps with previous (already accepted longer match)\n    if (entity.positionStart < lastEnd) continue;\n\n    result.push(entity);\n    lastEnd = entity.positionEnd;\n  }\n\n  return result;\n}",
      "references": [
        "a",
        "b",
        "entity",
        "lastEnd",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:validateEntityType:346": {
      "id": "file:src/services/entities.ts:fn:validateEntityType:346",
      "type": "function",
      "name": "validateEntityType",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 346,
      "endLine": 368,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "proposedType",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityType",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_context",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityType",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Validates entity type by matching name against TYPE_INDICATORS patterns, correcting if mismatch.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function validateEntityType(\n  name: string,\n  proposedType: EntityType,\n  _context: string\n): EntityType {\n  // Check each type's indicators\n  for (const [type, patterns] of Object.entries(TYPE_INDICATORS)) {\n    for (const pattern of patterns) {\n      if (pattern.test(name)) {\n        // Found an indicator - override the proposed type\n        if (type !== proposedType) {\n          console.log(\n            `[EntityValidation] Corrected \"${name}\" from ${proposedType} to ${type}`\n          );\n        }\n        return type as EntityType;\n      }\n    }\n  }\n\n  // No indicator found - keep the proposed type\n  return proposedType;\n}",
      "references": [
        "patterns",
        "Object",
        "TYPE_INDICATORS",
        "pattern",
        "console"
      ]
    },
    "file:src/services/entities.ts:fn:llmDisambiguate:401": {
      "id": "file:src/services/entities.ts:fn:llmDisambiguate:401",
      "type": "function",
      "name": "llmDisambiguate",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 401,
      "endLine": 455,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "newEntity",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntityWithRelationship",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "candidates",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Uses LLM to disambiguate new entity against candidates, returns match or null.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function llmDisambiguate(\n  newEntity: ExtractedEntityWithRelationship,\n  candidates: Entity[]\n): Promise<Entity | null> {\n  const candidateList = candidates\n    .map((c, i) => {\n      const rel = (c.attributes as Record<string, unknown>)?.initial_relationship || 'unknown';\n      const desc = c.description || 'no description';\n      return `${i + 1}. ${c.name} - relationship: ${rel} - ${desc}`;\n    })\n    .join('\\n');\n\n  const prompt = DISAMBIGUATION_PROMPT\n    .replace('{name}', newEntity.name)\n    .replace('{context}', newEntity.context || '')\n    .replace('{relationship}', newEntity.relationship_type || 'unknown')\n    .replace('{candidates}', candidateList);\n\n  try {\n    const result = await complete(\n      [\n        { role: 'system', content: 'You disambiguate entity mentions. Respond with only a number or \"NEW\".' },\n        { role: 'user', content: prompt },\n      ],\n      { temperature: 0.1, maxTokens: 10 }\n    );\n\n    const response = result.content.trim().toUpperCase();\n\n    if (response === 'NEW') {\n      console.log(`[Disambiguation] LLM says \"${newEntity.name}\" is NEW entity`);\n      return null;\n    }\n\n    const matchIndex = parseInt(response, 10);\n    if (!isNaN(matchIndex) && matchIndex >= 1 && matchIndex <= candidates.length) {\n      const matched = candidates[matchIndex - 1];\n      if (matched) {\n        console.log(`[Disambiguation] LLM matched \"${newEntity.name}\" to candidate ${matchIndex}`);\n        return matched;\n      }\n    }\n\n    // Unclear response - default to first candidate (most mentioned)\n    const first = candidates[0];\n    if (first) {\n      console.log(`[Disambiguation] LLM unclear (\"${response}\"), defaulting to first candidate`);\n      return first;\n    }\n    return null;\n  } catch (error) {\n    console.error('[Disambiguation] LLM failed, defaulting to first candidate:', error);\n    return candidates[0] ?? null;\n  }\n}",
      "references": [
        "c",
        "i",
        "rel",
        "desc",
        "DISAMBIGUATION_PROMPT",
        "candidateList",
        "complete",
        "prompt",
        "result",
        "response",
        "console",
        "parseInt",
        "isNaN",
        "matchIndex",
        "matched",
        "first",
        "error"
      ]
    },
    "file:src/services/entities.ts:fn:disambiguateEntity:468": {
      "id": "file:src/services/entities.ts:fn:disambiguateEntity:468",
      "type": "function",
      "name": "disambiguateEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 468,
      "endLine": 506,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "newEntity",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntityWithRelationship",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "candidates",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Disambiguates new entity against candidates via relationship match or LLM.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function disambiguateEntity(\n  newEntity: ExtractedEntityWithRelationship,\n  candidates: Entity[]\n): Promise<Entity | null> {\n  if (candidates.length === 0) {\n    return null; // No candidates = definitely new\n  }\n\n  const newRel = newEntity.relationship_type?.toLowerCase();\n\n  // Single candidate - check relationship match\n  if (candidates.length === 1) {\n    const candidate = candidates[0]!; // We know length is 1\n    const candidateRel = ((candidate.attributes as Record<string, unknown>)?.initial_relationship as string)?.toLowerCase();\n\n    // Both have relationships - compare them\n    if (candidateRel && newRel) {\n      if (candidateRel === newRel) {\n        console.log(`[Disambiguation] Relationship match: \"${newRel}\" - same entity`);\n        return candidate;\n      }\n      // Different relationships = different people\n      console.log(`[Disambiguation] Relationship mismatch: \"${candidateRel}\" vs \"${newRel}\" - NEW entity`);\n      return null;\n    }\n\n    // Only one has relationship - check context similarity\n    if (newEntity.context && candidate.description) {\n      // If contexts seem very different, might be different person\n      // For now, default to same person (conservative)\n    }\n\n    // Default: assume same person if no conflicting info\n    return candidate;\n  }\n\n  // Multiple candidates - use LLM to pick best match or create new\n  return llmDisambiguate(newEntity, candidates);\n}",
      "references": [
        "candidate",
        "candidateRel",
        "newRel",
        "console",
        "llmDisambiguate"
      ]
    },
    "file:src/services/entities.ts:fn:extractEntitiesWithLLM:545": {
      "id": "file:src/services/entities.ts:fn:extractEntitiesWithLLM:545",
      "type": "function",
      "name": "extractEntitiesWithLLM",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 545,
      "endLine": 609,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").LLMExtractedEntity[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts entities from text using LLM API, parses, validates, and filters results",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractEntitiesWithLLM(\n  text: string\n): Promise<LLMExtractedEntity[]> {\n  if (!text.trim()) {\n    return [];\n  }\n\n  const messages: LLMMessage[] = [\n    { role: 'system', content: ENTITY_EXTRACTION_SYSTEM_PROMPT },\n    { role: 'user', content: `Extract entities from:\\n\\n\"${text}\"` },\n  ];\n\n  try {\n    const result = await complete(messages, {\n      temperature: 0.2, // Low temperature for consistent extraction\n      maxTokens: 1000,\n    });\n\n    const content = result.content.trim();\n\n    // Handle empty response\n    if (!content || content === '[]') {\n      return [];\n    }\n\n    // Extract JSON from response (handle markdown wrapping)\n    let jsonStr = content;\n    const jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n\n    const parsed = JSON.parse(jsonStr) as Array<{\n      name: string;\n      type: string;\n      relationship?: string;\n      confidence: number;\n      mentionText?: string;\n    }>;\n\n    // Validate and filter results\n    const validTypes: EntityType[] = ['person', 'project', 'concept', 'place', 'organization'];\n\n    return parsed\n      .filter(\n        (e) =>\n          e.name &&\n          typeof e.name === 'string' &&\n          e.name.length >= 2 &&\n          validTypes.includes(e.type as EntityType) &&\n          e.confidence >= 0.3 &&\n          !STOP_WORDS.has(e.name)\n      )\n      .map((e) => ({\n        name: e.name.trim(),\n        type: e.type as EntityType,\n        relationship: e.relationship || undefined,\n        confidence: Math.min(1.0, Math.max(0.3, e.confidence)),\n        mentionText: e.mentionText || e.name,\n      }));\n  } catch (error) {\n    console.error('[EntityExtraction] LLM extraction failed:', error);\n    return [];\n  }\n}",
      "references": [
        "ENTITY_EXTRACTION_SYSTEM_PROMPT",
        "complete",
        "messages",
        "result",
        "content",
        "jsonMatch",
        "jsonStr",
        "JSON",
        "parsed",
        "e",
        "validTypes",
        "STOP_WORDS",
        "Math",
        "console",
        "error"
      ]
    },
    "file:src/services/entities.ts:fn:shouldInvokeLLM:618": {
      "id": "file:src/services/entities.ts:fn:shouldInvokeLLM:618",
      "type": "function",
      "name": "shouldInvokeLLM",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 618,
      "endLine": 653,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "regexEntities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Decides whether to invoke LLM for entity extraction based on regex entities, confidence, and text patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.025Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function shouldInvokeLLM(\n  text: string,\n  regexEntities: ExtractedEntity[],\n  options: ExtractionOptions = {}\n): boolean {\n  if (options.regexOnly) return false;\n  if (options.forceLLM) return true;\n\n  // Always invoke if regex found nothing\n  if (regexEntities.length === 0) return true;\n\n  // Check for relationship indicators that regex might miss\n  const relationshipPatterns = [\n    /\\bmy\\s+(wife|husband|partner|friend|boss|colleague|sister|brother|mom|dad|mother|father|son|daughter|uncle|aunt|cousin|grandma|grandpa|girlfriend|boyfriend)\\b/i,\n    /\\bour\\s+(client|customer|partner|vendor)\\b/i,\n    /\\bmet\\s+with\\s+\\w+/i,\n    /\\btalked\\s+to\\s+\\w+/i,\n    /\\bcalled\\s+\\w+/i,\n    /\\bnamed\\s+\\w+/i,\n  ];\n\n  const hasRelationshipIndicator = relationshipPatterns.some((p) => p.test(text));\n\n  // If text has relationship indicators but no person entities, invoke LLM\n  if (hasRelationshipIndicator) {\n    const hasPersonEntity = regexEntities.some((e) => e.type === 'person');\n    if (!hasPersonEntity) return true;\n  }\n\n  // Check average confidence\n  const avgConfidence =\n    regexEntities.reduce((sum, e) => sum + e.confidence, 0) / regexEntities.length;\n  const minConfidence = options.minRegexConfidence ?? 0.6;\n\n  return avgConfidence < minConfidence;\n}",
      "references": [
        "relationshipPatterns",
        "p",
        "hasRelationshipIndicator",
        "e",
        "hasPersonEntity",
        "sum",
        "avgConfidence",
        "minConfidence"
      ]
    },
    "file:src/services/entities.ts:fn:mergeExtractionResults:659": {
      "id": "file:src/services/entities.ts:fn:mergeExtractionResults:659",
      "type": "function",
      "name": "mergeExtractionResults",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 659,
      "endLine": 715,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "regexEntities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "llmEntities",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").LLMExtractedEntity[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "originalText",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntityWithRelationship[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Merges regex and LLM extracted entities, prioritizes regex, dedups, adds positions/context, sorts by position.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mergeExtractionResults(\n  regexEntities: ExtractedEntity[],\n  llmEntities: LLMExtractedEntity[],\n  originalText: string\n): ExtractedEntityWithRelationship[] {\n  const results: ExtractedEntityWithRelationship[] = [];\n\n  // Add regex entities first (they have precise positions)\n  for (const re of regexEntities) {\n    results.push({\n      ...re,\n      extraction_method: 'regex',\n    });\n  }\n\n  // Track covered names to avoid duplicates\n  const coveredNames = new Set(regexEntities.map((e) => e.name.toLowerCase()));\n\n  // Add LLM entities that don't overlap with regex results\n  for (const le of llmEntities) {\n    const lowerName = le.name.toLowerCase();\n\n    // Check if this entity is already covered by regex\n    const isDuplicate =\n      coveredNames.has(lowerName) ||\n      Array.from(coveredNames).some(\n        (name) => name.includes(lowerName) || lowerName.includes(name)\n      );\n\n    if (isDuplicate) continue;\n\n    // Find position of the mention in text\n    const lowerText = originalText.toLowerCase();\n    const position = lowerText.indexOf(lowerName);\n\n    // Calculate context snippet\n    const contextStart = Math.max(0, position - 30);\n    const contextEnd = Math.min(originalText.length, position + le.name.length + 30);\n\n    results.push({\n      name: le.name,\n      type: le.type,\n      mentionText: le.mentionText,\n      positionStart: position >= 0 ? position : 0,\n      positionEnd: position >= 0 ? position + le.name.length : le.name.length,\n      confidence: le.confidence,\n      context: position >= 0 ? originalText.slice(contextStart, contextEnd) : le.mentionText,\n      relationship_type: le.relationship,\n      extraction_method: 'llm',\n    });\n\n    coveredNames.add(lowerName);\n  }\n\n  // Sort by position\n  return results.sort((a, b) => a.positionStart - b.positionStart);\n}",
      "references": [
        "results",
        "re",
        "Set",
        "e",
        "le",
        "coveredNames",
        "lowerName",
        "Array",
        "name",
        "isDuplicate",
        "lowerText",
        "Math",
        "position",
        "contextStart",
        "contextEnd",
        "a",
        "b"
      ]
    },
    "file:src/services/entities.ts:fn:canonicalize:724": {
      "id": "file:src/services/entities.ts:fn:canonicalize:724",
      "type": "function",
      "name": "canonicalize",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 724,
      "endLine": 726,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Normalizes string by lowercasing, trimming whitespace, and collapsing multiple spaces.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function canonicalize(name: string): string {\n  return name.toLowerCase().trim().replace(/\\s+/g, ' ');\n}",
      "references": []
    },
    "file:src/services/entities.ts:fn:getOrCreateEntity:739": {
      "id": "file:src/services/entities.ts:fn:getOrCreateEntity:739",
      "type": "function",
      "name": "getOrCreateEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 739,
      "endLine": 829,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "extracted",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity | import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntityWithRelationship",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Finds or creates entity by canonical name/type, disambiguates candidates, updates or inserts into DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getOrCreateEntity(\n  extracted: ExtractedEntity | ExtractedEntityWithRelationship\n): Promise<Entity> {\n  const canonical = canonicalize(extracted.name);\n  const extractionMethod =\n    'extraction_method' in extracted ? extracted.extraction_method : 'regex';\n\n  // Step 1: Find candidates with same name and type\n  const candidates = await pool.query(\n    `SELECT * FROM entities\n     WHERE canonical_name = $1 AND entity_type = $2\n     AND is_merged = FALSE\n     ORDER BY mention_count DESC`,\n    [canonical, extracted.type]\n  );\n\n  // Step 2: Disambiguate if candidates exist\n  if (candidates.rows.length > 0) {\n    // Cast to ExtractedEntityWithRelationship for disambiguation\n    const extWithRel: ExtractedEntityWithRelationship = {\n      ...extracted,\n      extraction_method: extractionMethod,\n      relationship_type: 'relationship_type' in extracted ? extracted.relationship_type : undefined,\n    };\n\n    const match = await disambiguateEntity(extWithRel, candidates.rows as Entity[]);\n\n    if (match) {\n      // Same entity - update and return\n      const updated = await pool.query(\n        `UPDATE entities\n         SET last_seen_at = NOW(),\n             mention_count = mention_count + 1,\n             updated_at = NOW()\n         WHERE id = $1\n         RETURNING *`,\n        [match.id]\n      );\n      return updated.rows[0] as Entity;\n    }\n\n    // Different person with same name - fall through to create new\n    console.log(`[Entity] Creating new \"${extracted.name}\" (disambiguated from ${candidates.rows.length} existing)`);\n  }\n\n  // Step 3: Create new entity\n  const relationshipType = 'relationship_type' in extracted ? extracted.relationship_type : undefined;\n\n  // Build attributes JSONB (for relationship metadata)\n  const attributes: Record<string, unknown> = {};\n  if (relationshipType) {\n    attributes.initial_relationship = relationshipType;\n  }\n\n  // Build aliases array for disambiguation (T3-04)\n  const aliases: string[] = [];\n  if (relationshipType) {\n    // Add relationship-qualified alias: \"Rick (brother-in-law)\"\n    aliases.push(`${extracted.name} (${relationshipType})`);\n  }\n\n  // Create new entity with embedding\n  let embeddingStr: string | null = null;\n  try {\n    const embedding = await generateEmbedding(extracted.name);\n    embeddingStr = `[${embedding.join(',')}]`;\n  } catch {\n    // Embedding optional - continue without it\n  }\n\n  const result = await pool.query(\n    `INSERT INTO entities (\n      name, canonical_name, entity_type, aliases, embedding,\n      extraction_method, confidence, attributes\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n    RETURNING *`,\n    [\n      extracted.name,\n      canonical,\n      extracted.type,\n      aliases,\n      embeddingStr,\n      extractionMethod,\n      extracted.confidence,\n      JSON.stringify(attributes),\n    ]\n  );\n\n  return result.rows[0] as Entity;\n}",
      "references": [
        "canonicalize",
        "pool",
        "canonical",
        "candidates",
        "extractionMethod",
        "disambiguateEntity",
        "extWithRel",
        "match",
        "updated",
        "console",
        "relationshipType",
        "attributes",
        "aliases",
        "generateEmbedding",
        "embeddingStr",
        "embedding",
        "JSON",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:createMention:834": {
      "id": "file:src/services/entities.ts:fn:createMention:834",
      "type": "function",
      "name": "createMention",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 834,
      "endLine": 869,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "extracted",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntity",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityMention>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates or retrieves an entity mention in the database by position.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createMention(\n  memoryId: string,\n  entityId: string,\n  extracted: ExtractedEntity\n): Promise<EntityMention> {\n  // Check if mention already exists at this position\n  const existing = await pool.query(\n    `SELECT * FROM entity_mentions\n     WHERE memory_id = $1 AND entity_id = $2 AND position_start = $3`,\n    [memoryId, entityId, extracted.positionStart]\n  );\n\n  if (existing.rows.length > 0) {\n    return existing.rows[0] as EntityMention;\n  }\n\n  const result = await pool.query(\n    `INSERT INTO entity_mentions (\n      memory_id, entity_id, mention_text, context_snippet,\n      position_start, position_end, extraction_method, confidence\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, 'regex', $7)\n    RETURNING *`,\n    [\n      memoryId,\n      entityId,\n      extracted.mentionText,\n      extracted.context,\n      extracted.positionStart,\n      extracted.positionEnd,\n      extracted.confidence,\n    ]\n  );\n\n  return result.rows[0] as EntityMention;\n}",
      "references": [
        "pool",
        "existing",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:createMentionWithRelationship:875": {
      "id": "file:src/services/entities.ts:fn:createMentionWithRelationship:875",
      "type": "function",
      "name": "createMentionWithRelationship",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 875,
      "endLine": 917,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "extracted",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractedEntityWithRelationship",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityMention>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates or returns existing entity mention with relationship in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createMentionWithRelationship(\n  memoryId: string,\n  entityId: string,\n  extracted: ExtractedEntityWithRelationship\n): Promise<EntityMention> {\n  const extractionMethod = extracted.extraction_method || 'regex';\n\n  // Check if mention already exists at this position\n  const existing = await pool.query(\n    `SELECT * FROM entity_mentions\n     WHERE memory_id = $1 AND entity_id = $2 AND position_start = $3`,\n    [memoryId, entityId, extracted.positionStart]\n  );\n\n  if (existing.rows.length > 0) {\n    return existing.rows[0] as EntityMention;\n  }\n\n  const result = await pool.query(\n    `INSERT INTO entity_mentions (\n      memory_id, entity_id, mention_text, context_snippet,\n      position_start, position_end,\n      relationship_type, relationship_direction,\n      extraction_method, confidence\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n    RETURNING *`,\n    [\n      memoryId,\n      entityId,\n      extracted.mentionText,\n      extracted.context,\n      extracted.positionStart,\n      extracted.positionEnd,\n      extracted.relationship_type || null,\n      extracted.relationship_direction || null,\n      extractionMethod,\n      extracted.confidence,\n    ]\n  );\n\n  return result.rows[0] as EntityMention;\n}",
      "references": [
        "pool",
        "existing",
        "extractionMethod",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:extractAndStoreEntities:923": {
      "id": "file:src/services/entities.ts:fn:extractAndStoreEntities:923",
      "type": "function",
      "name": "extractAndStoreEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 923,
      "endLine": 964,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ entities: import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]; mentions: import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityMention[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts entities from content via regex/LLM, validates, stores in DB with mentions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractAndStoreEntities(\n  memoryId: string,\n  content: string,\n  options: ExtractionOptions = {}\n): Promise<{ entities: Entity[]; mentions: EntityMention[] }> {\n  // Step 1: Regex extraction (fast, free)\n  const regexExtracted = extractEntities(content);\n\n  // Step 2: Conditionally invoke LLM\n  let llmExtracted: LLMExtractedEntity[] = [];\n  if (shouldInvokeLLM(content, regexExtracted, options)) {\n    try {\n      llmExtracted = await extractEntitiesWithLLM(content);\n      console.log(\n        `[EntityExtraction] LLM found ${llmExtracted.length} entities: ` +\n          llmExtracted.map((e) => `${e.name} (${e.type}${e.relationship ? `, ${e.relationship}` : ''})`).join(', ')\n      );\n    } catch (error) {\n      console.error('[EntityExtraction] LLM failed, using regex only:', error);\n    }\n  }\n\n  // Step 3: Merge results\n  const allExtracted = mergeExtractionResults(regexExtracted, llmExtracted, content);\n\n  const entities: Entity[] = [];\n  const mentions: EntityMention[] = [];\n\n  for (const ext of allExtracted) {\n    // Step 4: Validate/correct entity type based on name indicators\n    const validatedType = validateEntityType(ext.name, ext.type, ext.context || '');\n    ext.type = validatedType;\n\n    const entity = await getOrCreateEntity(ext);\n    entities.push(entity);\n\n    const mention = await createMentionWithRelationship(memoryId, entity.id, ext);\n    mentions.push(mention);\n  }\n\n  return { entities, mentions };\n}",
      "references": [
        "extractEntities",
        "shouldInvokeLLM",
        "regexExtracted",
        "llmExtracted",
        "extractEntitiesWithLLM",
        "console",
        "e",
        "error",
        "mergeExtractionResults",
        "allExtracted",
        "validateEntityType",
        "ext",
        "validatedType",
        "getOrCreateEntity",
        "entities",
        "entity",
        "createMentionWithRelationship",
        "mentions",
        "mention"
      ]
    },
    "file:src/services/entities.ts:fn:listEntities:980": {
      "id": "file:src/services/entities.ts:fn:listEntities:980",
      "type": "function",
      "name": "listEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 980,
      "endLine": 1010,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").ListEntitiesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for entities list with optional type, search, limit, and offset filters.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listEntities(\n  options: ListEntitiesOptions = {}\n): Promise<Entity[]> {\n  const { type, limit = 50, offset = 0, search } = options;\n\n  let query = `\n    SELECT * FROM entities\n    WHERE is_merged = FALSE\n  `;\n  const params: (string | number)[] = [];\n  let paramIndex = 1;\n\n  if (type) {\n    query += ` AND entity_type = $${paramIndex}`;\n    params.push(type);\n    paramIndex++;\n  }\n\n  if (search) {\n    query += ` AND (name ILIKE $${paramIndex} OR canonical_name ILIKE $${paramIndex})`;\n    params.push(`%${search}%`);\n    paramIndex++;\n  }\n\n  query += ` ORDER BY mention_count DESC, last_seen_at DESC`;\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as Entity[];\n}",
      "references": [
        "limit",
        "offset",
        "search",
        "query",
        "paramIndex",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:getEntity:1015": {
      "id": "file:src/services/entities.ts:fn:getEntity:1015",
      "type": "function",
      "name": "getEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1015,
      "endLine": 1021,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entity by ID from database excluding merged ones, returns first or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEntity(id: string): Promise<Entity | null> {\n  const result = await pool.query(\n    `SELECT * FROM entities WHERE id = $1 AND is_merged = FALSE`,\n    [id]\n  );\n  return (result.rows[0] as Entity) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:searchEntities:1026": {
      "id": "file:src/services/entities.ts:fn:searchEntities:1026",
      "type": "function",
      "name": "searchEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1026,
      "endLine": 1052,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "type",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityType",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches entities DB table by query on canonical_name, name, aliases; optional type; top 20 by mention_count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchEntities(\n  query: string,\n  type?: EntityType\n): Promise<Entity[]> {\n  const canonical = canonicalize(query);\n\n  let sql = `\n    SELECT * FROM entities\n    WHERE is_merged = FALSE\n      AND (\n        canonical_name ILIKE $1\n        OR name ILIKE $1\n        OR $2 = ANY(aliases)\n      )\n  `;\n  const params: (string | EntityType | undefined)[] = [`%${canonical}%`, query];\n\n  if (type) {\n    sql += ` AND entity_type = $3`;\n    params.push(type);\n  }\n\n  sql += ` ORDER BY mention_count DESC LIMIT 20`;\n\n  const result = await pool.query(sql, params);\n  return result.rows as Entity[];\n}",
      "references": [
        "canonicalize",
        "canonical",
        "sql",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:getEntityWithMemories:1081": {
      "id": "file:src/services/entities.ts:fn:getEntityWithMemories:1081",
      "type": "function",
      "name": "getEntityWithMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1081,
      "endLine": 1135,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityWithMemories>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entity with recent memories, connected entities, and primary relationship via DB queries",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEntityWithMemories(\n  entityId: string\n): Promise<EntityWithMemories | null> {\n  // Get the entity\n  const entity = await getEntity(entityId);\n  if (!entity) return null;\n\n  // Get all memories that mention this entity, including relationship_type\n  const memoriesResult = await pool.query(\n    `SELECT m.id, m.content, m.created_at, m.salience_score,\n            em.mention_text, em.relationship_type\n     FROM memories m\n     JOIN entity_mentions em ON em.memory_id = m.id\n     WHERE em.entity_id = $1\n     ORDER BY m.created_at DESC\n     LIMIT 50`,\n    [entityId]\n  );\n\n  // Get connected entities (entities that appear in the same memories)\n  const connectedResult = await pool.query(\n    `SELECT e.id, e.name, e.entity_type, e.mention_count,\n            COUNT(DISTINCT em2.memory_id) as shared_memory_count\n     FROM entity_mentions em1\n     JOIN entity_mentions em2 ON em1.memory_id = em2.memory_id\n     JOIN entities e ON em2.entity_id = e.id\n     WHERE em1.entity_id = $1\n       AND em2.entity_id != $1\n       AND e.is_merged = FALSE\n     GROUP BY e.id, e.name, e.entity_type, e.mention_count\n     ORDER BY shared_memory_count DESC, e.mention_count DESC\n     LIMIT 10`,\n    [entityId]\n  );\n\n  // Find primary relationship (most common relationship_type for this entity)\n  const relationshipResult = await pool.query(\n    `SELECT relationship_type, COUNT(*) as count\n     FROM entity_mentions\n     WHERE entity_id = $1 AND relationship_type IS NOT NULL\n     GROUP BY relationship_type\n     ORDER BY count DESC\n     LIMIT 1`,\n    [entityId]\n  );\n\n  const primaryRelationship = relationshipResult.rows[0]?.relationship_type || null;\n\n  return {\n    ...entity,\n    memories: memoriesResult.rows,\n    connected_entities: connectedResult.rows,\n    primary_relationship: primaryRelationship,\n  };\n}",
      "references": [
        "getEntity",
        "entity",
        "pool",
        "relationshipResult",
        "memoriesResult",
        "connectedResult",
        "primaryRelationship"
      ]
    },
    "file:src/services/entities.ts:fn:findEntityByName:1141": {
      "id": "file:src/services/entities.ts:fn:findEntityByName:1141",
      "type": "function",
      "name": "findEntityByName",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1141,
      "endLine": 1150,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "nameQuery",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityWithMemories>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches entities by name, returns first match with memories or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findEntityByName(\n  nameQuery: string\n): Promise<EntityWithMemories | null> {\n  const entities = await searchEntities(nameQuery);\n  const first = entities[0];\n  if (!first) return null;\n\n  // Return first match (highest mention count)\n  return getEntityWithMemories(first.id);\n}",
      "references": [
        "searchEntities",
        "entities",
        "first",
        "getEntityWithMemories"
      ]
    },
    "file:src/services/entities.ts:fn:getMemoryEntities:1155": {
      "id": "file:src/services/entities.ts:fn:getMemoryEntities:1155",
      "type": "function",
      "name": "getMemoryEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1155,
      "endLine": 1164,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves non-merged entities linked to a memory via entity mentions from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.027Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMemoryEntities(memoryId: string): Promise<Entity[]> {\n  const result = await pool.query(\n    `SELECT e.* FROM entities e\n     JOIN entity_mentions em ON em.entity_id = e.id\n     WHERE em.memory_id = $1 AND e.is_merged = FALSE\n     ORDER BY e.entity_type, e.name`,\n    [memoryId]\n  );\n  return result.rows as Entity[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/entities.ts:fn:countEntitiesByType:1169": {
      "id": "file:src/services/entities.ts:fn:countEntitiesByType:1169",
      "type": "function",
      "name": "countEntitiesByType",
      "filePath": "/home/ridgetop/projects/squire/src/services/entities.ts",
      "line": 1169,
      "endLine": 1190,
      "parentFileId": "file:src/services/entities.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<Record<import(\"/home/ridgetop/projects/squire/src/services/entities\").EntityType, number>>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Counts non-merged entities by entity_type from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.027Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function countEntitiesByType(): Promise<Record<EntityType, number>> {\n  const result = await pool.query(\n    `SELECT entity_type, COUNT(*) as count\n     FROM entities\n     WHERE is_merged = FALSE\n     GROUP BY entity_type`\n  );\n\n  const counts: Record<string, number> = {\n    person: 0,\n    project: 0,\n    concept: 0,\n    place: 0,\n    organization: 0,\n  };\n\n  for (const row of result.rows) {\n    counts[row.entity_type] = parseInt(row.count, 10);\n  }\n\n  return counts as Record<EntityType, number>;\n}",
      "references": [
        "pool",
        "result",
        "counts",
        "row",
        "parseInt"
      ]
    },
    "file:src/services/expressionFilter.ts": {
      "id": "file:src/services/expressionFilter.ts",
      "type": "file",
      "name": "expressionFilter.ts",
      "filePath": "src/services/expressionFilter.ts",
      "line": 1,
      "endLine": 375,
      "imports": [
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "filterMemoriesOptimized",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FilteredMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExpressionFilterResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryToFilter",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/expressionFilter.ts:fn:filterMemoriesForExpression:95",
        "file:src/services/expressionFilter.ts:fn:filterBatch:136",
        "file:src/services/expressionFilter.ts:fn:passAllMemories:245",
        "file:src/services/expressionFilter.ts:fn:shouldSkipFilter:264",
        "file:src/services/expressionFilter.ts:fn:shouldBlockWithoutFilter:288",
        "file:src/services/expressionFilter.ts:fn:filterMemoriesOptimized:311"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/expressionFilter.ts:fn:filterMemoriesForExpression:95": {
      "id": "file:src/services/expressionFilter.ts:fn:filterMemoriesForExpression:95",
      "type": "function",
      "name": "filterMemoriesForExpression",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 95,
      "endLine": 131,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").MemoryToFilter[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationContext",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").ExpressionFilterResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Filters memories in batches via filterBatch, aggregates passed/blocked results, logs stats",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.341Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function filterMemoriesForExpression(\n  memories: MemoryToFilter[],\n  conversationContext?: string\n): Promise<ExpressionFilterResult> {\n  const result: ExpressionFilterResult = {\n    filtered: [],\n    passedIds: [],\n    blockedIds: [],\n    blockedCount: 0,\n    passedCount: 0,\n  };\n\n  if (!memories || memories.length === 0) {\n    return result;\n  }\n\n  // Process in batches of BATCH_SIZE\n  const batches: MemoryToFilter[][] = [];\n  for (let i = 0; i < memories.length; i += BATCH_SIZE) {\n    batches.push(memories.slice(i, i + BATCH_SIZE));\n  }\n\n  for (const batch of batches) {\n    const batchResult = await filterBatch(batch, conversationContext);\n    result.filtered.push(...batchResult.filtered);\n    result.passedIds.push(...batchResult.passedIds);\n    result.blockedIds.push(...batchResult.blockedIds);\n    result.blockedCount += batchResult.blockedCount;\n    result.passedCount += batchResult.passedCount;\n  }\n\n  console.log(\n    `[ExpressionFilter] Processed ${memories.length} memories: ${result.passedCount} passed, ${result.blockedCount} blocked`\n  );\n\n  return result;\n}",
      "references": [
        "result",
        "i",
        "BATCH_SIZE",
        "batches",
        "filterBatch",
        "batch",
        "batchResult",
        "console"
      ]
    },
    "file:src/services/expressionFilter.ts:fn:filterBatch:136": {
      "id": "file:src/services/expressionFilter.ts:fn:filterBatch:136",
      "type": "function",
      "name": "filterBatch",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 136,
      "endLine": 240,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").MemoryToFilter[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationContext",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").ExpressionFilterResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Filters batch of memories using LLM API to categorize as passed or blocked.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.028Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function filterBatch(\n  memories: MemoryToFilter[],\n  conversationContext?: string\n): Promise<ExpressionFilterResult> {\n  const result: ExpressionFilterResult = {\n    filtered: [],\n    passedIds: [],\n    blockedIds: [],\n    blockedCount: 0,\n    passedCount: 0,\n  };\n\n  try {\n    // Build the prompt\n    const memoriesForPrompt = memories.map((m) => ({\n      id: m.id.substring(0, 8), // Shorten IDs for token efficiency\n      content: m.content,\n    }));\n\n    let userMessage = `Filter these memories:\\n${JSON.stringify(memoriesForPrompt, null, 2)}`;\n\n    if (conversationContext) {\n      userMessage += `\\n\\nCurrent conversation context:\\n${conversationContext.slice(0, 500)}`;\n    }\n\n    const messages: LLMMessage[] = [\n      { role: 'system', content: EXPRESSION_FILTER_PROMPT },\n      { role: 'user', content: userMessage },\n    ];\n\n    const response = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 1000,\n    });\n\n    const content = response.content?.trim();\n    if (!content) {\n      // On failure, pass all memories (fail-open for user experience)\n      console.warn('[ExpressionFilter] Empty LLM response, passing all memories');\n      return passAllMemories(memories);\n    }\n\n    // Parse JSON response\n    let jsonStr = content;\n    const jsonMatch = content.match(/\\[[\\s\\S]*\\]/);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n\n    const verdicts = JSON.parse(jsonStr) as Array<{\n      id: string;\n      passed: boolean;\n      reason?: string;\n    }>;\n\n    // Map verdicts back to full memory IDs\n    const verdictMap = new Map<string, { passed: boolean; reason?: string }>();\n    for (const v of verdicts) {\n      verdictMap.set(v.id, { passed: v.passed, reason: v.reason });\n    }\n\n    // Build result with full IDs\n    for (const mem of memories) {\n      const shortId = mem.id.substring(0, 8);\n      const verdict = verdictMap.get(shortId);\n\n      if (verdict) {\n        const filtered: FilteredMemory = {\n          id: mem.id,\n          content: mem.content,\n          passed: verdict.passed,\n          reason: verdict.reason,\n        };\n        result.filtered.push(filtered);\n\n        if (verdict.passed) {\n          result.passedIds.push(mem.id);\n          result.passedCount++;\n        } else {\n          result.blockedIds.push(mem.id);\n          result.blockedCount++;\n          console.log(\n            `[ExpressionFilter] BLOCKED ${shortId}: \"${mem.content.substring(0, 50)}...\" - ${verdict.reason}`\n          );\n        }\n      } else {\n        // No verdict for this memory - pass it (fail-open)\n        result.filtered.push({\n          id: mem.id,\n          content: mem.content,\n          passed: true,\n          reason: 'No verdict received',\n        });\n        result.passedIds.push(mem.id);\n        result.passedCount++;\n      }\n    }\n\n    return result;\n  } catch (error) {\n    console.error('[ExpressionFilter] Error filtering batch:', error);\n    // Fail-open: pass all memories if filter fails\n    return passAllMemories(memories);\n  }\n}",
      "references": [
        "m",
        "JSON",
        "memoriesForPrompt",
        "userMessage",
        "EXPRESSION_FILTER_PROMPT",
        "complete",
        "messages",
        "response",
        "content",
        "console",
        "passAllMemories",
        "jsonMatch",
        "jsonStr",
        "Map",
        "verdicts",
        "verdictMap",
        "v",
        "mem",
        "shortId",
        "verdict",
        "result",
        "filtered",
        "error"
      ]
    },
    "file:src/services/expressionFilter.ts:fn:passAllMemories:245": {
      "id": "file:src/services/expressionFilter.ts:fn:passAllMemories:245",
      "type": "function",
      "name": "passAllMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 245,
      "endLine": 258,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").MemoryToFilter[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").ExpressionFilterResult",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Bypasses all memory filters, marking every memory as passed with bypass reason.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.028Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function passAllMemories(memories: MemoryToFilter[]): ExpressionFilterResult {\n  return {\n    filtered: memories.map((m) => ({\n      id: m.id,\n      content: m.content,\n      passed: true,\n      reason: 'Filter bypassed',\n    })),\n    passedIds: memories.map((m) => m.id),\n    blockedIds: [],\n    blockedCount: 0,\n    passedCount: memories.length,\n  };\n}",
      "references": [
        "m"
      ]
    },
    "file:src/services/expressionFilter.ts:fn:shouldSkipFilter:264": {
      "id": "file:src/services/expressionFilter.ts:fn:shouldSkipFilter:264",
      "type": "function",
      "name": "shouldSkipFilter",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 264,
      "endLine": 282,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if content matches biographical patterns to skip filtering.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.141Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function shouldSkipFilter(content: string): boolean {\n  const lower = content.toLowerCase();\n\n  // Biographical facts - always safe\n  const biographicalPatterns = [\n    /\\buser'?s?\\s+name\\s+is\\b/i,\n    /\\buser\\s+is\\s+from\\b/i,\n    /\\buser'?s?\\s+(wife|husband|spouse|partner)\\s+is\\b/i,\n    /\\buser'?s?\\s+(son|daughter|child|kid)\\b/i,\n    /\\buser\\s+lives\\s+in\\b/i,\n    /\\buser\\s+was\\s+born\\b/i,\n  ];\n\n  if (biographicalPatterns.some((p) => p.test(lower))) {\n    return true; // Skip filter - definitely safe\n  }\n\n  return false;\n}",
      "references": [
        "biographicalPatterns",
        "p",
        "lower"
      ]
    },
    "file:src/services/expressionFilter.ts:fn:shouldBlockWithoutFilter:288": {
      "id": "file:src/services/expressionFilter.ts:fn:shouldBlockWithoutFilter:288",
      "type": "function",
      "name": "shouldBlockWithoutFilter",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 288,
      "endLine": 305,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if content matches Meta-AI debugging patterns to block without LLM filter.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.316Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function shouldBlockWithoutFilter(content: string): boolean {\n  const lower = content.toLowerCase();\n\n  // Meta-AI debugging patterns - always block\n  const metaAiPatterns = [\n    /\\b(fix|debug|implement|refactor)\\s+(the|this|a)\\s+(bug|error|issue|code)\\b/i,\n    /\\b(run|running)\\s+(the\\s+)?(tests?|build|compile)\\b/i,\n    /\\buser\\s+(needs?|wants?)\\s+to\\s+(fix|debug|implement|test)\\b/i,\n    /\\bworking\\s+on\\s+(fixing|debugging|implementing)\\b/i,\n    /\\b(typescript|javascript|react|sql)\\s+error\\b/i,\n  ];\n\n  if (metaAiPatterns.some((p) => p.test(lower))) {\n    return true; // Block without calling LLM\n  }\n\n  return false;\n}",
      "references": [
        "metaAiPatterns",
        "p",
        "lower"
      ]
    },
    "file:src/services/expressionFilter.ts:fn:filterMemoriesOptimized:311": {
      "id": "file:src/services/expressionFilter.ts:fn:filterMemoriesOptimized:311",
      "type": "function",
      "name": "filterMemoriesOptimized",
      "filePath": "/home/ridgetop/projects/squire/src/services/expressionFilter.ts",
      "line": 311,
      "endLine": 374,
      "parentFileId": "file:src/services/expressionFilter.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").MemoryToFilter[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationContext",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/expressionFilter\").ExpressionFilterResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Filters memories using heuristics and LLM, categorizing passed/blocked with stats.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function filterMemoriesOptimized(\n  memories: MemoryToFilter[],\n  conversationContext?: string\n): Promise<ExpressionFilterResult> {\n  const result: ExpressionFilterResult = {\n    filtered: [],\n    passedIds: [],\n    blockedIds: [],\n    blockedCount: 0,\n    passedCount: 0,\n  };\n\n  const needsLlmFilter: MemoryToFilter[] = [];\n\n  for (const mem of memories) {\n    // Check heuristic pass\n    if (shouldSkipFilter(mem.content)) {\n      result.filtered.push({\n        id: mem.id,\n        content: mem.content,\n        passed: true,\n        reason: 'Heuristic: biographical fact',\n      });\n      result.passedIds.push(mem.id);\n      result.passedCount++;\n      continue;\n    }\n\n    // Check heuristic block\n    if (shouldBlockWithoutFilter(mem.content)) {\n      result.filtered.push({\n        id: mem.id,\n        content: mem.content,\n        passed: false,\n        reason: 'Heuristic: meta-AI debugging',\n      });\n      result.blockedIds.push(mem.id);\n      result.blockedCount++;\n      console.log(\n        `[ExpressionFilter] HEURISTIC BLOCKED: \"${mem.content.substring(0, 50)}...\"`\n      );\n      continue;\n    }\n\n    // Needs LLM evaluation\n    needsLlmFilter.push(mem);\n  }\n\n  // Run LLM filter on remaining memories\n  if (needsLlmFilter.length > 0) {\n    const llmResult = await filterMemoriesForExpression(needsLlmFilter, conversationContext);\n    result.filtered.push(...llmResult.filtered);\n    result.passedIds.push(...llmResult.passedIds);\n    result.blockedIds.push(...llmResult.blockedIds);\n    result.blockedCount += llmResult.blockedCount;\n    result.passedCount += llmResult.passedCount;\n  }\n\n  console.log(\n    `[ExpressionFilter] Total: ${memories.length} memories, ${result.passedCount} passed, ${result.blockedCount} blocked`\n  );\n\n  return result;\n}",
      "references": [
        "shouldSkipFilter",
        "mem",
        "result",
        "shouldBlockWithoutFilter",
        "console",
        "needsLlmFilter",
        "filterMemoriesForExpression",
        "llmResult"
      ]
    },
    "file:src/services/graph.ts": {
      "id": "file:src/services/graph.ts",
      "type": "file",
      "name": "graph.ts",
      "filePath": "src/services/graph.ts",
      "line": 1,
      "endLine": 1059,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./entities.js",
          "items": [
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./edges.js",
          "items": [
            {
              "name": "EdgeType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "findEntityNeighbors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findSharedMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "traverseEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "traverseMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findPathBetweenEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findPathBetweenMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntitySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemorySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFullGraphVisualization",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getGraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NodeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GraphNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "Subgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PathSegment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityNeighbor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryNeighbor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VisualizationOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/graph.ts:fn:findEntityNeighbors:78",
        "file:src/services/graph.ts:fn:findSharedMemories:176",
        "file:src/services/graph.ts:fn:traverseEntities:206",
        "file:src/services/graph.ts:fn:traverseMemories:284",
        "file:src/services/graph.ts:fn:findPathBetweenEntities:366",
        "file:src/services/graph.ts:fn:findPathBetweenMemories:461",
        "file:src/services/graph.ts:fn:getEntitySubgraph:556",
        "file:src/services/graph.ts:fn:getMemorySubgraph:681",
        "file:src/services/graph.ts:fn:getFullGraphVisualization:821",
        "file:src/services/graph.ts:fn:getGraphStats:1003"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/graph.ts:fn:findEntityNeighbors:78": {
      "id": "file:src/services/graph.ts:fn:findEntityNeighbors:78",
      "type": "function",
      "name": "findEntityNeighbors",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 78,
      "endLine": 170,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSharedMemories?: number; entityType?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/graph\").EntityNeighbor[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for entities co-occurring with given entityId in shared memories, ranked by overlap.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findEntityNeighbors(\n  entityId: string,\n  options: {\n    limit?: number;\n    minSharedMemories?: number;\n    entityType?: string;\n  } = {}\n): Promise<EntityNeighbor[]> {\n  const { limit = 20, minSharedMemories = 1, entityType } = options;\n\n  let query = `\n    WITH entity_memories AS (\n      SELECT memory_id FROM entity_mentions WHERE entity_id = $1\n    ),\n    co_occurrences AS (\n      SELECT\n        e.id,\n        e.name,\n        e.canonical_name,\n        e.entity_type,\n        e.mention_count,\n        e.aliases,\n        e.description,\n        e.attributes,\n        e.first_seen_at,\n        e.last_seen_at,\n        e.extraction_method,\n        e.confidence,\n        e.is_merged,\n        e.merged_into_id,\n        e.created_at,\n        e.updated_at,\n        COUNT(DISTINCT em.memory_id) as shared_count,\n        ARRAY_AGG(DISTINCT em.memory_id) as shared_memory_ids\n      FROM entities e\n      JOIN entity_mentions em ON em.entity_id = e.id\n      WHERE em.memory_id IN (SELECT memory_id FROM entity_memories)\n        AND e.id != $1\n        AND e.is_merged = FALSE\n  `;\n\n  const params: (string | number)[] = [entityId];\n  let paramIndex = 2;\n\n  if (entityType) {\n    query += ` AND e.entity_type = $${paramIndex}`;\n    params.push(entityType);\n    paramIndex++;\n  }\n\n  query += `\n      GROUP BY e.id, e.name, e.canonical_name, e.entity_type, e.mention_count,\n               e.aliases, e.description, e.attributes, e.first_seen_at, e.last_seen_at,\n               e.extraction_method, e.confidence, e.is_merged, e.merged_into_id,\n               e.created_at, e.updated_at\n      HAVING COUNT(DISTINCT em.memory_id) >= $${paramIndex}\n    )\n    SELECT *,\n           shared_count::float / GREATEST(\n             (SELECT COUNT(*) FROM entity_memories), 1\n           ) as connection_strength\n    FROM co_occurrences\n    ORDER BY shared_count DESC, connection_strength DESC\n    LIMIT $${paramIndex + 1}\n  `;\n  params.push(minSharedMemories, limit);\n\n  const result = await pool.query(query, params);\n\n  return result.rows.map((row) => ({\n    entity: {\n      id: row.id,\n      name: row.name,\n      canonical_name: row.canonical_name,\n      entity_type: row.entity_type,\n      aliases: row.aliases || [],\n      description: row.description,\n      attributes: row.attributes || {},\n      first_seen_at: row.first_seen_at,\n      last_seen_at: row.last_seen_at,\n      mention_count: row.mention_count,\n      extraction_method: row.extraction_method,\n      confidence: row.confidence,\n      is_merged: row.is_merged,\n      merged_into_id: row.merged_into_id,\n      created_at: row.created_at,\n      updated_at: row.updated_at,\n    } as Entity,\n    sharedMemoryCount: parseInt(row.shared_count, 10),\n    connectionStrength: parseFloat(row.connection_strength),\n    sharedMemoryIds: row.shared_memory_ids,\n  }));\n}",
      "references": [
        "limit",
        "minSharedMemories",
        "entityType",
        "query",
        "paramIndex",
        "params",
        "pool",
        "result",
        "row",
        "parseInt",
        "parseFloat"
      ]
    },
    "file:src/services/graph.ts:fn:findSharedMemories:176": {
      "id": "file:src/services/graph.ts:fn:findSharedMemories:176",
      "type": "function",
      "name": "findSharedMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 176,
      "endLine": 194,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId1",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId2",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for shared memories between two entities, ordered by salience and time, limited.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findSharedMemories(\n  entityId1: string,\n  entityId2: string,\n  options: { limit?: number } = {}\n): Promise<Memory[]> {\n  const { limit = 20 } = options;\n\n  const result = await pool.query(\n    `SELECT DISTINCT m.*\n     FROM memories m\n     JOIN entity_mentions em1 ON em1.memory_id = m.id AND em1.entity_id = $1\n     JOIN entity_mentions em2 ON em2.memory_id = m.id AND em2.entity_id = $2\n     ORDER BY m.salience_score DESC, m.created_at DESC\n     LIMIT $3`,\n    [entityId1, entityId2, limit]\n  );\n\n  return result.rows as Memory[];\n}",
      "references": [
        "limit",
        "pool",
        "result"
      ]
    },
    "file:src/services/graph.ts:fn:traverseEntities:206": {
      "id": "file:src/services/graph.ts:fn:traverseEntities:206",
      "type": "function",
      "name": "traverseEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 206,
      "endLine": 278,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "startEntityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; limit?: number; minStrength?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ entity: import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity; hops: number; pathStrength: number; }[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Traverses entity graph from start ID via recursive SQL query, returns connected entities with hops and path strength",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function traverseEntities(\n  startEntityId: string,\n  options: {\n    maxHops?: number;\n    limit?: number;\n    minStrength?: number;\n  } = {}\n): Promise<Array<{ entity: Entity; hops: number; pathStrength: number }>> {\n  const { maxHops = 2, limit = 50, minStrength = 0.1 } = options;\n\n  const result = await pool.query(\n    `WITH RECURSIVE entity_graph AS (\n       -- Start with the seed entity\n       SELECT\n         $1::uuid as entity_id,\n         0 as hops,\n         1.0::float as path_strength,\n         ARRAY[$1::uuid] as path\n\n       UNION ALL\n\n       -- Find entities connected via shared memories\n       SELECT DISTINCT ON (e.id)\n         e.id as entity_id,\n         eg.hops + 1 as hops,\n         eg.path_strength * (\n           COUNT(*) OVER (PARTITION BY e.id)::float /\n           GREATEST((SELECT COUNT(*) FROM entity_mentions WHERE entity_id = eg.entity_id), 1)\n         ) as path_strength,\n         eg.path || e.id as path\n       FROM entity_graph eg\n       JOIN entity_mentions em1 ON em1.entity_id = eg.entity_id\n       JOIN entity_mentions em2 ON em2.memory_id = em1.memory_id AND em2.entity_id != eg.entity_id\n       JOIN entities e ON e.id = em2.entity_id AND e.is_merged = FALSE\n       WHERE eg.hops < $2\n         AND NOT (e.id = ANY(eg.path))  -- Avoid cycles\n     )\n     SELECT DISTINCT ON (eg.entity_id)\n       e.*,\n       eg.hops,\n       eg.path_strength\n     FROM entity_graph eg\n     JOIN entities e ON e.id = eg.entity_id\n     WHERE eg.entity_id != $1\n       AND eg.path_strength >= $3\n     ORDER BY eg.entity_id, eg.hops ASC, eg.path_strength DESC\n     LIMIT $4`,\n    [startEntityId, maxHops, minStrength, limit]\n  );\n\n  return result.rows.map((row) => ({\n    entity: {\n      id: row.id,\n      name: row.name,\n      canonical_name: row.canonical_name,\n      entity_type: row.entity_type,\n      aliases: row.aliases || [],\n      description: row.description,\n      attributes: row.attributes || {},\n      first_seen_at: row.first_seen_at,\n      last_seen_at: row.last_seen_at,\n      mention_count: row.mention_count,\n      extraction_method: row.extraction_method,\n      confidence: row.confidence,\n      is_merged: row.is_merged,\n      merged_into_id: row.merged_into_id,\n      created_at: row.created_at,\n      updated_at: row.updated_at,\n    } as Entity,\n    hops: row.hops,\n    pathStrength: row.path_strength,\n  }));\n}",
      "references": [
        "maxHops",
        "limit",
        "minStrength",
        "pool",
        "result",
        "row"
      ]
    },
    "file:src/services/graph.ts:fn:traverseMemories:284": {
      "id": "file:src/services/graph.ts:fn:traverseMemories:284",
      "type": "function",
      "name": "traverseMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 284,
      "endLine": 356,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "startMemoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; edgeTypes?: import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType[]; minWeight?: number; limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ memory: import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory; hops: number; pathWeight: number; }[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Traverses memory graph from start ID via recursive SQL, returns connected memories with hops and path weights",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function traverseMemories(\n  startMemoryId: string,\n  options: {\n    maxHops?: number;\n    edgeTypes?: EdgeType[];\n    minWeight?: number;\n    limit?: number;\n  } = {}\n): Promise<Array<{ memory: Memory; hops: number; pathWeight: number }>> {\n  const {\n    maxHops = 2,\n    edgeTypes = ['SIMILAR'],\n    minWeight = 0.3,\n    limit = 30,\n  } = options;\n\n  const edgeTypesArray = `ARRAY[${edgeTypes.map((t) => `'${t}'`).join(',')}]::varchar[]`;\n\n  const result = await pool.query(\n    `WITH RECURSIVE memory_graph AS (\n       -- Start with the seed memory\n       SELECT\n         $1::uuid as memory_id,\n         0 as hops,\n         1.0::float as path_weight,\n         ARRAY[$1::uuid] as path\n\n       UNION ALL\n\n       -- Find connected memories via edges\n       SELECT\n         CASE\n           WHEN e.source_memory_id = mg.memory_id THEN e.target_memory_id\n           ELSE e.source_memory_id\n         END as memory_id,\n         mg.hops + 1 as hops,\n         mg.path_weight * e.weight as path_weight,\n         mg.path || CASE\n           WHEN e.source_memory_id = mg.memory_id THEN e.target_memory_id\n           ELSE e.source_memory_id\n         END as path\n       FROM memory_graph mg\n       JOIN memory_edges e ON (\n         e.source_memory_id = mg.memory_id OR e.target_memory_id = mg.memory_id\n       )\n       WHERE mg.hops < $2\n         AND e.edge_type = ANY(${edgeTypesArray})\n         AND e.weight >= $3\n         AND NOT (\n           CASE\n             WHEN e.source_memory_id = mg.memory_id THEN e.target_memory_id\n             ELSE e.source_memory_id\n           END = ANY(mg.path)\n         )\n     )\n     SELECT DISTINCT ON (mg.memory_id)\n       m.*,\n       mg.hops,\n       mg.path_weight\n     FROM memory_graph mg\n     JOIN memories m ON m.id = mg.memory_id\n     WHERE mg.memory_id != $1\n     ORDER BY mg.memory_id, mg.hops ASC, mg.path_weight DESC\n     LIMIT $4`,\n    [startMemoryId, maxHops, minWeight, limit]\n  );\n\n  return result.rows.map((row) => ({\n    memory: row as Memory,\n    hops: row.hops,\n    pathWeight: row.path_weight,\n  }));\n}",
      "references": [
        "maxHops",
        "edgeTypes",
        "minWeight",
        "limit",
        "t",
        "pool",
        "edgeTypesArray",
        "result",
        "row"
      ]
    },
    "file:src/services/graph.ts:fn:findPathBetweenEntities:366": {
      "id": "file:src/services/graph.ts:fn:findPathBetweenEntities:366",
      "type": "function",
      "name": "findPathBetweenEntities",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 366,
      "endLine": 456,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "startEntityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "endEntityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ found: boolean; path: import(\"/home/ridgetop/projects/squire/src/services/entities\").Entity[]; connectingMemories: import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory[][]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Finds shortest path between two entities via shared memories using recursive SQL CTE",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.029Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findPathBetweenEntities(\n  startEntityId: string,\n  endEntityId: string,\n  options: { maxHops?: number } = {}\n): Promise<{\n  found: boolean;\n  path: Entity[];\n  connectingMemories: Memory[][];\n} | null> {\n  const { maxHops = 4 } = options;\n\n  const result = await pool.query(\n    `WITH RECURSIVE entity_path AS (\n       -- Start from source\n       SELECT\n         $1::uuid as current_id,\n         ARRAY[$1::uuid] as path,\n         ARRAY[]::uuid[] as memory_path,\n         0 as depth\n\n       UNION ALL\n\n       -- Expand to neighbors\n       SELECT DISTINCT ON (e.id)\n         e.id as current_id,\n         ep.path || e.id as path,\n         ep.memory_path || em1.memory_id as memory_path,\n         ep.depth + 1 as depth\n       FROM entity_path ep\n       JOIN entity_mentions em1 ON em1.entity_id = ep.current_id\n       JOIN entity_mentions em2 ON em2.memory_id = em1.memory_id AND em2.entity_id != ep.current_id\n       JOIN entities e ON e.id = em2.entity_id AND e.is_merged = FALSE\n       WHERE ep.depth < $3\n         AND NOT (e.id = ANY(ep.path))\n     )\n     SELECT path, memory_path\n     FROM entity_path\n     WHERE current_id = $2\n     ORDER BY depth ASC\n     LIMIT 1`,\n    [startEntityId, endEntityId, maxHops]\n  );\n\n  if (result.rows.length === 0) {\n    return { found: false, path: [], connectingMemories: [] };\n  }\n\n  const row = result.rows[0];\n  const pathIds: string[] = row.path;\n  const memoryPathIds: string[] = row.memory_path;\n\n  // Fetch full entity objects\n  const entitiesResult = await pool.query(\n    `SELECT * FROM entities WHERE id = ANY($1) AND is_merged = FALSE`,\n    [pathIds]\n  );\n\n  // Sort entities by path order\n  const entityMap = new Map<string, Entity>();\n  for (const e of entitiesResult.rows) {\n    entityMap.set(e.id, e as Entity);\n  }\n  const orderedEntities = pathIds\n    .map((id) => entityMap.get(id))\n    .filter((e): e is Entity => e !== undefined);\n\n  // Fetch connecting memories (grouped by hop)\n  const memoriesResult = await pool.query(\n    `SELECT * FROM memories WHERE id = ANY($1)`,\n    [memoryPathIds]\n  );\n  const memoryMap = new Map<string, Memory>();\n  for (const m of memoriesResult.rows) {\n    memoryMap.set(m.id, m as Memory);\n  }\n\n  // Group memories by hop\n  const connectingMemories: Memory[][] = [];\n  for (const memId of memoryPathIds) {\n    const mem = memoryMap.get(memId);\n    if (mem) {\n      connectingMemories.push([mem]);\n    }\n  }\n\n  return {\n    found: true,\n    path: orderedEntities,\n    connectingMemories,\n  };\n}",
      "references": [
        "maxHops",
        "pool",
        "result",
        "row",
        "pathIds",
        "Map",
        "entitiesResult",
        "entityMap",
        "e",
        "id",
        "memoryPathIds",
        "memoriesResult",
        "memoryMap",
        "m",
        "memId",
        "mem",
        "connectingMemories",
        "orderedEntities"
      ]
    },
    "file:src/services/graph.ts:fn:findPathBetweenMemories:461": {
      "id": "file:src/services/graph.ts:fn:findPathBetweenMemories:461",
      "type": "function",
      "name": "findPathBetweenMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 461,
      "endLine": 546,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "startMemoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "endMemoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; edgeTypes?: import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType[]; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ found: boolean; path: import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory[]; edges: { type: import(\"/home/ridgetop/projects/squire/src/services/edges\").EdgeType; weight: number; }[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Finds path between two memories using recursive SQL graph traversal query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findPathBetweenMemories(\n  startMemoryId: string,\n  endMemoryId: string,\n  options: {\n    maxHops?: number;\n    edgeTypes?: EdgeType[];\n  } = {}\n): Promise<{\n  found: boolean;\n  path: Memory[];\n  edges: Array<{ type: EdgeType; weight: number }>;\n} | null> {\n  const { maxHops = 5, edgeTypes = ['SIMILAR'] } = options;\n  const edgeTypesArray = `ARRAY[${edgeTypes.map((t) => `'${t}'`).join(',')}]::varchar[]`;\n\n  const result = await pool.query(\n    `WITH RECURSIVE memory_path AS (\n       SELECT\n         $1::uuid as current_id,\n         ARRAY[$1::uuid] as path,\n         ARRAY[]::jsonb as edge_info,\n         0 as depth\n\n       UNION ALL\n\n       SELECT\n         CASE\n           WHEN e.source_memory_id = mp.current_id THEN e.target_memory_id\n           ELSE e.source_memory_id\n         END as current_id,\n         mp.path || CASE\n           WHEN e.source_memory_id = mp.current_id THEN e.target_memory_id\n           ELSE e.source_memory_id\n         END as path,\n         mp.edge_info || jsonb_build_object('type', e.edge_type, 'weight', e.weight) as edge_info,\n         mp.depth + 1 as depth\n       FROM memory_path mp\n       JOIN memory_edges e ON (\n         e.source_memory_id = mp.current_id OR e.target_memory_id = mp.current_id\n       )\n       WHERE mp.depth < $3\n         AND e.edge_type = ANY(${edgeTypesArray})\n         AND NOT (\n           CASE\n             WHEN e.source_memory_id = mp.current_id THEN e.target_memory_id\n             ELSE e.source_memory_id\n           END = ANY(mp.path)\n         )\n     )\n     SELECT path, edge_info\n     FROM memory_path\n     WHERE current_id = $2\n     ORDER BY depth ASC\n     LIMIT 1`,\n    [startMemoryId, endMemoryId, maxHops]\n  );\n\n  if (result.rows.length === 0) {\n    return { found: false, path: [], edges: [] };\n  }\n\n  const row = result.rows[0];\n  const pathIds: string[] = row.path;\n  const edgeInfo: Array<{ type: EdgeType; weight: number }> = row.edge_info;\n\n  // Fetch full memory objects\n  const memoriesResult = await pool.query(\n    `SELECT * FROM memories WHERE id = ANY($1)`,\n    [pathIds]\n  );\n\n  const memoryMap = new Map<string, Memory>();\n  for (const m of memoriesResult.rows) {\n    memoryMap.set(m.id, m as Memory);\n  }\n\n  const orderedMemories = pathIds\n    .map((id) => memoryMap.get(id))\n    .filter((m): m is Memory => m !== undefined);\n\n  return {\n    found: true,\n    path: orderedMemories,\n    edges: edgeInfo,\n  };\n}",
      "references": [
        "maxHops",
        "edgeTypes",
        "t",
        "pool",
        "edgeTypesArray",
        "result",
        "row",
        "pathIds",
        "Map",
        "memoriesResult",
        "memoryMap",
        "m",
        "id",
        "orderedMemories",
        "edgeInfo"
      ]
    },
    "file:src/services/graph.ts:fn:getEntitySubgraph:556": {
      "id": "file:src/services/graph.ts:fn:getEntitySubgraph:556",
      "type": "function",
      "name": "getEntitySubgraph",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 556,
      "endLine": 675,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ memoryLimit?: number; entityLimit?: number; includeEdges?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/graph\").Subgraph>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches subgraph for entity: center entity, mentioning memories, neighbor entities",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEntitySubgraph(\n  entityId: string,\n  options: {\n    memoryLimit?: number;\n    entityLimit?: number;\n    includeEdges?: boolean;\n  } = {}\n): Promise<Subgraph> {\n  const { memoryLimit = 20, entityLimit = 10, includeEdges = true } = options;\n\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n\n  // Get the center entity\n  const entityResult = await pool.query(\n    `SELECT * FROM entities WHERE id = $1 AND is_merged = FALSE`,\n    [entityId]\n  );\n\n  if (entityResult.rows.length === 0) {\n    return { nodes: [], edges: [] };\n  }\n\n  const centerEntity = entityResult.rows[0] as Entity;\n  nodes.push({\n    id: centerEntity.id,\n    type: 'entity',\n    label: centerEntity.name,\n    attributes: {\n      entity_type: centerEntity.entity_type,\n      mention_count: centerEntity.mention_count,\n    },\n  });\n\n  // Get memories mentioning this entity\n  const memoriesResult = await pool.query(\n    `SELECT m.*, em.mention_text\n     FROM memories m\n     JOIN entity_mentions em ON em.memory_id = m.id\n     WHERE em.entity_id = $1\n     ORDER BY m.salience_score DESC\n     LIMIT $2`,\n    [entityId, memoryLimit]\n  );\n\n  for (const row of memoriesResult.rows) {\n    const memory = row as Memory & { mention_text: string };\n    nodes.push({\n      id: memory.id,\n      type: 'memory',\n      label: memory.content.slice(0, 50) + '...',\n      attributes: {\n        salience: memory.salience_score,\n        created_at: memory.created_at,\n      },\n    });\n\n    edges.push({\n      source: entityId,\n      target: memory.id,\n      type: 'MENTIONS',\n      weight: 1.0,\n      attributes: { mention_text: row.mention_text },\n    });\n  }\n\n  // Get connected entities\n  const neighbors = await findEntityNeighbors(entityId, { limit: entityLimit });\n\n  for (const neighbor of neighbors) {\n    nodes.push({\n      id: neighbor.entity.id,\n      type: 'entity',\n      label: neighbor.entity.name,\n      attributes: {\n        entity_type: neighbor.entity.entity_type,\n        shared_memories: neighbor.sharedMemoryCount,\n      },\n    });\n\n    edges.push({\n      source: entityId,\n      target: neighbor.entity.id,\n      type: 'CO_OCCURS',\n      weight: neighbor.connectionStrength,\n      attributes: { shared_memory_ids: neighbor.sharedMemoryIds },\n    });\n  }\n\n  // Optionally include memory edges\n  if (includeEdges) {\n    const memoryIds = memoriesResult.rows.map((r) => r.id);\n    if (memoryIds.length > 0) {\n      const edgesResult = await pool.query(\n        `SELECT * FROM memory_edges\n         WHERE source_memory_id = ANY($1) AND target_memory_id = ANY($1)`,\n        [memoryIds]\n      );\n\n      for (const edge of edgesResult.rows) {\n        edges.push({\n          source: edge.source_memory_id,\n          target: edge.target_memory_id,\n          type: edge.edge_type,\n          weight: edge.weight,\n          attributes: { similarity: edge.similarity },\n        });\n      }\n    }\n  }\n\n  // Filter edges to only include nodes that exist in the subgraph\n  // (prevents d3-force crash when edges reference missing nodes)\n  const nodeIds = new Set(nodes.map((n) => n.id));\n  const validEdges = edges.filter(\n    (e) => nodeIds.has(e.source) && nodeIds.has(e.target)\n  );\n\n  return { nodes, edges: validEdges };\n}",
      "references": [
        "memoryLimit",
        "entityLimit",
        "includeEdges",
        "pool",
        "entityResult",
        "nodes",
        "centerEntity",
        "memoriesResult",
        "row",
        "memory",
        "edges",
        "findEntityNeighbors",
        "neighbors",
        "neighbor",
        "r",
        "memoryIds",
        "edgesResult",
        "edge",
        "Set",
        "n",
        "nodeIds",
        "e",
        "validEdges"
      ]
    },
    "file:src/services/graph.ts:fn:getMemorySubgraph:681": {
      "id": "file:src/services/graph.ts:fn:getMemorySubgraph:681",
      "type": "function",
      "name": "getMemorySubgraph",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 681,
      "endLine": 802,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; includeEntities?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/graph\").Subgraph>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches subgraph of memories centered on memoryId with connected nodes/edges up to maxHops",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMemorySubgraph(\n  memoryId: string,\n  options: {\n    maxHops?: number;\n    includeEntities?: boolean;\n  } = {}\n): Promise<Subgraph> {\n  const { maxHops = 1, includeEntities = true } = options;\n\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n\n  // Get the center memory\n  const memoryResult = await pool.query(\n    `SELECT * FROM memories WHERE id = $1`,\n    [memoryId]\n  );\n\n  if (memoryResult.rows.length === 0) {\n    return { nodes: [], edges: [] };\n  }\n\n  const centerMemory = memoryResult.rows[0] as Memory;\n  nodes.push({\n    id: centerMemory.id,\n    type: 'memory',\n    label: centerMemory.content.slice(0, 50) + '...',\n    attributes: {\n      salience: centerMemory.salience_score,\n      created_at: centerMemory.created_at,\n      strength: centerMemory.current_strength,\n    },\n  });\n\n  // Get connected memories\n  const connected = await traverseMemories(memoryId, { maxHops, limit: 20 });\n\n  for (const conn of connected) {\n    nodes.push({\n      id: conn.memory.id,\n      type: 'memory',\n      label: conn.memory.content.slice(0, 50) + '...',\n      attributes: {\n        salience: conn.memory.salience_score,\n        hops: conn.hops,\n        path_weight: conn.pathWeight,\n      },\n    });\n  }\n\n  // Get edges between all these memories\n  const allMemoryIds = [memoryId, ...connected.map((c) => c.memory.id)];\n  const edgesResult = await pool.query(\n    `SELECT * FROM memory_edges\n     WHERE source_memory_id = ANY($1) OR target_memory_id = ANY($1)`,\n    [allMemoryIds]\n  );\n\n  const seenEdges = new Set<string>();\n  for (const edge of edgesResult.rows) {\n    const edgeKey = [edge.source_memory_id, edge.target_memory_id].sort().join('-');\n    if (seenEdges.has(edgeKey)) continue;\n    seenEdges.add(edgeKey);\n\n    // Only include if both ends are in our node set\n    if (\n      allMemoryIds.includes(edge.source_memory_id) &&\n      allMemoryIds.includes(edge.target_memory_id)\n    ) {\n      edges.push({\n        source: edge.source_memory_id,\n        target: edge.target_memory_id,\n        type: edge.edge_type,\n        weight: edge.weight,\n        attributes: { similarity: edge.similarity },\n      });\n    }\n  }\n\n  // Optionally include entities\n  if (includeEntities) {\n    const entitiesResult = await pool.query(\n      `SELECT DISTINCT e.*, em.memory_id\n       FROM entities e\n       JOIN entity_mentions em ON em.entity_id = e.id\n       WHERE em.memory_id = ANY($1) AND e.is_merged = FALSE`,\n      [allMemoryIds]\n    );\n\n    const entityMemoryMap = new Map<string, string[]>();\n    for (const row of entitiesResult.rows) {\n      if (!entityMemoryMap.has(row.id)) {\n        entityMemoryMap.set(row.id, []);\n        nodes.push({\n          id: row.id,\n          type: 'entity',\n          label: row.name,\n          attributes: {\n            entity_type: row.entity_type,\n            mention_count: row.mention_count,\n          },\n        });\n      }\n      entityMemoryMap.get(row.id)!.push(row.memory_id);\n    }\n\n    // Add MENTIONS edges\n    for (const [entityId, memIds] of entityMemoryMap) {\n      for (const memId of memIds) {\n        edges.push({\n          source: entityId,\n          target: memId,\n          type: 'MENTIONS',\n          weight: 1.0,\n          attributes: {},\n        });\n      }\n    }\n  }\n\n  return { nodes, edges };\n}",
      "references": [
        "maxHops",
        "includeEntities",
        "pool",
        "memoryResult",
        "nodes",
        "centerMemory",
        "traverseMemories",
        "connected",
        "conn",
        "c",
        "allMemoryIds",
        "Set",
        "edgesResult",
        "edge",
        "seenEdges",
        "edgeKey",
        "edges",
        "Map",
        "entitiesResult",
        "entityMemoryMap",
        "row",
        "entityId",
        "memIds",
        "memId"
      ]
    },
    "file:src/services/graph.ts:fn:getFullGraphVisualization:821": {
      "id": "file:src/services/graph.ts:fn:getFullGraphVisualization:821",
      "type": "function",
      "name": "getFullGraphVisualization",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 821,
      "endLine": 994,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/graph\").VisualizationOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/graph\").Subgraph>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for top entities and connected high-salience memories to build graph nodes.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getFullGraphVisualization(\n  options: VisualizationOptions = {}\n): Promise<Subgraph> {\n  const {\n    nodeLimit = 100,\n    entityLimit = 30,\n    memoryLimit = 70,\n    minSalience = 0,\n    entityTypes,\n    includeEdges = true,\n  } = options;\n\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const nodeIds = new Set<string>();\n\n  // 1. Get top entities by mention count\n  let entityQuery = `\n    SELECT * FROM entities\n    WHERE is_merged = FALSE\n  `;\n  const entityParams: (string | number | string[])[] = [];\n  let paramIndex = 1;\n\n  if (entityTypes && entityTypes.length > 0) {\n    entityQuery += ` AND entity_type = ANY($${paramIndex}::text[])`;\n    entityParams.push(entityTypes);\n    paramIndex++;\n  }\n\n  entityQuery += ` ORDER BY mention_count DESC LIMIT $${paramIndex}`;\n  entityParams.push(entityLimit);\n\n  const entitiesResult = await pool.query(entityQuery, entityParams);\n\n  for (const row of entitiesResult.rows) {\n    const entity = row as Entity;\n    nodes.push({\n      id: entity.id,\n      type: 'entity',\n      label: entity.name,\n      attributes: {\n        entity_type: entity.entity_type,\n        mention_count: entity.mention_count,\n      },\n    });\n    nodeIds.add(entity.id);\n  }\n\n  const entityIds = entitiesResult.rows.map((r) => r.id);\n\n  // 2. Get high-salience memories connected to these entities\n  if (entityIds.length > 0) {\n    const memoriesResult = await pool.query(\n      `SELECT DISTINCT m.*\n       FROM memories m\n       JOIN entity_mentions em ON em.memory_id = m.id\n       WHERE em.entity_id = ANY($1)\n         AND m.salience_score >= $2\n       ORDER BY m.salience_score DESC, m.created_at DESC\n       LIMIT $3`,\n      [entityIds, minSalience, memoryLimit]\n    );\n\n    for (const row of memoriesResult.rows) {\n      const memory = row as Memory;\n      nodes.push({\n        id: memory.id,\n        type: 'memory',\n        label: memory.content.slice(0, 50) + '...',\n        attributes: {\n          salience: memory.salience_score,\n          created_at: memory.created_at,\n        },\n      });\n      nodeIds.add(memory.id);\n    }\n\n    const memoryIds = memoriesResult.rows.map((r) => r.id);\n\n    // 3. Get entity-memory MENTIONS edges\n    if (memoryIds.length > 0) {\n      const mentionsResult = await pool.query(\n        `SELECT entity_id, memory_id, mention_text\n         FROM entity_mentions\n         WHERE entity_id = ANY($1) AND memory_id = ANY($2)`,\n        [entityIds, memoryIds]\n      );\n\n      for (const row of mentionsResult.rows) {\n        edges.push({\n          source: row.entity_id,\n          target: row.memory_id,\n          type: 'MENTIONS',\n          weight: 1.0,\n          attributes: { mention_text: row.mention_text },\n        });\n      }\n\n      // 4. Optionally get memory-memory edges (SIMILAR, etc.)\n      if (includeEdges && memoryIds.length > 1) {\n        const memoryEdgesResult = await pool.query(\n          `SELECT * FROM memory_edges\n           WHERE source_memory_id = ANY($1) AND target_memory_id = ANY($1)`,\n          [memoryIds]\n        );\n\n        for (const edge of memoryEdgesResult.rows) {\n          edges.push({\n            source: edge.source_memory_id,\n            target: edge.target_memory_id,\n            type: edge.edge_type,\n            weight: edge.weight,\n            attributes: { similarity: edge.similarity },\n          });\n        }\n      }\n    }\n\n    // 5. Add CO_OCCURS edges between entities that share ANY memory (not just visualized ones)\n    // Query database directly to find entity pairs that co-occur in the same memories\n    const visualizedEntityIds = nodes.filter((n) => n.type === 'entity').map((n) => n.id);\n\n    if (visualizedEntityIds.length > 1) {\n      const cooccursResult = await pool.query(\n        `SELECT\n           em1.entity_id as entity1,\n           em2.entity_id as entity2,\n           COUNT(DISTINCT em1.memory_id) as shared_count\n         FROM entity_mentions em1\n         JOIN entity_mentions em2 ON em1.memory_id = em2.memory_id\n         WHERE em1.entity_id = ANY($1)\n           AND em2.entity_id = ANY($1)\n           AND em1.entity_id < em2.entity_id\n         GROUP BY em1.entity_id, em2.entity_id\n         HAVING COUNT(DISTINCT em1.memory_id) > 0`,\n        [visualizedEntityIds]\n      );\n\n      for (const row of cooccursResult.rows) {\n        edges.push({\n          source: row.entity1,\n          target: row.entity2,\n          type: 'CO_OCCURS',\n          weight: Math.min(row.shared_count / 5, 1),\n          attributes: { shared_memory_count: parseInt(row.shared_count) },\n        });\n      }\n    }\n  }\n\n  // Limit total nodes if exceeded\n  if (nodes.length > nodeLimit) {\n    // Keep all entities, trim memories\n    const entityNodes = nodes.filter((n) => n.type === 'entity');\n    const memoryNodes = nodes.filter((n) => n.type === 'memory');\n    const keptMemories = memoryNodes.slice(0, nodeLimit - entityNodes.length);\n\n    // Filter edges to only include kept nodes\n    const keptNodeIds = new Set([\n      ...entityNodes.map((n) => n.id),\n      ...keptMemories.map((n) => n.id),\n    ]);\n\n    return {\n      nodes: [...entityNodes, ...keptMemories],\n      edges: edges.filter(\n        (e) => keptNodeIds.has(e.source) && keptNodeIds.has(e.target)\n      ),\n    };\n  }\n\n  return { nodes, edges };\n}",
      "references": [
        "nodeLimit",
        "entityLimit",
        "memoryLimit",
        "minSalience",
        "entityTypes",
        "includeEdges",
        "Set",
        "entityQuery",
        "paramIndex",
        "entityParams",
        "pool",
        "entitiesResult",
        "row",
        "nodes",
        "entity",
        "nodeIds",
        "r",
        "entityIds",
        "memoriesResult",
        "memory",
        "memoryIds",
        "mentionsResult",
        "edges",
        "memoryEdgesResult",
        "edge",
        "n",
        "visualizedEntityIds",
        "cooccursResult",
        "Math",
        "parseInt",
        "memoryNodes",
        "entityNodes",
        "keptMemories",
        "keptNodeIds",
        "e"
      ]
    },
    "file:src/services/graph.ts:fn:getGraphStats:1003": {
      "id": "file:src/services/graph.ts:fn:getGraphStats:1003",
      "type": "function",
      "name": "getGraphStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/graph.ts",
      "line": 1003,
      "endLine": 1058,
      "parentFileId": "file:src/services/graph.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ nodeCount: { memories: number; entities: number; }; edgeCount: { memoryEdges: number; mentions: number; }; averageDegree: { memories: number; entities: number; }; components: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for graph stats: counts nodes/edges, avg degrees, components for memories/entities.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getGraphStats(): Promise<{\n  nodeCount: { memories: number; entities: number };\n  edgeCount: { memoryEdges: number; mentions: number };\n  averageDegree: { memories: number; entities: number };\n  components: number;\n}> {\n  const stats = await pool.query(`\n    SELECT\n      (SELECT COUNT(*) FROM memories) as memory_count,\n      (SELECT COUNT(*) FROM entities WHERE is_merged = FALSE) as entity_count,\n      (SELECT COUNT(*) FROM memory_edges) as edge_count,\n      (SELECT COUNT(*) FROM entity_mentions) as mention_count\n  `);\n\n  const row = stats.rows[0];\n  const memoryCount = parseInt(row.memory_count, 10);\n  const entityCount = parseInt(row.entity_count, 10);\n  const edgeCount = parseInt(row.edge_count, 10);\n  const mentionCount = parseInt(row.mention_count, 10);\n\n  // Calculate average degrees\n  const avgMemoryDegree = memoryCount > 0 ? (edgeCount * 2) / memoryCount : 0;\n  const avgEntityDegree = entityCount > 0 ? mentionCount / entityCount : 0;\n\n  // Count weakly connected components (simplified - just count isolated memories)\n  const isolatedResult = await pool.query(`\n    SELECT COUNT(*) as isolated\n    FROM memories m\n    WHERE NOT EXISTS (\n      SELECT 1 FROM memory_edges e\n      WHERE e.source_memory_id = m.id OR e.target_memory_id = m.id\n    )\n    AND NOT EXISTS (\n      SELECT 1 FROM entity_mentions em WHERE em.memory_id = m.id\n    )\n  `);\n\n  const isolated = parseInt(isolatedResult.rows[0].isolated, 10);\n  const connected = memoryCount - isolated;\n\n  return {\n    nodeCount: {\n      memories: memoryCount,\n      entities: entityCount,\n    },\n    edgeCount: {\n      memoryEdges: edgeCount,\n      mentions: mentionCount,\n    },\n    averageDegree: {\n      memories: Math.round(avgMemoryDegree * 100) / 100,\n      entities: Math.round(avgEntityDegree * 100) / 100,\n    },\n    components: connected > 0 ? 1 + isolated : isolated,  // Simplified\n  };\n}",
      "references": [
        "pool",
        "stats",
        "parseInt",
        "row",
        "memoryCount",
        "edgeCount",
        "entityCount",
        "mentionCount",
        "isolatedResult",
        "isolated",
        "Math",
        "avgMemoryDegree",
        "avgEntityDegree",
        "connected"
      ]
    },
    "file:src/services/identity.ts": {
      "id": "file:src/services/identity.ts",
      "type": "file",
      "name": "identity.ts",
      "filePath": "src/services/identity.ts",
      "line": 1,
      "endLine": 229,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getUserIdentity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "setInitialIdentity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "renameUser",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unlockIdentity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "lockIdentity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "migrateFromPersonalitySummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UserIdentity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "IdentitySource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "PreviousName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/identity.ts:fn:getUserIdentity:45",
        "file:src/services/identity.ts:fn:setInitialIdentity:74",
        "file:src/services/identity.ts:fn:renameUser:112",
        "file:src/services/identity.ts:fn:unlockIdentity:157",
        "file:src/services/identity.ts:fn:lockIdentity:168",
        "file:src/services/identity.ts:fn:migrateFromPersonalitySummary:180"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/identity.ts:fn:getUserIdentity:45": {
      "id": "file:src/services/identity.ts:fn:getUserIdentity:45",
      "type": "function",
      "name": "getUserIdentity",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 45,
      "endLine": 67,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/identity\").UserIdentity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves the first user identity from the database or null if none exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getUserIdentity(): Promise<UserIdentity | null> {\n  const result = await pool.query(`\n    SELECT id, name, is_locked, locked_at, source, created_at, updated_at, previous_names\n    FROM user_identity\n    LIMIT 1\n  `);\n\n  if (result.rows.length === 0) {\n    return null;\n  }\n\n  const row = result.rows[0];\n  return {\n    id: row.id,\n    name: row.name,\n    is_locked: row.is_locked,\n    locked_at: new Date(row.locked_at),\n    source: row.source as IdentitySource,\n    created_at: new Date(row.created_at),\n    updated_at: new Date(row.updated_at),\n    previous_names: row.previous_names || [],\n  };\n}",
      "references": [
        "pool",
        "result",
        "row",
        "Date"
      ]
    },
    "file:src/services/identity.ts:fn:setInitialIdentity:74": {
      "id": "file:src/services/identity.ts:fn:setInitialIdentity:74",
      "type": "function",
      "name": "setInitialIdentity",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 74,
      "endLine": 106,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "source",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/identity\").IdentitySource",
          "isOptional": true,
          "defaultValue": "'auto_detection'"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/identity\").UserIdentity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sets initial user identity in DB if none exists, locks it, and returns the identity.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function setInitialIdentity(\n  name: string,\n  source: IdentitySource = 'auto_detection'\n): Promise<UserIdentity> {\n  // Check if identity already exists\n  const existing = await getUserIdentity();\n  if (existing) {\n    throw new Error(\n      `Identity already established as \"${existing.name}\". Use renameUser() to change.`\n    );\n  }\n\n  const result = await pool.query(\n    `INSERT INTO user_identity (name, source, is_locked, locked_at)\n     VALUES ($1, $2, TRUE, NOW())\n     RETURNING id, name, is_locked, locked_at, source, created_at, updated_at, previous_names`,\n    [name.trim(), source]\n  );\n\n  const row = result.rows[0];\n  console.log(`[Identity] Initial identity set: \"${name}\" (source: ${source})`);\n\n  return {\n    id: row.id,\n    name: row.name,\n    is_locked: row.is_locked,\n    locked_at: new Date(row.locked_at),\n    source: row.source as IdentitySource,\n    created_at: new Date(row.created_at),\n    updated_at: new Date(row.updated_at),\n    previous_names: row.previous_names || [],\n  };\n}",
      "references": [
        "getUserIdentity",
        "existing",
        "Error",
        "pool",
        "result",
        "console",
        "row",
        "Date"
      ]
    },
    "file:src/services/identity.ts:fn:renameUser:112": {
      "id": "file:src/services/identity.ts:fn:renameUser:112",
      "type": "function",
      "name": "renameUser",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 112,
      "endLine": 151,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "newName",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "reason",
          "type": "string",
          "isOptional": true,
          "defaultValue": "'User requested rename'"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/identity\").UserIdentity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Renames user identity in DB, logs change, appends previous name to history",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function renameUser(\n  newName: string,\n  reason: string = 'User requested rename'\n): Promise<UserIdentity> {\n  const existing = await getUserIdentity();\n  if (!existing) {\n    // No existing identity - just set initial\n    return setInitialIdentity(newName, 'rename_command');\n  }\n\n  const previousEntry: PreviousName = {\n    name: existing.name,\n    changed_at: new Date().toISOString(),\n    reason,\n  };\n\n  const result = await pool.query(\n    `UPDATE user_identity\n     SET name = $1,\n         source = 'rename_command',\n         updated_at = NOW(),\n         previous_names = previous_names || $2::jsonb\n     RETURNING id, name, is_locked, locked_at, source, created_at, updated_at, previous_names`,\n    [newName.trim(), JSON.stringify(previousEntry)]\n  );\n\n  const row = result.rows[0];\n  console.log(`[Identity] User renamed: \"${existing.name}\" -> \"${newName}\" (reason: ${reason})`);\n\n  return {\n    id: row.id,\n    name: row.name,\n    is_locked: row.is_locked,\n    locked_at: new Date(row.locked_at),\n    source: row.source as IdentitySource,\n    created_at: new Date(row.created_at),\n    updated_at: new Date(row.updated_at),\n    previous_names: row.previous_names || [],\n  };\n}",
      "references": [
        "getUserIdentity",
        "existing",
        "setInitialIdentity",
        "Date",
        "pool",
        "JSON",
        "previousEntry",
        "result",
        "console",
        "row"
      ]
    },
    "file:src/services/identity.ts:fn:unlockIdentity:157": {
      "id": "file:src/services/identity.ts:fn:unlockIdentity:157",
      "type": "function",
      "name": "unlockIdentity",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 157,
      "endLine": 163,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unlocks user identity by updating is_locked to FALSE and updated_at to NOW() in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.030Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unlockIdentity(): Promise<void> {\n  await pool.query(`\n    UPDATE user_identity\n    SET is_locked = FALSE, updated_at = NOW()\n  `);\n  console.log('[Identity] Identity unlocked - detection will run again');\n}",
      "references": [
        "pool",
        "console"
      ]
    },
    "file:src/services/identity.ts:fn:lockIdentity:168": {
      "id": "file:src/services/identity.ts:fn:lockIdentity:168",
      "type": "function",
      "name": "lockIdentity",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 168,
      "endLine": 174,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Locks user identity by updating is_locked to TRUE and timestamps in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.031Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function lockIdentity(): Promise<void> {\n  await pool.query(`\n    UPDATE user_identity\n    SET is_locked = TRUE, locked_at = NOW(), updated_at = NOW()\n  `);\n  console.log('[Identity] Identity locked');\n}",
      "references": [
        "pool",
        "console"
      ]
    },
    "file:src/services/identity.ts:fn:migrateFromPersonalitySummary:180": {
      "id": "file:src/services/identity.ts:fn:migrateFromPersonalitySummary:180",
      "type": "function",
      "name": "migrateFromPersonalitySummary",
      "filePath": "/home/ridgetop/projects/squire/src/services/identity.ts",
      "line": 180,
      "endLine": 228,
      "parentFileId": "file:src/services/identity.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/identity\").UserIdentity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Migrates user identity name from DB personality summary if none exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function migrateFromPersonalitySummary(): Promise<UserIdentity | null> {\n  // Check if identity already exists\n  const existing = await getUserIdentity();\n  if (existing) {\n    console.log(`[Identity] Identity already set: \"${existing.name}\" - skipping migration`);\n    return existing;\n  }\n\n  // Get personality summary\n  const result = await pool.query(`\n    SELECT content FROM living_summaries WHERE category = 'personality' LIMIT 1\n  `);\n\n  if (result.rows.length === 0) {\n    console.log('[Identity] No personality summary found - skipping migration');\n    return null;\n  }\n\n  const content = result.rows[0].content as string;\n\n  // Try to extract name from various patterns\n  const patterns = [\n    /Your name is (\\w+)/i,\n    /You're (\\w+),/i,\n    /You are (\\w+),/i,\n    /You're (\\w+)\\./i,\n    /You are (\\w+)\\./i,\n    /(\\w+) is your name/i,\n  ];\n\n  for (const pattern of patterns) {\n    const match = content.match(pattern);\n    if (match && match[1]) {\n      const name = match[1];\n      // Validate it looks like a name (not a common word)\n      const invalidNames = new Set([\n        'the', 'a', 'an', 'your', 'my', 'their', 'his', 'her', 'its',\n        'this', 'that', 'here', 'there', 'now', 'then',\n      ]);\n      if (!invalidNames.has(name.toLowerCase())) {\n        console.log(`[Identity] Migrating name from personality summary: \"${name}\"`);\n        return setInitialIdentity(name, 'import');\n      }\n    }\n  }\n\n  console.log('[Identity] Could not extract name from personality summary');\n  return null;\n}",
      "references": [
        "getUserIdentity",
        "existing",
        "console",
        "pool",
        "result",
        "patterns",
        "content",
        "pattern",
        "match",
        "Set",
        "invalidNames",
        "name",
        "setInitialIdentity"
      ]
    },
    "file:src/services/import.ts": {
      "id": "file:src/services/import.ts",
      "type": "file",
      "name": "import.ts",
      "filePath": "src/services/import.ts",
      "line": 1,
      "endLine": 286,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./salience.js",
          "items": [
            {
              "name": "calculateSalience",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./entities.js",
          "items": [
            {
              "name": "extractAndStoreEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "parseImportFile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "importMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getImportStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ImportMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ImportResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ImportOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/import.ts:fn:isDuplicate:43",
        "file:src/services/import.ts:fn:importSingleMemory:71",
        "file:src/services/import.ts:fn:parseImportFile:152",
        "file:src/services/import.ts:fn:importMemories:190",
        "file:src/services/import.ts:fn:getImportStats:248"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/import.ts:fn:isDuplicate:43": {
      "id": "file:src/services/import.ts:fn:isDuplicate:43",
      "type": "function",
      "name": "isDuplicate",
      "filePath": "/home/ridgetop/projects/squire/src/services/import.ts",
      "line": 43,
      "endLine": 66,
      "parentFileId": "file:src/services/import.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks if content exactly matches or has >95% embedding similarity to existing memories.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function isDuplicate(content: string): Promise<boolean> {\n  // Check for exact match first\n  const exactResult = await pool.query(\n    `SELECT id FROM memories WHERE content = $1 LIMIT 1`,\n    [content]\n  );\n  if (exactResult.rows.length > 0) {\n    return true;\n  }\n\n  // Check for high similarity match (>95%)\n  const embedding = await generateEmbedding(content);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const similarResult = await pool.query(\n    `SELECT id FROM memories\n     WHERE embedding IS NOT NULL\n       AND 1 - (embedding <=> $1::vector) > 0.95\n     LIMIT 1`,\n    [embeddingStr]\n  );\n\n  return similarResult.rows.length > 0;\n}",
      "references": [
        "pool",
        "exactResult",
        "generateEmbedding",
        "embedding",
        "embeddingStr",
        "similarResult"
      ]
    },
    "file:src/services/import.ts:fn:importSingleMemory:71": {
      "id": "file:src/services/import.ts:fn:importSingleMemory:71",
      "type": "function",
      "name": "importSingleMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/import.ts",
      "line": 71,
      "endLine": 147,
      "parentFileId": "file:src/services/import.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/import\").ImportMemory",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/import\").ImportOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ memory: import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory; entityCount: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Imports a single memory to DB after duplicate check, embedding generation, and entity extraction",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function importSingleMemory(\n  input: ImportMemory,\n  options: ImportOptions\n): Promise<{ memory: Memory; entityCount: number } | null> {\n  const {\n    content,\n    occurred_at,\n    source = 'import',\n    tags = [],\n    metadata = {},\n  } = input;\n\n  // Check for duplicates\n  if (!options.allowDuplicates) {\n    const duplicate = await isDuplicate(content);\n    if (duplicate) {\n      return null;\n    }\n  }\n\n  // Generate embedding\n  const embedding = await generateEmbedding(content);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  // Calculate salience\n  const salience = calculateSalience(content);\n\n  // Parse occurred_at if provided\n  const occurredAt = occurred_at ? new Date(occurred_at) : null;\n\n  // Build source metadata with tags\n  const sourceMetadata = {\n    ...metadata,\n    import_tags: tags,\n    imported_at: new Date().toISOString(),\n  };\n\n  // First, store raw observation\n  const rawObsResult = await pool.query(\n    `INSERT INTO raw_observations (content, content_type, source, source_metadata, occurred_at)\n     VALUES ($1, 'text', $2, $3, $4)\n     RETURNING id`,\n    [content, source, JSON.stringify(sourceMetadata), occurredAt]\n  );\n  const rawObservationId = rawObsResult.rows[0]?.id as string;\n\n  // Create the memory\n  const result = await pool.query(\n    `INSERT INTO memories (\n      raw_observation_id, content, content_type, source, source_metadata,\n      embedding, salience_score, salience_factors, occurred_at, processing_status, processed_at\n    )\n     VALUES ($1, $2, 'text', $3, $4, $5, $6, $7, $8, 'processed', NOW())\n     RETURNING *`,\n    [\n      rawObservationId,\n      content,\n      source,\n      JSON.stringify(sourceMetadata),\n      embeddingStr,\n      salience.score,\n      JSON.stringify(salience.factors),\n      occurredAt,\n    ]\n  );\n\n  const memory = result.rows[0] as Memory;\n\n  // Extract entities if not skipped\n  let entityCount = 0;\n  if (!options.skipEntities) {\n    const extraction = await extractAndStoreEntities(memory.id, content);\n    entityCount = extraction.entities.length;\n  }\n\n  return { memory, entityCount };\n}",
      "references": [
        "content",
        "occurred_at",
        "source",
        "tags",
        "metadata",
        "isDuplicate",
        "duplicate",
        "generateEmbedding",
        "embedding",
        "calculateSalience",
        "Date",
        "pool",
        "JSON",
        "sourceMetadata",
        "occurredAt",
        "rawObsResult",
        "rawObservationId",
        "embeddingStr",
        "salience",
        "result",
        "extractAndStoreEntities",
        "memory",
        "entityCount",
        "extraction"
      ]
    },
    "file:src/services/import.ts:fn:parseImportFile:152": {
      "id": "file:src/services/import.ts:fn:parseImportFile:152",
      "type": "function",
      "name": "parseImportFile",
      "filePath": "/home/ridgetop/projects/squire/src/services/import.ts",
      "line": 152,
      "endLine": 185,
      "parentFileId": "file:src/services/import.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/import\").ImportMemory[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses string content as JSON array or JSONL into ImportMemory array",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function parseImportFile(content: string): ImportMemory[] {\n  const trimmed = content.trim();\n\n  // Try parsing as JSON array first\n  if (trimmed.startsWith('[')) {\n    try {\n      return JSON.parse(trimmed) as ImportMemory[];\n    } catch {\n      // Fall through to JSONL\n    }\n  }\n\n  // Parse as JSONL (one JSON object per line)\n  const memories: ImportMemory[] = [];\n  const lines = trimmed.split('\\n');\n\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine || trimmedLine.startsWith('//') || trimmedLine.startsWith('#')) {\n      continue; // Skip empty lines and comments\n    }\n\n    try {\n      const parsed = JSON.parse(trimmedLine) as ImportMemory;\n      if (parsed.content) {\n        memories.push(parsed);\n      }\n    } catch {\n      // Skip malformed lines\n    }\n  }\n\n  return memories;\n}",
      "references": [
        "trimmed",
        "JSON",
        "lines",
        "line",
        "trimmedLine",
        "parsed",
        "memories"
      ]
    },
    "file:src/services/import.ts:fn:importMemories:190": {
      "id": "file:src/services/import.ts:fn:importMemories:190",
      "type": "function",
      "name": "importMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/import.ts",
      "line": 190,
      "endLine": 243,
      "parentFileId": "file:src/services/import.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/import\").ImportMemory[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/import\").ImportOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/import\").ImportResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Imports array of memories, skips short/duplicates, tracks progress/errors via callback.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function importMemories(\n  memories: ImportMemory[],\n  options: ImportOptions = {}\n): Promise<ImportResult> {\n  const { minLength = 10, onProgress } = options;\n\n  const result: ImportResult = {\n    total: memories.length,\n    imported: 0,\n    skipped: 0,\n    errors: 0,\n    memories: [],\n    errorDetails: [],\n  };\n\n  for (const [i, memory] of memories.entries()) {\n    // Progress callback\n    if (onProgress) {\n      const preview = memory.content.length > 50\n        ? memory.content.substring(0, 50) + '...'\n        : memory.content;\n      onProgress(i + 1, memories.length, preview);\n    }\n\n    // Skip if too short\n    if (memory.content.length < minLength) {\n      result.skipped++;\n      continue;\n    }\n\n    try {\n      const imported = await importSingleMemory(memory, options);\n\n      if (imported) {\n        result.imported++;\n        result.memories.push({\n          id: imported.memory.id,\n          content: memory.content.substring(0, 100),\n          salience: imported.memory.salience_score,\n          entities: imported.entityCount,\n        });\n      } else {\n        result.skipped++; // Duplicate\n      }\n    } catch (error) {\n      result.errors++;\n      result.errorDetails.push(\n        `Error importing \"${memory.content.substring(0, 50)}...\": ${error}`\n      );\n    }\n  }\n\n  return result;\n}",
      "references": [
        "minLength",
        "onProgress",
        "i",
        "memory",
        "preview",
        "result",
        "importSingleMemory",
        "imported",
        "error"
      ]
    },
    "file:src/services/import.ts:fn:getImportStats:248": {
      "id": "file:src/services/import.ts:fn:getImportStats:248",
      "type": "function",
      "name": "getImportStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/import.ts",
      "line": 248,
      "endLine": 285,
      "parentFileId": "file:src/services/import.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ totalImported: number; bySources: Record<string, number>; dateRange: { oldest: Date; newest: Date; }; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves import stats: total memories by source (excl. cli/api) and date range from DB.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.032Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getImportStats(): Promise<{\n  totalImported: number;\n  bySources: Record<string, number>;\n  dateRange: { oldest: Date | null; newest: Date | null };\n}> {\n  const countResult = await pool.query(`\n    SELECT source, COUNT(*) as count\n    FROM memories\n    WHERE source NOT IN ('cli', 'api')\n    GROUP BY source\n  `);\n\n  const bySources: Record<string, number> = {};\n  let totalImported = 0;\n  for (const row of countResult.rows) {\n    bySources[row.source] = parseInt(row.count, 10);\n    totalImported += parseInt(row.count, 10);\n  }\n\n  const dateResult = await pool.query(`\n    SELECT\n      MIN(occurred_at) as oldest,\n      MAX(occurred_at) as newest\n    FROM memories\n    WHERE occurred_at IS NOT NULL\n  `);\n\n  const dates = dateResult.rows[0];\n\n  return {\n    totalImported,\n    bySources,\n    dateRange: {\n      oldest: dates.oldest ? new Date(dates.oldest) : null,\n      newest: dates.newest ? new Date(dates.newest) : null,\n    },\n  };\n}",
      "references": [
        "pool",
        "countResult",
        "bySources",
        "row",
        "parseInt",
        "totalImported",
        "dateResult",
        "dates",
        "Date"
      ]
    },
    "file:src/services/insights.ts": {
      "id": "file:src/services/insights.ts",
      "type": "file",
      "name": "insights.ts",
      "filePath": "src/services/insights.ts",
      "line": 1,
      "endLine": 761,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "completeText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../api/socket/broadcast.js",
          "items": [
            {
              "name": "broadcastInsightCreated",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "generateInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findSimilarInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightsByType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "validateInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "dismissInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "actionInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markStaleInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightSources",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightsBySource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isValidInsightType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightTypeDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getInsightTypeEmoji",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPriorityEmoji",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "processInsightsForConsolidation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "INSIGHT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "InsightType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "INSIGHT_PRIORITIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "InsightPriority",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "INSIGHT_STATUSES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "InsightStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "SOURCE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "SourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Insight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightGenerationResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/insights.ts:fn:generateInsights:85",
        "file:src/services/insights.ts:fn:findSimilarInsight:231",
        "file:src/services/insights.ts:fn:createInsight:259",
        "file:src/services/insights.ts:fn:getInsight:287",
        "file:src/services/insights.ts:fn:getAllInsights:298",
        "file:src/services/insights.ts:fn:getInsightsByType:364",
        "file:src/services/insights.ts:fn:validateInsight:371",
        "file:src/services/insights.ts:fn:dismissInsight:391",
        "file:src/services/insights.ts:fn:actionInsight:414",
        "file:src/services/insights.ts:fn:markStaleInsights:434",
        "file:src/services/insights.ts:fn:linkSource:452",
        "file:src/services/insights.ts:fn:getInsightSources:477",
        "file:src/services/insights.ts:fn:getInsightsBySource:510",
        "file:src/services/insights.ts:fn:getInsightStats:530",
        "file:src/services/insights.ts:fn:isValidInsightType:599",
        "file:src/services/insights.ts:fn:getInsightTypeDescription:606",
        "file:src/services/insights.ts:fn:getInsightTypeEmoji:619",
        "file:src/services/insights.ts:fn:getPriorityEmoji:632",
        "file:src/services/insights.ts:fn:processInsightsForConsolidation:654"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/insights.ts:fn:generateInsights:85": {
      "id": "file:src/services/insights.ts:fn:generateInsights:85",
      "type": "function",
      "name": "generateInsights",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 85,
      "endLine": 224,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "context",
          "type": "AnalysisContext",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").ExtractedInsight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates AI insights from beliefs/patterns/memories using a structured prompt (code truncated)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateInsights(\n  context: AnalysisContext\n): Promise<ExtractedInsight[]> {\n  if (context.beliefs.length === 0 && context.patterns.length === 0) {\n    return [];\n  }\n\n  const systemPrompt = `You are an insight generator. Given a person's beliefs, patterns, and recent memories, identify higher-level insights.\n\nAn insight is NOT just restating a belief or pattern - it's a NEW observation from CONNECTING different pieces of information.\n\nInsight types:\n- connection: Links between related concepts (\"Your productivity pattern aligns with your belief about morning work\")\n- contradiction: Inconsistencies between what someone believes vs does (\"You value balance but patterns show 60+ hour weeks\")\n- opportunity: Potential improvements based on the data (\"Your high-energy mornings could be better used for creative work\")\n- warning: Potential issues or risks to flag (\"Stress patterns correlating with project deadlines suggest overcommitment\")\n\nPriority levels: low, medium, high, critical\n\nRequirements:\n1. Each insight MUST reference at least 2 sources (beliefs, patterns, or memories)\n2. Only generate insights with confidence >= 0.5\n3. Focus on actionable or meaningful observations\n4. Avoid obvious or trivial connections\n\nReturn ONLY a JSON array. If no meaningful insights, return: []\n\nFormat: [{\n  \"content\": \"insight statement\",\n  \"insight_type\": \"connection|contradiction|opportunity|warning\",\n  \"priority\": \"low|medium|high|critical\",\n  \"confidence\": 0.X,\n  \"sources\": [\n    {\"type\": \"belief|pattern|memory\", \"id\": \"uuid\", \"contribution\": \"primary|supports|context|contrasts\", \"explanation\": \"how this source relates\"}\n  ],\n  \"reason\": \"why this insight matters\"\n}]`;\n\n  // Build context string\n  const beliefsStr = context.beliefs.length > 0\n    ? `BELIEFS:\\n${context.beliefs.map((b) => `- [${b.id}] (${b.type}, conf: ${b.confidence.toFixed(2)}): \"${b.content}\"`).join('\\n')}`\n    : 'BELIEFS: None recorded yet';\n\n  const patternsStr = context.patterns.length > 0\n    ? `PATTERNS:\\n${context.patterns.map((p) => `- [${p.id}] (${p.type}, conf: ${p.confidence.toFixed(2)}, freq: ${p.frequency.toFixed(2)}): \"${p.content}\"`).join('\\n')}`\n    : 'PATTERNS: None detected yet';\n\n  const memoriesStr = context.recentMemories.length > 0\n    ? `RECENT MEMORIES:\\n${context.recentMemories.slice(0, 10).map((m) => `- [${m.id}]: \"${m.content.slice(0, 200)}...\"`).join('\\n')}`\n    : 'RECENT MEMORIES: None';\n\n  const prompt = `Analyze this person's data and generate insights:\n\n${beliefsStr}\n\n${patternsStr}\n\n${memoriesStr}\n\nWhat connections, contradictions, opportunities, or warnings do you see? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.3,\n      maxTokens: 2000,\n    });\n\n    // Parse JSON response - find the JSON array by matching balanced brackets\n    let jsonStr: string | null = null;\n    const startIdx = response.indexOf('[');\n    if (startIdx === -1) {\n      return [];\n    }\n\n    // Find matching closing bracket\n    let depth = 0;\n    let endIdx = -1;\n    for (let i = startIdx; i < response.length; i++) {\n      if (response[i] === '[') depth++;\n      if (response[i] === ']') depth--;\n      if (depth === 0) {\n        endIdx = i;\n        break;\n      }\n    }\n\n    if (endIdx === -1) {\n      return [];\n    }\n\n    jsonStr = response.substring(startIdx, endIdx + 1);\n\n    const extracted = JSON.parse(jsonStr) as Array<{\n      content: string;\n      insight_type: string;\n      priority: string;\n      confidence: number;\n      sources: Array<{\n        type: string;\n        id: string;\n        contribution: string;\n        explanation?: string;\n      }>;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    const filtered = extracted\n      .filter(\n        (i) =>\n          INSIGHT_TYPES.includes(i.insight_type as InsightType) &&\n          INSIGHT_PRIORITIES.includes(i.priority as InsightPriority) &&\n          i.content &&\n          i.confidence >= 0.5 &&\n          Array.isArray(i.sources)  // Just require sources array exists (can be empty)\n      )\n      .map((i) => ({\n        content: i.content,\n        insight_type: i.insight_type as InsightType,\n        priority: i.priority as InsightPriority,\n        confidence: Math.min(1.0, Math.max(0.0, i.confidence)),\n        sources: i.sources\n          .filter((s) => SOURCE_TYPES.includes(s.type as SourceType))\n          .map((s) => ({\n            type: s.type as SourceType,\n            id: s.id,\n            contribution: (['supports', 'primary', 'context', 'contrasts'].includes(s.contribution)\n              ? s.contribution\n              : 'supports') as 'supports' | 'primary' | 'context' | 'contrasts',\n            explanation: s.explanation,\n          })),\n        reason: i.reason || '',\n      }));\n\n    return filtered;\n  } catch (error) {\n    console.error('Insight generation failed:', error);\n    return [];\n  }\n}",
      "references": [
        "b",
        "p",
        "m",
        "beliefsStr",
        "patternsStr",
        "memoriesStr",
        "completeText",
        "prompt",
        "systemPrompt",
        "response",
        "startIdx",
        "i",
        "depth",
        "endIdx",
        "jsonStr",
        "JSON",
        "extracted",
        "INSIGHT_TYPES",
        "INSIGHT_PRIORITIES",
        "Array",
        "Math",
        "SOURCE_TYPES",
        "s",
        "filtered",
        "console",
        "error"
      ]
    },
    "file:src/services/insights.ts:fn:findSimilarInsight:231": {
      "id": "file:src/services/insights.ts:fn:findSimilarInsight:231",
      "type": "function",
      "name": "findSimilarInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 231,
      "endLine": 252,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "insightType",
          "type": "\"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for active insight matching type and normalized content.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findSimilarInsight(\n  content: string,\n  insightType: InsightType\n): Promise<Insight | null> {\n  const normalized = content.toLowerCase().trim();\n\n  const result = await pool.query<Insight>(\n    `SELECT * FROM insights\n     WHERE insight_type = $1\n       AND status = 'active'\n       AND LOWER(content) = $2\n     LIMIT 1`,\n    [insightType, normalized]\n  );\n\n  if (result.rows[0]) {\n    return result.rows[0];\n  }\n\n  // TODO: Add embedding-based similarity search\n  return null;\n}",
      "references": [
        "pool",
        "normalized",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:createInsight:259": {
      "id": "file:src/services/insights.ts:fn:createInsight:259",
      "type": "function",
      "name": "createInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 259,
      "endLine": 282,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "insightType",
          "type": "\"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "confidence",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\" | \"critical\"",
          "isOptional": true,
          "defaultValue": "'medium'"
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts new insight into DB and broadcasts to WebSocket clients",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createInsight(\n  content: string,\n  insightType: InsightType,\n  confidence: number,\n  priority: InsightPriority = 'medium',\n  model?: string\n): Promise<Insight> {\n  const result = await pool.query<Insight>(\n    `INSERT INTO insights (\n       content, insight_type, confidence, priority,\n       generated_by_model, generation_prompt_version\n     )\n     VALUES ($1, $2, $3, $4, $5, 'v1')\n     RETURNING *`,\n    [content, insightType, confidence, priority, model || null]\n  );\n\n  const insight = result.rows[0]!;\n\n  // Broadcast to connected WebSocket clients (P6-T5)\n  broadcastInsightCreated(insight);\n\n  return insight;\n}",
      "references": [
        "pool",
        "result",
        "broadcastInsightCreated",
        "insight"
      ]
    },
    "file:src/services/insights.ts:fn:getInsight:287": {
      "id": "file:src/services/insights.ts:fn:getInsight:287",
      "type": "function",
      "name": "getInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 287,
      "endLine": 293,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves an insight by ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getInsight(id: string): Promise<Insight | null> {\n  const result = await pool.query<Insight>(\n    `SELECT * FROM insights WHERE id = $1`,\n    [id]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:getAllInsights:298": {
      "id": "file:src/services/insights.ts:fn:getAllInsights:298",
      "type": "function",
      "name": "getAllInsights",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 298,
      "endLine": 359,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ type?: \"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"; status?: \"dismissed\" | \"active\" | \"actioned\" | \"stale\"; priority?: \"low\" | \"medium\" | \"high\" | \"critical\"; minConfidence?: number; limit?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves insights from DB with optional filters on type, status, priority, min confidence, and limit",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllInsights(options?: {\n  type?: InsightType;\n  status?: InsightStatus;\n  priority?: InsightPriority;\n  minConfidence?: number;\n  limit?: number;\n}): Promise<Insight[]> {\n  const conditions: string[] = [];\n  const params: (string | number)[] = [];\n  let paramCount = 0;\n\n  if (options?.type) {\n    paramCount++;\n    conditions.push(`insight_type = $${paramCount}`);\n    params.push(options.type);\n  }\n\n  if (options?.status) {\n    paramCount++;\n    conditions.push(`status = $${paramCount}`);\n    params.push(options.status);\n  } else {\n    conditions.push(`status = 'active'`);\n  }\n\n  if (options?.priority) {\n    paramCount++;\n    conditions.push(`priority = $${paramCount}`);\n    params.push(options.priority);\n  }\n\n  if (options?.minConfidence) {\n    paramCount++;\n    conditions.push(`confidence >= $${paramCount}`);\n    params.push(options.minConfidence);\n  }\n\n  const whereClause = conditions.length > 0\n    ? `WHERE ${conditions.join(' AND ')}`\n    : '';\n\n  const limit = options?.limit || 100;\n  paramCount++;\n  params.push(limit);\n\n  const result = await pool.query<Insight>(\n    `SELECT * FROM insights\n     ${whereClause}\n     ORDER BY\n       CASE priority\n         WHEN 'critical' THEN 1\n         WHEN 'high' THEN 2\n         WHEN 'medium' THEN 3\n         WHEN 'low' THEN 4\n       END,\n       confidence DESC,\n       created_at DESC\n     LIMIT $${paramCount}`,\n    params\n  );\n  return result.rows;\n}",
      "references": [
        "paramCount",
        "conditions",
        "params",
        "limit",
        "pool",
        "whereClause",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightsByType:364": {
      "id": "file:src/services/insights.ts:fn:getInsightsByType:364",
      "type": "function",
      "name": "getInsightsByType",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 364,
      "endLine": 366,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves insights filtered by a specific type using getAllInsights",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getInsightsByType(type: InsightType): Promise<Insight[]> {\n  return getAllInsights({ type });\n}",
      "references": [
        "getAllInsights"
      ]
    },
    "file:src/services/insights.ts:fn:validateInsight:371": {
      "id": "file:src/services/insights.ts:fn:validateInsight:371",
      "type": "function",
      "name": "validateInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 371,
      "endLine": 386,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insightId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates validation count and timestamps for insight by ID and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function validateInsight(insightId: string): Promise<Insight> {\n  const result = await pool.query<Insight>(\n    `UPDATE insights\n     SET validation_count = validation_count + 1,\n         last_validated_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [insightId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Insight not found: ${insightId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/insights.ts:fn:dismissInsight:391": {
      "id": "file:src/services/insights.ts:fn:dismissInsight:391",
      "type": "function",
      "name": "dismissInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 391,
      "endLine": 409,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insightId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "reason",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates insight to dismissed status with optional reason and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function dismissInsight(\n  insightId: string,\n  reason?: string\n): Promise<Insight> {\n  const result = await pool.query<Insight>(\n    `UPDATE insights\n     SET status = 'dismissed',\n         dismissed_reason = $2,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [insightId, reason || null]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Insight not found: ${insightId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/insights.ts:fn:actionInsight:414": {
      "id": "file:src/services/insights.ts:fn:actionInsight:414",
      "type": "function",
      "name": "actionInsight",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 414,
      "endLine": 429,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insightId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates insight status to 'actioned' with timestamps and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function actionInsight(insightId: string): Promise<Insight> {\n  const result = await pool.query<Insight>(\n    `UPDATE insights\n     SET status = 'actioned',\n         actioned_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [insightId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Insight not found: ${insightId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/insights.ts:fn:markStaleInsights:434": {
      "id": "file:src/services/insights.ts:fn:markStaleInsights:434",
      "type": "function",
      "name": "markStaleInsights",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 434,
      "endLine": 445,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "daysThreshold",
          "type": "number",
          "isOptional": true,
          "defaultValue": "30"
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Marks active insights older than daysThreshold as stale and returns updated count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markStaleInsights(daysThreshold: number = 30): Promise<number> {\n  const result = await pool.query(\n    `UPDATE insights\n     SET status = 'stale',\n         updated_at = NOW()\n     WHERE status = 'active'\n       AND last_validated_at < NOW() - INTERVAL '1 day' * $1\n     RETURNING id`,\n    [daysThreshold]\n  );\n  return result.rowCount || 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:linkSource:452": {
      "id": "file:src/services/insights.ts:fn:linkSource:452",
      "type": "function",
      "name": "linkSource",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 452,
      "endLine": 472,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insightId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceType",
          "type": "\"memory\" | \"belief\" | \"pattern\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "contributionType",
          "type": "\"supports\" | \"primary\" | \"context\" | \"contrasts\"",
          "isOptional": true,
          "defaultValue": "'supports'"
        },
        {
          "name": "contributionStrength",
          "type": "number",
          "isOptional": true,
          "defaultValue": "0.5"
        },
        {
          "name": "explanation",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").InsightSource>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts or updates insight source link in database with conflict handling",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkSource(\n  insightId: string,\n  sourceType: SourceType,\n  sourceId: string,\n  contributionType: 'supports' | 'primary' | 'context' | 'contrasts' = 'supports',\n  contributionStrength: number = 0.5,\n  explanation?: string\n): Promise<InsightSource> {\n  const result = await pool.query<InsightSource>(\n    `INSERT INTO insight_sources (\n       insight_id, source_type, source_id,\n       contribution_type, contribution_strength, explanation\n     )\n     VALUES ($1, $2, $3, $4, $5, $6)\n     ON CONFLICT (insight_id, source_type, source_id)\n     DO UPDATE SET contribution_type = $4, contribution_strength = $5, explanation = $6\n     RETURNING *`,\n    [insightId, sourceType, sourceId, contributionType, contributionStrength, explanation || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightSources:477": {
      "id": "file:src/services/insights.ts:fn:getInsightSources:477",
      "type": "function",
      "name": "getInsightSources",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 477,
      "endLine": 505,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insightId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/insights\").InsightSource & { source_content?: string; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insight sources with polymorphic content from DB for given insight ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getInsightSources(\n  insightId: string\n): Promise<Array<InsightSource & { source_content?: string }>> {\n  // Get sources with their content (polymorphic join)\n  const result = await pool.query<InsightSource & { source_content: string }>(\n    `SELECT\n       s.*,\n       CASE s.source_type\n         WHEN 'memory' THEN m.content\n         WHEN 'belief' THEN b.content\n         WHEN 'pattern' THEN p.content\n       END as source_content\n     FROM insight_sources s\n     LEFT JOIN memories m ON s.source_type = 'memory' AND s.source_id = m.id\n     LEFT JOIN beliefs b ON s.source_type = 'belief' AND s.source_id = b.id\n     LEFT JOIN patterns p ON s.source_type = 'pattern' AND s.source_id = p.id\n     WHERE s.insight_id = $1\n     ORDER BY\n       CASE s.contribution_type\n         WHEN 'primary' THEN 1\n         WHEN 'supports' THEN 2\n         WHEN 'context' THEN 3\n         WHEN 'contrasts' THEN 4\n       END,\n       s.contribution_strength DESC`,\n    [insightId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightsBySource:510": {
      "id": "file:src/services/insights.ts:fn:getInsightsBySource:510",
      "type": "function",
      "name": "getInsightsBySource",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 510,
      "endLine": 523,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "sourceType",
          "type": "\"memory\" | \"belief\" | \"pattern\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active insights for given source type and ID from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getInsightsBySource(\n  sourceType: SourceType,\n  sourceId: string\n): Promise<Insight[]> {\n  const result = await pool.query<Insight>(\n    `SELECT i.*\n     FROM insights i\n     JOIN insight_sources s ON s.insight_id = i.id\n     WHERE s.source_type = $1 AND s.source_id = $2 AND i.status = 'active'\n     ORDER BY i.priority DESC, i.confidence DESC`,\n    [sourceType, sourceId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightStats:530": {
      "id": "file:src/services/insights.ts:fn:getInsightStats:530",
      "type": "function",
      "name": "getInsightStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 530,
      "endLine": 592,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; dismissed: number; actioned: number; stale: number; byType: Record<string, number>; byPriority: Record<string, number>; avgConfidence: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insight stats: counts by status/type/priority and avg confidence from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getInsightStats(): Promise<{\n  total: number;\n  active: number;\n  dismissed: number;\n  actioned: number;\n  stale: number;\n  byType: Record<string, number>;\n  byPriority: Record<string, number>;\n  avgConfidence: number;\n}> {\n  const result = await pool.query<{\n    total: string;\n    active: string;\n    dismissed: string;\n    actioned: string;\n    stale: string;\n    avg_confidence: string;\n  }>(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE status = 'active') as active,\n      COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed,\n      COUNT(*) FILTER (WHERE status = 'actioned') as actioned,\n      COUNT(*) FILTER (WHERE status = 'stale') as stale,\n      AVG(confidence) as avg_confidence\n    FROM insights\n  `);\n\n  const byTypeResult = await pool.query<{ insight_type: string; count: string }>(`\n    SELECT insight_type, COUNT(*) as count\n    FROM insights\n    WHERE status = 'active'\n    GROUP BY insight_type\n  `);\n\n  const byPriorityResult = await pool.query<{ priority: string; count: string }>(`\n    SELECT priority, COUNT(*) as count\n    FROM insights\n    WHERE status = 'active'\n    GROUP BY priority\n  `);\n\n  const row = result.rows[0]!;\n  const byType: Record<string, number> = {};\n  for (const r of byTypeResult.rows) {\n    byType[r.insight_type] = parseInt(r.count, 10);\n  }\n  const byPriority: Record<string, number> = {};\n  for (const r of byPriorityResult.rows) {\n    byPriority[r.priority] = parseInt(r.count, 10);\n  }\n\n  return {\n    total: parseInt(row.total, 10),\n    active: parseInt(row.active, 10),\n    dismissed: parseInt(row.dismissed, 10),\n    actioned: parseInt(row.actioned, 10),\n    stale: parseInt(row.stale, 10),\n    byType,\n    byPriority,\n    avgConfidence: parseFloat(row.avg_confidence) || 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "byTypeResult",
        "byType",
        "r",
        "parseInt",
        "byPriorityResult",
        "byPriority",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/insights.ts:fn:isValidInsightType:599": {
      "id": "file:src/services/insights.ts:fn:isValidInsightType:599",
      "type": "function",
      "name": "isValidInsightType",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 599,
      "endLine": 601,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Validates if a string is a valid InsightType by checking INSIGHT_TYPES array.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.033Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isValidInsightType(type: string): type is InsightType {\n  return INSIGHT_TYPES.includes(type as InsightType);\n}",
      "references": [
        "INSIGHT_TYPES"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightTypeDescription:606": {
      "id": "file:src/services/insights.ts:fn:getInsightTypeDescription:606",
      "type": "function",
      "name": "getInsightTypeDescription",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 606,
      "endLine": 614,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a description string for a given InsightType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getInsightTypeDescription(type: InsightType): string {\n  const descriptions: Record<InsightType, string> = {\n    connection: 'Links between related concepts',\n    contradiction: 'Inconsistencies in beliefs vs behaviors',\n    opportunity: 'Potential improvements',\n    warning: 'Potential issues or risks',\n  };\n  return descriptions[type];\n}",
      "references": [
        "descriptions"
      ]
    },
    "file:src/services/insights.ts:fn:getInsightTypeEmoji:619": {
      "id": "file:src/services/insights.ts:fn:getInsightTypeEmoji:619",
      "type": "function",
      "name": "getInsightTypeEmoji",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 619,
      "endLine": 627,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"connection\" | \"contradiction\" | \"opportunity\" | \"warning\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji string for the given InsightType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getInsightTypeEmoji(type: InsightType): string {\n  const emojis: Record<InsightType, string> = {\n    connection: '\\u{1F517}',    // link\n    contradiction: '\\u{26A0}',  // warning sign\n    opportunity: '\\u{1F4A1}',   // light bulb\n    warning: '\\u{1F6A8}',       // rotating light\n  };\n  return emojis[type];\n}",
      "references": [
        "emojis"
      ]
    },
    "file:src/services/insights.ts:fn:getPriorityEmoji:632": {
      "id": "file:src/services/insights.ts:fn:getPriorityEmoji:632",
      "type": "function",
      "name": "getPriorityEmoji",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 632,
      "endLine": 640,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\" | \"critical\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji string based on the given InsightPriority.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getPriorityEmoji(priority: InsightPriority): string {\n  const emojis: Record<InsightPriority, string> = {\n    low: '\\u{25CB}',       // white circle\n    medium: '\\u{25D0}',    // half circle\n    high: '\\u{25CF}',      // black circle\n    critical: '\\u{1F534}', // red circle\n  };\n  return emojis[priority];\n}",
      "references": [
        "emojis"
      ]
    },
    "file:src/services/insights.ts:fn:processInsightsForConsolidation:654": {
      "id": "file:src/services/insights.ts:fn:processInsightsForConsolidation:654",
      "type": "function",
      "name": "processInsightsForConsolidation",
      "filePath": "/home/ridgetop/projects/squire/src/services/insights.ts",
      "line": 654,
      "endLine": 760,
      "parentFileId": "file:src/services/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/insights\").InsightGenerationResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for beliefs/patterns/memories, generates insights, creates new or validates existing ones",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processInsightsForConsolidation(\n  model?: string\n): Promise<InsightGenerationResult> {\n  const result: InsightGenerationResult = {\n    created: [],\n    validated: [],\n    staleMarked: 0,\n  };\n\n  // Gather analysis context\n  const beliefsResult = await pool.query<{\n    id: string;\n    content: string;\n    belief_type: string;\n    confidence: number;\n  }>(\n    `SELECT id, content, belief_type, confidence\n     FROM beliefs\n     WHERE status = 'active'\n     ORDER BY confidence DESC\n     LIMIT 20`\n  );\n\n  const patternsResult = await pool.query<{\n    id: string;\n    content: string;\n    pattern_type: string;\n    confidence: number;\n    frequency: number;\n  }>(\n    `SELECT id, content, pattern_type, confidence, frequency\n     FROM patterns\n     WHERE status = 'active'\n     ORDER BY confidence DESC\n     LIMIT 20`\n  );\n\n  const memoriesResult = await pool.query<{\n    id: string;\n    content: string;\n    created_at: Date;\n  }>(\n    `SELECT id, content, created_at\n     FROM memories\n     ORDER BY created_at DESC\n     LIMIT 15`\n  );\n\n  const context: AnalysisContext = {\n    beliefs: beliefsResult.rows.map((b) => ({\n      id: b.id,\n      content: b.content,\n      type: b.belief_type,\n      confidence: b.confidence,\n    })),\n    patterns: patternsResult.rows.map((p) => ({\n      id: p.id,\n      content: p.content,\n      type: p.pattern_type,\n      confidence: p.confidence,\n      frequency: p.frequency,\n    })),\n    recentMemories: memoriesResult.rows,\n  };\n\n  // Generate new insights\n  const extracted = await generateInsights(context);\n\n  for (const ext of extracted) {\n    // Check for existing similar insight\n    const existing = await findSimilarInsight(ext.content, ext.insight_type);\n\n    if (existing) {\n      // Validate existing insight\n      const validated = await validateInsight(existing.id);\n      result.validated.push({ insight: validated, wasValidated: true });\n    } else {\n      // Create new insight\n      const insight = await createInsight(\n        ext.content,\n        ext.insight_type,\n        ext.confidence,\n        ext.priority,\n        model\n      );\n\n      // Link sources\n      for (const source of ext.sources) {\n        await linkSource(\n          insight.id,\n          source.type,\n          source.id,\n          source.contribution,\n          ext.confidence,\n          source.explanation\n        );\n      }\n\n      result.created.push(insight);\n    }\n  }\n\n  // Mark stale insights\n  result.staleMarked = await markStaleInsights(30);\n\n  return result;\n}",
      "references": [
        "pool",
        "beliefsResult",
        "b",
        "patternsResult",
        "p",
        "memoriesResult",
        "generateInsights",
        "context",
        "extracted",
        "findSimilarInsight",
        "ext",
        "existing",
        "validateInsight",
        "result",
        "validated",
        "createInsight",
        "linkSource",
        "insight",
        "source",
        "markStaleInsights"
      ]
    },
    "file:src/services/lists.ts": {
      "id": "file:src/services/lists.ts",
      "type": "file",
      "name": "lists.ts",
      "filePath": "src/services/lists.ts",
      "line": 1,
      "endLine": 837,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getListWithItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listLists",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchLists",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getListsByEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findListByName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "addItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "removeItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "reorderItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "toggleItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "completeItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "uncompleteItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCompletionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "completeAllItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearCompletedItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportAllLists",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "SortType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "List",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListWithItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateListInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateListInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AddItemInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateItemInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListListsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CompletionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExportListOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/lists.ts:fn:createList:127",
        "file:src/services/lists.ts:fn:getList:172",
        "file:src/services/lists.ts:fn:getListWithItems:180",
        "file:src/services/lists.ts:fn:updateList:191",
        "file:src/services/lists.ts:fn:archiveList:282",
        "file:src/services/lists.ts:fn:deleteList:292",
        "file:src/services/lists.ts:fn:listLists:303",
        "file:src/services/lists.ts:fn:searchLists:377",
        "file:src/services/lists.ts:fn:getListsByEntity:400",
        "file:src/services/lists.ts:fn:findListByName:413",
        "file:src/services/lists.ts:fn:getListItems:441",
        "file:src/services/lists.ts:fn:addItem:474",
        "file:src/services/lists.ts:fn:getItem:503",
        "file:src/services/lists.ts:fn:updateItem:511",
        "file:src/services/lists.ts:fn:removeItem:587",
        "file:src/services/lists.ts:fn:deleteItem:601",
        "file:src/services/lists.ts:fn:reorderItems:612",
        "file:src/services/lists.ts:fn:toggleItem:641",
        "file:src/services/lists.ts:fn:completeItem:651",
        "file:src/services/lists.ts:fn:uncompleteItem:658",
        "file:src/services/lists.ts:fn:getCompletionStats:665",
        "file:src/services/lists.ts:fn:completeAllItems:685",
        "file:src/services/lists.ts:fn:clearCompletedItems:698",
        "file:src/services/lists.ts:fn:exportList:717",
        "file:src/services/lists.ts:fn:exportAllLists:748",
        "file:src/services/lists.ts:fn:exportListAsMarkdown:764",
        "file:src/services/lists.ts:fn:exportListAsCsv:802",
        "file:src/services/lists.ts:fn:exportListAsTxt:818",
        "file:src/services/lists.ts:fn:escapeCsvField:831"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/lists.ts:fn:createList:127": {
      "id": "file:src/services/lists.ts:fn:createList:127",
      "type": "function",
      "name": "createList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 127,
      "endLine": 167,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").CreateListInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new list into the database with generated embedding.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createList(input: CreateListInput): Promise<List> {\n  const {\n    name,\n    description,\n    list_type = 'checklist',\n    primary_entity_id,\n    category,\n    tags = [],\n    is_pinned = false,\n    color,\n    default_sort = 'manual',\n  } = input;\n\n  // Generate embedding for semantic search\n  const textForEmbedding = description ? `${name}. ${description}` : name;\n  const embedding = await generateEmbedding(textForEmbedding);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query(\n    `INSERT INTO lists (\n      name, description, list_type, primary_entity_id,\n      category, tags, is_pinned, color, default_sort, embedding\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n    RETURNING *`,\n    [\n      name,\n      description ?? null,\n      list_type,\n      primary_entity_id ?? null,\n      category ?? null,\n      tags,\n      is_pinned,\n      color ?? null,\n      default_sort,\n      embeddingStr,\n    ]\n  );\n\n  return result.rows[0] as List;\n}",
      "references": [
        "name",
        "description",
        "list_type",
        "primary_entity_id",
        "category",
        "tags",
        "is_pinned",
        "color",
        "default_sort",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:getList:172": {
      "id": "file:src/services/lists.ts:fn:getList:172",
      "type": "function",
      "name": "getList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 172,
      "endLine": 175,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a list by ID from the database or null if not found.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getList(id: string): Promise<List | null> {\n  const result = await pool.query('SELECT * FROM lists WHERE id = $1', [id]);\n  return (result.rows[0] as List) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:getListWithItems:180": {
      "id": "file:src/services/lists.ts:fn:getListWithItems:180",
      "type": "function",
      "name": "getListWithItems",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 180,
      "endLine": 186,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListWithItems>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a list by ID and its items, returns combined or null if list not found",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getListWithItems(id: string): Promise<ListWithItems | null> {\n  const list = await getList(id);\n  if (!list) return null;\n\n  const items = await getListItems(id);\n  return { ...list, items };\n}",
      "references": [
        "getList",
        "list",
        "getListItems",
        "items"
      ]
    },
    "file:src/services/lists.ts:fn:updateList:191": {
      "id": "file:src/services/lists.ts:fn:updateList:191",
      "type": "function",
      "name": "updateList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 191,
      "endLine": 277,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").UpdateListInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates list in DB with input fields; regenerates embedding if name changes (truncated)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateList(id: string, input: UpdateListInput): Promise<List | null> {\n  const updates: string[] = [];\n  const params: (string | string[] | boolean | null)[] = [];\n  let paramIndex = 1;\n\n  if (input.name !== undefined) {\n    updates.push(`name = $${paramIndex}`);\n    params.push(input.name);\n    paramIndex++;\n\n    // Re-generate embedding\n    const list = await getList(id);\n    if (list) {\n      const textForEmbedding = input.description !== undefined\n        ? `${input.name}. ${input.description ?? ''}`\n        : list.description\n          ? `${input.name}. ${list.description}`\n          : input.name;\n      const embedding = await generateEmbedding(textForEmbedding);\n      updates.push(`embedding = $${paramIndex}`);\n      params.push(`[${embedding.join(',')}]`);\n      paramIndex++;\n    }\n  }\n\n  if (input.description !== undefined) {\n    updates.push(`description = $${paramIndex}`);\n    params.push(input.description);\n    paramIndex++;\n  }\n\n  if (input.list_type !== undefined) {\n    updates.push(`list_type = $${paramIndex}`);\n    params.push(input.list_type);\n    paramIndex++;\n  }\n\n  if (input.primary_entity_id !== undefined) {\n    updates.push(`primary_entity_id = $${paramIndex}`);\n    params.push(input.primary_entity_id);\n    paramIndex++;\n  }\n\n  if (input.category !== undefined) {\n    updates.push(`category = $${paramIndex}`);\n    params.push(input.category);\n    paramIndex++;\n  }\n\n  if (input.tags !== undefined) {\n    updates.push(`tags = $${paramIndex}`);\n    params.push(input.tags);\n    paramIndex++;\n  }\n\n  if (input.is_pinned !== undefined) {\n    updates.push(`is_pinned = $${paramIndex}`);\n    params.push(input.is_pinned);\n    paramIndex++;\n  }\n\n  if (input.color !== undefined) {\n    updates.push(`color = $${paramIndex}`);\n    params.push(input.color);\n    paramIndex++;\n  }\n\n  if (input.default_sort !== undefined) {\n    updates.push(`default_sort = $${paramIndex}`);\n    params.push(input.default_sort);\n    paramIndex++;\n  }\n\n  if (updates.length === 0) {\n    return getList(id);\n  }\n\n  updates.push(`updated_at = NOW()`);\n  params.push(id);\n\n  const result = await pool.query(\n    `UPDATE lists SET ${updates.join(', ')} WHERE id = $${paramIndex} AND archived_at IS NULL RETURNING *`,\n    params\n  );\n\n  return (result.rows[0] as List) ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "getList",
        "list",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:archiveList:282": {
      "id": "file:src/services/lists.ts:fn:archiveList:282",
      "type": "function",
      "name": "archiveList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 282,
      "endLine": 287,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a list by updating archived_at and updated_at in the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:06.034Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveList(id: string): Promise<void> {\n  await pool.query(\n    'UPDATE lists SET archived_at = NOW(), updated_at = NOW() WHERE id = $1',\n    [id]\n  );\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/lists.ts:fn:deleteList:292": {
      "id": "file:src/services/lists.ts:fn:deleteList:292",
      "type": "function",
      "name": "deleteList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 292,
      "endLine": 294,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a list from the database by its ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.304Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteList(id: string): Promise<void> {\n  await pool.query('DELETE FROM lists WHERE id = $1', [id]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/lists.ts:fn:listLists:303": {
      "id": "file:src/services/lists.ts:fn:listLists:303",
      "type": "function",
      "name": "listLists",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 303,
      "endLine": 372,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ListListsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/lists\").List & { item_count: number; completed_count: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for lists with item/completed counts, filtered by options",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.099Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listLists(options: ListListsOptions = {}): Promise<(List & { item_count: number; completed_count: number })[]> {\n  const {\n    limit = 50,\n    offset = 0,\n    list_type,\n    category,\n    entity_id,\n    is_pinned,\n    include_archived = false,\n  } = options;\n\n  const conditions: string[] = [];\n  const params: (string | boolean | number)[] = [];\n  let paramIndex = 1;\n\n  if (!include_archived) {\n    conditions.push('l.archived_at IS NULL');\n  }\n\n  if (list_type) {\n    conditions.push(`l.list_type = $${paramIndex}`);\n    params.push(list_type);\n    paramIndex++;\n  }\n\n  if (category) {\n    conditions.push(`l.category = $${paramIndex}`);\n    params.push(category);\n    paramIndex++;\n  }\n\n  if (entity_id) {\n    conditions.push(`l.primary_entity_id = $${paramIndex}`);\n    params.push(entity_id);\n    paramIndex++;\n  }\n\n  if (is_pinned !== undefined) {\n    conditions.push(`l.is_pinned = $${paramIndex}`);\n    params.push(is_pinned);\n    paramIndex++;\n  }\n\n  let query = `\n    SELECT l.*,\n      COALESCE(counts.item_count, 0)::int AS item_count,\n      COALESCE(counts.completed_count, 0)::int AS completed_count\n    FROM lists l\n    LEFT JOIN (\n      SELECT\n        list_id,\n        COUNT(*) AS item_count,\n        COUNT(*) FILTER (WHERE is_completed = TRUE) AS completed_count\n      FROM list_items\n      WHERE archived_at IS NULL\n      GROUP BY list_id\n    ) counts ON counts.list_id = l.id\n  `;\n\n  if (conditions.length > 0) {\n    query += ' WHERE ' + conditions.join(' AND ');\n  }\n\n  query += ' ORDER BY l.is_pinned DESC, l.updated_at DESC';\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as (List & { item_count: number; completed_count: number })[];\n}",
      "references": [
        "limit",
        "offset",
        "list_type",
        "category",
        "entity_id",
        "is_pinned",
        "include_archived",
        "conditions",
        "paramIndex",
        "params",
        "query",
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:searchLists:377": {
      "id": "file:src/services/lists.ts:fn:searchLists:377",
      "type": "function",
      "name": "searchLists",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 377,
      "endLine": 395,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "20"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/lists\").List & { similarity: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates query embedding and searches DB for similar non-archived lists with similarity >0.3, returns top matches.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.336Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchLists(\n  query: string,\n  limit: number = 20\n): Promise<(List & { similarity: number })[]> {\n  const embedding = await generateEmbedding(query);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query(\n    `SELECT *, 1 - (embedding <=> $1) AS similarity\n     FROM lists\n     WHERE archived_at IS NULL\n       AND 1 - (embedding <=> $1) > 0.3\n     ORDER BY similarity DESC\n     LIMIT $2`,\n    [embeddingStr, limit]\n  );\n\n  return result.rows as (List & { similarity: number })[];\n}",
      "references": [
        "generateEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:getListsByEntity:400": {
      "id": "file:src/services/lists.ts:fn:getListsByEntity:400",
      "type": "function",
      "name": "getListsByEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 400,
      "endLine": 408,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").List[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves non-archived lists by entity ID from database, ordered by updated_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.557Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getListsByEntity(entityId: string): Promise<List[]> {\n  const result = await pool.query(\n    `SELECT * FROM lists \n     WHERE archived_at IS NULL AND primary_entity_id = $1\n     ORDER BY updated_at DESC`,\n    [entityId]\n  );\n  return result.rows as List[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:findListByName:413": {
      "id": "file:src/services/lists.ts:fn:findListByName:413",
      "type": "function",
      "name": "findListByName",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 413,
      "endLine": 432,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Finds list by exact case-insensitive name match or semantic search with similarity >0.7",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.118Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findListByName(name: string): Promise<List | null> {\n  // First try exact match\n  let result = await pool.query(\n    `SELECT * FROM lists WHERE archived_at IS NULL AND LOWER(name) = LOWER($1) LIMIT 1`,\n    [name]\n  );\n\n  if (result.rows.length > 0) {\n    return result.rows[0] as List;\n  }\n\n  // Then try semantic search\n  const matches = await searchLists(name, 1);\n  const match = matches[0];\n  if (match && match.similarity > 0.7) {\n    return match;\n  }\n\n  return null;\n}",
      "references": [
        "pool",
        "result",
        "searchLists",
        "matches",
        "match"
      ]
    },
    "file:src/services/lists.ts:fn:getListItems:441": {
      "id": "file:src/services/lists.ts:fn:getListItems:441",
      "type": "function",
      "name": "getListItems",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 441,
      "endLine": 469,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches non-archived list items for a list ID, ordered by list's default sort.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.232Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getListItems(listId: string): Promise<ListItem[]> {\n  const list = await getList(listId);\n  if (!list) return [];\n\n  let orderBy: string;\n  switch (list.default_sort) {\n    case 'created':\n      orderBy = 'created_at DESC';\n      break;\n    case 'priority':\n      orderBy = 'priority DESC, sort_order ASC';\n      break;\n    case 'due_date':\n      orderBy = 'COALESCE(due_at, \\'9999-12-31\\'::timestamptz) ASC, sort_order ASC';\n      break;\n    case 'manual':\n    default:\n      orderBy = 'sort_order ASC';\n  }\n\n  const result = await pool.query(\n    `SELECT * FROM list_items \n     WHERE list_id = $1 AND archived_at IS NULL\n     ORDER BY ${orderBy}`,\n    [listId]\n  );\n\n  return result.rows as ListItem[];\n}",
      "references": [
        "getList",
        "list",
        "orderBy",
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:addItem:474": {
      "id": "file:src/services/lists.ts:fn:addItem:474",
      "type": "function",
      "name": "addItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 474,
      "endLine": 498,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").AddItemInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Adds item to list with auto sort_order if needed, updates list timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function addItem(listId: string, input: AddItemInput): Promise<ListItem> {\n  const { content, notes, priority = 0, due_at, entity_id, sort_order } = input;\n\n  // If no sort_order provided, get next available\n  let order = sort_order;\n  if (order === undefined) {\n    const maxResult = await pool.query(\n      'SELECT COALESCE(MAX(sort_order), -1) + 1 AS next_order FROM list_items WHERE list_id = $1 AND archived_at IS NULL',\n      [listId]\n    );\n    order = maxResult.rows[0].next_order;\n  }\n\n  const result = await pool.query(\n    `INSERT INTO list_items (list_id, content, notes, priority, due_at, entity_id, sort_order)\n     VALUES ($1, $2, $3, $4, $5, $6, $7)\n     RETURNING *`,\n    [listId, content, notes ?? null, priority, due_at ?? null, entity_id ?? null, order]\n  );\n\n  // Update list's updated_at\n  await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [listId]);\n\n  return result.rows[0] as ListItem;\n}",
      "references": [
        "content",
        "notes",
        "priority",
        "due_at",
        "entity_id",
        "sort_order",
        "order",
        "pool",
        "maxResult",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:getItem:503": {
      "id": "file:src/services/lists.ts:fn:getItem:503",
      "type": "function",
      "name": "getItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 503,
      "endLine": 506,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a list item from the database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.086Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getItem(itemId: string): Promise<ListItem | null> {\n  const result = await pool.query('SELECT * FROM list_items WHERE id = $1', [itemId]);\n  return (result.rows[0] as ListItem) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:updateItem:511": {
      "id": "file:src/services/lists.ts:fn:updateItem:511",
      "type": "function",
      "name": "updateItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 511,
      "endLine": 582,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").UpdateItemInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates list item fields in DB via SQL, sets timestamps, updates parent list if changed",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.921Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateItem(itemId: string, input: UpdateItemInput): Promise<ListItem | null> {\n  const updates: string[] = [];\n  const params: (string | boolean | number | Date | null)[] = [];\n  let paramIndex = 1;\n\n  if (input.content !== undefined) {\n    updates.push(`content = $${paramIndex}`);\n    params.push(input.content);\n    paramIndex++;\n  }\n\n  if (input.notes !== undefined) {\n    updates.push(`notes = $${paramIndex}`);\n    params.push(input.notes);\n    paramIndex++;\n  }\n\n  if (input.is_completed !== undefined) {\n    updates.push(`is_completed = $${paramIndex}`);\n    params.push(input.is_completed);\n    paramIndex++;\n\n    if (input.is_completed) {\n      updates.push(`completed_at = NOW()`);\n    } else {\n      updates.push(`completed_at = NULL`);\n    }\n  }\n\n  if (input.priority !== undefined) {\n    updates.push(`priority = $${paramIndex}`);\n    params.push(input.priority);\n    paramIndex++;\n  }\n\n  if (input.due_at !== undefined) {\n    updates.push(`due_at = $${paramIndex}`);\n    params.push(input.due_at);\n    paramIndex++;\n  }\n\n  if (input.entity_id !== undefined) {\n    updates.push(`entity_id = $${paramIndex}`);\n    params.push(input.entity_id);\n    paramIndex++;\n  }\n\n  if (input.sort_order !== undefined) {\n    updates.push(`sort_order = $${paramIndex}`);\n    params.push(input.sort_order);\n    paramIndex++;\n  }\n\n  if (updates.length === 0) {\n    return getItem(itemId);\n  }\n\n  updates.push(`updated_at = NOW()`);\n  params.push(itemId);\n\n  const result = await pool.query(\n    `UPDATE list_items SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n    params\n  );\n\n  // Update parent list's updated_at\n  if (result.rows[0]) {\n    await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [result.rows[0].list_id]);\n  }\n\n  return (result.rows[0] as ListItem) ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "getItem",
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:removeItem:587": {
      "id": "file:src/services/lists.ts:fn:removeItem:587",
      "type": "function",
      "name": "removeItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 587,
      "endLine": 596,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives list item by ID via DB update and updates parent list timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.813Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function removeItem(itemId: string): Promise<void> {\n  const item = await getItem(itemId);\n  if (item) {\n    await pool.query(\n      'UPDATE list_items SET archived_at = NOW(), updated_at = NOW() WHERE id = $1',\n      [itemId]\n    );\n    await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [item.list_id]);\n  }\n}",
      "references": [
        "getItem",
        "item",
        "pool"
      ]
    },
    "file:src/services/lists.ts:fn:deleteItem:601": {
      "id": "file:src/services/lists.ts:fn:deleteItem:601",
      "type": "function",
      "name": "deleteItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 601,
      "endLine": 607,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a list item by ID and updates parent list's updated_at timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.792Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteItem(itemId: string): Promise<void> {\n  const item = await getItem(itemId);\n  if (item) {\n    await pool.query('DELETE FROM list_items WHERE id = $1', [itemId]);\n    await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [item.list_id]);\n  }\n}",
      "references": [
        "getItem",
        "item",
        "pool"
      ]
    },
    "file:src/services/lists.ts:fn:reorderItems:612": {
      "id": "file:src/services/lists.ts:fn:reorderItems:612",
      "type": "function",
      "name": "reorderItems",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 612,
      "endLine": 632,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "itemIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Reorders list items by updating sort_order in database transaction.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.000Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function reorderItems(listId: string, itemIds: string[]): Promise<void> {\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    for (let i = 0; i < itemIds.length; i++) {\n      await client.query(\n        'UPDATE list_items SET sort_order = $1, updated_at = NOW() WHERE id = $2 AND list_id = $3',\n        [i, itemIds[i], listId]\n      );\n    }\n\n    await client.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [listId]);\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}",
      "references": [
        "pool",
        "client",
        "i",
        "error"
      ]
    },
    "file:src/services/lists.ts:fn:toggleItem:641": {
      "id": "file:src/services/lists.ts:fn:toggleItem:641",
      "type": "function",
      "name": "toggleItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 641,
      "endLine": 646,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Toggles completion status of a list item by reading and updating it in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.254Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function toggleItem(itemId: string): Promise<ListItem | null> {\n  const item = await getItem(itemId);\n  if (!item) return null;\n\n  return updateItem(itemId, { is_completed: !item.is_completed });\n}",
      "references": [
        "getItem",
        "item",
        "updateItem"
      ]
    },
    "file:src/services/lists.ts:fn:completeItem:651": {
      "id": "file:src/services/lists.ts:fn:completeItem:651",
      "type": "function",
      "name": "completeItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 651,
      "endLine": 653,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates a list item to mark it as completed by setting is_completed to true",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.375Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function completeItem(itemId: string): Promise<ListItem | null> {\n  return updateItem(itemId, { is_completed: true });\n}",
      "references": [
        "updateItem"
      ]
    },
    "file:src/services/lists.ts:fn:uncompleteItem:658": {
      "id": "file:src/services/lists.ts:fn:uncompleteItem:658",
      "type": "function",
      "name": "uncompleteItem",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 658,
      "endLine": 660,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unmarks a list item as completed by updating is_completed to false via updateItem",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:17.102Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function uncompleteItem(itemId: string): Promise<ListItem | null> {\n  return updateItem(itemId, { is_completed: false });\n}",
      "references": [
        "updateItem"
      ]
    },
    "file:src/services/lists.ts:fn:getCompletionStats:665": {
      "id": "file:src/services/lists.ts:fn:getCompletionStats:665",
      "type": "function",
      "name": "getCompletionStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 665,
      "endLine": 680,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/lists\").CompletionStats>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches completion stats (completed, total, percentage) for a list from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.402Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCompletionStats(listId: string): Promise<CompletionStats> {\n  const result = await pool.query(\n    `SELECT \n       COUNT(*) FILTER (WHERE is_completed = TRUE) AS completed,\n       COUNT(*) AS total\n     FROM list_items\n     WHERE list_id = $1 AND archived_at IS NULL`,\n    [listId]\n  );\n\n  const completed = parseInt(result.rows[0].completed, 10);\n  const total = parseInt(result.rows[0].total, 10);\n  const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;\n\n  return { completed, total, percentage };\n}",
      "references": [
        "pool",
        "parseInt",
        "result",
        "total",
        "Math",
        "completed",
        "percentage"
      ]
    },
    "file:src/services/lists.ts:fn:completeAllItems:685": {
      "id": "file:src/services/lists.ts:fn:completeAllItems:685",
      "type": "function",
      "name": "completeAllItems",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 685,
      "endLine": 693,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Marks all incomplete non-archived list items as completed and updates list timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:08.870Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function completeAllItems(listId: string): Promise<void> {\n  await pool.query(\n    `UPDATE list_items \n     SET is_completed = TRUE, completed_at = NOW(), updated_at = NOW()\n     WHERE list_id = $1 AND archived_at IS NULL AND is_completed = FALSE`,\n    [listId]\n  );\n  await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [listId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/lists.ts:fn:clearCompletedItems:698": {
      "id": "file:src/services/lists.ts:fn:clearCompletedItems:698",
      "type": "function",
      "name": "clearCompletedItems",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 698,
      "endLine": 708,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives completed non-archived items in a list and updates list timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function clearCompletedItems(listId: string): Promise<number> {\n  const result = await pool.query(\n    `UPDATE list_items \n     SET archived_at = NOW(), updated_at = NOW()\n     WHERE list_id = $1 AND is_completed = TRUE AND archived_at IS NULL\n     RETURNING id`,\n    [listId]\n  );\n  await pool.query('UPDATE lists SET updated_at = NOW() WHERE id = $1', [listId]);\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/lists.ts:fn:exportList:717": {
      "id": "file:src/services/lists.ts:fn:exportList:717",
      "type": "function",
      "name": "exportList",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 717,
      "endLine": 743,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ExportListOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches list by ID, optionally filters items, exports as markdown/CSV/TXT/JSON string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.026Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportList(listId: string, options: ExportListOptions): Promise<string> {\n  const list = await getListWithItems(listId);\n  if (!list) {\n    throw new Error(`List not found: ${listId}`);\n  }\n\n  let items = list.items;\n\n  // Filter items\n  if (options.only_completed) {\n    items = items.filter(item => item.is_completed);\n  } else if (options.include_completed === false) {\n    items = items.filter(item => !item.is_completed);\n  }\n\n  switch (options.format) {\n    case 'markdown':\n      return exportListAsMarkdown(list, items, options.include_metadata);\n    case 'csv':\n      return exportListAsCsv(list, items);\n    case 'txt':\n      return exportListAsTxt(list, items);\n    case 'json':\n    default:\n      return JSON.stringify({ ...list, items }, null, 2);\n  }\n}",
      "references": [
        "getListWithItems",
        "list",
        "Error",
        "items",
        "item",
        "exportListAsMarkdown",
        "exportListAsCsv",
        "exportListAsTxt",
        "JSON"
      ]
    },
    "file:src/services/lists.ts:fn:exportAllLists:748": {
      "id": "file:src/services/lists.ts:fn:exportAllLists:748",
      "type": "function",
      "name": "exportAllLists",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 748,
      "endLine": 762,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ExportListOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches all lists and exports each via exportList, joins results as JSON array or separated string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportAllLists(options: ExportListOptions): Promise<string> {\n  const lists = await listLists({ limit: 10000 });\n  const results: string[] = [];\n\n  for (const list of lists) {\n    const exported = await exportList(list.id, options);\n    results.push(exported);\n  }\n\n  if (options.format === 'json') {\n    return `[${results.join(',')}]`;\n  }\n\n  return results.join('\\n\\n---\\n\\n');\n}",
      "references": [
        "listLists",
        "lists",
        "exportList",
        "list",
        "results",
        "exported"
      ]
    },
    "file:src/services/lists.ts:fn:exportListAsMarkdown:764": {
      "id": "file:src/services/lists.ts:fn:exportListAsMarkdown:764",
      "type": "function",
      "name": "exportListAsMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 764,
      "endLine": 800,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "list",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").List",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "items",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "includeMetadata",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates Markdown string from list, items, and optional metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.893Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function exportListAsMarkdown(list: List, items: ListItem[], includeMetadata?: boolean): string {\n  const lines: string[] = [`# ${list.name}`];\n\n  if (list.description) {\n    lines.push('', list.description);\n  }\n\n  if (includeMetadata) {\n    lines.push('');\n    lines.push(`- **Type:** ${list.list_type}`);\n    lines.push(`- **Created:** ${list.created_at.toISOString()}`);\n    if (list.category) lines.push(`- **Category:** ${list.category}`);\n    if (list.tags.length > 0) lines.push(`- **Tags:** ${list.tags.join(', ')}`);\n  }\n\n  lines.push('');\n\n  for (const item of items) {\n    const checkbox = list.list_type === 'checklist'\n      ? item.is_completed ? '[x]' : '[ ]'\n      : '-';\n    \n    let line = `${checkbox} ${item.content}`;\n    \n    if (item.due_at) {\n      line += ` (due: ${item.due_at.toISOString().split('T')[0]})`;\n    }\n    \n    lines.push(line);\n    \n    if (item.notes) {\n      lines.push(`  - ${item.notes}`);\n    }\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "item",
        "checkbox",
        "line"
      ]
    },
    "file:src/services/lists.ts:fn:exportListAsCsv:802": {
      "id": "file:src/services/lists.ts:fn:exportListAsCsv:802",
      "type": "function",
      "name": "exportListAsCsv",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 802,
      "endLine": 816,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "list",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").List",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "items",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates CSV string from list name and item data with escaped fields.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function exportListAsCsv(list: List, items: ListItem[]): string {\n  const headers = ['list_name', 'item_id', 'content', 'is_completed', 'priority', 'due_at', 'notes', 'created_at'];\n  const rows = items.map(item => [\n    escapeCsvField(list.name),\n    item.id,\n    escapeCsvField(item.content),\n    item.is_completed ? 'true' : 'false',\n    item.priority.toString(),\n    item.due_at?.toISOString() ?? '',\n    escapeCsvField(item.notes ?? ''),\n    item.created_at.toISOString(),\n  ]);\n\n  return [headers.join(','), ...rows.map(row => row.join(','))].join('\\n');\n}",
      "references": [
        "escapeCsvField",
        "item",
        "headers",
        "rows",
        "row"
      ]
    },
    "file:src/services/lists.ts:fn:exportListAsTxt:818": {
      "id": "file:src/services/lists.ts:fn:exportListAsTxt:818",
      "type": "function",
      "name": "exportListAsTxt",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 818,
      "endLine": 829,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "list",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").List",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "items",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/lists\").ListItem[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a list and its items into a plain text string for export.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function exportListAsTxt(list: List, items: ListItem[]): string {\n  const lines: string[] = [list.name, '='.repeat(list.name.length), ''];\n\n  for (const item of items) {\n    const idx = items.indexOf(item);\n    const prefix = list.list_type === 'ranked' ? `${idx + 1}.` : '-';\n    const status = list.list_type === 'checklist' && item.is_completed ? ' [DONE]' : '';\n    lines.push(`${prefix} ${item.content}${status}`);\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "item",
        "idx",
        "lines",
        "prefix",
        "status"
      ]
    },
    "file:src/services/lists.ts:fn:escapeCsvField:831": {
      "id": "file:src/services/lists.ts:fn:escapeCsvField:831",
      "type": "function",
      "name": "escapeCsvField",
      "filePath": "/home/ridgetop/projects/squire/src/services/lists.ts",
      "line": 831,
      "endLine": 836,
      "parentFileId": "file:src/services/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "field",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Escapes CSV field by quoting if it contains ',' '\"' or '\\n', doubling internal quotes.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.726Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function escapeCsvField(field: string): string {\n  if (field.includes(',') || field.includes('\"') || field.includes('\\n')) {\n    return `\"${field.replace(/\"/g, '\"\"')}\"`;\n  }\n  return field;\n}",
      "references": []
    },
    "file:src/services/memories.ts": {
      "id": "file:src/services/memories.ts",
      "type": "file",
      "name": "memories.ts",
      "filePath": "src/services/memories.ts",
      "line": 1,
      "endLine": 239,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./salience.js",
          "items": [
            {
              "name": "calculateSalience",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./entities.js",
          "items": [
            {
              "name": "extractAndStoreEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityMention",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../api/socket/broadcast.js",
          "items": [
            {
              "name": "broadcastMemoryCreated",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "Memory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateMemoryInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateMemoryResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListMemoriesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchMemoriesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/memories.ts:fn:createMemory:52",
        "file:src/services/memories.ts:fn:getMemory:119",
        "file:src/services/memories.ts:fn:listMemories:133",
        "file:src/services/memories.ts:fn:countMemories:160",
        "file:src/services/memories.ts:fn:deleteMemory:168",
        "file:src/services/memories.ts:fn:searchMemories:201"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/memories.ts:fn:createMemory:52": {
      "id": "file:src/services/memories.ts:fn:createMemory:52",
      "type": "function",
      "name": "createMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 52,
      "endLine": 114,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memories\").CreateMemoryInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").CreateMemoryResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts raw observation and memory to DB, generates embedding/salience, broadcasts, optionally extracts entities",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.086Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createMemory(input: CreateMemoryInput): Promise<CreateMemoryResult> {\n  const {\n    content,\n    source = 'cli',\n    content_type = 'text',\n    source_metadata = {},\n    occurred_at,\n    skipEntityExtraction = false,\n  } = input;\n\n  // First, store the raw observation (immutable input)\n  const rawObsResult = await pool.query(\n    `INSERT INTO raw_observations (content, content_type, source, source_metadata, occurred_at)\n     VALUES ($1, $2, $3, $4, $5)\n     RETURNING id`,\n    [content, content_type, source, JSON.stringify(source_metadata), occurred_at]\n  );\n  const rawObservationId = rawObsResult.rows[0]?.id as string;\n\n  // Generate embedding for semantic search\n  const embedding = await generateEmbedding(content);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  // Calculate salience score (Slice 2)\n  const salience = calculateSalience(content);\n\n  // Create the memory with embedding and salience\n  const result = await pool.query(\n    `INSERT INTO memories (\n      raw_observation_id, content, content_type, source, source_metadata,\n      embedding, salience_score, salience_factors, occurred_at, processing_status, processed_at\n    )\n     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'processed', NOW())\n     RETURNING *`,\n    [\n      rawObservationId,\n      content,\n      content_type,\n      source,\n      JSON.stringify(source_metadata),\n      embeddingStr,\n      salience.score,\n      JSON.stringify(salience.factors),\n      occurred_at,\n    ]\n  );\n\n  const memory = result.rows[0] as Memory;\n\n  // Broadcast to connected WebSocket clients (P6-T5)\n  broadcastMemoryCreated(memory);\n\n  // Extract and store entities (Slice 4)\n  let entities: Entity[] = [];\n  let mentions: EntityMention[] = [];\n  if (!skipEntityExtraction) {\n    const extraction = await extractAndStoreEntities(memory.id, content);\n    entities = extraction.entities;\n    mentions = extraction.mentions;\n  }\n\n  return { memory, entities, mentions };\n}",
      "references": [
        "content",
        "source",
        "content_type",
        "source_metadata",
        "occurred_at",
        "skipEntityExtraction",
        "pool",
        "JSON",
        "rawObsResult",
        "generateEmbedding",
        "embedding",
        "calculateSalience",
        "rawObservationId",
        "embeddingStr",
        "salience",
        "result",
        "broadcastMemoryCreated",
        "memory",
        "extractAndStoreEntities",
        "entities",
        "extraction",
        "mentions"
      ]
    },
    "file:src/services/memories.ts:fn:getMemory:119": {
      "id": "file:src/services/memories.ts:fn:getMemory:119",
      "type": "function",
      "name": "getMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 119,
      "endLine": 128,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves memory by ID, updating last_accessed_at and access_count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.086Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMemory(id: string): Promise<Memory | null> {\n  const result = await pool.query(\n    `UPDATE memories\n     SET last_accessed_at = NOW(), access_count = access_count + 1\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as Memory) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/memories.ts:fn:listMemories:133": {
      "id": "file:src/services/memories.ts:fn:listMemories:133",
      "type": "function",
      "name": "listMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 133,
      "endLine": 155,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memories\").ListMemoriesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves paginated list of memories from DB, optionally filtered by source",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.086Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listMemories(options: ListMemoriesOptions = {}): Promise<Memory[]> {\n  const { limit = 50, offset = 0, source } = options;\n\n  let query = `\n    SELECT * FROM memories\n    WHERE 1=1\n  `;\n  const params: (string | number)[] = [];\n  let paramIndex = 1;\n\n  if (source) {\n    query += ` AND source = $${paramIndex}`;\n    params.push(source);\n    paramIndex++;\n  }\n\n  query += ` ORDER BY created_at DESC`;\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as Memory[];\n}",
      "references": [
        "limit",
        "offset",
        "source",
        "query",
        "paramIndex",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/memories.ts:fn:countMemories:160": {
      "id": "file:src/services/memories.ts:fn:countMemories:160",
      "type": "function",
      "name": "countMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 160,
      "endLine": 163,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Counts the number of rows in the 'memories' database table.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.086Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function countMemories(): Promise<number> {\n  const result = await pool.query('SELECT COUNT(*) as count FROM memories');\n  return parseInt(result.rows[0]?.count ?? '0', 10);\n}",
      "references": [
        "pool",
        "parseInt",
        "result"
      ]
    },
    "file:src/services/memories.ts:fn:deleteMemory:168": {
      "id": "file:src/services/memories.ts:fn:deleteMemory:168",
      "type": "function",
      "name": "deleteMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 168,
      "endLine": 171,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a memory from the database by ID and returns true if successful.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteMemory(id: string): Promise<boolean> {\n  const result = await pool.query('DELETE FROM memories WHERE id = $1', [id]);\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/memories.ts:fn:searchMemories:201": {
      "id": "file:src/services/memories.ts:fn:searchMemories:201",
      "type": "function",
      "name": "searchMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/memories.ts",
      "line": 201,
      "endLine": 238,
      "parentFileId": "file:src/services/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memories\").SearchMemoriesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memories\").SearchResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches memories DB using query embedding cosine similarity, optional salience weighting.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchMemories(\n  query: string,\n  options: SearchMemoriesOptions = {}\n): Promise<SearchResult[]> {\n  const { limit = 10, minSimilarity = 0.3, useSalience = true } = options;\n\n  // Generate embedding for the search query\n  const queryEmbedding = await generateEmbedding(query);\n  const embeddingStr = `[${queryEmbedding.join(',')}]`;\n\n  // Search using cosine similarity combined with salience\n  // pgvector uses <=> for cosine distance, so similarity = 1 - distance\n  // Combined score = (similarity * 0.6) + (salience_normalized * 0.4)\n  const result = await pool.query(\n    `SELECT *,\n       1 - (embedding <=> $1::vector) as similarity,\n       CASE WHEN $4 THEN\n         (1 - (embedding <=> $1::vector)) * $5 + (salience_score / 10.0) * $6\n       ELSE\n         1 - (embedding <=> $1::vector)\n       END as combined_score\n     FROM memories\n     WHERE embedding IS NOT NULL\n       AND 1 - (embedding <=> $1::vector) >= $2\n     ORDER BY combined_score DESC\n     LIMIT $3`,\n    [\n      embeddingStr,\n      minSimilarity,\n      limit,\n      useSalience,\n      SEARCH_WEIGHTS.similarity,\n      SEARCH_WEIGHTS.salience,\n    ]\n  );\n\n  return result.rows as SearchResult[];\n}",
      "references": [
        "limit",
        "minSimilarity",
        "useSalience",
        "generateEmbedding",
        "queryEmbedding",
        "pool",
        "embeddingStr",
        "SEARCH_WEIGHTS",
        "result"
      ]
    },
    "file:src/services/memoryGraph.ts": {
      "id": "file:src/services/memoryGraph.ts",
      "type": "file",
      "name": "memoryGraph.ts",
      "filePath": "src/services/memoryGraph.ts",
      "line": 1,
      "endLine": 350,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "getNeighborhoodFromMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "flattenNeighborhoods",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphEdgeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GraphNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphNeighborhood",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "TraversalOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/memoryGraph.ts:fn:getNeighborhoodFromMemories:68",
        "file:src/services/memoryGraph.ts:fn:traverseFromSeed:90",
        "file:src/services/memoryGraph.ts:fn:getSimilarNeighbors:182",
        "file:src/services/memoryGraph.ts:fn:getEntityNeighbors:228",
        "file:src/services/memoryGraph.ts:fn:getSummaryNeighbors:277",
        "file:src/services/memoryGraph.ts:fn:flattenNeighborhoods:327"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/memoryGraph.ts:fn:getNeighborhoodFromMemories:68": {
      "id": "file:src/services/memoryGraph.ts:fn:getNeighborhoodFromMemories:68",
      "type": "function",
      "name": "getNeighborhoodFromMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 68,
      "endLine": 85,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "seedIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").TraversalOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").GraphNeighborhood[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves graph neighborhoods for up to 10 seed IDs via traversal.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function getNeighborhoodFromMemories(\n  seedIds: string[],\n  options: TraversalOptions = {}\n): Promise<GraphNeighborhood[]> {\n  if (seedIds.length === 0) return [];\n\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n  const results: GraphNeighborhood[] = [];\n\n  for (const seedId of seedIds.slice(0, 10)) { // Limit seeds to prevent explosion\n    const neighborhood = await traverseFromSeed(seedId, opts);\n    if (neighborhood) {\n      results.push(neighborhood);\n    }\n  }\n\n  return results;\n}",
      "references": [
        "DEFAULT_OPTIONS",
        "traverseFromSeed",
        "seedId",
        "opts",
        "neighborhood",
        "results"
      ]
    },
    "file:src/services/memoryGraph.ts:fn:traverseFromSeed:90": {
      "id": "file:src/services/memoryGraph.ts:fn:traverseFromSeed:90",
      "type": "function",
      "name": "traverseFromSeed",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 90,
      "endLine": 169,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "seedId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "opts",
          "type": "Required<import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").TraversalOptions>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").GraphNeighborhood>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "BFS traverses graph from seed memory ID, querying DB for seed and neighbors to build GraphNeighborhood",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function traverseFromSeed(\n  seedId: string,\n  opts: Required<TraversalOptions>\n): Promise<GraphNeighborhood | null> {\n  // Get seed memory\n  const seedResult = await pool.query<Memory>(\n    `SELECT id, content, source, created_at, salience_score\n     FROM memories WHERE id = $1`,\n    [seedId]\n  );\n\n  if (seedResult.rows.length === 0) return null;\n\n  const seedMem = seedResult.rows[0]!;\n  const seed: GraphNode = {\n    id: seedMem.id,\n    kind: 'memory',\n    content: seedMem.content,\n    created_at: seedMem.created_at,\n    score: 1.0,\n    salience: seedMem.salience_score,\n    source: seedMem.source,\n  };\n\n  const nodes: GraphNode[] = [];\n  const edges: GraphEdge[] = [];\n  const visited = new Set<string>([seedId]);\n\n  // BFS traversal\n  let frontier: Array<{ id: string; depth: number }> = [{ id: seedId, depth: 0 }];\n\n  while (frontier.length > 0 && nodes.length < opts.maxNodes) {\n    const nextFrontier: Array<{ id: string; depth: number }> = [];\n\n    for (const { id, depth } of frontier) {\n      if (depth >= opts.maxDepth) continue;\n\n      // Get neighbors via each edge type\n      if (opts.edgeTypes.includes('SIMILAR')) {\n        const similarNeighbors = await getSimilarNeighbors(id, opts.minWeight, opts.minSalience);\n        for (const neighbor of similarNeighbors) {\n          if (!visited.has(neighbor.id) && nodes.length < opts.maxNodes) {\n            visited.add(neighbor.id);\n            nodes.push(neighbor.node);\n            edges.push(neighbor.edge);\n            nextFrontier.push({ id: neighbor.id, depth: depth + 1 });\n          }\n        }\n      }\n\n      if (opts.edgeTypes.includes('ENTITY')) {\n        const entityNeighbors = await getEntityNeighbors(id, opts.minWeight, opts.minSalience);\n        for (const neighbor of entityNeighbors) {\n          if (!visited.has(neighbor.id) && nodes.length < opts.maxNodes) {\n            visited.add(neighbor.id);\n            nodes.push(neighbor.node);\n            edges.push(neighbor.edge);\n            nextFrontier.push({ id: neighbor.id, depth: depth + 1 });\n          }\n        }\n      }\n\n      if (opts.edgeTypes.includes('SUMMARY')) {\n        const summaryNeighbors = await getSummaryNeighbors(id, opts.minWeight);\n        for (const neighbor of summaryNeighbors) {\n          if (!visited.has(neighbor.id) && nodes.length < opts.maxNodes) {\n            visited.add(neighbor.id);\n            nodes.push(neighbor.node);\n            edges.push(neighbor.edge);\n            // Don't add summaries to frontier - they're leaf nodes\n          }\n        }\n      }\n    }\n\n    frontier = nextFrontier;\n  }\n\n  return { seed, nodes, edges };\n}",
      "references": [
        "pool",
        "seedResult",
        "seedMem",
        "Set",
        "frontier",
        "nodes",
        "id",
        "depth",
        "getSimilarNeighbors",
        "similarNeighbors",
        "visited",
        "neighbor",
        "edges",
        "nextFrontier",
        "getEntityNeighbors",
        "entityNeighbors",
        "getSummaryNeighbors",
        "summaryNeighbors",
        "seed"
      ]
    },
    "file:src/services/memoryGraph.ts:fn:getSimilarNeighbors:182": {
      "id": "file:src/services/memoryGraph.ts:fn:getSimilarNeighbors:182",
      "type": "function",
      "name": "getSimilarNeighbors",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 182,
      "endLine": 223,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "minWeight",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "minSalience",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<NeighborResult[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for similar neighboring memories filtered by weight and salience, returns up to 15 results",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getSimilarNeighbors(\n  memoryId: string,\n  minWeight: number,\n  minSalience: number\n): Promise<NeighborResult[]> {\n  const result = await pool.query<Memory & { edge_weight: number; edge_similarity: number }>(\n    `SELECT DISTINCT ON (m.id)\n       m.id, m.content, m.source, m.created_at, m.salience_score,\n       e.weight as edge_weight,\n       e.similarity as edge_similarity\n     FROM memory_edges e\n     JOIN memories m ON (\n       CASE WHEN e.source_memory_id = $1 THEN e.target_memory_id ELSE e.source_memory_id END = m.id\n     )\n     WHERE (e.source_memory_id = $1 OR e.target_memory_id = $1)\n       AND e.edge_type = 'SIMILAR'\n       AND e.weight >= $2\n       AND m.salience_score >= $3\n     ORDER BY m.id, e.weight DESC\n     LIMIT 15`,\n    [memoryId, minWeight, minSalience]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    node: {\n      id: row.id,\n      kind: 'memory' as const,\n      content: row.content,\n      created_at: row.created_at,\n      score: row.edge_weight,\n      salience: row.salience_score,\n      source: row.source,\n    },\n    edge: {\n      source_id: memoryId,\n      target_id: row.id,\n      edge_type: 'SIMILAR' as const,\n      weight: row.edge_weight,\n    },\n  }));\n}",
      "references": [
        "pool",
        "result",
        "row"
      ]
    },
    "file:src/services/memoryGraph.ts:fn:getEntityNeighbors:228": {
      "id": "file:src/services/memoryGraph.ts:fn:getEntityNeighbors:228",
      "type": "function",
      "name": "getEntityNeighbors",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 228,
      "endLine": 272,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_minWeight",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "minSalience",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<NeighborResult[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for up to 10 memories sharing entities with given memoryId, filtered by salience and entity type",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getEntityNeighbors(\n  memoryId: string,\n  _minWeight: number, // API consistency with other neighbor functions\n  minSalience: number\n): Promise<NeighborResult[]> {\n  const result = await pool.query<Memory & { entity_name: string; shared_entity_count: number }>(\n    `WITH memory_entities AS (\n       SELECT entity_id FROM entity_mentions WHERE memory_id = $1\n     )\n     SELECT DISTINCT ON (m.id)\n       m.id, m.content, m.source, m.created_at, m.salience_score,\n       e.name as entity_name,\n       COUNT(*) OVER (PARTITION BY m.id) as shared_entity_count\n     FROM memories m\n     JOIN entity_mentions em ON em.memory_id = m.id\n     JOIN entities e ON e.id = em.entity_id\n     WHERE em.entity_id IN (SELECT entity_id FROM memory_entities)\n       AND m.id != $1\n       AND m.salience_score >= $2\n       AND e.entity_type IN ('person', 'project', 'organization')\n     ORDER BY m.id, m.salience_score DESC\n     LIMIT 10`,\n    [memoryId, minSalience]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    node: {\n      id: row.id,\n      kind: 'memory' as const,\n      content: row.content,\n      created_at: row.created_at,\n      score: Math.min(row.shared_entity_count / 3, 1.0),\n      salience: row.salience_score,\n      source: row.source,\n    },\n    edge: {\n      source_id: memoryId,\n      target_id: row.id,\n      edge_type: 'ENTITY' as const,\n      weight: Math.min(row.shared_entity_count / 3, 1.0),\n      via: row.entity_name,\n    },\n  }));\n}",
      "references": [
        "pool",
        "result",
        "row",
        "Math"
      ]
    },
    "file:src/services/memoryGraph.ts:fn:getSummaryNeighbors:277": {
      "id": "file:src/services/memoryGraph.ts:fn:getSummaryNeighbors:277",
      "type": "function",
      "name": "getSummaryNeighbors",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 277,
      "endLine": 319,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "minWeight",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<NeighborResult[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for top 5 summary neighbors of a memory with relevance >= minWeight",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getSummaryNeighbors(\n  memoryId: string,\n  minWeight: number\n): Promise<NeighborResult[]> {\n  const result = await pool.query<{\n    id: string;\n    category: string;\n    content: string;\n    relevance_score: number;\n    updated_at: Date;\n  }>(\n    `SELECT\n       ls.id, ls.category, ls.content, msl.relevance_score,\n       ls.last_updated_at as updated_at\n     FROM memory_summary_links msl\n     JOIN living_summaries ls ON ls.category = msl.summary_category\n     WHERE msl.memory_id = $1\n       AND msl.relevance_score >= $2\n       AND ls.content IS NOT NULL\n       AND ls.content != ''\n     ORDER BY msl.relevance_score DESC\n     LIMIT 5`,\n    [memoryId, minWeight]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    node: {\n      id: row.id,\n      kind: 'summary' as const,\n      content: row.content,\n      created_at: row.updated_at,\n      score: row.relevance_score,\n    },\n    edge: {\n      source_id: memoryId,\n      target_id: row.id,\n      edge_type: 'SUMMARY' as const,\n      weight: row.relevance_score,\n      via: row.category,\n    },\n  }));\n}",
      "references": [
        "pool",
        "result",
        "row"
      ]
    },
    "file:src/services/memoryGraph.ts:fn:flattenNeighborhoods:327": {
      "id": "file:src/services/memoryGraph.ts:fn:flattenNeighborhoods:327",
      "type": "function",
      "name": "flattenNeighborhoods",
      "filePath": "/home/ridgetop/projects/squire/src/services/memoryGraph.ts",
      "line": 327,
      "endLine": 348,
      "parentFileId": "file:src/services/memoryGraph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "neighborhoods",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").GraphNeighborhood[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").GraphNode[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Merges graph neighborhoods into unique nodes list, keeping highest score per ID, sorted by score descending",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function flattenNeighborhoods(neighborhoods: GraphNeighborhood[]): GraphNode[] {\n  const nodeMap = new Map<string, GraphNode>();\n\n  for (const neighborhood of neighborhoods) {\n    // Add seed with highest priority\n    const existing = nodeMap.get(neighborhood.seed.id);\n    if (!existing || neighborhood.seed.score > existing.score) {\n      nodeMap.set(neighborhood.seed.id, neighborhood.seed);\n    }\n\n    // Add neighborhood nodes\n    for (const node of neighborhood.nodes) {\n      const existing = nodeMap.get(node.id);\n      if (!existing || node.score > existing.score) {\n        nodeMap.set(node.id, node);\n      }\n    }\n  }\n\n  return Array.from(nodeMap.values())\n    .sort((a, b) => b.score - a.score);\n}",
      "references": [
        "Map",
        "nodeMap",
        "neighborhood",
        "existing",
        "node",
        "Array",
        "b",
        "a"
      ]
    },
    "file:src/services/notes.ts": {
      "id": "file:src/services/notes.ts",
      "type": "file",
      "name": "notes.ts",
      "filePath": "src/services/notes.ts",
      "line": 1,
      "endLine": 599,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "createMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getNotesByEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPinnedNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "findNoteByTitle",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkNoteToEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unlinkNoteFromEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pinNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unpinNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NoteSourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Note",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateNoteInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateNoteInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListNotesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchNotesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExportOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExportResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/notes.ts:fn:createNote:99",
        "file:src/services/notes.ts:fn:getNote:165",
        "file:src/services/notes.ts:fn:updateNote:176",
        "file:src/services/notes.ts:fn:archiveNote:261",
        "file:src/services/notes.ts:fn:deleteNote:271",
        "file:src/services/notes.ts:fn:listNotes:282",
        "file:src/services/notes.ts:fn:searchNotes:341",
        "file:src/services/notes.ts:fn:getNotesByEntity:384",
        "file:src/services/notes.ts:fn:getPinnedNotes:398",
        "file:src/services/notes.ts:fn:findNoteByTitle:411",
        "file:src/services/notes.ts:fn:linkNoteToEntity:449",
        "file:src/services/notes.ts:fn:unlinkNoteFromEntity:481",
        "file:src/services/notes.ts:fn:pinNote:500",
        "file:src/services/notes.ts:fn:unpinNote:507",
        "file:src/services/notes.ts:fn:exportNotes:518",
        "file:src/services/notes.ts:fn:exportAsMarkdown:548",
        "file:src/services/notes.ts:fn:exportAsCsv:577",
        "file:src/services/notes.ts:fn:escapeCsvField:593"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/notes.ts:fn:createNote:99": {
      "id": "file:src/services/notes.ts:fn:createNote:99",
      "type": "function",
      "name": "createNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 99,
      "endLine": 160,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").CreateNoteInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a note in DB with embedding, optional memory, and entity associations",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createNote(input: CreateNoteInput): Promise<Note> {\n  const {\n    title,\n    content,\n    source_type = 'manual',\n    source_context = {},\n    primary_entity_id,\n    entity_ids = [],\n    category,\n    tags = [],\n    is_pinned = false,\n    color,\n    create_memory = true,\n  } = input;\n\n  // Generate embedding for semantic search\n  const textForEmbedding = title ? `${title}. ${content}` : content;\n  const embedding = await generateEmbedding(textForEmbedding);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  // Optionally create underlying memory for graph integration\n  let memoryId: string | null = null;\n  if (create_memory) {\n    const result = await createMemory({\n      content: textForEmbedding,\n      content_type: 'note',\n      source: source_type === 'calendar_event' ? 'calendar' : source_type,\n      source_metadata: source_context,\n    });\n    memoryId = result.memory.id;\n  }\n\n  // Ensure primary entity is in entity_ids\n  const allEntityIds = primary_entity_id && !entity_ids.includes(primary_entity_id)\n    ? [primary_entity_id, ...entity_ids]\n    : entity_ids;\n\n  const result = await pool.query(\n    `INSERT INTO notes (\n      title, content, memory_id, source_type, source_context,\n      primary_entity_id, entity_ids, category, tags, is_pinned, color, embedding\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n    RETURNING *`,\n    [\n      title ?? null,\n      content,\n      memoryId,\n      source_type,\n      JSON.stringify(source_context),\n      primary_entity_id ?? null,\n      allEntityIds,\n      category ?? null,\n      tags,\n      is_pinned,\n      color ?? null,\n      embeddingStr,\n    ]\n  );\n\n  return result.rows[0] as Note;\n}",
      "references": [
        "title",
        "content",
        "source_type",
        "source_context",
        "primary_entity_id",
        "entity_ids",
        "category",
        "tags",
        "is_pinned",
        "color",
        "create_memory",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "createMemory",
        "memoryId",
        "result",
        "pool",
        "JSON",
        "allEntityIds",
        "embeddingStr"
      ]
    },
    "file:src/services/notes.ts:fn:getNote:165": {
      "id": "file:src/services/notes.ts:fn:getNote:165",
      "type": "function",
      "name": "getNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 165,
      "endLine": 171,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a note from the database by its ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getNote(id: string): Promise<Note | null> {\n  const result = await pool.query(\n    'SELECT * FROM notes WHERE id = $1',\n    [id]\n  );\n  return (result.rows[0] as Note) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:updateNote:176": {
      "id": "file:src/services/notes.ts:fn:updateNote:176",
      "type": "function",
      "name": "updateNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 176,
      "endLine": 256,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").UpdateNoteInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates note in DB with dynamic fields, regenerates embedding if content changes",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateNote(id: string, input: UpdateNoteInput): Promise<Note | null> {\n  const updates: string[] = [];\n  const params: (string | string[] | boolean | null)[] = [];\n  let paramIndex = 1;\n\n  if (input.title !== undefined) {\n    updates.push(`title = $${paramIndex}`);\n    params.push(input.title);\n    paramIndex++;\n  }\n\n  if (input.content !== undefined) {\n    updates.push(`content = $${paramIndex}`);\n    params.push(input.content);\n    paramIndex++;\n\n    // Re-generate embedding\n    const note = await getNote(id);\n    if (note) {\n      const textForEmbedding = input.title !== undefined\n        ? `${input.title ?? ''}. ${input.content}`\n        : note.title\n          ? `${note.title}. ${input.content}`\n          : input.content;\n      const embedding = await generateEmbedding(textForEmbedding);\n      updates.push(`embedding = $${paramIndex}`);\n      params.push(`[${embedding.join(',')}]`);\n      paramIndex++;\n    }\n  }\n\n  if (input.primary_entity_id !== undefined) {\n    updates.push(`primary_entity_id = $${paramIndex}`);\n    params.push(input.primary_entity_id);\n    paramIndex++;\n  }\n\n  if (input.entity_ids !== undefined) {\n    updates.push(`entity_ids = $${paramIndex}`);\n    params.push(input.entity_ids);\n    paramIndex++;\n  }\n\n  if (input.category !== undefined) {\n    updates.push(`category = $${paramIndex}`);\n    params.push(input.category);\n    paramIndex++;\n  }\n\n  if (input.tags !== undefined) {\n    updates.push(`tags = $${paramIndex}`);\n    params.push(input.tags);\n    paramIndex++;\n  }\n\n  if (input.is_pinned !== undefined) {\n    updates.push(`is_pinned = $${paramIndex}`);\n    params.push(input.is_pinned);\n    paramIndex++;\n  }\n\n  if (input.color !== undefined) {\n    updates.push(`color = $${paramIndex}`);\n    params.push(input.color);\n    paramIndex++;\n  }\n\n  if (updates.length === 0) {\n    return getNote(id);\n  }\n\n  updates.push(`updated_at = NOW()`);\n  params.push(id);\n\n  const result = await pool.query(\n    `UPDATE notes SET ${updates.join(', ')} WHERE id = $${paramIndex} AND archived_at IS NULL RETURNING *`,\n    params\n  );\n\n  return (result.rows[0] as Note) ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "getNote",
        "note",
        "generateEmbedding",
        "textForEmbedding",
        "embedding",
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:archiveNote:261": {
      "id": "file:src/services/notes.ts:fn:archiveNote:261",
      "type": "function",
      "name": "archiveNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 261,
      "endLine": 266,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a note by updating archived_at and updated_at in the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveNote(id: string): Promise<void> {\n  await pool.query(\n    'UPDATE notes SET archived_at = NOW(), updated_at = NOW() WHERE id = $1',\n    [id]\n  );\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/notes.ts:fn:deleteNote:271": {
      "id": "file:src/services/notes.ts:fn:deleteNote:271",
      "type": "function",
      "name": "deleteNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 271,
      "endLine": 273,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a note from the database by ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.087Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteNote(id: string): Promise<void> {\n  await pool.query('DELETE FROM notes WHERE id = $1', [id]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/notes.ts:fn:listNotes:282": {
      "id": "file:src/services/notes.ts:fn:listNotes:282",
      "type": "function",
      "name": "listNotes",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 282,
      "endLine": 336,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").ListNotesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches notes from database with filters, pagination, and sorting.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listNotes(options: ListNotesOptions = {}): Promise<Note[]> {\n  const {\n    limit = 50,\n    offset = 0,\n    category,\n    entity_id,\n    is_pinned,\n    include_archived = false,\n    tags,\n  } = options;\n\n  const conditions: string[] = [];\n  const params: (string | string[] | boolean | number)[] = [];\n  let paramIndex = 1;\n\n  if (!include_archived) {\n    conditions.push('archived_at IS NULL');\n  }\n\n  if (category) {\n    conditions.push(`category = $${paramIndex}`);\n    params.push(category);\n    paramIndex++;\n  }\n\n  if (entity_id) {\n    conditions.push(`(primary_entity_id = $${paramIndex} OR $${paramIndex} = ANY(entity_ids))`);\n    params.push(entity_id);\n    paramIndex++;\n  }\n\n  if (is_pinned !== undefined) {\n    conditions.push(`is_pinned = $${paramIndex}`);\n    params.push(is_pinned);\n    paramIndex++;\n  }\n\n  if (tags && tags.length > 0) {\n    conditions.push(`tags && $${paramIndex}`);\n    params.push(tags);\n    paramIndex++;\n  }\n\n  let query = 'SELECT * FROM notes';\n  if (conditions.length > 0) {\n    query += ' WHERE ' + conditions.join(' AND ');\n  }\n\n  query += ' ORDER BY is_pinned DESC, updated_at DESC';\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as Note[];\n}",
      "references": [
        "limit",
        "offset",
        "category",
        "entity_id",
        "is_pinned",
        "include_archived",
        "tags",
        "conditions",
        "paramIndex",
        "params",
        "query",
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:searchNotes:341": {
      "id": "file:src/services/notes.ts:fn:searchNotes:341",
      "type": "function",
      "name": "searchNotes",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 341,
      "endLine": 379,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").SearchNotesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/notes\").Note & { similarity: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches notes by semantic similarity using query embedding with optional filters.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchNotes(\n  query: string,\n  options: SearchNotesOptions = {}\n): Promise<(Note & { similarity: number })[]> {\n  const { limit = 20, threshold = 0.3, entity_id, category } = options;\n\n  const embedding = await generateEmbedding(query);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const conditions: string[] = ['archived_at IS NULL'];\n  const params: (string | number)[] = [embeddingStr];\n  let paramIndex = 2;\n\n  if (entity_id) {\n    conditions.push(`(primary_entity_id = $${paramIndex} OR $${paramIndex} = ANY(entity_ids))`);\n    params.push(entity_id);\n    paramIndex++;\n  }\n\n  if (category) {\n    conditions.push(`category = $${paramIndex}`);\n    params.push(category);\n    paramIndex++;\n  }\n\n  params.push(threshold, limit);\n\n  const result = await pool.query(\n    `SELECT *, 1 - (embedding <=> $1) AS similarity\n     FROM notes\n     WHERE ${conditions.join(' AND ')}\n       AND 1 - (embedding <=> $1) > $${paramIndex}\n     ORDER BY similarity DESC\n     LIMIT $${paramIndex + 1}`,\n    params\n  );\n\n  return result.rows as (Note & { similarity: number })[];\n}",
      "references": [
        "limit",
        "threshold",
        "entity_id",
        "category",
        "generateEmbedding",
        "embedding",
        "embeddingStr",
        "conditions",
        "paramIndex",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:getNotesByEntity:384": {
      "id": "file:src/services/notes.ts:fn:getNotesByEntity:384",
      "type": "function",
      "name": "getNotesByEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 384,
      "endLine": 393,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves non-archived notes for given entity ID from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getNotesByEntity(entityId: string): Promise<Note[]> {\n  const result = await pool.query(\n    `SELECT * FROM notes \n     WHERE archived_at IS NULL \n       AND (primary_entity_id = $1 OR $1 = ANY(entity_ids))\n     ORDER BY updated_at DESC`,\n    [entityId]\n  );\n  return result.rows as Note[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:getPinnedNotes:398": {
      "id": "file:src/services/notes.ts:fn:getPinnedNotes:398",
      "type": "function",
      "name": "getPinnedNotes",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 398,
      "endLine": 405,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves pinned, non-archived notes from database ordered by updated_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPinnedNotes(): Promise<Note[]> {\n  const result = await pool.query(\n    `SELECT * FROM notes\n     WHERE archived_at IS NULL AND is_pinned = TRUE\n     ORDER BY updated_at DESC`\n  );\n  return result.rows as Note[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:findNoteByTitle:411": {
      "id": "file:src/services/notes.ts:fn:findNoteByTitle:411",
      "type": "function",
      "name": "findNoteByTitle",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 411,
      "endLine": 440,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches for a non-archived note by title via exact, partial, or semantic match.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function findNoteByTitle(title: string): Promise<Note | null> {\n  // First try exact match on title\n  let result = await pool.query(\n    `SELECT * FROM notes WHERE archived_at IS NULL AND LOWER(title) = LOWER($1) LIMIT 1`,\n    [title]\n  );\n\n  if (result.rows.length > 0) {\n    return result.rows[0] as Note;\n  }\n\n  // Then try partial match on title\n  result = await pool.query(\n    `SELECT * FROM notes WHERE archived_at IS NULL AND LOWER(title) LIKE LOWER($1) LIMIT 1`,\n    [`%${title}%`]\n  );\n\n  if (result.rows.length > 0) {\n    return result.rows[0] as Note;\n  }\n\n  // Finally try semantic search\n  const matches = await searchNotes(title, { limit: 1 });\n  const match = matches[0];\n  if (match && match.similarity > 0.7) {\n    return match;\n  }\n\n  return null;\n}",
      "references": [
        "pool",
        "result",
        "searchNotes",
        "matches",
        "match"
      ]
    },
    "file:src/services/notes.ts:fn:linkNoteToEntity:449": {
      "id": "file:src/services/notes.ts:fn:linkNoteToEntity:449",
      "type": "function",
      "name": "linkNoteToEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 449,
      "endLine": 476,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "noteId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "isPrimary",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": "false"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates note's entity_ids array and optionally primary_entity_id via DB UPDATE query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkNoteToEntity(\n  noteId: string,\n  entityId: string,\n  isPrimary: boolean = false\n): Promise<Note | null> {\n  if (isPrimary) {\n    const result = await pool.query(\n      `UPDATE notes \n       SET primary_entity_id = $1,\n           entity_ids = array_append(array_remove(entity_ids, $1), $1),\n           updated_at = NOW()\n       WHERE id = $2\n       RETURNING *`,\n      [entityId, noteId]\n    );\n    return (result.rows[0] as Note) ?? null;\n  } else {\n    const result = await pool.query(\n      `UPDATE notes \n       SET entity_ids = array_append(array_remove(entity_ids, $1), $1),\n           updated_at = NOW()\n       WHERE id = $2\n       RETURNING *`,\n      [entityId, noteId]\n    );\n    return (result.rows[0] as Note) ?? null;\n  }\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:unlinkNoteFromEntity:481": {
      "id": "file:src/services/notes.ts:fn:unlinkNoteFromEntity:481",
      "type": "function",
      "name": "unlinkNoteFromEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 481,
      "endLine": 495,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "noteId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unlinks entity from note by removing from entity_ids array and nulling primary_entity_id if matched",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unlinkNoteFromEntity(\n  noteId: string,\n  entityId: string\n): Promise<Note | null> {\n  const result = await pool.query(\n    `UPDATE notes \n     SET entity_ids = array_remove(entity_ids, $1),\n         primary_entity_id = CASE WHEN primary_entity_id = $1 THEN NULL ELSE primary_entity_id END,\n         updated_at = NOW()\n     WHERE id = $2\n     RETURNING *`,\n    [entityId, noteId]\n  );\n  return (result.rows[0] as Note) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/notes.ts:fn:pinNote:500": {
      "id": "file:src/services/notes.ts:fn:pinNote:500",
      "type": "function",
      "name": "pinNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 500,
      "endLine": 502,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Pins a note by calling updateNote to set is_pinned to true.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function pinNote(id: string): Promise<Note | null> {\n  return updateNote(id, { is_pinned: true });\n}",
      "references": [
        "updateNote"
      ]
    },
    "file:src/services/notes.ts:fn:unpinNote:507": {
      "id": "file:src/services/notes.ts:fn:unpinNote:507",
      "type": "function",
      "name": "unpinNote",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 507,
      "endLine": 509,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unpins a note by updating its is_pinned field to false.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unpinNote(id: string): Promise<Note | null> {\n  return updateNote(id, { is_pinned: false });\n}",
      "references": [
        "updateNote"
      ]
    },
    "file:src/services/notes.ts:fn:exportNotes:518": {
      "id": "file:src/services/notes.ts:fn:exportNotes:518",
      "type": "function",
      "name": "exportNotes",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 518,
      "endLine": 546,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").ExportOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/notes\").ExportResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches notes via listNotes and exports as markdown, CSV, or JSON.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportNotes(options: ExportOptions): Promise<ExportResult> {\n  const notes = await listNotes({\n    entity_id: options.entity_id,\n    category: options.category,\n    include_archived: options.include_archived,\n    limit: 10000, // High limit for export\n  });\n\n  let data: string;\n\n  switch (options.format) {\n    case 'markdown':\n      data = exportAsMarkdown(notes, options.include_metadata);\n      break;\n    case 'csv':\n      data = exportAsCsv(notes);\n      break;\n    case 'json':\n    default:\n      data = JSON.stringify(notes, null, 2);\n      break;\n  }\n\n  return {\n    format: options.format,\n    count: notes.length,\n    data,\n  };\n}",
      "references": [
        "listNotes",
        "data",
        "exportAsMarkdown",
        "notes",
        "exportAsCsv",
        "JSON"
      ]
    },
    "file:src/services/notes.ts:fn:exportAsMarkdown:548": {
      "id": "file:src/services/notes.ts:fn:exportAsMarkdown:548",
      "type": "function",
      "name": "exportAsMarkdown",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 548,
      "endLine": 575,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "notes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").Note[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "includeMetadata",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates Markdown export string from notes array, optionally with metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function exportAsMarkdown(notes: Note[], includeMetadata?: boolean): string {\n  const lines: string[] = ['# Notes Export', '', `Exported: ${new Date().toISOString()}`, ''];\n\n  for (const note of notes) {\n    if (note.title) {\n      lines.push(`## ${note.title}`);\n    } else {\n      lines.push(`## Note (${note.created_at.toISOString().split('T')[0]})`);\n    }\n\n    if (includeMetadata) {\n      lines.push('');\n      lines.push(`- **ID:** ${note.id}`);\n      lines.push(`- **Created:** ${note.created_at.toISOString()}`);\n      if (note.category) lines.push(`- **Category:** ${note.category}`);\n      if (note.tags.length > 0) lines.push(`- **Tags:** ${note.tags.join(', ')}`);\n      if (note.is_pinned) lines.push(`- **Pinned:** Yes`);\n    }\n\n    lines.push('');\n    lines.push(note.content);\n    lines.push('');\n    lines.push('---');\n    lines.push('');\n  }\n\n  return lines.join('\\n');\n}",
      "references": [
        "Date",
        "note",
        "lines"
      ]
    },
    "file:src/services/notes.ts:fn:exportAsCsv:577": {
      "id": "file:src/services/notes.ts:fn:exportAsCsv:577",
      "type": "function",
      "name": "exportAsCsv",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 577,
      "endLine": 591,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "notes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/notes\").Note[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a CSV string from an array of notes.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function exportAsCsv(notes: Note[]): string {\n  const headers = ['id', 'title', 'content', 'category', 'tags', 'is_pinned', 'created_at', 'updated_at'];\n  const rows = notes.map(note => [\n    note.id,\n    escapeCsvField(note.title ?? ''),\n    escapeCsvField(note.content),\n    note.category ?? '',\n    note.tags.join(';'),\n    note.is_pinned ? 'true' : 'false',\n    note.created_at.toISOString(),\n    note.updated_at.toISOString(),\n  ]);\n\n  return [headers.join(','), ...rows.map(row => row.join(','))].join('\\n');\n}",
      "references": [
        "note",
        "escapeCsvField",
        "headers",
        "rows",
        "row"
      ]
    },
    "file:src/services/notes.ts:fn:escapeCsvField:593": {
      "id": "file:src/services/notes.ts:fn:escapeCsvField:593",
      "type": "function",
      "name": "escapeCsvField",
      "filePath": "/home/ridgetop/projects/squire/src/services/notes.ts",
      "line": 593,
      "endLine": 598,
      "parentFileId": "file:src/services/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "field",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Escapes CSV field by quoting if it contains ',' '\"' or '\\n', doubling internal quotes.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.088Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function escapeCsvField(field: string): string {\n  if (field.includes(',') || field.includes('\"') || field.includes('\\n')) {\n    return `\"${field.replace(/\"/g, '\"\"')}\"`;\n  }\n  return field;\n}",
      "references": []
    },
    "file:src/services/objects.ts": {
      "id": "file:src/services/objects.ts",
      "type": "file",
      "name": "objects.ts",
      "filePath": "src/services/objects.ts",
      "line": 1,
      "endLine": 1043,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "path",
          "items": [
            {
              "name": "path",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "crypto",
          "items": [
            {
              "name": "crypto",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectByHash",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listObjects",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unlinkFromMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectsForMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getMemoriesForObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkToEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unlinkFromEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectsForEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntitiesForObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "addTag",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "removeTag",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectTags",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllTags",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createCollection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCollectionById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listCollections",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "addToCollection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "removeFromCollection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCollectionObjects",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateProcessingStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateObjectEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchObjectsSemantic",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getObjectStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "OBJECT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ObjectType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "STORAGE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "StorageType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "OBJECT_SOURCES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ObjectSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "OBJECT_STATUSES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ObjectStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "PROCESSING_STATUSES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ProcessingStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "MEMORY_LINK_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "MemoryLinkType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ENTITY_LINK_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "EntityLinkType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DETECTION_METHODS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DetectionMethod",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "TAG_SOURCES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "TagSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "StoredObject",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ObjectMemoryLink",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ObjectEntityLink",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ObjectTag",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ObjectCollection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateObjectInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateObjectResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListObjectsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ObjectStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/objects.ts:fn:ensureStorageDir:116",
        "file:src/services/objects.ts:fn:calculateHash:125",
        "file:src/services/objects.ts:fn:getObjectTypeFromMime:132",
        "file:src/services/objects.ts:fn:createObject:180",
        "file:src/services/objects.ts:fn:getObjectById:270",
        "file:src/services/objects.ts:fn:getObjectByHash:279",
        "file:src/services/objects.ts:fn:listObjects:301",
        "file:src/services/objects.ts:fn:updateObject:350",
        "file:src/services/objects.ts:fn:deleteObject:400",
        "file:src/services/objects.ts:fn:getObjectData:413",
        "file:src/services/objects.ts:fn:linkToMemory:434",
        "file:src/services/objects.ts:fn:unlinkFromMemory:459",
        "file:src/services/objects.ts:fn:getObjectsForMemory:470",
        "file:src/services/objects.ts:fn:getMemoriesForObject:497",
        "file:src/services/objects.ts:fn:linkToEntity:510",
        "file:src/services/objects.ts:fn:unlinkFromEntity:535",
        "file:src/services/objects.ts:fn:getObjectsForEntity:556",
        "file:src/services/objects.ts:fn:getEntitiesForObject:584",
        "file:src/services/objects.ts:fn:addTag:597",
        "file:src/services/objects.ts:fn:removeTag:632",
        "file:src/services/objects.ts:fn:getObjectTags:643",
        "file:src/services/objects.ts:fn:getAllTags:654",
        "file:src/services/objects.ts:fn:createCollection:671",
        "file:src/services/objects.ts:fn:getCollectionById:687",
        "file:src/services/objects.ts:fn:listCollections:696",
        "file:src/services/objects.ts:fn:addToCollection:706",
        "file:src/services/objects.ts:fn:removeFromCollection:747",
        "file:src/services/objects.ts:fn:getCollectionObjects:770",
        "file:src/services/objects.ts:fn:updateProcessingStatus:786",
        "file:src/services/objects.ts:fn:generateObjectEmbedding:838",
        "file:src/services/objects.ts:fn:searchObjectsSemantic:859",
        "file:src/services/objects.ts:fn:getObjectStats:909",
        "file:src/services/objects.ts:fn:mapRowToObject:969",
        "file:src/services/objects.ts:fn:mapRowToMemoryLink:997",
        "file:src/services/objects.ts:fn:mapRowToEntityLink:1009",
        "file:src/services/objects.ts:fn:mapRowToTag:1022",
        "file:src/services/objects.ts:fn:mapRowToCollection:1032"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:src/services/objects.ts:fn:ensureStorageDir:116": {
      "id": "file:src/services/objects.ts:fn:ensureStorageDir:116",
      "type": "function",
      "name": "ensureStorageDir",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 116,
      "endLine": 120,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subdir",
          "type": "string",
          "isOptional": true,
          "defaultValue": "''"
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates storage directory at STORAGE_BASE/subdir recursively and returns path",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": true,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function ensureStorageDir(subdir: string = ''): Promise<string> {\n  const dir = path.join(STORAGE_BASE, subdir);\n  await fs.mkdir(dir, { recursive: true });\n  return dir;\n}",
      "references": [
        "path",
        "STORAGE_BASE",
        "fs",
        "dir"
      ]
    },
    "file:src/services/objects.ts:fn:calculateHash:125": {
      "id": "file:src/services/objects.ts:fn:calculateHash:125",
      "type": "function",
      "name": "calculateHash",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 125,
      "endLine": 127,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Computes SHA256 hash of a Buffer and returns it as a hexadecimal string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateHash(buffer: Buffer): string {\n  return crypto.createHash('sha256').update(buffer).digest('hex');\n}",
      "references": [
        "crypto"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectTypeFromMime:132": {
      "id": "file:src/services/objects.ts:fn:getObjectTypeFromMime:132",
      "type": "function",
      "name": "getObjectTypeFromMime",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 132,
      "endLine": 154,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "\"image\" | \"document\" | \"audio\" | \"video\" | \"archive\" | \"other\"",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps MIME type string to object type (image, audio, video, document, archive, other).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getObjectTypeFromMime(mimeType: string): ObjectType {\n  if (mimeType.startsWith('image/')) return 'image';\n  if (mimeType.startsWith('audio/')) return 'audio';\n  if (mimeType.startsWith('video/')) return 'video';\n  if (\n    mimeType.startsWith('text/') ||\n    mimeType === 'application/pdf' ||\n    mimeType.includes('document') ||\n    mimeType.includes('spreadsheet') ||\n    mimeType.includes('presentation')\n  ) {\n    return 'document';\n  }\n  if (\n    mimeType === 'application/zip' ||\n    mimeType === 'application/x-tar' ||\n    mimeType === 'application/gzip' ||\n    mimeType === 'application/x-rar-compressed'\n  ) {\n    return 'archive';\n  }\n  return 'other';\n}",
      "references": []
    },
    "file:src/services/objects.ts:fn:createObject:180": {
      "id": "file:src/services/objects.ts:fn:createObject:180",
      "type": "function",
      "name": "createObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 180,
      "endLine": 265,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/objects\").CreateObjectInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").CreateObjectResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates object by writing file to disk, inserting to DB, deduplicating by hash.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": true,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createObject(input: CreateObjectInput): Promise<CreateObjectResult> {\n  const {\n    name,\n    filename,\n    mimeType,\n    data,\n    description,\n    source = 'upload',\n    sourceUrl,\n    metadata = {},\n  } = input;\n\n  // Calculate hash for deduplication\n  const hash = calculateHash(data);\n\n  // Check for duplicate\n  const dupCheck = await pool.query(\n    `SELECT id FROM objects WHERE hash_sha256 = $1 AND status = 'active'`,\n    [hash]\n  );\n\n  if (dupCheck.rows.length > 0) {\n    const existingId = dupCheck.rows[0].id as string;\n    const existing = await getObjectById(existingId);\n    return {\n      object: existing!,\n      tags: await getObjectTags(existingId),\n      isDuplicate: true,\n      existingId,\n    };\n  }\n\n  // Determine object type and storage path\n  const objectType = getObjectTypeFromMime(mimeType);\n  const datePrefix = new Date().toISOString().slice(0, 7); // YYYY-MM\n  const storageSubdir = `${objectType}/${datePrefix}`;\n  await ensureStorageDir(storageSubdir);\n\n  // Generate unique filename\n  const ext = path.extname(filename) || '';\n  const uniqueFilename = `${crypto.randomUUID()}${ext}`;\n  const storagePath = path.join(storageSubdir, uniqueFilename);\n  const fullPath = path.join(STORAGE_BASE, storagePath);\n\n  // Write file to disk\n  await fs.writeFile(fullPath, data);\n\n  // Insert into database\n  const result = await pool.query(\n    `INSERT INTO objects (\n      name, filename, mime_type, size_bytes, hash_sha256,\n      storage_type, storage_path, object_type,\n      description, metadata, source, source_url,\n      processing_status\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\n    RETURNING *`,\n    [\n      name,\n      filename,\n      mimeType,\n      data.length,\n      hash,\n      'local',\n      storagePath,\n      objectType,\n      description || null,\n      JSON.stringify(metadata),\n      source,\n      sourceUrl || null,\n      'pending',\n    ]\n  );\n\n  const object = mapRowToObject(result.rows[0]);\n\n  // Add tags if provided\n  const tags: ObjectTag[] = [];\n  if (input.tags && input.tags.length > 0) {\n    for (const tag of input.tags) {\n      const tagResult = await addTag(object.id, tag, 'user');\n      if (tagResult) tags.push(tagResult);\n    }\n  }\n\n  return { object, tags, isDuplicate: false };\n}",
      "references": [
        "name",
        "filename",
        "mimeType",
        "data",
        "description",
        "source",
        "sourceUrl",
        "metadata",
        "calculateHash",
        "pool",
        "hash",
        "dupCheck",
        "getObjectById",
        "existingId",
        "existing",
        "getObjectTags",
        "getObjectTypeFromMime",
        "Date",
        "objectType",
        "datePrefix",
        "ensureStorageDir",
        "storageSubdir",
        "path",
        "crypto",
        "ext",
        "uniqueFilename",
        "STORAGE_BASE",
        "storagePath",
        "fs",
        "fullPath",
        "JSON",
        "mapRowToObject",
        "result",
        "addTag",
        "tag",
        "tagResult",
        "tags"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectById:270": {
      "id": "file:src/services/objects.ts:fn:getObjectById:270",
      "type": "function",
      "name": "getObjectById",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 270,
      "endLine": 274,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a StoredObject from the database by ID or returns null if not found.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectById(id: string): Promise<StoredObject | null> {\n  const result = await pool.query(`SELECT * FROM objects WHERE id = $1`, [id]);\n  if (result.rows.length === 0) return null;\n  return mapRowToObject(result.rows[0]);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectByHash:279": {
      "id": "file:src/services/objects.ts:fn:getObjectByHash:279",
      "type": "function",
      "name": "getObjectByHash",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 279,
      "endLine": 286,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "hash",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves an active StoredObject from database by SHA256 hash or null.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectByHash(hash: string): Promise<StoredObject | null> {\n  const result = await pool.query(\n    `SELECT * FROM objects WHERE hash_sha256 = $1 AND status = 'active'`,\n    [hash]\n  );\n  if (result.rows.length === 0) return null;\n  return mapRowToObject(result.rows[0]);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:listObjects:301": {
      "id": "file:src/services/objects.ts:fn:listObjects:301",
      "type": "function",
      "name": "listObjects",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 301,
      "endLine": 345,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/objects\").ListObjectsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for stored objects with filters, search, tag join, pagination.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listObjects(options: ListObjectsOptions = {}): Promise<StoredObject[]> {\n  const { limit = 50, offset = 0, objectType, status = 'active', processingStatus, tag, search } = options;\n\n  let query = `SELECT o.* FROM objects o`;\n  const params: unknown[] = [];\n  const conditions: string[] = [];\n  let paramIndex = 1;\n\n  // Join for tag filtering\n  if (tag) {\n    query += ` JOIN object_tags t ON o.id = t.object_id`;\n    conditions.push(`t.tag = $${paramIndex++}`);\n    params.push(tag.toLowerCase());\n  }\n\n  // Status filter\n  conditions.push(`o.status = $${paramIndex++}`);\n  params.push(status);\n\n  if (objectType) {\n    conditions.push(`o.object_type = $${paramIndex++}`);\n    params.push(objectType);\n  }\n\n  if (processingStatus) {\n    conditions.push(`o.processing_status = $${paramIndex++}`);\n    params.push(processingStatus);\n  }\n\n  if (search) {\n    conditions.push(`(o.name ILIKE $${paramIndex} OR o.filename ILIKE $${paramIndex} OR o.description ILIKE $${paramIndex})`);\n    params.push(`%${search}%`);\n    paramIndex++;\n  }\n\n  if (conditions.length > 0) {\n    query += ` WHERE ${conditions.join(' AND ')}`;\n  }\n\n  query += ` ORDER BY o.created_at DESC LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows.map(mapRowToObject);\n}",
      "references": [
        "limit",
        "offset",
        "objectType",
        "status",
        "processingStatus",
        "tag",
        "search",
        "query",
        "conditions",
        "paramIndex",
        "params",
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:updateObject:350": {
      "id": "file:src/services/objects.ts:fn:updateObject:350",
      "type": "function",
      "name": "updateObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 350,
      "endLine": 395,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "updates",
          "type": "{ name?: string; description?: string; metadata?: Record<string, unknown>; status?: \"active\" | \"archived\" | \"deleted\"; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates database object with provided fields, sets updated_at, returns updated object or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateObject(\n  id: string,\n  updates: {\n    name?: string;\n    description?: string;\n    metadata?: Record<string, unknown>;\n    status?: ObjectStatus;\n  }\n): Promise<StoredObject | null> {\n  const setClauses: string[] = ['updated_at = NOW()'];\n  const params: unknown[] = [];\n  let paramIndex = 1;\n\n  if (updates.name !== undefined) {\n    setClauses.push(`name = $${paramIndex++}`);\n    params.push(updates.name);\n  }\n\n  if (updates.description !== undefined) {\n    setClauses.push(`description = $${paramIndex++}`);\n    params.push(updates.description);\n  }\n\n  if (updates.metadata !== undefined) {\n    setClauses.push(`metadata = $${paramIndex++}`);\n    params.push(JSON.stringify(updates.metadata));\n  }\n\n  if (updates.status !== undefined) {\n    setClauses.push(`status = $${paramIndex++}`);\n    params.push(updates.status);\n    if (updates.status === 'deleted') {\n      setClauses.push(`deleted_at = NOW()`);\n    }\n  }\n\n  params.push(id);\n\n  const result = await pool.query(\n    `UPDATE objects SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n    params\n  );\n\n  if (result.rows.length === 0) return null;\n  return mapRowToObject(result.rows[0]);\n}",
      "references": [
        "setClauses",
        "paramIndex",
        "params",
        "JSON",
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:deleteObject:400": {
      "id": "file:src/services/objects.ts:fn:deleteObject:400",
      "type": "function",
      "name": "deleteObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 400,
      "endLine": 408,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Soft-deletes object by updating status to 'deleted' and returns success boolean",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteObject(id: string): Promise<boolean> {\n  const result = await pool.query(\n    `UPDATE objects SET status = 'deleted', deleted_at = NOW(), updated_at = NOW()\n     WHERE id = $1 AND status != 'deleted'\n     RETURNING id`,\n    [id]\n  );\n  return result.rows.length > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectData:413": {
      "id": "file:src/services/objects.ts:fn:getObjectData:413",
      "type": "function",
      "name": "getObjectData",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 413,
      "endLine": 427,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Buffer>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches object data as Buffer from local filesystem by ID or returns null if missing/deleted.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": true,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectData(id: string): Promise<Buffer | null> {\n  const obj = await getObjectById(id);\n  if (!obj || obj.status === 'deleted') return null;\n\n  if (obj.storage_type !== 'local') {\n    throw new Error(`Storage type ${obj.storage_type} not yet supported for reading`);\n  }\n\n  const fullPath = path.join(STORAGE_BASE, obj.storage_path);\n  try {\n    return await fs.readFile(fullPath);\n  } catch {\n    return null;\n  }\n}",
      "references": [
        "getObjectById",
        "obj",
        "Error",
        "path",
        "STORAGE_BASE",
        "fs",
        "fullPath"
      ]
    },
    "file:src/services/objects.ts:fn:linkToMemory:434": {
      "id": "file:src/services/objects.ts:fn:linkToMemory:434",
      "type": "function",
      "name": "linkToMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 434,
      "endLine": 454,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "linkType",
          "type": "\"attachment\" | \"source\" | \"reference\" | \"illustration\"",
          "isOptional": true,
          "defaultValue": "'attachment'"
        },
        {
          "name": "options",
          "type": "{ relevance?: number; notes?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectMemoryLink>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts or updates a link between object and memory in database, returns the link.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkToMemory(\n  objectId: string,\n  memoryId: string,\n  linkType: MemoryLinkType = 'attachment',\n  options: { relevance?: number; notes?: string } = {}\n): Promise<ObjectMemoryLink> {\n  const { relevance = 0.5, notes } = options;\n\n  const result = await pool.query(\n    `INSERT INTO object_memory_links (object_id, memory_id, link_type, relevance, notes)\n     VALUES ($1, $2, $3, $4, $5)\n     ON CONFLICT (object_id, memory_id) DO UPDATE SET\n       link_type = EXCLUDED.link_type,\n       relevance = EXCLUDED.relevance,\n       notes = EXCLUDED.notes\n     RETURNING *`,\n    [objectId, memoryId, linkType, relevance, notes || null]\n  );\n\n  return mapRowToMemoryLink(result.rows[0]);\n}",
      "references": [
        "relevance",
        "notes",
        "pool",
        "mapRowToMemoryLink",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:unlinkFromMemory:459": {
      "id": "file:src/services/objects.ts:fn:unlinkFromMemory:459",
      "type": "function",
      "name": "unlinkFromMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 459,
      "endLine": 465,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes object-memory link from database and returns true if row was deleted",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unlinkFromMemory(objectId: string, memoryId: string): Promise<boolean> {\n  const result = await pool.query(\n    `DELETE FROM object_memory_links WHERE object_id = $1 AND memory_id = $2 RETURNING id`,\n    [objectId, memoryId]\n  );\n  return result.rows.length > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectsForMemory:470": {
      "id": "file:src/services/objects.ts:fn:getObjectsForMemory:470",
      "type": "function",
      "name": "getObjectsForMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 470,
      "endLine": 492,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject & { link: import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectMemoryLink; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active objects linked to a memory ID from database with link details.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectsForMemory(memoryId: string): Promise<(StoredObject & { link: ObjectMemoryLink })[]> {\n  const result = await pool.query(\n    `SELECT o.*, l.id as link_id, l.link_type, l.relevance, l.notes, l.created_at as link_created_at\n     FROM objects o\n     JOIN object_memory_links l ON o.id = l.object_id\n     WHERE l.memory_id = $1 AND o.status = 'active'\n     ORDER BY l.relevance DESC, o.created_at DESC`,\n    [memoryId]\n  );\n\n  return result.rows.map((row) => ({\n    ...mapRowToObject(row),\n    link: {\n      id: row.link_id,\n      object_id: row.id,\n      memory_id: memoryId,\n      link_type: row.link_type,\n      relevance: row.relevance,\n      notes: row.notes,\n      created_at: row.link_created_at,\n    },\n  }));\n}",
      "references": [
        "pool",
        "result",
        "mapRowToObject",
        "row"
      ]
    },
    "file:src/services/objects.ts:fn:getMemoriesForObject:497": {
      "id": "file:src/services/objects.ts:fn:getMemoriesForObject:497",
      "type": "function",
      "name": "getMemoriesForObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 497,
      "endLine": 503,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectMemoryLink[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches memory links for an object ID from DB, ordered by created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getMemoriesForObject(objectId: string): Promise<ObjectMemoryLink[]> {\n  const result = await pool.query(\n    `SELECT * FROM object_memory_links WHERE object_id = $1 ORDER BY created_at DESC`,\n    [objectId]\n  );\n  return result.rows.map(mapRowToMemoryLink);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToMemoryLink"
      ]
    },
    "file:src/services/objects.ts:fn:linkToEntity:510": {
      "id": "file:src/services/objects.ts:fn:linkToEntity:510",
      "type": "function",
      "name": "linkToEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 510,
      "endLine": 530,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "linkType",
          "type": "\"depicts\" | \"represents\" | \"created_by\" | \"about\" | \"owned_by\"",
          "isOptional": true,
          "defaultValue": "'about'"
        },
        {
          "name": "options",
          "type": "{ confidence?: number; notes?: string; detectionMethod?: \"manual\" | \"import\" | \"face_detection\" | \"mention\" | \"llm\"; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectEntityLink>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Upserts a link between object and entity in database with given type, confidence, notes, method.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkToEntity(\n  objectId: string,\n  entityId: string,\n  linkType: EntityLinkType = 'about',\n  options: { confidence?: number; notes?: string; detectionMethod?: DetectionMethod } = {}\n): Promise<ObjectEntityLink> {\n  const { confidence = 0.5, notes, detectionMethod = 'manual' } = options;\n\n  const result = await pool.query(\n    `INSERT INTO object_entity_links (object_id, entity_id, link_type, confidence, notes, detection_method)\n     VALUES ($1, $2, $3, $4, $5, $6)\n     ON CONFLICT (object_id, entity_id, link_type) DO UPDATE SET\n       confidence = EXCLUDED.confidence,\n       notes = EXCLUDED.notes,\n       detection_method = EXCLUDED.detection_method\n     RETURNING *`,\n    [objectId, entityId, linkType, confidence, notes || null, detectionMethod]\n  );\n\n  return mapRowToEntityLink(result.rows[0]);\n}",
      "references": [
        "confidence",
        "notes",
        "detectionMethod",
        "pool",
        "mapRowToEntityLink",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:unlinkFromEntity:535": {
      "id": "file:src/services/objects.ts:fn:unlinkFromEntity:535",
      "type": "function",
      "name": "unlinkFromEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 535,
      "endLine": 551,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "linkType",
          "type": "\"depicts\" | \"represents\" | \"created_by\" | \"about\" | \"owned_by\"",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes object-entity link from database by IDs and optional link type.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.089Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unlinkFromEntity(\n  objectId: string,\n  entityId: string,\n  linkType?: EntityLinkType\n): Promise<boolean> {\n  let query = `DELETE FROM object_entity_links WHERE object_id = $1 AND entity_id = $2`;\n  const params: unknown[] = [objectId, entityId];\n\n  if (linkType) {\n    query += ` AND link_type = $3`;\n    params.push(linkType);\n  }\n\n  query += ` RETURNING id`;\n  const result = await pool.query(query, params);\n  return result.rows.length > 0;\n}",
      "references": [
        "query",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectsForEntity:556": {
      "id": "file:src/services/objects.ts:fn:getObjectsForEntity:556",
      "type": "function",
      "name": "getObjectsForEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 556,
      "endLine": 579,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject & { link: import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectEntityLink; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active objects linked to an entity from DB with link details.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectsForEntity(entityId: string): Promise<(StoredObject & { link: ObjectEntityLink })[]> {\n  const result = await pool.query(\n    `SELECT o.*, l.id as link_id, l.link_type, l.confidence, l.notes, l.detection_method, l.created_at as link_created_at\n     FROM objects o\n     JOIN object_entity_links l ON o.id = l.object_id\n     WHERE l.entity_id = $1 AND o.status = 'active'\n     ORDER BY l.confidence DESC, o.created_at DESC`,\n    [entityId]\n  );\n\n  return result.rows.map((row) => ({\n    ...mapRowToObject(row),\n    link: {\n      id: row.link_id,\n      object_id: row.id,\n      entity_id: entityId,\n      link_type: row.link_type,\n      confidence: row.confidence,\n      notes: row.notes,\n      detection_method: row.detection_method,\n      created_at: row.link_created_at,\n    },\n  }));\n}",
      "references": [
        "pool",
        "result",
        "mapRowToObject",
        "row"
      ]
    },
    "file:src/services/objects.ts:fn:getEntitiesForObject:584": {
      "id": "file:src/services/objects.ts:fn:getEntitiesForObject:584",
      "type": "function",
      "name": "getEntitiesForObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 584,
      "endLine": 590,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectEntityLink[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves entity links for object ID from database, ordered by confidence and created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEntitiesForObject(objectId: string): Promise<ObjectEntityLink[]> {\n  const result = await pool.query(\n    `SELECT * FROM object_entity_links WHERE object_id = $1 ORDER BY confidence DESC, created_at DESC`,\n    [objectId]\n  );\n  return result.rows.map(mapRowToEntityLink);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToEntityLink"
      ]
    },
    "file:src/services/objects.ts:fn:addTag:597": {
      "id": "file:src/services/objects.ts:fn:addTag:597",
      "type": "function",
      "name": "addTag",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 597,
      "endLine": 627,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tag",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "source",
          "type": "\"import\" | \"user\" | \"auto\"",
          "isOptional": true,
          "defaultValue": "'user'"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectTag>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Adds normalized tag to object in DB via INSERT, fetches if exists, returns ObjectTag or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function addTag(\n  objectId: string,\n  tag: string,\n  source: TagSource = 'user'\n): Promise<ObjectTag | null> {\n  const normalizedTag = tag.toLowerCase().trim();\n  if (!normalizedTag) return null;\n\n  try {\n    const result = await pool.query(\n      `INSERT INTO object_tags (object_id, tag, source)\n       VALUES ($1, $2, $3)\n       ON CONFLICT (object_id, tag) DO NOTHING\n       RETURNING *`,\n      [objectId, normalizedTag, source]\n    );\n\n    if (result.rows.length === 0) {\n      // Tag already exists, fetch it\n      const existing = await pool.query(\n        `SELECT * FROM object_tags WHERE object_id = $1 AND tag = $2`,\n        [objectId, normalizedTag]\n      );\n      return existing.rows.length > 0 ? mapRowToTag(existing.rows[0]) : null;\n    }\n\n    return mapRowToTag(result.rows[0]);\n  } catch {\n    return null;\n  }\n}",
      "references": [
        "normalizedTag",
        "pool",
        "result",
        "existing",
        "mapRowToTag"
      ]
    },
    "file:src/services/objects.ts:fn:removeTag:632": {
      "id": "file:src/services/objects.ts:fn:removeTag:632",
      "type": "function",
      "name": "removeTag",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 632,
      "endLine": 638,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tag",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a tag from object_tags table by objectId and returns true if deleted",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function removeTag(objectId: string, tag: string): Promise<boolean> {\n  const result = await pool.query(\n    `DELETE FROM object_tags WHERE object_id = $1 AND tag = $2 RETURNING id`,\n    [objectId, tag.toLowerCase().trim()]\n  );\n  return result.rows.length > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectTags:643": {
      "id": "file:src/services/objects.ts:fn:getObjectTags:643",
      "type": "function",
      "name": "getObjectTags",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 643,
      "endLine": 649,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectTag[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves tags for a given object ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectTags(objectId: string): Promise<ObjectTag[]> {\n  const result = await pool.query(\n    `SELECT * FROM object_tags WHERE object_id = $1 ORDER BY tag`,\n    [objectId]\n  );\n  return result.rows.map(mapRowToTag);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToTag"
      ]
    },
    "file:src/services/objects.ts:fn:getAllTags:654": {
      "id": "file:src/services/objects.ts:fn:getAllTags:654",
      "type": "function",
      "name": "getAllTags",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 654,
      "endLine": 664,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ tag: string; count: number; }[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves all tags with counts from active objects via SQL query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllTags(): Promise<{ tag: string; count: number }[]> {\n  const result = await pool.query(\n    `SELECT tag, COUNT(*) as count\n     FROM object_tags t\n     JOIN objects o ON t.object_id = o.id\n     WHERE o.status = 'active'\n     GROUP BY tag\n     ORDER BY count DESC, tag`\n  );\n  return result.rows.map((row) => ({ tag: row.tag, count: parseInt(row.count, 10) }));\n}",
      "references": [
        "pool",
        "result",
        "row",
        "parseInt"
      ]
    },
    "file:src/services/objects.ts:fn:createCollection:671": {
      "id": "file:src/services/objects.ts:fn:createCollection:671",
      "type": "function",
      "name": "createCollection",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 671,
      "endLine": 682,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "description",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectCollection>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a new object collection in the database with name and optional description",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createCollection(\n  name: string,\n  description?: string\n): Promise<ObjectCollection> {\n  const result = await pool.query(\n    `INSERT INTO object_collections (name, description)\n     VALUES ($1, $2)\n     RETURNING *`,\n    [name, description || null]\n  );\n  return mapRowToCollection(result.rows[0]);\n}",
      "references": [
        "pool",
        "mapRowToCollection",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getCollectionById:687": {
      "id": "file:src/services/objects.ts:fn:getCollectionById:687",
      "type": "function",
      "name": "getCollectionById",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 687,
      "endLine": 691,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectCollection>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves ObjectCollection by ID from database or returns null if not found",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCollectionById(id: string): Promise<ObjectCollection | null> {\n  const result = await pool.query(`SELECT * FROM object_collections WHERE id = $1`, [id]);\n  if (result.rows.length === 0) return null;\n  return mapRowToCollection(result.rows[0]);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToCollection"
      ]
    },
    "file:src/services/objects.ts:fn:listCollections:696": {
      "id": "file:src/services/objects.ts:fn:listCollections:696",
      "type": "function",
      "name": "listCollections",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 696,
      "endLine": 701,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectCollection[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves all object collections from DB, sorted by updated_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listCollections(): Promise<ObjectCollection[]> {\n  const result = await pool.query(\n    `SELECT * FROM object_collections ORDER BY updated_at DESC`\n  );\n  return result.rows.map(mapRowToCollection);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToCollection"
      ]
    },
    "file:src/services/objects.ts:fn:addToCollection:706": {
      "id": "file:src/services/objects.ts:fn:addToCollection:706",
      "type": "function",
      "name": "addToCollection",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 706,
      "endLine": 742,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "collectionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "position",
          "type": "number",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Adds object to collection at position (auto if unspecified), updates count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function addToCollection(\n  collectionId: string,\n  objectId: string,\n  position?: number\n): Promise<boolean> {\n  try {\n    // Get next position if not specified\n    if (position === undefined) {\n      const posResult = await pool.query(\n        `SELECT COALESCE(MAX(position), -1) + 1 as next_pos\n         FROM object_collection_items WHERE collection_id = $1`,\n        [collectionId]\n      );\n      position = posResult.rows[0].next_pos;\n    }\n\n    await pool.query(\n      `INSERT INTO object_collection_items (collection_id, object_id, position)\n       VALUES ($1, $2, $3)\n       ON CONFLICT (collection_id, object_id) DO UPDATE SET position = EXCLUDED.position`,\n      [collectionId, objectId, position]\n    );\n\n    // Update collection count\n    await pool.query(\n      `UPDATE object_collections SET\n         object_count = (SELECT COUNT(*) FROM object_collection_items WHERE collection_id = $1),\n         updated_at = NOW()\n       WHERE id = $1`,\n      [collectionId]\n    );\n\n    return true;\n  } catch {\n    return false;\n  }\n}",
      "references": [
        "pool",
        "posResult"
      ]
    },
    "file:src/services/objects.ts:fn:removeFromCollection:747": {
      "id": "file:src/services/objects.ts:fn:removeFromCollection:747",
      "type": "function",
      "name": "removeFromCollection",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 747,
      "endLine": 765,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "collectionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Removes object from collection via DELETE and updates collection object count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function removeFromCollection(collectionId: string, objectId: string): Promise<boolean> {\n  const result = await pool.query(\n    `DELETE FROM object_collection_items WHERE collection_id = $1 AND object_id = $2 RETURNING id`,\n    [collectionId, objectId]\n  );\n\n  if (result.rows.length > 0) {\n    // Update collection count\n    await pool.query(\n      `UPDATE object_collections SET\n         object_count = (SELECT COUNT(*) FROM object_collection_items WHERE collection_id = $1),\n         updated_at = NOW()\n       WHERE id = $1`,\n      [collectionId]\n    );\n    return true;\n  }\n  return false;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/objects.ts:fn:getCollectionObjects:770": {
      "id": "file:src/services/objects.ts:fn:getCollectionObjects:770",
      "type": "function",
      "name": "getCollectionObjects",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 770,
      "endLine": 779,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "collectionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active objects in a collection by ID from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCollectionObjects(collectionId: string): Promise<StoredObject[]> {\n  const result = await pool.query(\n    `SELECT o.* FROM objects o\n     JOIN object_collection_items i ON o.id = i.object_id\n     WHERE i.collection_id = $1 AND o.status = 'active'\n     ORDER BY i.position`,\n    [collectionId]\n  );\n  return result.rows.map(mapRowToObject);\n}",
      "references": [
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:updateProcessingStatus:786": {
      "id": "file:src/services/objects.ts:fn:updateProcessingStatus:786",
      "type": "function",
      "name": "updateProcessingStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 786,
      "endLine": 833,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "\"completed\" | \"pending\" | \"processing\" | \"failed\" | \"skipped\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ extractedText?: string; thumbnailPath?: string; embedding?: number[]; error?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates processing status and optional fields for an object in the database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateProcessingStatus(\n  id: string,\n  status: ProcessingStatus,\n  options: {\n    extractedText?: string;\n    thumbnailPath?: string;\n    embedding?: number[];\n    error?: string;\n  } = {}\n): Promise<StoredObject | null> {\n  const setClauses: string[] = ['processing_status = $1', 'updated_at = NOW()'];\n  const params: unknown[] = [status];\n  let paramIndex = 2;\n\n  if (status === 'completed' || status === 'failed') {\n    setClauses.push(`processed_at = NOW()`);\n  }\n\n  if (options.extractedText !== undefined) {\n    setClauses.push(`extracted_text = $${paramIndex++}`);\n    params.push(options.extractedText);\n  }\n\n  if (options.thumbnailPath !== undefined) {\n    setClauses.push(`thumbnail_path = $${paramIndex++}`);\n    params.push(options.thumbnailPath);\n  }\n\n  if (options.embedding !== undefined) {\n    setClauses.push(`embedding = $${paramIndex++}`);\n    params.push(`[${options.embedding.join(',')}]`);\n  }\n\n  if (options.error !== undefined) {\n    setClauses.push(`processing_error = $${paramIndex++}`);\n    params.push(options.error);\n  }\n\n  params.push(id);\n\n  const result = await pool.query(\n    `UPDATE objects SET ${setClauses.join(', ')} WHERE id = $${paramIndex} RETURNING *`,\n    params\n  );\n\n  if (result.rows.length === 0) return null;\n  return mapRowToObject(result.rows[0]);\n}",
      "references": [
        "setClauses",
        "paramIndex",
        "params",
        "pool",
        "result",
        "mapRowToObject"
      ]
    },
    "file:src/services/objects.ts:fn:generateObjectEmbedding:838": {
      "id": "file:src/services/objects.ts:fn:generateObjectEmbedding:838",
      "type": "function",
      "name": "generateObjectEmbedding",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 838,
      "endLine": 852,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embedding for object by ID from text and updates DB status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateObjectEmbedding(id: string): Promise<boolean> {\n  const obj = await getObjectById(id);\n  if (!obj) return false;\n\n  const textToEmbed = obj.description || obj.extracted_text || obj.name;\n  if (!textToEmbed) return false;\n\n  try {\n    const embedding = await generateEmbedding(textToEmbed);\n    await updateProcessingStatus(id, obj.processing_status, { embedding });\n    return true;\n  } catch {\n    return false;\n  }\n}",
      "references": [
        "getObjectById",
        "obj",
        "textToEmbed",
        "generateEmbedding",
        "updateProcessingStatus",
        "embedding"
      ]
    },
    "file:src/services/objects.ts:fn:searchObjectsSemantic:859": {
      "id": "file:src/services/objects.ts:fn:searchObjectsSemantic:859",
      "type": "function",
      "name": "searchObjectsSemantic",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 859,
      "endLine": 890,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; objectType?: \"image\" | \"document\" | \"audio\" | \"video\" | \"archive\" | \"other\"; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject & { similarity: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Performs semantic search on active objects using vector embeddings from database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.090Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchObjectsSemantic(\n  query: string,\n  options: { limit?: number; objectType?: ObjectType } = {}\n): Promise<(StoredObject & { similarity: number })[]> {\n  const { limit = 20, objectType } = options;\n\n  const queryEmbedding = await generateEmbedding(query);\n  const embeddingStr = `[${queryEmbedding.join(',')}]`;\n\n  let queryStr = `\n    SELECT o.*, 1 - (o.embedding <=> $1::vector) as similarity\n    FROM objects o\n    WHERE o.status = 'active'\n      AND o.embedding IS NOT NULL\n  `;\n  const params: unknown[] = [embeddingStr];\n  let paramIndex = 2;\n\n  if (objectType) {\n    queryStr += ` AND o.object_type = $${paramIndex++}`;\n    params.push(objectType);\n  }\n\n  queryStr += ` ORDER BY similarity DESC LIMIT $${paramIndex}`;\n  params.push(limit);\n\n  const result = await pool.query(queryStr, params);\n  return result.rows.map((row) => ({\n    ...mapRowToObject(row),\n    similarity: parseFloat(row.similarity),\n  }));\n}",
      "references": [
        "limit",
        "objectType",
        "generateEmbedding",
        "queryEmbedding",
        "embeddingStr",
        "queryStr",
        "paramIndex",
        "params",
        "pool",
        "result",
        "mapRowToObject",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/objects.ts:fn:getObjectStats:909": {
      "id": "file:src/services/objects.ts:fn:getObjectStats:909",
      "type": "function",
      "name": "getObjectStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 909,
      "endLine": 965,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectStats>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches object statistics by type, status, processing, size, tags, collections, and links from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getObjectStats(): Promise<ObjectStats> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE object_type = 'image') as images,\n      COUNT(*) FILTER (WHERE object_type = 'document') as documents,\n      COUNT(*) FILTER (WHERE object_type = 'audio') as audio,\n      COUNT(*) FILTER (WHERE object_type = 'video') as video,\n      COUNT(*) FILTER (WHERE object_type = 'archive') as archives,\n      COUNT(*) FILTER (WHERE object_type = 'other') as other_type,\n      COUNT(*) FILTER (WHERE status = 'active') as active,\n      COUNT(*) FILTER (WHERE status = 'archived') as archived,\n      COUNT(*) FILTER (WHERE status = 'deleted') as deleted,\n      COUNT(*) FILTER (WHERE processing_status = 'pending') as pending,\n      COUNT(*) FILTER (WHERE processing_status = 'processing') as processing,\n      COUNT(*) FILTER (WHERE processing_status = 'completed') as completed,\n      COUNT(*) FILTER (WHERE processing_status = 'failed') as failed,\n      COUNT(*) FILTER (WHERE processing_status = 'skipped') as skipped,\n      COALESCE(SUM(size_bytes), 0) as total_size\n    FROM objects\n  `);\n\n  const tagCountResult = await pool.query(`SELECT COUNT(DISTINCT tag) as count FROM object_tags`);\n  const collectionResult = await pool.query(`SELECT COUNT(*) as count FROM object_collections`);\n  const memoryLinksResult = await pool.query(`SELECT COUNT(*) as count FROM object_memory_links`);\n  const entityLinksResult = await pool.query(`SELECT COUNT(*) as count FROM object_entity_links`);\n\n  const row = result.rows[0];\n  return {\n    total: parseInt(row.total, 10),\n    by_type: {\n      image: parseInt(row.images, 10),\n      document: parseInt(row.documents, 10),\n      audio: parseInt(row.audio, 10),\n      video: parseInt(row.video, 10),\n      archive: parseInt(row.archives, 10),\n      other: parseInt(row.other_type, 10),\n    },\n    by_status: {\n      active: parseInt(row.active, 10),\n      archived: parseInt(row.archived, 10),\n      deleted: parseInt(row.deleted, 10),\n    },\n    by_processing: {\n      pending: parseInt(row.pending, 10),\n      processing: parseInt(row.processing, 10),\n      completed: parseInt(row.completed, 10),\n      failed: parseInt(row.failed, 10),\n      skipped: parseInt(row.skipped, 10),\n    },\n    total_size_bytes: parseInt(row.total_size, 10),\n    tag_count: parseInt(tagCountResult.rows[0].count, 10),\n    collection_count: parseInt(collectionResult.rows[0].count, 10),\n    memory_links: parseInt(memoryLinksResult.rows[0].count, 10),\n    entity_links: parseInt(entityLinksResult.rows[0].count, 10),\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row",
        "tagCountResult",
        "collectionResult",
        "memoryLinksResult",
        "entityLinksResult"
      ]
    },
    "file:src/services/objects.ts:fn:mapRowToObject:969": {
      "id": "file:src/services/objects.ts:fn:mapRowToObject:969",
      "type": "function",
      "name": "mapRowToObject",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 969,
      "endLine": 995,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/objects\").StoredObject",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps database row to StoredObject with type casts, parsing, and Date creation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapRowToObject(row: Record<string, unknown>): StoredObject {\n  return {\n    id: row.id as string,\n    name: row.name as string,\n    filename: row.filename as string,\n    mime_type: row.mime_type as string,\n    size_bytes: parseInt(row.size_bytes as string, 10),\n    hash_sha256: row.hash_sha256 as string | null,\n    storage_type: row.storage_type as StorageType,\n    storage_path: row.storage_path as string,\n    object_type: row.object_type as ObjectType,\n    extracted_text: row.extracted_text as string | null,\n    description: row.description as string | null,\n    metadata: (row.metadata || {}) as Record<string, unknown>,\n    embedding: row.embedding as number[] | null,\n    processing_status: row.processing_status as ProcessingStatus,\n    processing_error: row.processing_error as string | null,\n    processed_at: row.processed_at ? new Date(row.processed_at as string) : null,\n    thumbnail_path: row.thumbnail_path as string | null,\n    source: row.source as ObjectSource,\n    source_url: row.source_url as string | null,\n    status: row.status as ObjectStatus,\n    deleted_at: row.deleted_at ? new Date(row.deleted_at as string) : null,\n    created_at: new Date(row.created_at as string),\n    updated_at: new Date(row.updated_at as string),\n  };\n}",
      "references": [
        "parseInt",
        "Date"
      ]
    },
    "file:src/services/objects.ts:fn:mapRowToMemoryLink:997": {
      "id": "file:src/services/objects.ts:fn:mapRowToMemoryLink:997",
      "type": "function",
      "name": "mapRowToMemoryLink",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 997,
      "endLine": 1007,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectMemoryLink",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps a database row to an ObjectMemoryLink object.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapRowToMemoryLink(row: Record<string, unknown>): ObjectMemoryLink {\n  return {\n    id: row.id as string,\n    object_id: row.object_id as string,\n    memory_id: row.memory_id as string,\n    link_type: row.link_type as MemoryLinkType,\n    relevance: parseFloat(row.relevance as string),\n    notes: row.notes as string | null,\n    created_at: new Date(row.created_at as string),\n  };\n}",
      "references": [
        "parseFloat",
        "Date"
      ]
    },
    "file:src/services/objects.ts:fn:mapRowToEntityLink:1009": {
      "id": "file:src/services/objects.ts:fn:mapRowToEntityLink:1009",
      "type": "function",
      "name": "mapRowToEntityLink",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 1009,
      "endLine": 1020,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectEntityLink",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps database row to ObjectEntityLink entity object",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapRowToEntityLink(row: Record<string, unknown>): ObjectEntityLink {\n  return {\n    id: row.id as string,\n    object_id: row.object_id as string,\n    entity_id: row.entity_id as string,\n    link_type: row.link_type as EntityLinkType,\n    confidence: parseFloat(row.confidence as string),\n    notes: row.notes as string | null,\n    detection_method: row.detection_method as DetectionMethod,\n    created_at: new Date(row.created_at as string),\n  };\n}",
      "references": [
        "parseFloat",
        "Date"
      ]
    },
    "file:src/services/objects.ts:fn:mapRowToTag:1022": {
      "id": "file:src/services/objects.ts:fn:mapRowToTag:1022",
      "type": "function",
      "name": "mapRowToTag",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 1022,
      "endLine": 1030,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectTag",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps a database row to an ObjectTag object.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapRowToTag(row: Record<string, unknown>): ObjectTag {\n  return {\n    id: row.id as string,\n    object_id: row.object_id as string,\n    tag: row.tag as string,\n    source: row.source as TagSource,\n    created_at: new Date(row.created_at as string),\n  };\n}",
      "references": [
        "Date"
      ]
    },
    "file:src/services/objects.ts:fn:mapRowToCollection:1032": {
      "id": "file:src/services/objects.ts:fn:mapRowToCollection:1032",
      "type": "function",
      "name": "mapRowToCollection",
      "filePath": "/home/ridgetop/projects/squire/src/services/objects.ts",
      "line": 1032,
      "endLine": 1042,
      "parentFileId": "file:src/services/objects.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/objects\").ObjectCollection",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps a database row object to an ObjectCollection instance.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapRowToCollection(row: Record<string, unknown>): ObjectCollection {\n  return {\n    id: row.id as string,\n    name: row.name as string,\n    description: row.description as string | null,\n    cover_object_id: row.cover_object_id as string | null,\n    object_count: parseInt(row.object_count as string, 10),\n    created_at: new Date(row.created_at as string),\n    updated_at: new Date(row.updated_at as string),\n  };\n}",
      "references": [
        "parseInt",
        "Date"
      ]
    },
    "file:src/services/patterns.ts": {
      "id": "file:src/services/patterns.ts",
      "type": "file",
      "name": "patterns.ts",
      "filePath": "src/services/patterns.ts",
      "line": 1,
      "endLine": 567,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "completeText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getPattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllPatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPatternsByType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPatternsByEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPatternEvidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markStalePatternsDormant",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPatternStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isValidPatternType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPatternTypeDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "processMemoryForPatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PATTERN_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "PatternType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "TIME_OF_DAY",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "TimeOfDay",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DAY_OF_WEEK",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DayOfWeek",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Pattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PatternEvidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PatternDetectionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/patterns.ts:fn:extractPatternsFromContent:85",
        "file:src/services/patterns.ts:fn:findSimilarPattern:174",
        "file:src/services/patterns.ts:fn:createPattern:204",
        "file:src/services/patterns.ts:fn:getPattern:241",
        "file:src/services/patterns.ts:fn:getAllPatterns:252",
        "file:src/services/patterns.ts:fn:getPatternsByType:317",
        "file:src/services/patterns.ts:fn:getPatternsByEntity:324",
        "file:src/services/patterns.ts:fn:reinforcePattern:337",
        "file:src/services/patterns.ts:fn:linkEvidence:366",
        "file:src/services/patterns.ts:fn:getPatternEvidence:399",
        "file:src/services/patterns.ts:fn:markStalePatternsDormant:418",
        "file:src/services/patterns.ts:fn:getPatternStats:437",
        "file:src/services/patterns.ts:fn:isValidPatternType:493",
        "file:src/services/patterns.ts:fn:getPatternTypeDescription:500",
        "file:src/services/patterns.ts:fn:processMemoryForPatterns:523"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/patterns.ts:fn:extractPatternsFromContent:85": {
      "id": "file:src/services/patterns.ts:fn:extractPatternsFromContent:85",
      "type": "function",
      "name": "extractPatternsFromContent",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 85,
      "endLine": 167,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "existingPatterns",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern[]",
          "isOptional": true,
          "defaultValue": "[]"
        }
      ],
      "returnType": "Promise<ExtractedPattern[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Uses AI completion to extract patterns from content, considering existing patterns",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function extractPatternsFromContent(\n  content: string,\n  existingPatterns: Pattern[] = []\n): Promise<ExtractedPattern[]> {\n  const systemPrompt = `You are a pattern detector. Given a memory/observation, identify any recurring patterns this might indicate about the person.\n\nA pattern is a recurring behavior, tendency, or rhythm - NOT a one-time event.\n\nPattern types:\n- behavioral: Recurring actions/habits (\"checks email first thing\", \"procrastinates on complex tasks\")\n- temporal: Time-based rhythms (\"most productive in the morning\", \"energy dips after lunch\")\n- emotional: Emotional tendencies (\"gets anxious before presentations\", \"energized by deadlines\")\n- social: Interaction patterns (\"prefers 1-on-1 meetings\", \"avoids large groups\")\n- cognitive: Thinking patterns (\"overthinks decisions\", \"thinks best while walking\")\n- physical: Body/health patterns (\"tired after lunch\", \"exercises when stressed\")\n\nTime indicators (optional):\n- time_of_day: early_morning, morning, midday, afternoon, evening, night, late_night\n- day_of_week: monday, tuesday, etc., or weekday/weekend\n\nReturn ONLY a JSON array of patterns. Include confidence (0.0-1.0) and frequency (0.0=rare, 1.0=constant).\nIf no patterns are present, return an empty array: []\n\nFormat: [{\"content\": \"pattern description\", \"pattern_type\": \"type\", \"confidence\": 0.X, \"frequency\": 0.X, \"time_of_day\": \"morning\" or null, \"day_of_week\": \"monday\" or null, \"entity_name\": \"name if about specific person/project\", \"reason\": \"why this is a pattern\"}]`;\n\n  const existingInfo = existingPatterns.length > 0\n    ? `\\n\\nExisting patterns (check for reinforcement):\\n${existingPatterns.map((p) => `- ${p.content}`).join('\\n')}`\n    : '';\n\n  const prompt = `Memory: \"${content}\"${existingInfo}\n\nWhat patterns does this memory reveal or reinforce? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.2,\n      maxTokens: 600,\n    });\n\n    // Parse JSON response\n    const jsonMatch = response.match(/\\[[\\s\\S]*?\\]/);\n    if (!jsonMatch) {\n      return [];\n    }\n\n    const extracted = JSON.parse(jsonMatch[0]) as Array<{\n      content: string;\n      pattern_type: string;\n      confidence: number;\n      frequency?: number;\n      time_of_day?: string;\n      day_of_week?: string;\n      entity_name?: string;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    return extracted\n      .filter(\n        (p) =>\n          PATTERN_TYPES.includes(p.pattern_type as PatternType) &&\n          p.content &&\n          p.confidence >= 0.3\n      )\n      .map((p) => ({\n        content: p.content,\n        pattern_type: p.pattern_type as PatternType,\n        confidence: Math.min(1.0, Math.max(0.0, p.confidence)),\n        frequency: p.frequency ? Math.min(1.0, Math.max(0.0, p.frequency)) : undefined,\n        time_of_day: TIME_OF_DAY.includes(p.time_of_day as TimeOfDay)\n          ? (p.time_of_day as TimeOfDay)\n          : undefined,\n        day_of_week: DAY_OF_WEEK.includes(p.day_of_week as DayOfWeek)\n          ? (p.day_of_week as DayOfWeek)\n          : undefined,\n        entity_name: p.entity_name,\n        reason: p.reason || '',\n      }));\n  } catch (error) {\n    console.error('Pattern extraction failed:', error);\n    return [];\n  }\n}",
      "references": [
        "p",
        "existingInfo",
        "completeText",
        "prompt",
        "systemPrompt",
        "response",
        "jsonMatch",
        "JSON",
        "extracted",
        "PATTERN_TYPES",
        "Math",
        "TIME_OF_DAY",
        "DAY_OF_WEEK",
        "console",
        "error"
      ]
    },
    "file:src/services/patterns.ts:fn:findSimilarPattern:174": {
      "id": "file:src/services/patterns.ts:fn:findSimilarPattern:174",
      "type": "function",
      "name": "findSimilarPattern",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 174,
      "endLine": 197,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "patternType",
          "type": "\"behavioral\" | \"temporal\" | \"emotional\" | \"social\" | \"cognitive\" | \"physical\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for active pattern matching normalized content and type exactly.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findSimilarPattern(\n  content: string,\n  patternType: PatternType\n): Promise<Pattern | null> {\n  // Normalize for comparison\n  const normalized = content.toLowerCase().trim();\n\n  // Look for patterns of same type with similar content\n  const result = await pool.query<Pattern>(\n    `SELECT * FROM patterns\n     WHERE pattern_type = $1\n       AND status = 'active'\n       AND LOWER(content) = $2\n     LIMIT 1`,\n    [patternType, normalized]\n  );\n\n  if (result.rows[0]) {\n    return result.rows[0];\n  }\n\n  // TODO: Add embedding-based similarity search\n  return null;\n}",
      "references": [
        "pool",
        "normalized",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:createPattern:204": {
      "id": "file:src/services/patterns.ts:fn:createPattern:204",
      "type": "function",
      "name": "createPattern",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 204,
      "endLine": 236,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "patternType",
          "type": "\"behavioral\" | \"temporal\" | \"emotional\" | \"social\" | \"cognitive\" | \"physical\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "confidence",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ frequency?: number; timeOfDay?: \"early_morning\" | \"morning\" | \"midday\" | \"afternoon\" | \"evening\" | \"night\" | \"late_night\"; dayOfWeek?: \"monday\" | \"tuesday\" | \"wednesday\" | \"thursday\" | \"friday\" | \"saturday\" | \"sunday\" | \"weekday\" | \"weekend\"; relatedEntityId?: string; model?: string; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new pattern into the database and returns the created record",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function createPattern(\n  content: string,\n  patternType: PatternType,\n  confidence: number,\n  options?: {\n    frequency?: number;\n    timeOfDay?: TimeOfDay;\n    dayOfWeek?: DayOfWeek;\n    relatedEntityId?: string;\n    model?: string;\n  }\n): Promise<Pattern> {\n  const result = await pool.query<Pattern>(\n    `INSERT INTO patterns (\n       content, pattern_type, related_entity_id, confidence, frequency,\n       time_of_day, day_of_week,\n       detected_by_model, detection_prompt_version\n     )\n     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'v1')\n     RETURNING *`,\n    [\n      content,\n      patternType,\n      options?.relatedEntityId || null,\n      confidence,\n      options?.frequency || 0.5,\n      options?.timeOfDay || null,\n      options?.dayOfWeek || null,\n      options?.model || null,\n    ]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:getPattern:241": {
      "id": "file:src/services/patterns.ts:fn:getPattern:241",
      "type": "function",
      "name": "getPattern",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 241,
      "endLine": 247,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a pattern from the database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPattern(id: string): Promise<Pattern | null> {\n  const result = await pool.query<Pattern>(\n    `SELECT * FROM patterns WHERE id = $1`,\n    [id]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:getAllPatterns:252": {
      "id": "file:src/services/patterns.ts:fn:getAllPatterns:252",
      "type": "function",
      "name": "getAllPatterns",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 252,
      "endLine": 312,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ type?: \"behavioral\" | \"temporal\" | \"emotional\" | \"social\" | \"cognitive\" | \"physical\"; status?: string; minConfidence?: number; timeOfDay?: \"early_morning\" | \"morning\" | \"midday\" | \"afternoon\" | \"evening\" | \"night\" | \"late_night\"; dayOfWeek?: \"monday\" | \"tuesday\" | \"wednesday\" | \"thursday\" | \"friday\" | \"saturday\" | \"sunday\" | \"weekday\" | \"weekend\"; limit?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for patterns with optional filters on type, status, confidence, time, day, and limit",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllPatterns(options?: {\n  type?: PatternType;\n  status?: string;\n  minConfidence?: number;\n  timeOfDay?: TimeOfDay;\n  dayOfWeek?: DayOfWeek;\n  limit?: number;\n}): Promise<Pattern[]> {\n  const conditions: string[] = [];\n  const params: (string | number)[] = [];\n  let paramCount = 0;\n\n  if (options?.type) {\n    paramCount++;\n    conditions.push(`pattern_type = $${paramCount}`);\n    params.push(options.type);\n  }\n\n  if (options?.status) {\n    paramCount++;\n    conditions.push(`status = $${paramCount}`);\n    params.push(options.status);\n  } else {\n    conditions.push(`status = 'active'`);\n  }\n\n  if (options?.minConfidence) {\n    paramCount++;\n    conditions.push(`confidence >= $${paramCount}`);\n    params.push(options.minConfidence);\n  }\n\n  if (options?.timeOfDay) {\n    paramCount++;\n    conditions.push(`time_of_day = $${paramCount}`);\n    params.push(options.timeOfDay);\n  }\n\n  if (options?.dayOfWeek) {\n    paramCount++;\n    conditions.push(`day_of_week = $${paramCount}`);\n    params.push(options.dayOfWeek);\n  }\n\n  const whereClause = conditions.length > 0\n    ? `WHERE ${conditions.join(' AND ')}`\n    : '';\n\n  const limit = options?.limit || 100;\n  paramCount++;\n  params.push(limit);\n\n  const result = await pool.query<Pattern>(\n    `SELECT * FROM patterns\n     ${whereClause}\n     ORDER BY confidence DESC, observation_count DESC\n     LIMIT $${paramCount}`,\n    params\n  );\n  return result.rows;\n}",
      "references": [
        "paramCount",
        "conditions",
        "params",
        "limit",
        "pool",
        "whereClause",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:getPatternsByType:317": {
      "id": "file:src/services/patterns.ts:fn:getPatternsByType:317",
      "type": "function",
      "name": "getPatternsByType",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 317,
      "endLine": 319,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"behavioral\" | \"temporal\" | \"emotional\" | \"social\" | \"cognitive\" | \"physical\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves patterns filtered by type using getAllPatterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPatternsByType(type: PatternType): Promise<Pattern[]> {\n  return getAllPatterns({ type });\n}",
      "references": [
        "getAllPatterns"
      ]
    },
    "file:src/services/patterns.ts:fn:getPatternsByEntity:324": {
      "id": "file:src/services/patterns.ts:fn:getPatternsByEntity:324",
      "type": "function",
      "name": "getPatternsByEntity",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 324,
      "endLine": 332,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active patterns for given entity ID from database, ordered by confidence DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPatternsByEntity(entityId: string): Promise<Pattern[]> {\n  const result = await pool.query<Pattern>(\n    `SELECT * FROM patterns\n     WHERE related_entity_id = $1 AND status = 'active'\n     ORDER BY confidence DESC`,\n    [entityId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:reinforcePattern:337": {
      "id": "file:src/services/patterns.ts:fn:reinforcePattern:337",
      "type": "function",
      "name": "reinforcePattern",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 337,
      "endLine": 358,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "patternId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "confidenceBoost",
          "type": "number",
          "isOptional": true,
          "defaultValue": "0.05"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").Pattern>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates pattern confidence, observation count, status, and timestamps in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function reinforcePattern(\n  patternId: string,\n  confidenceBoost: number = 0.05\n): Promise<Pattern> {\n  const result = await pool.query<Pattern>(\n    `UPDATE patterns\n     SET confidence = LEAST(1.0, confidence + $2),\n         observation_count = observation_count + 1,\n         last_observed_at = NOW(),\n         status = 'active',\n         dormant_since = NULL,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [patternId, confidenceBoost]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Pattern not found: ${patternId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/patterns.ts:fn:linkEvidence:366": {
      "id": "file:src/services/patterns.ts:fn:linkEvidence:366",
      "type": "function",
      "name": "linkEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 366,
      "endLine": 394,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "patternId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "evidenceStrength",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "evidenceType",
          "type": "\"contradicts\" | \"context\" | \"demonstrates\" | \"triggers\"",
          "isOptional": true,
          "defaultValue": "'demonstrates'"
        },
        {
          "name": "memoryTimestamp",
          "type": "Date",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").PatternEvidence>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts or updates pattern evidence link and updates pattern's source memory count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function linkEvidence(\n  patternId: string,\n  memoryId: string,\n  evidenceStrength: number,\n  evidenceType: 'demonstrates' | 'contradicts' | 'triggers' | 'context' = 'demonstrates',\n  memoryTimestamp?: Date\n): Promise<PatternEvidence> {\n  const result = await pool.query<PatternEvidence>(\n    `INSERT INTO pattern_evidence (pattern_id, memory_id, evidence_strength, evidence_type, memory_timestamp)\n     VALUES ($1, $2, $3, $4, $5)\n     ON CONFLICT (pattern_id, memory_id)\n     DO UPDATE SET evidence_strength = $3, evidence_type = $4\n     RETURNING *`,\n    [patternId, memoryId, evidenceStrength, evidenceType, memoryTimestamp || null]\n  );\n\n  // Update source memory count\n  await pool.query(\n    `UPDATE patterns\n     SET source_memory_count = (\n       SELECT COUNT(*) FROM pattern_evidence WHERE pattern_id = $1\n     ),\n     updated_at = NOW()\n     WHERE id = $1`,\n    [patternId]\n  );\n\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:getPatternEvidence:399": {
      "id": "file:src/services/patterns.ts:fn:getPatternEvidence:399",
      "type": "function",
      "name": "getPatternEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 399,
      "endLine": 411,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "patternId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/patterns\").PatternEvidence & { memory_content: string; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pattern evidence with memory content from DB by pattern ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPatternEvidence(\n  patternId: string\n): Promise<Array<PatternEvidence & { memory_content: string }>> {\n  const result = await pool.query<PatternEvidence & { memory_content: string }>(\n    `SELECT pe.*, m.content as memory_content\n     FROM pattern_evidence pe\n     JOIN memories m ON m.id = pe.memory_id\n     WHERE pe.pattern_id = $1\n     ORDER BY pe.evidence_strength DESC`,\n    [patternId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:markStalePatternsDormant:418": {
      "id": "file:src/services/patterns.ts:fn:markStalePatternsDormant:418",
      "type": "function",
      "name": "markStalePatternsDormant",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 418,
      "endLine": 430,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "daysThreshold",
          "type": "number",
          "isOptional": true,
          "defaultValue": "30"
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Marks active patterns as dormant if last observed over daysThreshold days ago",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markStalePatternsDormant(daysThreshold: number = 30): Promise<number> {\n  const result = await pool.query(\n    `UPDATE patterns\n     SET status = 'dormant',\n         dormant_since = NOW(),\n         updated_at = NOW()\n     WHERE status = 'active'\n       AND last_observed_at < NOW() - INTERVAL '1 day' * $1\n     RETURNING id`,\n    [daysThreshold]\n  );\n  return result.rowCount || 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/patterns.ts:fn:getPatternStats:437": {
      "id": "file:src/services/patterns.ts:fn:getPatternStats:437",
      "type": "function",
      "name": "getPatternStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 437,
      "endLine": 486,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; dormant: number; disproven: number; byType: Record<string, number>; avgConfidence: number; avgFrequency: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves pattern statistics (counts by status/type, averages) from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPatternStats(): Promise<{\n  total: number;\n  active: number;\n  dormant: number;\n  disproven: number;\n  byType: Record<string, number>;\n  avgConfidence: number;\n  avgFrequency: number;\n}> {\n  const result = await pool.query<{\n    total: string;\n    active: string;\n    dormant: string;\n    disproven: string;\n    avg_confidence: string;\n    avg_frequency: string;\n  }>(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE status = 'active') as active,\n      COUNT(*) FILTER (WHERE status = 'dormant') as dormant,\n      COUNT(*) FILTER (WHERE status = 'disproven') as disproven,\n      AVG(confidence) as avg_confidence,\n      AVG(frequency) as avg_frequency\n    FROM patterns\n  `);\n\n  const byTypeResult = await pool.query<{ pattern_type: string; count: string }>(`\n    SELECT pattern_type, COUNT(*) as count\n    FROM patterns\n    WHERE status = 'active'\n    GROUP BY pattern_type\n  `);\n\n  const row = result.rows[0]!;\n  const byType: Record<string, number> = {};\n  for (const r of byTypeResult.rows) {\n    byType[r.pattern_type] = parseInt(r.count, 10);\n  }\n\n  return {\n    total: parseInt(row.total, 10),\n    active: parseInt(row.active, 10),\n    dormant: parseInt(row.dormant, 10),\n    disproven: parseInt(row.disproven, 10),\n    byType,\n    avgConfidence: parseFloat(row.avg_confidence) || 0,\n    avgFrequency: parseFloat(row.avg_frequency) || 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "byTypeResult",
        "byType",
        "r",
        "parseInt",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/patterns.ts:fn:isValidPatternType:493": {
      "id": "file:src/services/patterns.ts:fn:isValidPatternType:493",
      "type": "function",
      "name": "isValidPatternType",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 493,
      "endLine": 495,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if a string is a valid PatternType by checking inclusion in PATTERN_TYPES array.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isValidPatternType(type: string): type is PatternType {\n  return PATTERN_TYPES.includes(type as PatternType);\n}",
      "references": [
        "PATTERN_TYPES"
      ]
    },
    "file:src/services/patterns.ts:fn:getPatternTypeDescription:500": {
      "id": "file:src/services/patterns.ts:fn:getPatternTypeDescription:500",
      "type": "function",
      "name": "getPatternTypeDescription",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 500,
      "endLine": 510,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"behavioral\" | \"temporal\" | \"emotional\" | \"social\" | \"cognitive\" | \"physical\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a description string for a given PatternType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getPatternTypeDescription(type: PatternType): string {\n  const descriptions: Record<PatternType, string> = {\n    behavioral: 'Recurring actions and habits',\n    temporal: 'Time-based rhythms and cycles',\n    emotional: 'Emotional tendencies and reactions',\n    social: 'Interaction and relationship patterns',\n    cognitive: 'Thinking and decision patterns',\n    physical: 'Body and health patterns',\n  };\n  return descriptions[type];\n}",
      "references": [
        "descriptions"
      ]
    },
    "file:src/services/patterns.ts:fn:processMemoryForPatterns:523": {
      "id": "file:src/services/patterns.ts:fn:processMemoryForPatterns:523",
      "type": "function",
      "name": "processMemoryForPatterns",
      "filePath": "/home/ridgetop/projects/squire/src/services/patterns.ts",
      "line": 523,
      "endLine": 566,
      "parentFileId": "file:src/services/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryTimestamp",
          "type": "Date",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/patterns\").PatternDetectionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes memory content to detect patterns, create/reinforce them, and link evidence.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processMemoryForPatterns(\n  memoryId: string,\n  content: string,\n  memoryTimestamp?: Date,\n  model?: string\n): Promise<PatternDetectionResult> {\n  const result: PatternDetectionResult = {\n    created: [],\n    reinforced: [],\n  };\n\n  // Get existing patterns for context\n  const existingPatterns = await getAllPatterns({ status: 'active', limit: 50 });\n\n  // Extract patterns from content\n  const extracted = await extractPatternsFromContent(content, existingPatterns);\n  if (extracted.length === 0) {\n    return result;\n  }\n\n  for (const ext of extracted) {\n    // Check if similar pattern already exists\n    const existing = await findSimilarPattern(ext.content, ext.pattern_type);\n\n    if (existing) {\n      // Reinforce existing pattern\n      const reinforced = await reinforcePattern(existing.id, 0.03);\n      await linkEvidence(existing.id, memoryId, ext.confidence, 'demonstrates', memoryTimestamp);\n      result.reinforced.push({ pattern: reinforced, wasReinforced: true });\n    } else {\n      // Create new pattern\n      const pattern = await createPattern(ext.content, ext.pattern_type, ext.confidence, {\n        frequency: ext.frequency,\n        timeOfDay: ext.time_of_day,\n        dayOfWeek: ext.day_of_week,\n        model,\n      });\n      await linkEvidence(pattern.id, memoryId, ext.confidence, 'demonstrates', memoryTimestamp);\n      result.created.push(pattern);\n    }\n  }\n\n  return result;\n}",
      "references": [
        "getAllPatterns",
        "extractPatternsFromContent",
        "existingPatterns",
        "extracted",
        "result",
        "findSimilarPattern",
        "ext",
        "existing",
        "reinforcePattern",
        "linkEvidence",
        "reinforced",
        "createPattern",
        "pattern"
      ]
    },
    "file:src/services/push.ts": {
      "id": "file:src/services/push.ts",
      "type": "file",
      "name": "push.ts",
      "filePath": "src/services/push.ts",
      "line": 1,
      "endLine": 496,
      "imports": [
        {
          "source": "web-push",
          "items": [
            {
              "name": "webpush",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getVapidPublicKey",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isPushConfigured",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "subscribe",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unsubscribe",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unsubscribeById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deactivateSubscription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "reactivateSubscription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSubscription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSubscriptionByEndpoint",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getActiveSubscriptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listSubscriptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "sendToSubscription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "sendToAll",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "sendById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "sendReminderNotification",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "sendSimpleNotification",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "cleanupStaleSubscriptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSubscriptionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateDeviceName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PushSubscription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SubscribeInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PushPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SendResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/push.ts:fn:ensureVapidConfigured:70",
        "file:src/services/push.ts:fn:getVapidPublicKey:86",
        "file:src/services/push.ts:fn:isPushConfigured:93",
        "file:src/services/push.ts:fn:subscribe:104",
        "file:src/services/push.ts:fn:unsubscribe:131",
        "file:src/services/push.ts:fn:unsubscribeById:142",
        "file:src/services/push.ts:fn:deactivateSubscription:153",
        "file:src/services/push.ts:fn:reactivateSubscription:167",
        "file:src/services/push.ts:fn:getSubscription:185",
        "file:src/services/push.ts:fn:getSubscriptionByEndpoint:196",
        "file:src/services/push.ts:fn:getActiveSubscriptions:207",
        "file:src/services/push.ts:fn:listSubscriptions:217",
        "file:src/services/push.ts:fn:sendToSubscription:246",
        "file:src/services/push.ts:fn:sendToAll:330",
        "file:src/services/push.ts:fn:sendById:347",
        "file:src/services/push.ts:fn:sendReminderNotification:376",
        "file:src/services/push.ts:fn:sendSimpleNotification:410",
        "file:src/services/push.ts:fn:cleanupStaleSubscriptions:441",
        "file:src/services/push.ts:fn:getSubscriptionStats:459",
        "file:src/services/push.ts:fn:updateDeviceName:486"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:src/services/push.ts:fn:ensureVapidConfigured:70": {
      "id": "file:src/services/push.ts:fn:ensureVapidConfigured:70",
      "type": "function",
      "name": "ensureVapidConfigured",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 70,
      "endLine": 81,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Ensures VAPID keys are configured for webpush, sets details if available.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.091Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function ensureVapidConfigured(): void {\n  if (vapidConfigured) return;\n\n  if (!VAPID_PUBLIC_KEY || !VAPID_PRIVATE_KEY) {\n    console.warn('VAPID keys not configured. Push notifications will not work.');\n    console.warn('Generate keys with: npx web-push generate-vapid-keys');\n    return;\n  }\n\n  webpush.setVapidDetails(VAPID_SUBJECT, VAPID_PUBLIC_KEY, VAPID_PRIVATE_KEY);\n  vapidConfigured = true;\n}",
      "references": [
        "vapidConfigured",
        "VAPID_PUBLIC_KEY",
        "VAPID_PRIVATE_KEY",
        "console",
        "webpush",
        "VAPID_SUBJECT"
      ]
    },
    "file:src/services/push.ts:fn:getVapidPublicKey:86": {
      "id": "file:src/services/push.ts:fn:getVapidPublicKey:86",
      "type": "function",
      "name": "getVapidPublicKey",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 86,
      "endLine": 88,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the VAPID public key constant.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getVapidPublicKey(): string {\n  return VAPID_PUBLIC_KEY;\n}",
      "references": [
        "VAPID_PUBLIC_KEY"
      ]
    },
    "file:src/services/push.ts:fn:isPushConfigured:93": {
      "id": "file:src/services/push.ts:fn:isPushConfigured:93",
      "type": "function",
      "name": "isPushConfigured",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 93,
      "endLine": 95,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if both VAPID public and private keys are configured.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isPushConfigured(): boolean {\n  return Boolean(VAPID_PUBLIC_KEY && VAPID_PRIVATE_KEY);\n}",
      "references": [
        "Boolean",
        "VAPID_PUBLIC_KEY",
        "VAPID_PRIVATE_KEY"
      ]
    },
    "file:src/services/push.ts:fn:subscribe:104": {
      "id": "file:src/services/push.ts:fn:subscribe:104",
      "type": "function",
      "name": "subscribe",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 104,
      "endLine": 126,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/push\").SubscribeInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Upserts push subscription into database, activates it and resets failures.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function subscribe(input: SubscribeInput): Promise<PushSubscription> {\n  const { endpoint, p256dh, auth, user_agent, device_name } = input;\n\n  // Upsert: update if endpoint exists, insert if new\n  const result = await pool.query(\n    `INSERT INTO push_subscriptions (endpoint, p256dh, auth, user_agent, device_name, active)\n     VALUES ($1, $2, $3, $4, $5, true)\n     ON CONFLICT (endpoint) DO UPDATE SET\n       p256dh = EXCLUDED.p256dh,\n       auth = EXCLUDED.auth,\n       user_agent = COALESCE(EXCLUDED.user_agent, push_subscriptions.user_agent),\n       device_name = COALESCE(EXCLUDED.device_name, push_subscriptions.device_name),\n       active = true,\n       failure_count = 0,\n       last_failure_at = NULL,\n       last_failure_reason = NULL,\n       updated_at = NOW()\n     RETURNING *`,\n    [endpoint, p256dh, auth, user_agent ?? null, device_name ?? null]\n  );\n\n  return result.rows[0] as PushSubscription;\n}",
      "references": [
        "endpoint",
        "p256dh",
        "auth",
        "user_agent",
        "device_name",
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:unsubscribe:131": {
      "id": "file:src/services/push.ts:fn:unsubscribe:131",
      "type": "function",
      "name": "unsubscribe",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 131,
      "endLine": 137,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes push subscription from DB by endpoint, returns success boolean",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unsubscribe(endpoint: string): Promise<boolean> {\n  const result = await pool.query(\n    'DELETE FROM push_subscriptions WHERE endpoint = $1',\n    [endpoint]\n  );\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:unsubscribeById:142": {
      "id": "file:src/services/push.ts:fn:unsubscribeById:142",
      "type": "function",
      "name": "unsubscribeById",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 142,
      "endLine": 148,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes push subscription from DB by ID and returns true if successful",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unsubscribeById(id: string): Promise<boolean> {\n  const result = await pool.query(\n    'DELETE FROM push_subscriptions WHERE id = $1',\n    [id]\n  );\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:deactivateSubscription:153": {
      "id": "file:src/services/push.ts:fn:deactivateSubscription:153",
      "type": "function",
      "name": "deactivateSubscription",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 153,
      "endLine": 162,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deactivates push subscription by ID via UPDATE query and returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deactivateSubscription(id: string): Promise<PushSubscription | null> {\n  const result = await pool.query(\n    `UPDATE push_subscriptions\n     SET active = false, updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as PushSubscription) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:reactivateSubscription:167": {
      "id": "file:src/services/push.ts:fn:reactivateSubscription:167",
      "type": "function",
      "name": "reactivateSubscription",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 167,
      "endLine": 180,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates push subscription to active, resets failures, returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function reactivateSubscription(id: string): Promise<PushSubscription | null> {\n  const result = await pool.query(\n    `UPDATE push_subscriptions\n     SET active = true,\n         failure_count = 0,\n         last_failure_at = NULL,\n         last_failure_reason = NULL,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as PushSubscription) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:getSubscription:185": {
      "id": "file:src/services/push.ts:fn:getSubscription:185",
      "type": "function",
      "name": "getSubscription",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 185,
      "endLine": 191,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a push subscription from the database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSubscription(id: string): Promise<PushSubscription | null> {\n  const result = await pool.query(\n    'SELECT * FROM push_subscriptions WHERE id = $1',\n    [id]\n  );\n  return (result.rows[0] as PushSubscription) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:getSubscriptionByEndpoint:196": {
      "id": "file:src/services/push.ts:fn:getSubscriptionByEndpoint:196",
      "type": "function",
      "name": "getSubscriptionByEndpoint",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 196,
      "endLine": 202,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves push subscription from database by endpoint",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSubscriptionByEndpoint(endpoint: string): Promise<PushSubscription | null> {\n  const result = await pool.query(\n    'SELECT * FROM push_subscriptions WHERE endpoint = $1',\n    [endpoint]\n  );\n  return (result.rows[0] as PushSubscription) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:getActiveSubscriptions:207": {
      "id": "file:src/services/push.ts:fn:getActiveSubscriptions:207",
      "type": "function",
      "name": "getActiveSubscriptions",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 207,
      "endLine": 212,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves active push subscriptions from DB, ordered by created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getActiveSubscriptions(): Promise<PushSubscription[]> {\n  const result = await pool.query(\n    'SELECT * FROM push_subscriptions WHERE active = true ORDER BY created_at DESC'\n  );\n  return result.rows as PushSubscription[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:listSubscriptions:217": {
      "id": "file:src/services/push.ts:fn:listSubscriptions:217",
      "type": "function",
      "name": "listSubscriptions",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 217,
      "endLine": 237,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ active_only?: boolean; limit?: number; offset?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves paginated list of push subscriptions from DB, optionally active only",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listSubscriptions(\n  options: { active_only?: boolean; limit?: number; offset?: number } = {}\n): Promise<PushSubscription[]> {\n  const { active_only = false, limit = 50, offset = 0 } = options;\n\n  let query = 'SELECT * FROM push_subscriptions';\n  const params: (boolean | number)[] = [];\n  let paramIndex = 1;\n\n  if (active_only) {\n    query += ` WHERE active = $${paramIndex}`;\n    params.push(true);\n    paramIndex++;\n  }\n\n  query += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as PushSubscription[];\n}",
      "references": [
        "active_only",
        "limit",
        "offset",
        "query",
        "paramIndex",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:sendToSubscription:246": {
      "id": "file:src/services/push.ts:fn:sendToSubscription:246",
      "type": "function",
      "name": "sendToSubscription",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 246,
      "endLine": 325,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subscription",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/push\").PushPayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").SendResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends push notification to subscription, updates DB on success/failure, deactivates on errors.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendToSubscription(\n  subscription: PushSubscription,\n  payload: PushPayload\n): Promise<SendResult> {\n  ensureVapidConfigured();\n\n  if (!isPushConfigured()) {\n    return {\n      subscription_id: subscription.id,\n      success: false,\n      error: 'VAPID keys not configured',\n    };\n  }\n\n  const pushSubscription = {\n    endpoint: subscription.endpoint,\n    keys: {\n      p256dh: subscription.p256dh,\n      auth: subscription.auth,\n    },\n  };\n\n  try {\n    const response = await webpush.sendNotification(\n      pushSubscription,\n      JSON.stringify(payload)\n    );\n\n    // Update last_used_at on success\n    await pool.query(\n      `UPDATE push_subscriptions\n       SET last_used_at = NOW(),\n           failure_count = 0,\n           updated_at = NOW()\n       WHERE id = $1`,\n      [subscription.id]\n    );\n\n    return {\n      subscription_id: subscription.id,\n      success: true,\n      statusCode: response.statusCode,\n    };\n  } catch (error) {\n    const err = error as Error & { statusCode?: number };\n    const statusCode = err.statusCode;\n    const errorMessage = err.message || 'Unknown error';\n\n    // Update failure tracking\n    await pool.query(\n      `UPDATE push_subscriptions\n       SET failure_count = failure_count + 1,\n           last_failure_at = NOW(),\n           last_failure_reason = $1,\n           updated_at = NOW()\n       WHERE id = $2`,\n      [errorMessage, subscription.id]\n    );\n\n    // Check if we should deactivate\n    // 410 Gone means the subscription is no longer valid\n    // 404 means endpoint not found\n    if (statusCode === 410 || statusCode === 404) {\n      await deactivateSubscription(subscription.id);\n    } else {\n      // Check if we've exceeded max failures\n      const updated = await getSubscription(subscription.id);\n      if (updated && updated.failure_count >= MAX_FAILURE_COUNT) {\n        await deactivateSubscription(subscription.id);\n      }\n    }\n\n    return {\n      subscription_id: subscription.id,\n      success: false,\n      error: errorMessage,\n      statusCode,\n    };\n  }\n}",
      "references": [
        "ensureVapidConfigured",
        "isPushConfigured",
        "webpush",
        "pushSubscription",
        "JSON",
        "pool",
        "response",
        "error",
        "err",
        "errorMessage",
        "statusCode",
        "deactivateSubscription",
        "getSubscription",
        "updated",
        "MAX_FAILURE_COUNT"
      ]
    },
    "file:src/services/push.ts:fn:sendToAll:330": {
      "id": "file:src/services/push.ts:fn:sendToAll:330",
      "type": "function",
      "name": "sendToAll",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 330,
      "endLine": 342,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/push\").PushPayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").SendResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends push payload to all active subscriptions concurrently",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendToAll(payload: PushPayload): Promise<SendResult[]> {\n  const subscriptions = await getActiveSubscriptions();\n\n  if (subscriptions.length === 0) {\n    return [];\n  }\n\n  const results = await Promise.all(\n    subscriptions.map(sub => sendToSubscription(sub, payload))\n  );\n\n  return results;\n}",
      "references": [
        "getActiveSubscriptions",
        "subscriptions",
        "Promise",
        "sendToSubscription",
        "sub",
        "results"
      ]
    },
    "file:src/services/push.ts:fn:sendById:347": {
      "id": "file:src/services/push.ts:fn:sendById:347",
      "type": "function",
      "name": "sendById",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 347,
      "endLine": 367,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/push\").PushPayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").SendResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends push notification to subscription by ID if active.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendById(id: string, payload: PushPayload): Promise<SendResult> {\n  const subscription = await getSubscription(id);\n\n  if (!subscription) {\n    return {\n      subscription_id: id,\n      success: false,\n      error: 'Subscription not found',\n    };\n  }\n\n  if (!subscription.active) {\n    return {\n      subscription_id: id,\n      success: false,\n      error: 'Subscription is inactive',\n    };\n  }\n\n  return sendToSubscription(subscription, payload);\n}",
      "references": [
        "getSubscription",
        "subscription",
        "sendToSubscription"
      ]
    },
    "file:src/services/push.ts:fn:sendReminderNotification:376": {
      "id": "file:src/services/push.ts:fn:sendReminderNotification:376",
      "type": "function",
      "name": "sendReminderNotification",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 376,
      "endLine": 405,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "reminderId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "body",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ commitmentId?: string; url?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").SendResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends push reminder notification to all users with title, body, and custom data.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendReminderNotification(\n  reminderId: string,\n  title: string,\n  body: string,\n  options: {\n    commitmentId?: string;\n    url?: string;\n  } = {}\n): Promise<SendResult[]> {\n  const payload: PushPayload = {\n    title,\n    body,\n    icon: '/icon-192.png',\n    badge: '/badge-72.png',\n    tag: reminderId,\n    data: {\n      type: 'reminder',\n      reminder_id: reminderId,\n      commitment_id: options.commitmentId,\n      url: options.url || '/app/commitments',\n    },\n    actions: [\n      { action: 'view', title: 'View' },\n      { action: 'snooze', title: 'Snooze 1h' },\n      { action: 'done', title: 'Done' },\n    ],\n  };\n\n  return sendToAll(payload);\n}",
      "references": [
        "sendToAll",
        "payload"
      ]
    },
    "file:src/services/push.ts:fn:sendSimpleNotification:410": {
      "id": "file:src/services/push.ts:fn:sendSimpleNotification:410",
      "type": "function",
      "name": "sendSimpleNotification",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 410,
      "endLine": 432,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "body",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ tag?: string; url?: string; data?: Record<string, unknown>; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").SendResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Prepares a push notification payload and sends it to all users via sendToAll.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendSimpleNotification(\n  title: string,\n  body?: string,\n  options: {\n    tag?: string;\n    url?: string;\n    data?: Record<string, unknown>;\n  } = {}\n): Promise<SendResult[]> {\n  const payload: PushPayload = {\n    title,\n    body,\n    icon: '/icon-192.png',\n    badge: '/badge-72.png',\n    tag: options.tag,\n    data: {\n      url: options.url || '/app',\n      ...options.data,\n    },\n  };\n\n  return sendToAll(payload);\n}",
      "references": [
        "sendToAll",
        "payload"
      ]
    },
    "file:src/services/push.ts:fn:cleanupStaleSubscriptions:441": {
      "id": "file:src/services/push.ts:fn:cleanupStaleSubscriptions:441",
      "type": "function",
      "name": "cleanupStaleSubscriptions",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 441,
      "endLine": 454,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ older_than_days?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes inactive push subscriptions older than N days from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function cleanupStaleSubscriptions(\n  options: { older_than_days?: number } = {}\n): Promise<number> {\n  const { older_than_days = 30 } = options;\n\n  const result = await pool.query(\n    `DELETE FROM push_subscriptions\n     WHERE active = false\n       AND updated_at < NOW() - INTERVAL '1 day' * $1`,\n    [older_than_days]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "older_than_days",
        "pool",
        "result"
      ]
    },
    "file:src/services/push.ts:fn:getSubscriptionStats:459": {
      "id": "file:src/services/push.ts:fn:getSubscriptionStats:459",
      "type": "function",
      "name": "getSubscriptionStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 459,
      "endLine": 481,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; inactive: number; recent_failures: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves push subscription stats: total, active, inactive, and recent failures from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSubscriptionStats(): Promise<{\n  total: number;\n  active: number;\n  inactive: number;\n  recent_failures: number;\n}> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE active = true) as active,\n      COUNT(*) FILTER (WHERE active = false) as inactive,\n      COUNT(*) FILTER (WHERE failure_count > 0 AND last_failure_at > NOW() - INTERVAL '24 hours') as recent_failures\n    FROM push_subscriptions\n  `);\n\n  const row = result.rows[0];\n  return {\n    total: parseInt(row.total, 10),\n    active: parseInt(row.active, 10),\n    inactive: parseInt(row.inactive, 10),\n    recent_failures: parseInt(row.recent_failures, 10),\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row"
      ]
    },
    "file:src/services/push.ts:fn:updateDeviceName:486": {
      "id": "file:src/services/push.ts:fn:updateDeviceName:486",
      "type": "function",
      "name": "updateDeviceName",
      "filePath": "/home/ridgetop/projects/squire/src/services/push.ts",
      "line": 486,
      "endLine": 495,
      "parentFileId": "file:src/services/push.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "deviceName",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/push\").PushSubscription>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates device name of push subscription by ID and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateDeviceName(id: string, deviceName: string): Promise<PushSubscription | null> {\n  const result = await pool.query(\n    `UPDATE push_subscriptions\n     SET device_name = $1, updated_at = NOW()\n     WHERE id = $2\n     RETURNING *`,\n    [deviceName, id]\n  );\n  return (result.rows[0] as PushSubscription) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/recurrence.ts": {
      "id": "file:src/services/recurrence.ts",
      "type": "file",
      "name": "recurrence.ts",
      "filePath": "src/services/recurrence.ts",
      "line": 1,
      "endLine": 205,
      "imports": [
        {
          "source": "rrule",
          "items": [
            {
              "name": "rrulePkg",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "expandRecurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getNextOccurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "RRuleType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "RRuleSetType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FrequencyType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "WeekdayType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "RecurrenceOccurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceExpansion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExpandRecurrenceOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceFrequency",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DayOfWeek",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ParsedRecurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrencePreset",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        }
      ],
      "functions": [
        "file:src/services/recurrence.ts:fn:expandRecurrence:110",
        "file:src/services/recurrence.ts:fn:getNextOccurrence:172"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/recurrence.ts:fn:expandRecurrence:110": {
      "id": "file:src/services/recurrence.ts:fn:expandRecurrence:110",
      "type": "function",
      "name": "expandRecurrence",
      "filePath": "/home/ridgetop/projects/squire/src/services/recurrence.ts",
      "line": 110,
      "endLine": 167,
      "parentFileId": "file:src/services/recurrence.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "rruleString",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "dtstart",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/recurrence\").ExpandRecurrenceOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/recurrence\").RecurrenceExpansion",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Expands RRULE string into occurrences within a date range with options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function expandRecurrence(\n  rruleString: string,\n  dtstart: Date,\n  options: ExpandRecurrenceOptions\n): RecurrenceExpansion {\n  const { after = new Date(), before, inclusive = true, limit = 100 } = options;\n\n  // Parse the RRULE\n  let rule: RRuleType | RRuleSetType;\n  try {\n    // Try parsing as RRuleSet first (handles EXDATE, RDATE)\n    if (rruleString.includes('EXDATE') || rruleString.includes('RDATE')) {\n      rule = rrulestr(rruleString, { dtstart }) as RRuleSetType;\n    } else {\n      // Simple RRULE\n      rule = RRule.fromString(rruleString);\n      rule = new RRule({\n        ...rule.origOptions,\n        dtstart,\n      });\n    }\n  } catch (err) {\n    // Invalid RRULE - return empty expansion\n    return {\n      rrule: rruleString,\n      dtstart,\n      occurrences: [],\n      totalCount: 0,\n      isInfinite: false,\n    };\n  }\n\n  // Get occurrences within the range\n  const occurrences = rule.between(after, before, inclusive).slice(0, limit);\n\n  // Determine if rule is infinite\n  const isInfinite = !rule.origOptions.until && !rule.origOptions.count;\n\n  // Try to get total count (only for bounded rules)\n  let totalCount: number | null = null;\n  if (!isInfinite) {\n    try {\n      totalCount = rule.all().length;\n    } catch {\n      // Infinite or very long - leave as null\n    }\n  }\n\n  return {\n    rrule: rruleString,\n    dtstart,\n    until: rule.origOptions.until ?? undefined,\n    count: rule.origOptions.count ?? undefined,\n    occurrences,\n    totalCount,\n    isInfinite,\n  };\n}",
      "references": [
        "after",
        "Date",
        "before",
        "inclusive",
        "limit",
        "rule",
        "rrulestr",
        "RRule",
        "isInfinite",
        "totalCount",
        "occurrences"
      ]
    },
    "file:src/services/recurrence.ts:fn:getNextOccurrence:172": {
      "id": "file:src/services/recurrence.ts:fn:getNextOccurrence:172",
      "type": "function",
      "name": "getNextOccurrence",
      "filePath": "/home/ridgetop/projects/squire/src/services/recurrence.ts",
      "line": 172,
      "endLine": 187,
      "parentFileId": "file:src/services/recurrence.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "rruleString",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "dtstart",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "after",
          "type": "Date",
          "isOptional": true,
          "defaultValue": "new Date()"
        }
      ],
      "returnType": "Date",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses RRULE string and returns next occurrence after given date.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getNextOccurrence(\n  rruleString: string,\n  dtstart: Date,\n  after: Date = new Date()\n): Date | null {\n  try {\n    const rule = RRule.fromString(rruleString);\n    const ruleWithStart = new RRule({\n      ...rule.origOptions,\n      dtstart,\n    });\n    return ruleWithStart.after(after, false);\n  } catch {\n    return null;\n  }\n}",
      "references": [
        "RRule",
        "rule",
        "ruleWithStart"
      ]
    },
    "file:src/services/reinforcement.ts": {
      "id": "file:src/services/reinforcement.ts",
      "type": "file",
      "name": "reinforcement.ts",
      "filePath": "src/services/reinforcement.ts",
      "line": 1,
      "endLine": 251,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./edges.js",
          "items": [
            {
              "name": "createEdge",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "checkReinforcement",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "checkReinforcementBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "promoteToSolid",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "demoteToHypothesis",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getTierStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ReinforcementResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/reinforcement.ts:fn:checkReinforcement:43",
        "file:src/services/reinforcement.ts:fn:checkReinforcementBatch:146",
        "file:src/services/reinforcement.ts:fn:promoteToSolid:163",
        "file:src/services/reinforcement.ts:fn:demoteToHypothesis:188",
        "file:src/services/reinforcement.ts:fn:getTierStats:215"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/reinforcement.ts:fn:checkReinforcement:43": {
      "id": "file:src/services/reinforcement.ts:fn:checkReinforcement:43",
      "type": "function",
      "name": "checkReinforcement",
      "filePath": "/home/ridgetop/projects/squire/src/services/reinforcement.ts",
      "line": 43,
      "endLine": 140,
      "parentFileId": "file:src/services/reinforcement.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "currentConfidence",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reinforcement\").ReinforcementResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embedding, queries similar memories, boosts confidence, creates similarity edges.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.092Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function checkReinforcement(\n  memoryId: string,\n  content: string,\n  currentConfidence: number\n): Promise<ReinforcementResult> {\n  const result: ReinforcementResult = {\n    memoryId,\n    previousConfidence: currentConfidence,\n    newConfidence: currentConfidence,\n    previousTier: currentConfidence >= PROMOTION_THRESHOLD ? 'solid' : 'hypothesis',\n    newTier: currentConfidence >= PROMOTION_THRESHOLD ? 'solid' : 'hypothesis',\n    wasPromoted: false,\n    reinforcedBy: [],\n  };\n\n  try {\n    // Generate embedding for the new memory content\n    const embedding = await generateEmbedding(content);\n    const embeddingStr = `[${embedding.join(',')}]`;\n\n    // Find similar memories (excluding this one)\n    const similarResult = await pool.query<SimilarMemory>(\n      `SELECT id, content, tier, confidence,\n              1 - (embedding <=> $1::vector) as similarity\n       FROM memories\n       WHERE id != $2\n         AND embedding IS NOT NULL\n         AND 1 - (embedding <=> $1::vector) >= $3\n       ORDER BY similarity DESC\n       LIMIT 5`,\n      [embeddingStr, memoryId, SIMILARITY_THRESHOLD]\n    );\n\n    const similarMemories = similarResult.rows;\n\n    if (similarMemories.length === 0) {\n      // No similar memories found - no reinforcement\n      return result;\n    }\n\n    // Calculate confidence boost based on number and quality of matches\n    let totalBoost = 0;\n    for (const similar of similarMemories) {\n      // Higher similarity = stronger reinforcement\n      const similarityBonus = (similar.similarity - SIMILARITY_THRESHOLD) / (1 - SIMILARITY_THRESHOLD);\n      const boost = CONFIDENCE_BOOST * (0.5 + 0.5 * similarityBonus);\n      totalBoost += boost;\n\n      result.reinforcedBy.push(similar.id);\n\n      // Create SIMILAR edge for audit trail\n      await createEdge({\n        source_memory_id: memoryId,\n        target_memory_id: similar.id,\n        edge_type: 'SIMILAR',\n        similarity: similar.similarity,\n        weight: boost,\n        metadata: {\n          reinforcement: true,\n          boost_applied: boost,\n        },\n      });\n\n      console.log(\n        `[Reinforcement] Memory ${memoryId.substring(0, 8)} reinforced by ${similar.id.substring(0, 8)} (similarity: ${similar.similarity.toFixed(3)}, boost: ${boost.toFixed(3)})`\n      );\n    }\n\n    // Cap total boost at 0.4 to prevent one batch from going 0.3  1.0\n    totalBoost = Math.min(totalBoost, 0.4);\n\n    // Calculate new confidence (capped at 1.0)\n    result.newConfidence = Math.min(currentConfidence + totalBoost, 1.0);\n\n    // Check if promotion to solid is warranted\n    if (result.previousTier === 'hypothesis' && result.newConfidence >= PROMOTION_THRESHOLD) {\n      result.newTier = 'solid';\n      result.wasPromoted = true;\n    }\n\n    // Update the memory in the database\n    await pool.query(\n      `UPDATE memories SET confidence = $1, tier = $2 WHERE id = $3`,\n      [result.newConfidence, result.newTier, memoryId]\n    );\n\n    if (result.wasPromoted) {\n      console.log(\n        `[Reinforcement] PROMOTED memory ${memoryId.substring(0, 8)} to SOLID (confidence: ${result.previousConfidence.toFixed(2)}  ${result.newConfidence.toFixed(2)})`\n      );\n    }\n\n    return result;\n  } catch (error) {\n    console.error('[Reinforcement] Error checking reinforcement:', error);\n    return result;\n  }\n}",
      "references": [
        "PROMOTION_THRESHOLD",
        "generateEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "SIMILARITY_THRESHOLD",
        "similarResult",
        "similarMemories",
        "result",
        "similar",
        "CONFIDENCE_BOOST",
        "similarityBonus",
        "totalBoost",
        "boost",
        "createEdge",
        "console",
        "Math",
        "error"
      ]
    },
    "file:src/services/reinforcement.ts:fn:checkReinforcementBatch:146": {
      "id": "file:src/services/reinforcement.ts:fn:checkReinforcementBatch:146",
      "type": "function",
      "name": "checkReinforcementBatch",
      "filePath": "/home/ridgetop/projects/squire/src/services/reinforcement.ts",
      "line": 146,
      "endLine": 157,
      "parentFileId": "file:src/services/reinforcement.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "{ id: string; content: string; confidence: number; }[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reinforcement\").ReinforcementResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks reinforcement for a batch of memories concurrently and returns results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function checkReinforcementBatch(\n  memories: Array<{ id: string; content: string; confidence: number }>\n): Promise<ReinforcementResult[]> {\n  const results: ReinforcementResult[] = [];\n\n  for (const mem of memories) {\n    const result = await checkReinforcement(mem.id, mem.content, mem.confidence);\n    results.push(result);\n  }\n\n  return results;\n}",
      "references": [
        "checkReinforcement",
        "mem",
        "results",
        "result"
      ]
    },
    "file:src/services/reinforcement.ts:fn:promoteToSolid:163": {
      "id": "file:src/services/reinforcement.ts:fn:promoteToSolid:163",
      "type": "function",
      "name": "promoteToSolid",
      "filePath": "/home/ridgetop/projects/squire/src/services/reinforcement.ts",
      "line": 163,
      "endLine": 182,
      "parentFileId": "file:src/services/reinforcement.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates memory tier to 'solid' and ensures min confidence if hypothesis tier",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function promoteToSolid(memoryId: string): Promise<boolean> {\n  try {\n    const result = await pool.query(\n      `UPDATE memories \n       SET tier = 'solid', confidence = GREATEST(confidence, $1)\n       WHERE id = $2 AND tier = 'hypothesis'\n       RETURNING id`,\n      [PROMOTION_THRESHOLD, memoryId]\n    );\n\n    if (result.rowCount && result.rowCount > 0) {\n      console.log(`[Reinforcement] Manually promoted memory ${memoryId.substring(0, 8)} to SOLID`);\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('[Reinforcement] Error promoting memory:', error);\n    return false;\n  }\n}",
      "references": [
        "pool",
        "PROMOTION_THRESHOLD",
        "result",
        "console",
        "error"
      ]
    },
    "file:src/services/reinforcement.ts:fn:demoteToHypothesis:188": {
      "id": "file:src/services/reinforcement.ts:fn:demoteToHypothesis:188",
      "type": "function",
      "name": "demoteToHypothesis",
      "filePath": "/home/ridgetop/projects/squire/src/services/reinforcement.ts",
      "line": 188,
      "endLine": 210,
      "parentFileId": "file:src/services/reinforcement.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "newConfidence",
          "type": "number",
          "isOptional": true,
          "defaultValue": "0.4"
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Demotes 'solid' memory to 'hypothesis' tier with new confidence via DB update.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function demoteToHypothesis(\n  memoryId: string,\n  newConfidence: number = 0.4\n): Promise<boolean> {\n  try {\n    const result = await pool.query(\n      `UPDATE memories \n       SET tier = 'hypothesis', confidence = $1\n       WHERE id = $2 AND tier = 'solid'\n       RETURNING id`,\n      [newConfidence, memoryId]\n    );\n\n    if (result.rowCount && result.rowCount > 0) {\n      console.log(`[Reinforcement] Demoted memory ${memoryId.substring(0, 8)} to HYPOTHESIS`);\n      return true;\n    }\n    return false;\n  } catch (error) {\n    console.error('[Reinforcement] Error demoting memory:', error);\n    return false;\n  }\n}",
      "references": [
        "pool",
        "result",
        "console",
        "error"
      ]
    },
    "file:src/services/reinforcement.ts:fn:getTierStats:215": {
      "id": "file:src/services/reinforcement.ts:fn:getTierStats:215",
      "type": "function",
      "name": "getTierStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/reinforcement.ts",
      "line": 215,
      "endLine": 250,
      "parentFileId": "file:src/services/reinforcement.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ hypothesis: number; solid: number; avgHypothesisConfidence: number; avgSolidConfidence: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves count and avg confidence stats for hypothesis and solid memory tiers from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getTierStats(): Promise<{\n  hypothesis: number;\n  solid: number;\n  avgHypothesisConfidence: number;\n  avgSolidConfidence: number;\n}> {\n  const result = await pool.query<{\n    tier: string;\n    count: string;\n    avg_confidence: string;\n  }>(\n    `SELECT tier, COUNT(*) as count, AVG(confidence) as avg_confidence\n     FROM memories\n     WHERE tier IS NOT NULL\n     GROUP BY tier`\n  );\n\n  const stats = {\n    hypothesis: 0,\n    solid: 0,\n    avgHypothesisConfidence: 0,\n    avgSolidConfidence: 0,\n  };\n\n  for (const row of result.rows) {\n    if (row.tier === 'hypothesis') {\n      stats.hypothesis = parseInt(row.count, 10);\n      stats.avgHypothesisConfidence = parseFloat(row.avg_confidence);\n    } else if (row.tier === 'solid') {\n      stats.solid = parseInt(row.count, 10);\n      stats.avgSolidConfidence = parseFloat(row.avg_confidence);\n    }\n  }\n\n  return stats;\n}",
      "references": [
        "pool",
        "result",
        "row",
        "stats",
        "parseInt",
        "parseFloat"
      ]
    },
    "file:src/services/reminders.ts": {
      "id": "file:src/services/reminders.ts",
      "type": "file",
      "name": "reminders.ts",
      "filePath": "src/services/reminders.ts",
      "line": 1,
      "endLine": 626,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createStandaloneReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createScheduledReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listReminders",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "cancelReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markReminderSent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markReminderAcknowledged",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markReminderFailed",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "snoozeReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unsnoozeReminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingReminders",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getRetryableReminders",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSnoozedRemindersToWake",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "resetReminderForRetry",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getReminderStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCommitmentReminders",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ReminderStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ReminderChannel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "OffsetType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Reminder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateReminderInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateReminderInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListRemindersOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SnoozeReminderInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/reminders.ts:fn:createReminder:72",
        "file:src/services/reminders.ts:fn:createStandaloneReminder:146",
        "file:src/services/reminders.ts:fn:createScheduledReminder:168",
        "file:src/services/reminders.ts:fn:getReminder:193",
        "file:src/services/reminders.ts:fn:listReminders:204",
        "file:src/services/reminders.ts:fn:updateReminder:274",
        "file:src/services/reminders.ts:fn:deleteReminder:334",
        "file:src/services/reminders.ts:fn:cancelReminder:342",
        "file:src/services/reminders.ts:fn:markReminderSent:356",
        "file:src/services/reminders.ts:fn:markReminderAcknowledged:372",
        "file:src/services/reminders.ts:fn:markReminderFailed:388",
        "file:src/services/reminders.ts:fn:snoozeReminder:425",
        "file:src/services/reminders.ts:fn:unsnoozeReminder:454",
        "file:src/services/reminders.ts:fn:getPendingReminders:481",
        "file:src/services/reminders.ts:fn:getRetryableReminders:501",
        "file:src/services/reminders.ts:fn:getSnoozedRemindersToWake:522",
        "file:src/services/reminders.ts:fn:resetReminderForRetry:543",
        "file:src/services/reminders.ts:fn:getReminderStats:560",
        "file:src/services/reminders.ts:fn:getCommitmentReminders:601"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/reminders.ts:fn:createReminder:72": {
      "id": "file:src/services/reminders.ts:fn:createReminder:72",
      "type": "function",
      "name": "createReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 72,
      "endLine": 141,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/reminders\").CreateReminderInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates reminder in DB after deduplicating by title/commitment and scheduled date",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createReminder(input: CreateReminderInput): Promise<Reminder> {\n  const {\n    commitment_id,\n    title,\n    body,\n    scheduled_for,\n    timezone = config.timezone,\n    offset_type,\n    offset_minutes,\n    channel = 'push',\n    metadata = {},\n  } = input;\n\n  // Validate: must have either commitment_id or title\n  if (!commitment_id && !title) {\n    throw new Error('Reminder must have either commitment_id or title');\n  }\n\n  // Deduplication: check for existing reminder with same title/commitment and same date\n  // This prevents duplicates when extraction runs on both real-time and consolidation paths\n  if (title) {\n    const existing = await pool.query(\n      `SELECT * FROM reminders\n       WHERE title = $1 AND DATE(scheduled_for) = DATE($2)\n       AND status NOT IN ('canceled', 'acknowledged')`,\n      [title, scheduled_for]\n    );\n    if (existing.rows.length > 0) {\n      console.log(`[Reminders] Skipping duplicate reminder: \"${title}\" on ${scheduled_for.toDateString()}`);\n      return existing.rows[0] as Reminder;\n    }\n  }\n\n  if (commitment_id) {\n    const existing = await pool.query(\n      `SELECT * FROM reminders\n       WHERE commitment_id = $1 AND DATE(scheduled_for) = DATE($2)\n       AND status NOT IN ('canceled', 'acknowledged')`,\n      [commitment_id, scheduled_for]\n    );\n    if (existing.rows.length > 0) {\n      console.log(`[Reminders] Skipping duplicate commitment reminder for ${commitment_id}`);\n      return existing.rows[0] as Reminder;\n    }\n  }\n\n  const result = await pool.query(\n    `INSERT INTO reminders (\n      commitment_id, title, body,\n      scheduled_for, timezone,\n      offset_type, offset_minutes,\n      channel, metadata\n    )\n    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n    RETURNING *`,\n    [\n      commitment_id ?? null,\n      title ?? null,\n      body ?? null,\n      scheduled_for,\n      timezone,\n      offset_type ?? null,\n      offset_minutes ?? null,\n      channel,\n      JSON.stringify(metadata),\n    ]\n  );\n\n  return result.rows[0] as Reminder;\n}",
      "references": [
        "commitment_id",
        "title",
        "body",
        "scheduled_for",
        "timezone",
        "config",
        "offset_type",
        "offset_minutes",
        "channel",
        "metadata",
        "Error",
        "pool",
        "existing",
        "console",
        "JSON",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:createStandaloneReminder:146": {
      "id": "file:src/services/reminders.ts:fn:createStandaloneReminder:146",
      "type": "function",
      "name": "createStandaloneReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 146,
      "endLine": 163,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "delayMinutes",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ body?: string; timezone?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a standalone push reminder scheduled after a given delay in minutes",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createStandaloneReminder(\n  title: string,\n  delayMinutes: number,\n  options: { body?: string; timezone?: string } = {}\n): Promise<Reminder> {\n  const { body, timezone = config.timezone } = options;\n\n  const scheduledFor = new Date(Date.now() + delayMinutes * 60000);\n\n  return createReminder({\n    title,\n    body,\n    scheduled_for: scheduledFor,\n    offset_type: 'exact',\n    timezone,\n    channel: 'push',\n  });\n}",
      "references": [
        "body",
        "timezone",
        "config",
        "Date",
        "createReminder",
        "scheduledFor"
      ]
    },
    "file:src/services/reminders.ts:fn:createScheduledReminder:168": {
      "id": "file:src/services/reminders.ts:fn:createScheduledReminder:168",
      "type": "function",
      "name": "createScheduledReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 168,
      "endLine": 188,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "scheduledAt",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ body?: string; timezone?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a scheduled push reminder with title, future date, optional body, and timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createScheduledReminder(\n  title: string,\n  scheduledAt: Date,\n  options: { body?: string; timezone?: string } = {}\n): Promise<Reminder> {\n  const { body, timezone = config.timezone } = options;\n\n  // Validate the scheduled date is in the future\n  if (scheduledAt <= new Date()) {\n    throw new Error('Scheduled time must be in the future');\n  }\n\n  return createReminder({\n    title,\n    body,\n    scheduled_for: scheduledAt,\n    offset_type: 'exact',\n    timezone,\n    channel: 'push',\n  });\n}",
      "references": [
        "body",
        "timezone",
        "config",
        "Date",
        "Error",
        "createReminder"
      ]
    },
    "file:src/services/reminders.ts:fn:getReminder:193": {
      "id": "file:src/services/reminders.ts:fn:getReminder:193",
      "type": "function",
      "name": "getReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 193,
      "endLine": 199,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a reminder from the database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getReminder(id: string): Promise<Reminder | null> {\n  const result = await pool.query(\n    'SELECT * FROM reminders WHERE id = $1',\n    [id]\n  );\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:listReminders:204": {
      "id": "file:src/services/reminders.ts:fn:listReminders:204",
      "type": "function",
      "name": "listReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 204,
      "endLine": 269,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/reminders\").ListRemindersOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries reminders from DB with filters (status, commitment, schedule, channel), limit/offset, ordered by scheduled_for",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listReminders(options: ListRemindersOptions = {}): Promise<Reminder[]> {\n  const {\n    limit = 50,\n    offset = 0,\n    status,\n    commitment_id,\n    scheduled_before,\n    scheduled_after,\n    channel,\n  } = options;\n\n  const conditions: string[] = [];\n  const params: (string | number | Date | string[])[] = [];\n  let paramIndex = 1;\n\n  // Filter by status\n  if (status) {\n    if (Array.isArray(status)) {\n      conditions.push(`status = ANY($${paramIndex})`);\n      params.push(status);\n    } else {\n      conditions.push(`status = $${paramIndex}`);\n      params.push(status);\n    }\n    paramIndex++;\n  }\n\n  // Filter by commitment\n  if (commitment_id) {\n    conditions.push(`commitment_id = $${paramIndex}`);\n    params.push(commitment_id);\n    paramIndex++;\n  }\n\n  // Filter by scheduled time range\n  if (scheduled_before) {\n    conditions.push(`scheduled_for <= $${paramIndex}`);\n    params.push(scheduled_before);\n    paramIndex++;\n  }\n\n  if (scheduled_after) {\n    conditions.push(`scheduled_for >= $${paramIndex}`);\n    params.push(scheduled_after);\n    paramIndex++;\n  }\n\n  // Filter by channel\n  if (channel) {\n    conditions.push(`channel = $${paramIndex}`);\n    params.push(channel);\n    paramIndex++;\n  }\n\n  let query = 'SELECT * FROM reminders';\n  if (conditions.length > 0) {\n    query += ' WHERE ' + conditions.join(' AND ');\n  }\n\n  query += ` ORDER BY scheduled_for ASC`;\n  query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n  params.push(limit, offset);\n\n  const result = await pool.query(query, params);\n  return result.rows as Reminder[];\n}",
      "references": [
        "limit",
        "offset",
        "status",
        "commitment_id",
        "scheduled_before",
        "scheduled_after",
        "channel",
        "Array",
        "conditions",
        "paramIndex",
        "params",
        "query",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:updateReminder:274": {
      "id": "file:src/services/reminders.ts:fn:updateReminder:274",
      "type": "function",
      "name": "updateReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 274,
      "endLine": 329,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/reminders\").UpdateReminderInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates reminder in DB with given fields or fetches existing if none provided",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateReminder(\n  id: string,\n  input: UpdateReminderInput\n): Promise<Reminder | null> {\n  const updates: string[] = [];\n  const params: (string | number | Date | null)[] = [];\n  let paramIndex = 1;\n\n  if (input.title !== undefined) {\n    updates.push(`title = $${paramIndex}`);\n    params.push(input.title);\n    paramIndex++;\n  }\n  if (input.body !== undefined) {\n    updates.push(`body = $${paramIndex}`);\n    params.push(input.body);\n    paramIndex++;\n  }\n  if (input.scheduled_for !== undefined) {\n    updates.push(`scheduled_for = $${paramIndex}`);\n    params.push(input.scheduled_for);\n    paramIndex++;\n  }\n  if (input.timezone !== undefined) {\n    updates.push(`timezone = $${paramIndex}`);\n    params.push(input.timezone);\n    paramIndex++;\n  }\n  if (input.channel !== undefined) {\n    updates.push(`channel = $${paramIndex}`);\n    params.push(input.channel);\n    paramIndex++;\n  }\n  if (input.status !== undefined) {\n    updates.push(`status = $${paramIndex}`);\n    params.push(input.status);\n    paramIndex++;\n  }\n  if (input.metadata !== undefined) {\n    updates.push(`metadata = $${paramIndex}`);\n    params.push(JSON.stringify(input.metadata));\n    paramIndex++;\n  }\n\n  if (updates.length === 0) {\n    return getReminder(id);\n  }\n\n  updates.push('updated_at = NOW()');\n\n  params.push(id);\n  const query = `UPDATE reminders SET ${updates.join(', ')} WHERE id = $${paramIndex} RETURNING *`;\n\n  const result = await pool.query(query, params);\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "JSON",
        "getReminder",
        "pool",
        "query",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:deleteReminder:334": {
      "id": "file:src/services/reminders.ts:fn:deleteReminder:334",
      "type": "function",
      "name": "deleteReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 334,
      "endLine": 337,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a reminder from the database by ID and returns true if successful",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteReminder(id: string): Promise<boolean> {\n  const result = await pool.query('DELETE FROM reminders WHERE id = $1', [id]);\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:cancelReminder:342": {
      "id": "file:src/services/reminders.ts:fn:cancelReminder:342",
      "type": "function",
      "name": "cancelReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 342,
      "endLine": 351,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates reminder status to 'canceled' and returns the updated reminder or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function cancelReminder(id: string): Promise<Reminder | null> {\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'canceled', updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:markReminderSent:356": {
      "id": "file:src/services/reminders.ts:fn:markReminderSent:356",
      "type": "function",
      "name": "markReminderSent",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 356,
      "endLine": 367,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates reminder status to 'sent' with timestamps and returns updated reminder or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markReminderSent(id: string): Promise<Reminder | null> {\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'sent',\n         sent_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:markReminderAcknowledged:372": {
      "id": "file:src/services/reminders.ts:fn:markReminderAcknowledged:372",
      "type": "function",
      "name": "markReminderAcknowledged",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 372,
      "endLine": 383,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates reminder status to acknowledged and returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markReminderAcknowledged(id: string): Promise<Reminder | null> {\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'acknowledged',\n         acknowledged_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:markReminderFailed:388": {
      "id": "file:src/services/reminders.ts:fn:markReminderFailed:388",
      "type": "function",
      "name": "markReminderFailed",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 388,
      "endLine": 420,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "reason",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "scheduleRetry",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": "true"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Marks reminder as failed with reason, increments retry count, optionally schedules retry via DB update",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markReminderFailed(\n  id: string,\n  reason: string,\n  scheduleRetry: boolean = true\n): Promise<Reminder | null> {\n  // Exponential backoff: 1min, 5min, 15min, 1hr, then give up\n  const RETRY_DELAYS = [1, 5, 15, 60]; // minutes\n\n  const current = await getReminder(id);\n  if (!current) return null;\n\n  const retryCount = current.retry_count + 1;\n  let nextRetryAt: Date | null = null;\n\n  if (scheduleRetry && retryCount <= RETRY_DELAYS.length) {\n    const delayMinutes = RETRY_DELAYS[retryCount - 1] ?? 60; // Default to 1 hour\n    nextRetryAt = new Date(Date.now() + delayMinutes * 60000);\n  }\n\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'failed',\n         failure_reason = $1,\n         retry_count = $2,\n         next_retry_at = $3,\n         updated_at = NOW()\n     WHERE id = $4\n     RETURNING *`,\n    [reason, retryCount, nextRetryAt, id]\n  );\n\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "getReminder",
        "current",
        "retryCount",
        "RETRY_DELAYS",
        "nextRetryAt",
        "Date",
        "delayMinutes",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:snoozeReminder:425": {
      "id": "file:src/services/reminders.ts:fn:snoozeReminder:425",
      "type": "function",
      "name": "snoozeReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 425,
      "endLine": 449,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/reminders\").SnoozeReminderInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Snoozes a reminder by updating DB with snoozed status, snooze_until, and original scheduled time.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function snoozeReminder(\n  id: string,\n  input: SnoozeReminderInput\n): Promise<Reminder | null> {\n  const { snooze_until } = input;\n\n  const current = await getReminder(id);\n  if (!current) return null;\n\n  // Preserve original scheduled time if not already snoozed\n  const originalScheduledFor = current.original_scheduled_for ?? current.scheduled_for;\n\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'snoozed',\n         snoozed_until = $1,\n         original_scheduled_for = $2,\n         updated_at = NOW()\n     WHERE id = $3\n     RETURNING *`,\n    [snooze_until, originalScheduledFor, id]\n  );\n\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "snooze_until",
        "getReminder",
        "current",
        "pool",
        "originalScheduledFor",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:unsnoozeReminder:454": {
      "id": "file:src/services/reminders.ts:fn:unsnoozeReminder:454",
      "type": "function",
      "name": "unsnoozeReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 454,
      "endLine": 472,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unsnoozes a reminder by updating status from 'snoozed' to 'pending' and returns it.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unsnoozeReminder(id: string): Promise<Reminder | null> {\n  const current = await getReminder(id);\n  if (!current || current.status !== 'snoozed' || !current.snoozed_until) {\n    return null;\n  }\n\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'pending',\n         scheduled_for = snoozed_until,\n         snoozed_until = NULL,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [id]\n  );\n\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "getReminder",
        "current",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:getPendingReminders:481": {
      "id": "file:src/services/reminders.ts:fn:getPendingReminders:481",
      "type": "function",
      "name": "getPendingReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 481,
      "endLine": 496,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ limit?: number; beforeTime?: Date; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for pending reminders due before a time, ordered by scheduled_for, limited.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPendingReminders(\n  options: { limit?: number; beforeTime?: Date } = {}\n): Promise<Reminder[]> {\n  const { limit = 100, beforeTime = new Date() } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM reminders\n     WHERE status = 'pending'\n       AND scheduled_for <= $1\n     ORDER BY scheduled_for ASC\n     LIMIT $2`,\n    [beforeTime, limit]\n  );\n\n  return result.rows as Reminder[];\n}",
      "references": [
        "limit",
        "beforeTime",
        "Date",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:getRetryableReminders:501": {
      "id": "file:src/services/reminders.ts:fn:getRetryableReminders:501",
      "type": "function",
      "name": "getRetryableReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 501,
      "endLine": 517,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches failed reminders ready for retry from DB, ordered by next_retry_at, with optional limit",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getRetryableReminders(\n  options: { limit?: number } = {}\n): Promise<Reminder[]> {\n  const { limit = 50 } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM reminders\n     WHERE status = 'failed'\n       AND next_retry_at IS NOT NULL\n       AND next_retry_at <= NOW()\n     ORDER BY next_retry_at ASC\n     LIMIT $1`,\n    [limit]\n  );\n\n  return result.rows as Reminder[];\n}",
      "references": [
        "limit",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:getSnoozedRemindersToWake:522": {
      "id": "file:src/services/reminders.ts:fn:getSnoozedRemindersToWake:522",
      "type": "function",
      "name": "getSnoozedRemindersToWake",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 522,
      "endLine": 538,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches snoozed reminders ready to wake (snoozed_until <= NOW()), limited to 50.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSnoozedRemindersToWake(\n  options: { limit?: number } = {}\n): Promise<Reminder[]> {\n  const { limit = 50 } = options;\n\n  const result = await pool.query(\n    `SELECT * FROM reminders\n     WHERE status = 'snoozed'\n       AND snoozed_until IS NOT NULL\n       AND snoozed_until <= NOW()\n     ORDER BY snoozed_until ASC\n     LIMIT $1`,\n    [limit]\n  );\n\n  return result.rows as Reminder[];\n}",
      "references": [
        "limit",
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:resetReminderForRetry:543": {
      "id": "file:src/services/reminders.ts:fn:resetReminderForRetry:543",
      "type": "function",
      "name": "resetReminderForRetry",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 543,
      "endLine": 555,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates failed reminder to pending, resets next_retry_at, returns updated row or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function resetReminderForRetry(id: string): Promise<Reminder | null> {\n  const result = await pool.query(\n    `UPDATE reminders\n     SET status = 'pending',\n         next_retry_at = NULL,\n         updated_at = NOW()\n     WHERE id = $1 AND status = 'failed'\n     RETURNING *`,\n    [id]\n  );\n\n  return (result.rows[0] as Reminder) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/reminders.ts:fn:getReminderStats:560": {
      "id": "file:src/services/reminders.ts:fn:getReminderStats:560",
      "type": "function",
      "name": "getReminderStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 560,
      "endLine": 596,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ by_status: Record<import(\"/home/ridgetop/projects/squire/src/services/reminders\").ReminderStatus, number>; pending_count: number; upcoming_24h: number; failed_count: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches reminder stats: counts by status, pending, upcoming 24h, and failed.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getReminderStats(): Promise<{\n  by_status: Record<ReminderStatus, number>;\n  pending_count: number;\n  upcoming_24h: number;\n  failed_count: number;\n}> {\n  const [statusResult, upcomingResult] = await Promise.all([\n    pool.query(\n      `SELECT status, COUNT(*) as count FROM reminders GROUP BY status`\n    ),\n    pool.query(\n      `SELECT COUNT(*) as count FROM reminders\n       WHERE status = 'pending'\n         AND scheduled_for <= NOW() + INTERVAL '24 hours'`\n    ),\n  ]);\n\n  const byStatus: Record<string, number> = {\n    pending: 0,\n    sent: 0,\n    acknowledged: 0,\n    snoozed: 0,\n    canceled: 0,\n    failed: 0,\n  };\n\n  for (const row of statusResult.rows) {\n    byStatus[row.status] = parseInt(row.count, 10);\n  }\n\n  return {\n    by_status: byStatus as Record<ReminderStatus, number>,\n    pending_count: byStatus.pending ?? 0,\n    upcoming_24h: parseInt(upcomingResult.rows[0]?.count ?? '0', 10),\n    failed_count: byStatus.failed ?? 0,\n  };\n}",
      "references": [
        "statusResult",
        "upcomingResult",
        "Promise",
        "pool",
        "byStatus",
        "row",
        "parseInt"
      ]
    },
    "file:src/services/reminders.ts:fn:getCommitmentReminders:601": {
      "id": "file:src/services/reminders.ts:fn:getCommitmentReminders:601",
      "type": "function",
      "name": "getCommitmentReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/reminders.ts",
      "line": 601,
      "endLine": 625,
      "parentFileId": "file:src/services/reminders.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ status?: import(\"/home/ridgetop/projects/squire/src/services/reminders\").ReminderStatus | import(\"/home/ridgetop/projects/squire/src/services/reminders\").ReminderStatus[]; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches reminders for a commitment from DB, optionally filtered by status.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.093Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCommitmentReminders(\n  commitmentId: string,\n  options: { status?: ReminderStatus | ReminderStatus[] } = {}\n): Promise<Reminder[]> {\n  const { status } = options;\n\n  if (status) {\n    const statusArray = Array.isArray(status) ? status : [status];\n    const result = await pool.query(\n      `SELECT * FROM reminders\n       WHERE commitment_id = $1 AND status = ANY($2)\n       ORDER BY scheduled_for ASC`,\n      [commitmentId, statusArray]\n    );\n    return result.rows as Reminder[];\n  }\n\n  const result = await pool.query(\n    `SELECT * FROM reminders\n     WHERE commitment_id = $1\n     ORDER BY scheduled_for ASC`,\n    [commitmentId]\n  );\n  return result.rows as Reminder[];\n}",
      "references": [
        "status",
        "Array",
        "pool",
        "statusArray",
        "result"
      ]
    },
    "file:src/services/research.ts": {
      "id": "file:src/services/research.ts",
      "type": "file",
      "name": "research.ts",
      "filePath": "src/services/research.ts",
      "line": 1,
      "endLine": 1427,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "completeText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllGaps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "partiallyFillGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fillGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "dismissGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllQuestions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "askQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "answerQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "dismissQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getGapSources",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getQuestionSources",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getGapStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getQuestionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getGapTypeEmoji",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getQuestionTypeEmoji",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getTimingHintDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "processResearchForConsolidation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GAP_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "GapType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GAP_PRIORITIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "GapPriority",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GAP_STATUSES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "GapStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "KnowledgeGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "QUESTION_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "QuestionType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "TIMING_HINTS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "TimingHint",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "QUESTION_STATUSES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "QuestionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ResearchQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GapSourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "QuestionSourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GapSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "QuestionSource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedGap",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedQuestion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ResearchGenerationResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/research.ts:fn:detectGaps:178",
        "file:src/services/research.ts:fn:generateQuestions:334",
        "file:src/services/research.ts:fn:findSimilarGap:484",
        "file:src/services/research.ts:fn:findSimilarQuestion:510",
        "file:src/services/research.ts:fn:createGap:533",
        "file:src/services/research.ts:fn:getGap:559",
        "file:src/services/research.ts:fn:getAllGaps:570",
        "file:src/services/research.ts:fn:surfaceGap:643",
        "file:src/services/research.ts:fn:partiallyFillGap:663",
        "file:src/services/research.ts:fn:fillGap:683",
        "file:src/services/research.ts:fn:dismissGap:703",
        "file:src/services/research.ts:fn:createQuestion:725",
        "file:src/services/research.ts:fn:getQuestion:751",
        "file:src/services/research.ts:fn:getAllQuestions:762",
        "file:src/services/research.ts:fn:askQuestion:841",
        "file:src/services/research.ts:fn:answerQuestion:861",
        "file:src/services/research.ts:fn:dismissQuestion:889",
        "file:src/services/research.ts:fn:expireOldQuestions:908",
        "file:src/services/research.ts:fn:linkGapSource:927",
        "file:src/services/research.ts:fn:linkQuestionSource:948",
        "file:src/services/research.ts:fn:getGapSources:969",
        "file:src/services/research.ts:fn:getQuestionSources:980",
        "file:src/services/research.ts:fn:getGapStats:993",
        "file:src/services/research.ts:fn:getQuestionStats:1060",
        "file:src/services/research.ts:fn:extractJsonArray:1120",
        "file:src/services/research.ts:fn:getGapTypeEmoji:1142",
        "file:src/services/research.ts:fn:getQuestionTypeEmoji:1159",
        "file:src/services/research.ts:fn:getTimingHintDescription:1176",
        "file:src/services/research.ts:fn:processResearchForConsolidation:1199"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/research.ts:fn:detectGaps:178": {
      "id": "file:src/services/research.ts:fn:detectGaps:178",
      "type": "function",
      "name": "detectGaps",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 178,
      "endLine": 320,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "context",
          "type": "GapDetectionContext",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ExtractedGap[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects knowledge gaps in entities and memories using AI system prompt",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectGaps(\n  context: GapDetectionContext\n): Promise<ExtractedGap[]> {\n  if (context.entities.length === 0 && context.recentMemories.length === 0) {\n    return [];\n  }\n\n  const systemPrompt = `You are a knowledge gap detector. Given a person's data, identify what is MISSING or UNKNOWN.\n\nA knowledge gap is NOT what we know - it's what we DON'T know but SHOULD know.\n\nGap types:\n- entity: Missing facts about a person/project/place (\"We don't know Sarah's role\")\n- relationship: Don't know how two entities relate (\"Unclear how Project X connects to Team Y\")\n- timeline: Missing when something happened (\"When did the promotion happen?\")\n- outcome: Know something started but not how it ended (\"The interview - what was the result?\")\n- context: Have facts but lack why/how (\"Why was this decision made?\")\n- commitment: Open promise without resolution (\"Promised to help with X - still pending?\")\n- preference: Don't know user's stance on something (\"Unclear preference on remote vs office\")\n- history: Missing backstory (\"How did you meet Sarah?\")\n\nPriority levels: low, medium, high, critical\nSeverity: 0.0 (minor) to 1.0 (critical gap)\n\nRequirements:\n1. Focus on ACTIONABLE gaps - things worth knowing\n2. Avoid trivial gaps (\"We don't know their shoe size\")\n3. Prioritize gaps about frequently mentioned entities\n4. Look for incomplete stories (started but no ending)\n5. Look for relationships without context\n\nReturn ONLY a JSON array. If no meaningful gaps, return: []\n\nFormat: [{\n  \"content\": \"description of the gap\",\n  \"gap_type\": \"entity|relationship|timeline|outcome|context|commitment|preference|history\",\n  \"priority\": \"low|medium|high|critical\",\n  \"severity\": 0.X,\n  \"related_entity_name\": \"optional entity name\",\n  \"secondary_entity_name\": \"optional for relationship gaps\",\n  \"sources\": [\n    {\"type\": \"memory|belief|pattern|entity\", \"id\": \"uuid\", \"revelation\": \"indicates|primary|context|deepens\", \"explanation\": \"why this reveals the gap\"}\n  ],\n  \"reason\": \"why this gap matters\"\n}]`;\n\n  // Build context string\n  const entitiesStr = context.entities.length > 0\n    ? `ENTITIES (people, projects, places):\\n${context.entities.map((e) =>\n        `- [${e.id}] ${e.name} (${e.type}, ${e.mention_count} mentions)${e.description ? `: ${e.description}` : ''}`\n      ).join('\\n')}`\n    : 'ENTITIES: None extracted yet';\n\n  const beliefsStr = context.beliefs.length > 0\n    ? `BELIEFS:\\n${context.beliefs.map((b) => `- [${b.id}] (${b.type}): \"${b.content}\"`).join('\\n')}`\n    : 'BELIEFS: None recorded';\n\n  const patternsStr = context.patterns.length > 0\n    ? `PATTERNS:\\n${context.patterns.map((p) => `- [${p.id}] (${p.type}): \"${p.content}\"`).join('\\n')}`\n    : 'PATTERNS: None detected';\n\n  const memoriesStr = context.recentMemories.length > 0\n    ? `RECENT MEMORIES:\\n${context.recentMemories.slice(0, 15).map((m) =>\n        `- [${m.id}]: \"${m.content.slice(0, 300)}${m.content.length > 300 ? '...' : ''}\"`\n      ).join('\\n')}`\n    : 'RECENT MEMORIES: None';\n\n  const commitmentsStr = context.commitments\n    ? `COMMITMENTS SUMMARY:\\n${context.commitments}`\n    : 'COMMITMENTS: No summary yet';\n\n  const prompt = `Analyze this person's data and identify knowledge gaps - what DON'T we know that we SHOULD know?\n\n${entitiesStr}\n\n${beliefsStr}\n\n${patternsStr}\n\n${memoriesStr}\n\n${commitmentsStr}\n\nWhat's missing? What incomplete stories exist? What relationships lack context? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.3,\n      maxTokens: 2000,\n    });\n\n    const jsonStr = extractJsonArray(response);\n    if (!jsonStr) return [];\n\n    const extracted = JSON.parse(jsonStr) as Array<{\n      content: string;\n      gap_type: string;\n      priority: string;\n      severity: number;\n      related_entity_name?: string;\n      secondary_entity_name?: string;\n      sources: Array<{\n        type: string;\n        id: string;\n        revelation: string;\n        explanation?: string;\n      }>;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    return extracted\n      .filter(\n        (g) =>\n          GAP_TYPES.includes(g.gap_type as GapType) &&\n          GAP_PRIORITIES.includes(g.priority as GapPriority) &&\n          g.content &&\n          g.severity >= 0 && g.severity <= 1\n      )\n      .map((g) => ({\n        content: g.content,\n        gap_type: g.gap_type as GapType,\n        priority: g.priority as GapPriority,\n        severity: Math.min(1.0, Math.max(0.0, g.severity)),\n        related_entity_name: g.related_entity_name,\n        secondary_entity_name: g.secondary_entity_name,\n        sources: (g.sources || [])\n          .filter((s) => GAP_SOURCE_TYPES.includes(s.type as GapSourceType))\n          .map((s) => ({\n            type: s.type as GapSourceType,\n            id: s.id,\n            revelation: (['indicates', 'primary', 'context', 'deepens'].includes(s.revelation)\n              ? s.revelation\n              : 'indicates') as 'indicates' | 'primary' | 'context' | 'deepens',\n            explanation: s.explanation,\n          })),\n        reason: g.reason || '',\n      }));\n  } catch (error) {\n    console.error('Gap detection failed:', error);\n    return [];\n  }\n}",
      "references": [
        "e",
        "b",
        "p",
        "m",
        "entitiesStr",
        "beliefsStr",
        "patternsStr",
        "memoriesStr",
        "commitmentsStr",
        "completeText",
        "prompt",
        "systemPrompt",
        "extractJsonArray",
        "response",
        "jsonStr",
        "JSON",
        "extracted",
        "GAP_TYPES",
        "g",
        "GAP_PRIORITIES",
        "Math",
        "GAP_SOURCE_TYPES",
        "s",
        "console",
        "error"
      ]
    },
    "file:src/services/research.ts:fn:generateQuestions:334": {
      "id": "file:src/services/research.ts:fn:generateQuestions:334",
      "type": "function",
      "name": "generateQuestions",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 334,
      "endLine": 477,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "context",
          "type": "QuestionGenerationContext",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ExtractedQuestion[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates AI-prompted questions addressing knowledge gaps from context",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function generateQuestions(\n  context: QuestionGenerationContext\n): Promise<ExtractedQuestion[]> {\n  const systemPrompt = `You are a thoughtful question generator. Given knowledge gaps and context, generate smart questions to ask.\n\nA good question:\n- Is specific and answerable\n- Addresses an important gap\n- Is appropriately timed (not intrusive)\n- Shows the system \"cares\" about understanding the user\n\nQuestion types:\n- clarification: \"What did you mean by X?\"\n- follow_up: \"How did the meeting with Sarah go?\"\n- exploration: \"Tell me more about Project Alpha\"\n- verification: \"Is it still true that X?\"\n- deepening: \"What made you feel that way about X?\"\n- connection: \"How does X relate to Y?\"\n- outcome: \"What happened with the interview?\"\n- preference: \"Do you prefer mornings or evenings for deep work?\"\n\nTiming hints:\n- immediately: Ask right now (urgent or time-sensitive)\n- next_session: Ask at start of next conversation\n- when_relevant: Ask when the topic comes up naturally\n- periodic: Ask periodically to verify (preferences, ongoing situations)\n- before_deadline: Ask before a commitment deadline\n\nRequirements:\n1. Each question should address a specific gap or expand understanding\n2. Don't generate duplicate or very similar questions\n3. Prioritize questions about high-severity gaps\n4. Be conversational, not interrogative\n5. Maximum 5-7 questions per generation\n\nReturn ONLY a JSON array. If no good questions, return: []\n\nFormat: [{\n  \"content\": \"the question to ask\",\n  \"question_type\": \"clarification|follow_up|exploration|verification|deepening|connection|outcome|preference\",\n  \"priority\": \"low|medium|high|critical\",\n  \"timing_hint\": \"immediately|next_session|when_relevant|periodic|before_deadline\",\n  \"for_gap_content\": \"optional - content of the gap this addresses\",\n  \"related_entity_name\": \"optional entity name\",\n  \"sources\": [\n    {\"type\": \"memory|belief|pattern|entity|insight|gap\", \"id\": \"uuid\", \"relation\": \"prompted|context|about\", \"explanation\": \"how this source relates\"}\n  ],\n  \"reason\": \"why this question matters\"\n}]`;\n\n  // Build context string\n  const gapsStr = context.gaps.length > 0\n    ? `KNOWLEDGE GAPS TO ADDRESS:\\n${context.gaps.map((g) =>\n        `- [${g.id}] (${g.type}, ${g.priority}, severity: ${g.severity.toFixed(2)}): \"${g.content}\"`\n      ).join('\\n')}`\n    : 'GAPS: None identified yet';\n\n  const entitiesStr = context.entities.length > 0\n    ? `KEY ENTITIES:\\n${context.entities.map((e) => `- [${e.id}] ${e.name} (${e.type})`).join('\\n')}`\n    : 'ENTITIES: None';\n\n  const memoriesStr = context.recentMemories.length > 0\n    ? `RECENT MEMORIES:\\n${context.recentMemories.slice(0, 10).map((m) =>\n        `- [${m.id}]: \"${m.content.slice(0, 200)}...\"`\n      ).join('\\n')}`\n    : 'RECENT MEMORIES: None';\n\n  const existingStr = context.existingQuestions.length > 0\n    ? `ALREADY ASKED/PENDING (do not duplicate):\\n${context.existingQuestions.map((q) =>\n        `- (${q.status}): \"${q.content}\"`\n      ).join('\\n')}`\n    : 'EXISTING QUESTIONS: None';\n\n  const prompt = `Generate thoughtful questions to ask this person to fill knowledge gaps and deepen understanding.\n\n${gapsStr}\n\n${entitiesStr}\n\n${memoriesStr}\n\n${existingStr}\n\nWhat questions would help us understand them better? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.4, // slightly higher for varied questions\n      maxTokens: 2000,\n    });\n\n    const jsonStr = extractJsonArray(response);\n    if (!jsonStr) return [];\n\n    const extracted = JSON.parse(jsonStr) as Array<{\n      content: string;\n      question_type: string;\n      priority: string;\n      timing_hint?: string;\n      for_gap_content?: string;\n      related_entity_name?: string;\n      sources: Array<{\n        type: string;\n        id: string;\n        relation: string;\n        explanation?: string;\n      }>;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    return extracted\n      .filter(\n        (q) =>\n          QUESTION_TYPES.includes(q.question_type as QuestionType) &&\n          GAP_PRIORITIES.includes(q.priority as GapPriority) &&\n          q.content\n      )\n      .map((q) => ({\n        content: q.content,\n        question_type: q.question_type as QuestionType,\n        priority: q.priority as GapPriority,\n        timing_hint: q.timing_hint && TIMING_HINTS.includes(q.timing_hint as TimingHint)\n          ? q.timing_hint as TimingHint\n          : undefined,\n        for_gap_content: q.for_gap_content,\n        related_entity_name: q.related_entity_name,\n        sources: (q.sources || [])\n          .filter((s) => QUESTION_SOURCE_TYPES.includes(s.type as QuestionSourceType))\n          .map((s) => ({\n            type: s.type as QuestionSourceType,\n            id: s.id,\n            relation: (['prompted', 'context', 'about'].includes(s.relation)\n              ? s.relation\n              : 'prompted') as 'prompted' | 'context' | 'about',\n            explanation: s.explanation,\n          })),\n        reason: q.reason || '',\n      }));\n  } catch (error) {\n    console.error('Question generation failed:', error);\n    return [];\n  }\n}",
      "references": [
        "g",
        "e",
        "m",
        "q",
        "gapsStr",
        "entitiesStr",
        "memoriesStr",
        "existingStr",
        "completeText",
        "prompt",
        "systemPrompt",
        "extractJsonArray",
        "response",
        "jsonStr",
        "JSON",
        "extracted",
        "QUESTION_TYPES",
        "GAP_PRIORITIES",
        "TIMING_HINTS",
        "QUESTION_SOURCE_TYPES",
        "s",
        "console",
        "error"
      ]
    },
    "file:src/services/research.ts:fn:findSimilarGap:484": {
      "id": "file:src/services/research.ts:fn:findSimilarGap:484",
      "type": "function",
      "name": "findSimilarGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 484,
      "endLine": 505,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "gapType",
          "type": "\"preference\" | \"context\" | \"entity\" | \"relationship\" | \"timeline\" | \"outcome\" | \"commitment\" | \"history\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for open knowledge gap matching normalized content and gap type exactly.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findSimilarGap(\n  content: string,\n  gapType: GapType\n): Promise<KnowledgeGap | null> {\n  const normalized = content.toLowerCase().trim();\n\n  const result = await pool.query<KnowledgeGap>(\n    `SELECT * FROM knowledge_gaps\n     WHERE gap_type = $1\n       AND status = 'open'\n       AND LOWER(content) = $2\n     LIMIT 1`,\n    [gapType, normalized]\n  );\n\n  if (result.rows[0]) {\n    return result.rows[0];\n  }\n\n  // TODO: Add embedding-based similarity search\n  return null;\n}",
      "references": [
        "pool",
        "normalized",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:findSimilarQuestion:510": {
      "id": "file:src/services/research.ts:fn:findSimilarQuestion:510",
      "type": "function",
      "name": "findSimilarQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 510,
      "endLine": 526,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "questionType",
          "type": "\"preference\" | \"connection\" | \"outcome\" | \"clarification\" | \"follow_up\" | \"exploration\" | \"verification\" | \"deepening\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for matching research question by normalized content and type.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findSimilarQuestion(\n  content: string,\n  questionType: QuestionType\n): Promise<ResearchQuestion | null> {\n  const normalized = content.toLowerCase().trim();\n\n  const result = await pool.query<ResearchQuestion>(\n    `SELECT * FROM research_questions\n     WHERE question_type = $1\n       AND status IN ('pending', 'asked')\n       AND LOWER(content) = $2\n     LIMIT 1`,\n    [questionType, normalized]\n  );\n\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "normalized",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:createGap:533": {
      "id": "file:src/services/research.ts:fn:createGap:533",
      "type": "function",
      "name": "createGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 533,
      "endLine": 554,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "gapType",
          "type": "\"preference\" | \"context\" | \"entity\" | \"relationship\" | \"timeline\" | \"outcome\" | \"commitment\" | \"history\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "severity",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\" | \"critical\"",
          "isOptional": true,
          "defaultValue": "'medium'"
        },
        {
          "name": "relatedEntityId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "secondaryEntityId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "detectionContext",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new knowledge gap into the database and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function createGap(\n  content: string,\n  gapType: GapType,\n  severity: number,\n  priority: GapPriority = 'medium',\n  relatedEntityId?: string,\n  secondaryEntityId?: string,\n  model?: string,\n  detectionContext?: string\n): Promise<KnowledgeGap> {\n  const result = await pool.query<KnowledgeGap>(\n    `INSERT INTO knowledge_gaps (\n       content, gap_type, severity, priority,\n       related_entity_id, secondary_entity_id,\n       detected_by_model, detection_prompt_version, detection_context\n     )\n     VALUES ($1, $2, $3, $4, $5, $6, $7, 'v1', $8)\n     RETURNING *`,\n    [content, gapType, severity, priority, relatedEntityId || null, secondaryEntityId || null, model || null, detectionContext || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getGap:559": {
      "id": "file:src/services/research.ts:fn:getGap:559",
      "type": "function",
      "name": "getGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 559,
      "endLine": 565,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a knowledge gap from the database by ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getGap(id: string): Promise<KnowledgeGap | null> {\n  const result = await pool.query<KnowledgeGap>(\n    `SELECT * FROM knowledge_gaps WHERE id = $1`,\n    [id]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getAllGaps:570": {
      "id": "file:src/services/research.ts:fn:getAllGaps:570",
      "type": "function",
      "name": "getAllGaps",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 570,
      "endLine": 638,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ type?: \"preference\" | \"context\" | \"entity\" | \"relationship\" | \"timeline\" | \"outcome\" | \"commitment\" | \"history\"; status?: \"open\" | \"dismissed\" | \"partially_filled\" | \"filled\"; priority?: \"low\" | \"medium\" | \"high\" | \"critical\"; entityId?: string; minSeverity?: number; limit?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves knowledge gaps from DB with optional filters, sorted by priority, severity, times_surfaced",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllGaps(options?: {\n  type?: GapType;\n  status?: GapStatus;\n  priority?: GapPriority;\n  entityId?: string;\n  minSeverity?: number;\n  limit?: number;\n}): Promise<KnowledgeGap[]> {\n  const conditions: string[] = [];\n  const params: (string | number)[] = [];\n  let paramCount = 0;\n\n  if (options?.type) {\n    paramCount++;\n    conditions.push(`gap_type = $${paramCount}`);\n    params.push(options.type);\n  }\n\n  if (options?.status) {\n    paramCount++;\n    conditions.push(`status = $${paramCount}`);\n    params.push(options.status);\n  } else {\n    conditions.push(`status = 'open'`);\n  }\n\n  if (options?.priority) {\n    paramCount++;\n    conditions.push(`priority = $${paramCount}`);\n    params.push(options.priority);\n  }\n\n  if (options?.entityId) {\n    paramCount++;\n    conditions.push(`(related_entity_id = $${paramCount} OR secondary_entity_id = $${paramCount})`);\n    params.push(options.entityId);\n  }\n\n  if (options?.minSeverity !== undefined) {\n    paramCount++;\n    conditions.push(`severity >= $${paramCount}`);\n    params.push(options.minSeverity);\n  }\n\n  const whereClause = conditions.length > 0\n    ? `WHERE ${conditions.join(' AND ')}`\n    : '';\n\n  const limit = options?.limit || 100;\n  paramCount++;\n  params.push(limit);\n\n  const result = await pool.query<KnowledgeGap>(\n    `SELECT * FROM knowledge_gaps\n     ${whereClause}\n     ORDER BY\n       CASE priority\n         WHEN 'critical' THEN 1\n         WHEN 'high' THEN 2\n         WHEN 'medium' THEN 3\n         WHEN 'low' THEN 4\n       END,\n       severity DESC,\n       times_surfaced DESC\n     LIMIT $${paramCount}`,\n    params\n  );\n  return result.rows;\n}",
      "references": [
        "paramCount",
        "conditions",
        "params",
        "limit",
        "pool",
        "whereClause",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:surfaceGap:643": {
      "id": "file:src/services/research.ts:fn:surfaceGap:643",
      "type": "function",
      "name": "surfaceGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 643,
      "endLine": 658,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates knowledge gap's times_surfaced and timestamps by ID, returns updated row",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function surfaceGap(gapId: string): Promise<KnowledgeGap> {\n  const result = await pool.query<KnowledgeGap>(\n    `UPDATE knowledge_gaps\n     SET times_surfaced = times_surfaced + 1,\n         last_surfaced_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [gapId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Gap not found: ${gapId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:partiallyFillGap:663": {
      "id": "file:src/services/research.ts:fn:partiallyFillGap:663",
      "type": "function",
      "name": "partiallyFillGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 663,
      "endLine": 678,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates knowledge gap status to 'partially_filled' in DB and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function partiallyFillGap(gapId: string): Promise<KnowledgeGap> {\n  const result = await pool.query<KnowledgeGap>(\n    `UPDATE knowledge_gaps\n     SET status = 'partially_filled',\n         partially_filled_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [gapId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Gap not found: ${gapId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:fillGap:683": {
      "id": "file:src/services/research.ts:fn:fillGap:683",
      "type": "function",
      "name": "fillGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 683,
      "endLine": 698,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates knowledge gap status to 'filled' in DB and returns the updated gap",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.094Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fillGap(gapId: string): Promise<KnowledgeGap> {\n  const result = await pool.query<KnowledgeGap>(\n    `UPDATE knowledge_gaps\n     SET status = 'filled',\n         filled_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [gapId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Gap not found: ${gapId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:dismissGap:703": {
      "id": "file:src/services/research.ts:fn:dismissGap:703",
      "type": "function",
      "name": "dismissGap",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 703,
      "endLine": 718,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "reason",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").KnowledgeGap>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates knowledge gap status to 'dismissed' with optional reason and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function dismissGap(gapId: string, reason?: string): Promise<KnowledgeGap> {\n  const result = await pool.query<KnowledgeGap>(\n    `UPDATE knowledge_gaps\n     SET status = 'dismissed',\n         dismissed_reason = $2,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [gapId, reason || null]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Gap not found: ${gapId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:createQuestion:725": {
      "id": "file:src/services/research.ts:fn:createQuestion:725",
      "type": "function",
      "name": "createQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 725,
      "endLine": 746,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "questionType",
          "type": "\"preference\" | \"connection\" | \"outcome\" | \"clarification\" | \"follow_up\" | \"exploration\" | \"verification\" | \"deepening\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "priority",
          "type": "\"low\" | \"medium\" | \"high\" | \"critical\"",
          "isOptional": true,
          "defaultValue": "'medium'"
        },
        {
          "name": "gapId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "relatedEntityId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "timingHint",
          "type": "\"immediately\" | \"next_session\" | \"when_relevant\" | \"periodic\" | \"before_deadline\"",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "expiresAt",
          "type": "Date",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new research question into the database and returns the created record",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function createQuestion(\n  content: string,\n  questionType: QuestionType,\n  priority: GapPriority = 'medium',\n  gapId?: string,\n  relatedEntityId?: string,\n  timingHint?: TimingHint,\n  expiresAt?: Date,\n  model?: string\n): Promise<ResearchQuestion> {\n  const result = await pool.query<ResearchQuestion>(\n    `INSERT INTO research_questions (\n       content, question_type, priority,\n       gap_id, related_entity_id, timing_hint, expires_at,\n       generated_by_model, generation_prompt_version\n     )\n     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 'v1')\n     RETURNING *`,\n    [content, questionType, priority, gapId || null, relatedEntityId || null, timingHint || null, expiresAt || null, model || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getQuestion:751": {
      "id": "file:src/services/research.ts:fn:getQuestion:751",
      "type": "function",
      "name": "getQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 751,
      "endLine": 757,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a research question by ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getQuestion(id: string): Promise<ResearchQuestion | null> {\n  const result = await pool.query<ResearchQuestion>(\n    `SELECT * FROM research_questions WHERE id = $1`,\n    [id]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getAllQuestions:762": {
      "id": "file:src/services/research.ts:fn:getAllQuestions:762",
      "type": "function",
      "name": "getAllQuestions",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 762,
      "endLine": 836,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ type?: \"preference\" | \"connection\" | \"outcome\" | \"clarification\" | \"follow_up\" | \"exploration\" | \"verification\" | \"deepening\"; status?: \"dismissed\" | \"expired\" | \"pending\" | \"asked\" | \"answered\"; priority?: \"low\" | \"medium\" | \"high\" | \"critical\"; gapId?: string; entityId?: string; timingHint?: \"immediately\" | \"next_session\" | \"when_relevant\" | \"periodic\" | \"before_deadline\"; limit?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for research questions with optional filters, sorts by priority/created_at, limits results",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllQuestions(options?: {\n  type?: QuestionType;\n  status?: QuestionStatus;\n  priority?: GapPriority;\n  gapId?: string;\n  entityId?: string;\n  timingHint?: TimingHint;\n  limit?: number;\n}): Promise<ResearchQuestion[]> {\n  const conditions: string[] = [];\n  const params: (string | number)[] = [];\n  let paramCount = 0;\n\n  if (options?.type) {\n    paramCount++;\n    conditions.push(`question_type = $${paramCount}`);\n    params.push(options.type);\n  }\n\n  if (options?.status) {\n    paramCount++;\n    conditions.push(`status = $${paramCount}`);\n    params.push(options.status);\n  } else {\n    conditions.push(`status = 'pending'`);\n  }\n\n  if (options?.priority) {\n    paramCount++;\n    conditions.push(`priority = $${paramCount}`);\n    params.push(options.priority);\n  }\n\n  if (options?.gapId) {\n    paramCount++;\n    conditions.push(`gap_id = $${paramCount}`);\n    params.push(options.gapId);\n  }\n\n  if (options?.entityId) {\n    paramCount++;\n    conditions.push(`related_entity_id = $${paramCount}`);\n    params.push(options.entityId);\n  }\n\n  if (options?.timingHint) {\n    paramCount++;\n    conditions.push(`timing_hint = $${paramCount}`);\n    params.push(options.timingHint);\n  }\n\n  const whereClause = conditions.length > 0\n    ? `WHERE ${conditions.join(' AND ')}`\n    : '';\n\n  const limit = options?.limit || 100;\n  paramCount++;\n  params.push(limit);\n\n  const result = await pool.query<ResearchQuestion>(\n    `SELECT * FROM research_questions\n     ${whereClause}\n     ORDER BY\n       CASE priority\n         WHEN 'critical' THEN 1\n         WHEN 'high' THEN 2\n         WHEN 'medium' THEN 3\n         WHEN 'low' THEN 4\n       END,\n       created_at DESC\n     LIMIT $${paramCount}`,\n    params\n  );\n  return result.rows;\n}",
      "references": [
        "paramCount",
        "conditions",
        "params",
        "limit",
        "pool",
        "whereClause",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:askQuestion:841": {
      "id": "file:src/services/research.ts:fn:askQuestion:841",
      "type": "function",
      "name": "askQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 841,
      "endLine": 856,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "questionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates research question status to 'asked' with timestamps and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function askQuestion(questionId: string): Promise<ResearchQuestion> {\n  const result = await pool.query<ResearchQuestion>(\n    `UPDATE research_questions\n     SET status = 'asked',\n         asked_at = NOW(),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [questionId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Question not found: ${questionId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:answerQuestion:861": {
      "id": "file:src/services/research.ts:fn:answerQuestion:861",
      "type": "function",
      "name": "answerQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 861,
      "endLine": 884,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "questionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "answer",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "answerMemoryId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "usefulnessScore",
          "type": "number",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates research question with answer, status, timestamps, and optional scores, returns updated row",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function answerQuestion(\n  questionId: string,\n  answer: string,\n  answerMemoryId?: string,\n  usefulnessScore?: number\n): Promise<ResearchQuestion> {\n  const result = await pool.query<ResearchQuestion>(\n    `UPDATE research_questions\n     SET status = 'answered',\n         answered_at = NOW(),\n         answer = $2,\n         answer_memory_id = $3,\n         usefulness_score = $4,\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [questionId, answer, answerMemoryId || null, usefulnessScore || null]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Question not found: ${questionId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:dismissQuestion:889": {
      "id": "file:src/services/research.ts:fn:dismissQuestion:889",
      "type": "function",
      "name": "dismissQuestion",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 889,
      "endLine": 903,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "questionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchQuestion>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates research question status to 'dismissed' and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function dismissQuestion(questionId: string): Promise<ResearchQuestion> {\n  const result = await pool.query<ResearchQuestion>(\n    `UPDATE research_questions\n     SET status = 'dismissed',\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [questionId]\n  );\n\n  if (!result.rows[0]) {\n    throw new Error(`Question not found: ${questionId}`);\n  }\n  return result.rows[0];\n}",
      "references": [
        "pool",
        "result",
        "Error"
      ]
    },
    "file:src/services/research.ts:fn:expireOldQuestions:908": {
      "id": "file:src/services/research.ts:fn:expireOldQuestions:908",
      "type": "function",
      "name": "expireOldQuestions",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 908,
      "endLine": 920,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<number>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates pending research questions past expiration to 'expired' and returns row count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function expireOldQuestions(): Promise<number> {\n  const result = await pool.query(\n    `UPDATE research_questions\n     SET status = 'expired',\n         expired_reason = 'Past expiration date',\n         updated_at = NOW()\n     WHERE status = 'pending'\n       AND expires_at IS NOT NULL\n       AND expires_at < NOW()\n     RETURNING id`\n  );\n  return result.rowCount || 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:linkGapSource:927": {
      "id": "file:src/services/research.ts:fn:linkGapSource:927",
      "type": "function",
      "name": "linkGapSource",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 927,
      "endLine": 943,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceType",
          "type": "\"memory\" | \"belief\" | \"pattern\" | \"entity\" | \"insight\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "revelationType",
          "type": "\"primary\" | \"context\" | \"indicates\" | \"deepens\"",
          "isOptional": true,
          "defaultValue": "'indicates'"
        },
        {
          "name": "explanation",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").GapSource>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts or updates a gap source link in the database with conflict handling.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function linkGapSource(\n  gapId: string,\n  sourceType: GapSourceType,\n  sourceId: string,\n  revelationType: 'indicates' | 'primary' | 'context' | 'deepens' = 'indicates',\n  explanation?: string\n): Promise<GapSource> {\n  const result = await pool.query<GapSource>(\n    `INSERT INTO gap_sources (gap_id, source_type, source_id, revelation_type, explanation)\n     VALUES ($1, $2, $3, $4, $5)\n     ON CONFLICT (gap_id, source_type, source_id)\n     DO UPDATE SET revelation_type = $4, explanation = $5\n     RETURNING *`,\n    [gapId, sourceType, sourceId, revelationType, explanation || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:linkQuestionSource:948": {
      "id": "file:src/services/research.ts:fn:linkQuestionSource:948",
      "type": "function",
      "name": "linkQuestionSource",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 948,
      "endLine": 964,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "questionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceType",
          "type": "\"memory\" | \"belief\" | \"pattern\" | \"entity\" | \"insight\" | \"gap\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sourceId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "relationType",
          "type": "\"context\" | \"about\" | \"prompted\"",
          "isOptional": true,
          "defaultValue": "'prompted'"
        },
        {
          "name": "explanation",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").QuestionSource>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts or updates question source link in database and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function linkQuestionSource(\n  questionId: string,\n  sourceType: QuestionSourceType,\n  sourceId: string,\n  relationType: 'prompted' | 'context' | 'about' = 'prompted',\n  explanation?: string\n): Promise<QuestionSource> {\n  const result = await pool.query<QuestionSource>(\n    `INSERT INTO question_sources (question_id, source_type, source_id, relation_type, explanation)\n     VALUES ($1, $2, $3, $4, $5)\n     ON CONFLICT (question_id, source_type, source_id)\n     DO UPDATE SET relation_type = $4, explanation = $5\n     RETURNING *`,\n    [questionId, sourceType, sourceId, relationType, explanation || null]\n  );\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getGapSources:969": {
      "id": "file:src/services/research.ts:fn:getGapSources:969",
      "type": "function",
      "name": "getGapSources",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 969,
      "endLine": 975,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "gapId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").GapSource[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves gap sources from database by gap ID, ordered by added_at",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getGapSources(gapId: string): Promise<GapSource[]> {\n  const result = await pool.query<GapSource>(\n    `SELECT * FROM gap_sources WHERE gap_id = $1 ORDER BY added_at`,\n    [gapId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getQuestionSources:980": {
      "id": "file:src/services/research.ts:fn:getQuestionSources:980",
      "type": "function",
      "name": "getQuestionSources",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 980,
      "endLine": 986,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "questionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").QuestionSource[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves question sources from database by question ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getQuestionSources(questionId: string): Promise<QuestionSource[]> {\n  const result = await pool.query<QuestionSource>(\n    `SELECT * FROM question_sources WHERE question_id = $1 ORDER BY added_at`,\n    [questionId]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/research.ts:fn:getGapStats:993": {
      "id": "file:src/services/research.ts:fn:getGapStats:993",
      "type": "function",
      "name": "getGapStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 993,
      "endLine": 1055,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; open: number; partiallyFilled: number; filled: number; dismissed: number; byType: Record<string, number>; byPriority: Record<string, number>; avgSeverity: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches knowledge gap stats: counts by status/type/priority and avg severity from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getGapStats(): Promise<{\n  total: number;\n  open: number;\n  partiallyFilled: number;\n  filled: number;\n  dismissed: number;\n  byType: Record<string, number>;\n  byPriority: Record<string, number>;\n  avgSeverity: number;\n}> {\n  const result = await pool.query<{\n    total: string;\n    open: string;\n    partially_filled: string;\n    filled: string;\n    dismissed: string;\n    avg_severity: string;\n  }>(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE status = 'open') as open,\n      COUNT(*) FILTER (WHERE status = 'partially_filled') as partially_filled,\n      COUNT(*) FILTER (WHERE status = 'filled') as filled,\n      COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed,\n      AVG(severity) as avg_severity\n    FROM knowledge_gaps\n  `);\n\n  const byTypeResult = await pool.query<{ gap_type: string; count: string }>(`\n    SELECT gap_type, COUNT(*) as count\n    FROM knowledge_gaps\n    WHERE status = 'open'\n    GROUP BY gap_type\n  `);\n\n  const byPriorityResult = await pool.query<{ priority: string; count: string }>(`\n    SELECT priority, COUNT(*) as count\n    FROM knowledge_gaps\n    WHERE status = 'open'\n    GROUP BY priority\n  `);\n\n  const row = result.rows[0]!;\n  const byType: Record<string, number> = {};\n  for (const r of byTypeResult.rows) {\n    byType[r.gap_type] = parseInt(r.count, 10);\n  }\n  const byPriority: Record<string, number> = {};\n  for (const r of byPriorityResult.rows) {\n    byPriority[r.priority] = parseInt(r.count, 10);\n  }\n\n  return {\n    total: parseInt(row.total, 10),\n    open: parseInt(row.open, 10),\n    partiallyFilled: parseInt(row.partially_filled, 10),\n    filled: parseInt(row.filled, 10),\n    dismissed: parseInt(row.dismissed, 10),\n    byType,\n    byPriority,\n    avgSeverity: parseFloat(row.avg_severity) || 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "byTypeResult",
        "byType",
        "r",
        "parseInt",
        "byPriorityResult",
        "byPriority",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/research.ts:fn:getQuestionStats:1060": {
      "id": "file:src/services/research.ts:fn:getQuestionStats:1060",
      "type": "function",
      "name": "getQuestionStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1060,
      "endLine": 1113,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; pending: number; asked: number; answered: number; dismissed: number; expired: number; byType: Record<string, number>; avgUsefulness: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches stats on research questions: counts by status/type and avg usefulness from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.095Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getQuestionStats(): Promise<{\n  total: number;\n  pending: number;\n  asked: number;\n  answered: number;\n  dismissed: number;\n  expired: number;\n  byType: Record<string, number>;\n  avgUsefulness: number;\n}> {\n  const result = await pool.query<{\n    total: string;\n    pending: string;\n    asked: string;\n    answered: string;\n    dismissed: string;\n    expired: string;\n    avg_usefulness: string;\n  }>(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE status = 'pending') as pending,\n      COUNT(*) FILTER (WHERE status = 'asked') as asked,\n      COUNT(*) FILTER (WHERE status = 'answered') as answered,\n      COUNT(*) FILTER (WHERE status = 'dismissed') as dismissed,\n      COUNT(*) FILTER (WHERE status = 'expired') as expired,\n      AVG(usefulness_score) FILTER (WHERE usefulness_score IS NOT NULL) as avg_usefulness\n    FROM research_questions\n  `);\n\n  const byTypeResult = await pool.query<{ question_type: string; count: string }>(`\n    SELECT question_type, COUNT(*) as count\n    FROM research_questions\n    WHERE status = 'pending'\n    GROUP BY question_type\n  `);\n\n  const row = result.rows[0]!;\n  const byType: Record<string, number> = {};\n  for (const r of byTypeResult.rows) {\n    byType[r.question_type] = parseInt(r.count, 10);\n  }\n\n  return {\n    total: parseInt(row.total, 10),\n    pending: parseInt(row.pending, 10),\n    asked: parseInt(row.asked, 10),\n    answered: parseInt(row.answered, 10),\n    dismissed: parseInt(row.dismissed, 10),\n    expired: parseInt(row.expired, 10),\n    byType,\n    avgUsefulness: parseFloat(row.avg_usefulness) || 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "byTypeResult",
        "byType",
        "r",
        "parseInt",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/research.ts:fn:extractJsonArray:1120": {
      "id": "file:src/services/research.ts:fn:extractJsonArray:1120",
      "type": "function",
      "name": "extractJsonArray",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1120,
      "endLine": 1137,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "response",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Extracts the first JSON array substring from a string by matching brackets.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function extractJsonArray(response: string): string | null {\n  const startIdx = response.indexOf('[');\n  if (startIdx === -1) return null;\n\n  let depth = 0;\n  let endIdx = -1;\n  for (let i = startIdx; i < response.length; i++) {\n    if (response[i] === '[') depth++;\n    if (response[i] === ']') depth--;\n    if (depth === 0) {\n      endIdx = i;\n      break;\n    }\n  }\n\n  if (endIdx === -1) return null;\n  return response.substring(startIdx, endIdx + 1);\n}",
      "references": [
        "startIdx",
        "i",
        "depth",
        "endIdx"
      ]
    },
    "file:src/services/research.ts:fn:getGapTypeEmoji:1142": {
      "id": "file:src/services/research.ts:fn:getGapTypeEmoji:1142",
      "type": "function",
      "name": "getGapTypeEmoji",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1142,
      "endLine": 1154,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"preference\" | \"context\" | \"entity\" | \"relationship\" | \"timeline\" | \"outcome\" | \"commitment\" | \"history\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji string for the given GapType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getGapTypeEmoji(type: GapType): string {\n  const emojis: Record<GapType, string> = {\n    entity: '\\u{1F464}',       // bust in silhouette\n    relationship: '\\u{1F517}', // link\n    timeline: '\\u{23F0}',      // alarm clock\n    outcome: '\\u{2753}',       // question mark\n    context: '\\u{1F4AC}',      // speech bubble\n    commitment: '\\u{1F91D}',   // handshake\n    preference: '\\u{2764}',    // heart\n    history: '\\u{1F4DC}',      // scroll\n  };\n  return emojis[type];\n}",
      "references": [
        "emojis"
      ]
    },
    "file:src/services/research.ts:fn:getQuestionTypeEmoji:1159": {
      "id": "file:src/services/research.ts:fn:getQuestionTypeEmoji:1159",
      "type": "function",
      "name": "getQuestionTypeEmoji",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1159,
      "endLine": 1171,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "\"preference\" | \"connection\" | \"outcome\" | \"clarification\" | \"follow_up\" | \"exploration\" | \"verification\" | \"deepening\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji string for the given QuestionType.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getQuestionTypeEmoji(type: QuestionType): string {\n  const emojis: Record<QuestionType, string> = {\n    clarification: '\\u{1F50D}', // magnifying glass\n    follow_up: '\\u{27A1}',      // right arrow\n    exploration: '\\u{1F30D}',   // globe\n    verification: '\\u{2705}',   // check mark\n    deepening: '\\u{1F4AD}',     // thought balloon\n    connection: '\\u{1F500}',    // shuffle\n    outcome: '\\u{1F3C1}',       // checkered flag\n    preference: '\\u{2764}',     // heart\n  };\n  return emojis[type];\n}",
      "references": [
        "emojis"
      ]
    },
    "file:src/services/research.ts:fn:getTimingHintDescription:1176": {
      "id": "file:src/services/research.ts:fn:getTimingHintDescription:1176",
      "type": "function",
      "name": "getTimingHintDescription",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1176,
      "endLine": 1185,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "hint",
          "type": "\"immediately\" | \"next_session\" | \"when_relevant\" | \"periodic\" | \"before_deadline\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a descriptive string for a given TimingHint value.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getTimingHintDescription(hint: TimingHint): string {\n  const descriptions: Record<TimingHint, string> = {\n    immediately: 'Ask right away',\n    next_session: 'Ask at start of next conversation',\n    when_relevant: 'Ask when topic comes up',\n    periodic: 'Ask periodically',\n    before_deadline: 'Ask before deadline',\n  };\n  return descriptions[hint];\n}",
      "references": [
        "descriptions"
      ]
    },
    "file:src/services/research.ts:fn:processResearchForConsolidation:1199": {
      "id": "file:src/services/research.ts:fn:processResearchForConsolidation:1199",
      "type": "function",
      "name": "processResearchForConsolidation",
      "filePath": "/home/ridgetop/projects/squire/src/services/research.ts",
      "line": 1199,
      "endLine": 1426,
      "parentFileId": "file:src/services/research.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "model",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/research\").ResearchGenerationResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for entities, beliefs, patterns, memories, commitments for research consolidation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processResearchForConsolidation(\n  model?: string\n): Promise<ResearchGenerationResult> {\n  const result: ResearchGenerationResult = {\n    gapsCreated: [],\n    gapsSurfaced: [],\n    questionsCreated: [],\n    questionsExpired: 0,\n  };\n\n  // Gather gap detection context\n  const entitiesResult = await pool.query<{\n    id: string;\n    name: string;\n    entity_type: string;\n    description: string | null;\n    mention_count: number;\n  }>(\n    `SELECT id, name, entity_type, description, mention_count\n     FROM entities\n     WHERE is_merged = FALSE\n     ORDER BY mention_count DESC\n     LIMIT 30`\n  );\n\n  const beliefsResult = await pool.query<{\n    id: string;\n    content: string;\n    belief_type: string;\n    confidence: number;\n  }>(\n    `SELECT id, content, belief_type, confidence\n     FROM beliefs\n     WHERE status = 'active'\n     ORDER BY confidence DESC\n     LIMIT 20`\n  );\n\n  const patternsResult = await pool.query<{\n    id: string;\n    content: string;\n    pattern_type: string;\n  }>(\n    `SELECT id, content, pattern_type\n     FROM patterns\n     WHERE status = 'active'\n     ORDER BY confidence DESC\n     LIMIT 20`\n  );\n\n  const memoriesResult = await pool.query<{\n    id: string;\n    content: string;\n    created_at: Date;\n  }>(\n    `SELECT id, content, created_at\n     FROM memories\n     ORDER BY created_at DESC\n     LIMIT 20`\n  );\n\n  const commitmentsResult = await pool.query<{ content: string }>(\n    `SELECT content FROM living_summaries WHERE category = 'commitments'`\n  );\n\n  const gapContext = {\n    entities: entitiesResult.rows.map((e) => ({\n      id: e.id,\n      name: e.name,\n      type: e.entity_type,\n      description: e.description,\n      mention_count: e.mention_count,\n    })),\n    beliefs: beliefsResult.rows.map((b) => ({\n      id: b.id,\n      content: b.content,\n      type: b.belief_type,\n      confidence: b.confidence,\n    })),\n    patterns: patternsResult.rows.map((p) => ({\n      id: p.id,\n      content: p.content,\n      type: p.pattern_type,\n    })),\n    recentMemories: memoriesResult.rows,\n    commitments: commitmentsResult.rows[0]?.content || '',\n  };\n\n  // Detect gaps\n  const extractedGaps = await detectGaps(gapContext);\n\n  for (const ext of extractedGaps) {\n    // Check for existing similar gap\n    const existing = await findSimilarGap(ext.content, ext.gap_type);\n\n    if (existing) {\n      // Surface existing gap\n      const surfaced = await surfaceGap(existing.id);\n      result.gapsSurfaced.push(surfaced);\n    } else {\n      // Resolve entity names to IDs\n      let relatedEntityId: string | undefined;\n      let secondaryEntityId: string | undefined;\n\n      if (ext.related_entity_name) {\n        const entityResult = await pool.query<{ id: string }>(\n          `SELECT id FROM entities WHERE LOWER(name) = LOWER($1) LIMIT 1`,\n          [ext.related_entity_name]\n        );\n        relatedEntityId = entityResult.rows[0]?.id;\n      }\n\n      if (ext.secondary_entity_name) {\n        const entityResult = await pool.query<{ id: string }>(\n          `SELECT id FROM entities WHERE LOWER(name) = LOWER($1) LIMIT 1`,\n          [ext.secondary_entity_name]\n        );\n        secondaryEntityId = entityResult.rows[0]?.id;\n      }\n\n      // Create new gap\n      const gap = await createGap(\n        ext.content,\n        ext.gap_type,\n        ext.severity,\n        ext.priority,\n        relatedEntityId,\n        secondaryEntityId,\n        model,\n        ext.reason\n      );\n\n      // Link sources\n      for (const source of ext.sources) {\n        try {\n          await linkGapSource(gap.id, source.type, source.id, source.revelation, source.explanation);\n        } catch {\n          // Source ID might not be valid - skip\n        }\n      }\n\n      result.gapsCreated.push(gap);\n    }\n  }\n\n  // Get open gaps for question generation\n  const openGaps = await getAllGaps({ status: 'open', limit: 20 });\n\n  // Get existing questions to avoid duplicates\n  const existingQuestions = await getAllQuestions({ limit: 50 });\n\n  const questionContext = {\n    gaps: openGaps.map((g) => ({\n      id: g.id,\n      content: g.content,\n      type: g.gap_type,\n      priority: g.priority,\n      severity: g.severity,\n    })),\n    entities: entitiesResult.rows.slice(0, 15).map((e) => ({\n      id: e.id,\n      name: e.name,\n      type: e.entity_type,\n    })),\n    recentMemories: memoriesResult.rows.slice(0, 10),\n    existingQuestions: existingQuestions.map((q) => ({\n      content: q.content,\n      status: q.status,\n    })),\n  };\n\n  // Generate questions\n  const extractedQuestions = await generateQuestions(questionContext);\n\n  for (const ext of extractedQuestions) {\n    // Check for existing similar question\n    const existing = await findSimilarQuestion(ext.content, ext.question_type);\n    if (existing) continue;\n\n    // Find gap ID if for_gap_content is provided\n    let gapId: string | undefined;\n    if (ext.for_gap_content) {\n      const matchingGap = openGaps.find((g) =>\n        g.content.toLowerCase().includes(ext.for_gap_content!.toLowerCase()) ||\n        ext.for_gap_content!.toLowerCase().includes(g.content.toLowerCase())\n      );\n      gapId = matchingGap?.id;\n    }\n\n    // Resolve entity name to ID\n    let relatedEntityId: string | undefined;\n    if (ext.related_entity_name) {\n      const entityResult = await pool.query<{ id: string }>(\n        `SELECT id FROM entities WHERE LOWER(name) = LOWER($1) LIMIT 1`,\n        [ext.related_entity_name]\n      );\n      relatedEntityId = entityResult.rows[0]?.id;\n    }\n\n    // Create question\n    const question = await createQuestion(\n      ext.content,\n      ext.question_type,\n      ext.priority,\n      gapId,\n      relatedEntityId,\n      ext.timing_hint,\n      undefined, // expires_at\n      model\n    );\n\n    // Link sources\n    for (const source of ext.sources) {\n      try {\n        await linkQuestionSource(question.id, source.type, source.id, source.relation, source.explanation);\n      } catch {\n        // Source ID might not be valid - skip\n      }\n    }\n\n    result.questionsCreated.push(question);\n  }\n\n  // Expire old questions\n  result.questionsExpired = await expireOldQuestions();\n\n  return result;\n}",
      "references": [
        "pool",
        "entitiesResult",
        "e",
        "beliefsResult",
        "b",
        "patternsResult",
        "p",
        "memoriesResult",
        "commitmentsResult",
        "detectGaps",
        "gapContext",
        "extractedGaps",
        "findSimilarGap",
        "ext",
        "existing",
        "surfaceGap",
        "result",
        "surfaced",
        "relatedEntityId",
        "entityResult",
        "secondaryEntityId",
        "createGap",
        "linkGapSource",
        "gap",
        "source",
        "getAllGaps",
        "getAllQuestions",
        "openGaps",
        "g",
        "existingQuestions",
        "q",
        "generateQuestions",
        "questionContext",
        "extractedQuestions",
        "findSimilarQuestion",
        "gapId",
        "matchingGap",
        "createQuestion",
        "linkQuestionSource",
        "question",
        "expireOldQuestions"
      ]
    },
    "file:src/services/resolution.ts": {
      "id": "file:src/services/resolution.ts",
      "type": "file",
      "name": "resolution.ts",
      "filePath": "src/services/resolution.ts",
      "line": 1,
      "endLine": 399,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./commitments.js",
          "items": [
            {
              "name": "Commitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ResolutionType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./edges.js",
          "items": [
            {
              "name": "createEdge",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "processMessagesForResolutions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ResolutionCandidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/resolution.ts:fn:detectResolution:89",
        "file:src/services/resolution.ts:fn:findMatchingCommitments:135",
        "file:src/services/resolution.ts:fn:findMatchingCommitmentsText:187",
        "file:src/services/resolution.ts:fn:processMessageForResolution:236",
        "file:src/services/resolution.ts:fn:autoResolveCommitment:281",
        "file:src/services/resolution.ts:fn:processMessagesForResolutions:363"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/resolution.ts:fn:detectResolution:89": {
      "id": "file:src/services/resolution.ts:fn:detectResolution:89",
      "type": "function",
      "name": "detectResolution",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 89,
      "endLine": 130,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ResolutionDetection>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects task resolution in message via keywords and LLM API call.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function detectResolution(message: string): Promise<ResolutionDetection | null> {\n  // Quick pre-check for resolution-related keywords to avoid unnecessary LLM calls\n  const resolutionKeywords = /\\b(finish|done|complete|cancel|nevermind|never mind|not going to|decided against|no longer|supersed|replaced|instead|rescheduled|taken care|handled|wrapped up|accomplished|achieved)\\b/i;\n\n  if (!resolutionKeywords.test(message)) {\n    return null;\n  }\n\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: RESOLUTION_DETECTION_PROMPT },\n      { role: 'user', content: message },\n    ];\n\n    const result = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 300,\n    });\n\n    const content = result.content.trim();\n\n    // Extract JSON from response\n    let jsonStr = content;\n    const jsonMatch = content.match(/\\{[\\s\\S]*\\}/);\n    if (jsonMatch) {\n      jsonStr = jsonMatch[0];\n    }\n\n    const parsed = JSON.parse(jsonStr) as ResolutionDetection;\n\n    // Validate structure\n    if (typeof parsed.is_resolution !== 'boolean') {\n      console.error('[Resolution] Invalid detection response - missing is_resolution');\n      return null;\n    }\n\n    return parsed;\n  } catch (error) {\n    console.error('[Resolution] Detection failed:', error);\n    return null;\n  }\n}",
      "references": [
        "resolutionKeywords",
        "RESOLUTION_DETECTION_PROMPT",
        "complete",
        "messages",
        "result",
        "content",
        "jsonMatch",
        "jsonStr",
        "JSON",
        "parsed",
        "console",
        "error"
      ]
    },
    "file:src/services/resolution.ts:fn:findMatchingCommitments:135": {
      "id": "file:src/services/resolution.ts:fn:findMatchingCommitments:135",
      "type": "function",
      "name": "findMatchingCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 135,
      "endLine": 182,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subjectHint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSimilarity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<CommitmentMatch[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Finds open commitments matching subject hint via vector embedding similarity search",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findMatchingCommitments(\n  subjectHint: string,\n  options: {\n    limit?: number;\n    minSimilarity?: number;\n  } = {}\n): Promise<CommitmentMatch[]> {\n  const { limit = 5, minSimilarity = 0.3 } = options;\n\n  // Generate embedding for the subject hint\n  const embedding = await generateEmbedding(subjectHint);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  // Search for open commitments by embedding similarity\n  const result = await pool.query<Commitment & { similarity: number }>(\n    `SELECT c.*,\n            1 - (c.embedding <=> $1::vector) as similarity\n     FROM commitments c\n     WHERE c.status IN ('open', 'in_progress')\n       AND c.embedding IS NOT NULL\n       AND 1 - (c.embedding <=> $1::vector) >= $2\n     ORDER BY similarity DESC\n     LIMIT $3`,\n    [embeddingStr, minSimilarity, limit]\n  );\n\n  return result.rows.map((row) => {\n    const similarity = row.similarity;\n    let confidence: 'high' | 'medium' | 'low';\n\n    if (similarity >= 0.7) {\n      confidence = 'high';\n    } else if (similarity >= 0.5) {\n      confidence = 'medium';\n    } else {\n      confidence = 'low';\n    }\n\n    // Remove similarity from the commitment object\n    const { similarity: _, ...commitment } = row;\n\n    return {\n      commitment: commitment as Commitment,\n      similarity,\n      confidence,\n    };\n  });\n}",
      "references": [
        "limit",
        "minSimilarity",
        "generateEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "result",
        "row",
        "similarity",
        "confidence",
        "_",
        "commitment"
      ]
    },
    "file:src/services/resolution.ts:fn:findMatchingCommitmentsText:187": {
      "id": "file:src/services/resolution.ts:fn:findMatchingCommitmentsText:187",
      "type": "function",
      "name": "findMatchingCommitmentsText",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 187,
      "endLine": 230,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subjectHint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<CommitmentMatch[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches open/in_progress commitments by text match in title/description using subject hint",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findMatchingCommitmentsText(\n  subjectHint: string,\n  options: {\n    limit?: number;\n  } = {}\n): Promise<CommitmentMatch[]> {\n  const { limit = 5 } = options;\n\n  // Prepare search terms from the hint\n  const searchTerms = subjectHint\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((term) => term.length > 2)\n    .map((term) => term.replace(/[^a-z0-9]/g, ''));\n\n  if (searchTerms.length === 0) {\n    return [];\n  }\n\n  // Build ILIKE conditions for each term\n  const conditions = searchTerms.map((_, i) => `(title ILIKE $${i + 2} OR description ILIKE $${i + 2})`);\n  const params = searchTerms.map((term) => `%${term}%`);\n\n  const result = await pool.query<Commitment>(\n    `SELECT *\n     FROM commitments\n     WHERE status IN ('open', 'in_progress')\n       AND (${conditions.join(' OR ')})\n     ORDER BY\n       CASE\n         WHEN title ILIKE $${searchTerms.length + 2} THEN 1\n         ELSE 2\n       END,\n       created_at DESC\n     LIMIT $1`,\n    [limit, ...params, `%${subjectHint}%`]\n  );\n\n  return result.rows.map((commitment) => ({\n    commitment,\n    similarity: 0.4, // Text match gets moderate base similarity\n    confidence: 'medium' as const,\n  }));\n}",
      "references": [
        "limit",
        "term",
        "searchTerms",
        "i",
        "pool",
        "conditions",
        "params",
        "result",
        "commitment"
      ]
    },
    "file:src/services/resolution.ts:fn:processMessageForResolution:236": {
      "id": "file:src/services/resolution.ts:fn:processMessageForResolution:236",
      "type": "function",
      "name": "processMessageForResolution",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 236,
      "endLine": 275,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/resolution\").ResolutionCandidate>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects resolution in message, finds matching commitments via embedding/text search, checks confirmation need",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processMessageForResolution(\n  message: string\n): Promise<ResolutionCandidate | null> {\n  // Step 1: Detect if message indicates resolution\n  const detection = await detectResolution(message);\n\n  if (!detection?.is_resolution) {\n    return null;\n  }\n\n  // Step 2: Find matching commitments\n  let matches: CommitmentMatch[] = [];\n\n  if (detection.subject_hint) {\n    // Try embedding similarity first\n    matches = await findMatchingCommitments(detection.subject_hint);\n\n    // If no embedding matches, try text search\n    if (matches.length === 0) {\n      matches = await findMatchingCommitmentsText(detection.subject_hint);\n    }\n  }\n\n  // Step 3: Determine if confirmation is needed\n  const firstMatch = matches[0];\n  const bestMatch: CommitmentMatch | null = firstMatch ?? null;\n  const requiresConfirmation =\n    !bestMatch ||\n    bestMatch.confidence === 'low' ||\n    detection.confidence === 'low' ||\n    matches.length > 1;\n\n  return {\n    message_content: message,\n    detection,\n    matches,\n    best_match: bestMatch,\n    requires_confirmation: requiresConfirmation,\n  };\n}",
      "references": [
        "detectResolution",
        "detection",
        "matches",
        "findMatchingCommitments",
        "findMatchingCommitmentsText",
        "firstMatch",
        "bestMatch",
        "requiresConfirmation"
      ]
    },
    "file:src/services/resolution.ts:fn:autoResolveCommitment:281": {
      "id": "file:src/services/resolution.ts:fn:autoResolveCommitment:281",
      "type": "function",
      "name": "autoResolveCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 281,
      "endLine": 356,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "candidate",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/resolution\").ResolutionCandidate",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "resolutionMemoryId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Auto-resolves high-confidence commitment by updating DB status and creating memory edge",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function autoResolveCommitment(\n  candidate: ResolutionCandidate,\n  resolutionMemoryId?: string\n): Promise<boolean> {\n  if (\n    !candidate.best_match ||\n    candidate.requires_confirmation ||\n    !candidate.detection.resolution_type\n  ) {\n    return false;\n  }\n\n  // Only auto-resolve high confidence matches\n  if (\n    candidate.detection.confidence !== 'high' ||\n    candidate.best_match.confidence !== 'high'\n  ) {\n    return false;\n  }\n\n  const commitment = candidate.best_match.commitment;\n  const resolutionType = candidate.detection.resolution_type;\n\n  // Update the commitment status\n  const newStatus = resolutionType === 'completed' ? 'completed' : 'canceled';\n\n  await pool.query(\n    `UPDATE commitments\n     SET status = $1,\n         resolved_at = NOW(),\n         resolution_type = $2,\n         resolution_memory_id = $3,\n         updated_at = NOW()\n     WHERE id = $4`,\n    [\n      newStatus,\n      resolutionType,\n      resolutionMemoryId ?? null,\n      commitment.id,\n    ]\n  );\n\n  // Create memory edge if both original and resolution memories exist\n  if (commitment.memory_id && resolutionMemoryId) {\n    try {\n      // Use RESOLVES for completion, CONTRADICTS for cancellation\n      const edgeType = resolutionType === 'completed' || resolutionType === 'superseded'\n        ? 'RESOLVES'\n        : 'CONTRADICTS';\n\n      await createEdge({\n        source_memory_id: commitment.memory_id,\n        target_memory_id: resolutionMemoryId,\n        edge_type: edgeType,\n        weight: 1.0,\n        metadata: {\n          commitment_id: commitment.id,\n          resolution_type: resolutionType,\n          auto_resolved: true,\n        },\n      });\n\n      console.log(\n        `[Resolution] Created ${edgeType} edge from memory ${commitment.memory_id} to ${resolutionMemoryId}`\n      );\n    } catch (edgeError) {\n      console.error('[Resolution] Failed to create memory edge:', edgeError);\n    }\n  }\n\n  console.log(\n    `[Resolution] Auto-resolved commitment \"${commitment.title}\" as ${resolutionType}`\n  );\n\n  return true;\n}",
      "references": [
        "resolutionType",
        "pool",
        "newStatus",
        "commitment",
        "createEdge",
        "edgeType",
        "console",
        "edgeError"
      ]
    },
    "file:src/services/resolution.ts:fn:processMessagesForResolutions:363": {
      "id": "file:src/services/resolution.ts:fn:processMessagesForResolutions:363",
      "type": "function",
      "name": "processMessagesForResolutions",
      "filePath": "/home/ridgetop/projects/squire/src/services/resolution.ts",
      "line": 363,
      "endLine": 398,
      "parentFileId": "file:src/services/resolution.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "messages",
          "type": "{ id: string; content: string; }[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ resolved: { messageId: string; commitmentId: string; resolutionType: import(\"/home/ridgetop/projects/squire/src/services/commitments\").ResolutionType; }[]; pendingConfirmation: { messageId: string; candidate: import(\"/home/ridgetop/projects/squire/src/services/resolution\").ResolutionCandidate; }[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes messages for resolutions: auto-resolves some, collects pending confirmations.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function processMessagesForResolutions(\n  messages: { id: string; content: string }[]\n): Promise<{\n  resolved: { messageId: string; commitmentId: string; resolutionType: ResolutionType }[];\n  pendingConfirmation: { messageId: string; candidate: ResolutionCandidate }[];\n}> {\n  const resolved: { messageId: string; commitmentId: string; resolutionType: ResolutionType }[] = [];\n  const pendingConfirmation: { messageId: string; candidate: ResolutionCandidate }[] = [];\n\n  for (const msg of messages) {\n    try {\n      const candidate = await processMessageForResolution(msg.content);\n\n      if (!candidate) {\n        continue;\n      }\n\n      if (candidate.requires_confirmation) {\n        pendingConfirmation.push({ messageId: msg.id, candidate });\n      } else if (candidate.best_match && candidate.detection.resolution_type) {\n        const wasResolved = await autoResolveCommitment(candidate);\n        if (wasResolved) {\n          resolved.push({\n            messageId: msg.id,\n            commitmentId: candidate.best_match.commitment.id,\n            resolutionType: candidate.detection.resolution_type,\n          });\n        }\n      }\n    } catch (error) {\n      console.error(`[Resolution] Failed to process message ${msg.id}:`, error);\n    }\n  }\n\n  return { resolved, pendingConfirmation };\n}",
      "references": [
        "processMessageForResolution",
        "msg",
        "candidate",
        "pendingConfirmation",
        "autoResolveCommitment",
        "wasResolved",
        "resolved",
        "console",
        "error"
      ]
    },
    "file:src/services/salience.ts": {
      "id": "file:src/services/salience.ts",
      "type": "file",
      "name": "salience.ts",
      "filePath": "src/services/salience.ts",
      "line": 1,
      "endLine": 285,
      "imports": [],
      "exports": [
        {
          "name": "calculateSalience",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SalienceFactors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SalienceResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/salience.ts:fn:scorePatterns:138",
        "file:src/services/salience.ts:fn:scoreTemporal:156",
        "file:src/services/salience.ts:fn:scoreRelationship:163",
        "file:src/services/salience.ts:fn:scoreAction:211",
        "file:src/services/salience.ts:fn:scoreExplicit:218",
        "file:src/services/salience.ts:fn:scoreSelfReference:225",
        "file:src/services/salience.ts:fn:scoreLengthComplexity:233",
        "file:src/services/salience.ts:fn:calculateSalience:261"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/salience.ts:fn:scorePatterns:138": {
      "id": "file:src/services/salience.ts:fn:scorePatterns:138",
      "type": "function",
      "name": "scorePatterns",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 138,
      "endLine": 151,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "patterns",
          "type": "RegExp[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts matching regex patterns in content and returns scaled score (0-10).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scorePatterns(content: string, patterns: RegExp[]): number {\n  let matches = 0;\n  for (const pattern of patterns) {\n    if (pattern.test(content)) {\n      matches++;\n    }\n  }\n  // Scale: 0 matches = 0, 1 match = 4, 2 matches = 6, 3+ matches = 8-10\n  if (matches === 0) return 0;\n  if (matches === 1) return 4;\n  if (matches === 2) return 6;\n  if (matches === 3) return 8;\n  return Math.min(10, 8 + matches - 3);\n}",
      "references": [
        "pattern",
        "matches",
        "Math"
      ]
    },
    "file:src/services/salience.ts:fn:scoreTemporal:156": {
      "id": "file:src/services/salience.ts:fn:scoreTemporal:156",
      "type": "function",
      "name": "scoreTemporal",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 156,
      "endLine": 158,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Scores temporal patterns in the given content string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreTemporal(content: string): number {\n  return scorePatterns(content, TEMPORAL_PATTERNS);\n}",
      "references": [
        "scorePatterns",
        "TEMPORAL_PATTERNS"
      ]
    },
    "file:src/services/salience.ts:fn:scoreRelationship:163": {
      "id": "file:src/services/salience.ts:fn:scoreRelationship:163",
      "type": "function",
      "name": "scoreRelationship",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 163,
      "endLine": 206,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Scores relationship salience in text using patterns and capitalized proper names.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreRelationship(content: string): number {\n  // Also check for capitalized proper names (simple heuristic)\n  const namePattern = /\\b[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)?\\b/g;\n  const names = content.match(namePattern) || [];\n  // Filter out common words that happen to be capitalized\n  const commonWords = new Set([\n    'I',\n    'The',\n    'This',\n    'That',\n    'These',\n    'Those',\n    'What',\n    'When',\n    'Where',\n    'Why',\n    'How',\n    'Monday',\n    'Tuesday',\n    'Wednesday',\n    'Thursday',\n    'Friday',\n    'Saturday',\n    'Sunday',\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December',\n  ]);\n  const actualNames = names.filter((n) => !commonWords.has(n));\n\n  const patternScore = scorePatterns(content, RELATIONSHIP_PATTERNS);\n  const nameBonus = Math.min(4, actualNames.length * 2);\n\n  return Math.min(10, patternScore + nameBonus);\n}",
      "references": [
        "namePattern",
        "Set",
        "names",
        "commonWords",
        "n",
        "scorePatterns",
        "RELATIONSHIP_PATTERNS",
        "Math",
        "actualNames",
        "patternScore",
        "nameBonus"
      ]
    },
    "file:src/services/salience.ts:fn:scoreAction:211": {
      "id": "file:src/services/salience.ts:fn:scoreAction:211",
      "type": "function",
      "name": "scoreAction",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 211,
      "endLine": 213,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Scores action relevance of content using ACTION_PATTERNS.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreAction(content: string): number {\n  return scorePatterns(content, ACTION_PATTERNS);\n}",
      "references": [
        "scorePatterns",
        "ACTION_PATTERNS"
      ]
    },
    "file:src/services/salience.ts:fn:scoreExplicit:218": {
      "id": "file:src/services/salience.ts:fn:scoreExplicit:218",
      "type": "function",
      "name": "scoreExplicit",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 218,
      "endLine": 220,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Scores explicit content in a string using predefined patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreExplicit(content: string): number {\n  return scorePatterns(content, EXPLICIT_PATTERNS);\n}",
      "references": [
        "scorePatterns",
        "EXPLICIT_PATTERNS"
      ]
    },
    "file:src/services/salience.ts:fn:scoreSelfReference:225": {
      "id": "file:src/services/salience.ts:fn:scoreSelfReference:225",
      "type": "function",
      "name": "scoreSelfReference",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 225,
      "endLine": 227,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Scores self-references in content using predefined patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreSelfReference(content: string): number {\n  return scorePatterns(content, SELF_REFERENCE_PATTERNS);\n}",
      "references": [
        "scorePatterns",
        "SELF_REFERENCE_PATTERNS"
      ]
    },
    "file:src/services/salience.ts:fn:scoreLengthComplexity:233": {
      "id": "file:src/services/salience.ts:fn:scoreLengthComplexity:233",
      "type": "function",
      "name": "scoreLengthComplexity",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 233,
      "endLine": 251,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Computes complexity score from word count and sentence count of input string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function scoreLengthComplexity(content: string): number {\n  const words = content.split(/\\s+/).length;\n  const sentences = content.split(/[.!?]+/).filter((s) => s.trim()).length;\n\n  // Short (< 10 words): 2\n  // Medium (10-30 words): 5\n  // Long (30-60 words): 7\n  // Very long (60+ words): 9\n  let lengthScore: number;\n  if (words < 10) lengthScore = 2;\n  else if (words < 30) lengthScore = 5;\n  else if (words < 60) lengthScore = 7;\n  else lengthScore = 9;\n\n  // Bonus for multiple sentences (indicates structure)\n  const sentenceBonus = Math.min(1, (sentences - 1) * 0.5);\n\n  return Math.min(10, lengthScore + sentenceBonus);\n}",
      "references": [
        "s",
        "words",
        "lengthScore",
        "Math",
        "sentences",
        "sentenceBonus"
      ]
    },
    "file:src/services/salience.ts:fn:calculateSalience:261": {
      "id": "file:src/services/salience.ts:fn:calculateSalience:261",
      "type": "function",
      "name": "calculateSalience",
      "filePath": "/home/ridgetop/projects/squire/src/services/salience.ts",
      "line": 261,
      "endLine": 284,
      "parentFileId": "file:src/services/salience.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/salience\").SalienceResult",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates salience score and factors for content using weighted sub-scores.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function calculateSalience(content: string): SalienceResult {\n  const factors: SalienceFactors = {\n    temporal_relevance: scoreTemporal(content),\n    relationship: scoreRelationship(content),\n    action_language: scoreAction(content),\n    explicit_marking: scoreExplicit(content),\n    self_reference: scoreSelfReference(content),\n    length_complexity: scoreLengthComplexity(content),\n  };\n\n  // Calculate weighted score\n  let score = 0;\n  for (const [factor, weight] of Object.entries(SALIENCE_WEIGHTS)) {\n    score += factors[factor as keyof SalienceFactors] * weight;\n  }\n\n  // Ensure score is in valid range\n  score = Math.min(10.0, Math.max(0.0, score));\n\n  // Round to 1 decimal place\n  score = Math.round(score * 10) / 10;\n\n  return { score, factors };\n}",
      "references": [
        "scoreTemporal",
        "scoreRelationship",
        "scoreAction",
        "scoreExplicit",
        "scoreSelfReference",
        "scoreLengthComplexity",
        "factor",
        "weight",
        "Object",
        "SALIENCE_WEIGHTS",
        "score",
        "factors",
        "Math"
      ]
    },
    "file:src/services/scheduler.ts": {
      "id": "file:src/services/scheduler.ts",
      "type": "file",
      "name": "scheduler.ts",
      "filePath": "src/services/scheduler.ts",
      "line": 1,
      "endLine": 388,
      "imports": [
        {
          "source": "./reminders.js",
          "items": [
            {
              "name": "getPendingReminders",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getRetryableReminders",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSnoozedRemindersToWake",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markReminderSent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markReminderFailed",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "resetReminderForRetry",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unsnoozeReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Reminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./push.js",
          "items": [
            {
              "name": "sendReminderNotification",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isPushConfigured",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./commitments.js",
          "items": [
            {
              "name": "getCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "expireCandidates",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "start",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "stop",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isRunning",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "resetStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "runOnce",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "initScheduler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "shutdownScheduler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SchedulerConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SchedulerStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/scheduler.ts:fn:start:77",
        "file:src/services/scheduler.ts:fn:stop:104",
        "file:src/services/scheduler.ts:fn:isRunning:119",
        "file:src/services/scheduler.ts:fn:getStats:126",
        "file:src/services/scheduler.ts:fn:resetStats:133",
        "file:src/services/scheduler.ts:fn:runOnce:145",
        "file:src/services/scheduler.ts:fn:tick:156",
        "file:src/services/scheduler.ts:fn:processPendingReminders:212",
        "file:src/services/scheduler.ts:fn:processRetryableReminders:237",
        "file:src/services/scheduler.ts:fn:processSnoozedReminders:266",
        "file:src/services/scheduler.ts:fn:deliverReminder:287",
        "file:src/services/scheduler.ts:fn:log:360",
        "file:src/services/scheduler.ts:fn:initScheduler:374",
        "file:src/services/scheduler.ts:fn:shutdownScheduler:385"
      ],
      "classes": [],
      "topLevelReferences": [
        "process",
        "DEFAULT_CONFIG"
      ]
    },
    "file:src/services/scheduler.ts:fn:start:77": {
      "id": "file:src/services/scheduler.ts:fn:start:77",
      "type": "function",
      "name": "start",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 77,
      "endLine": 99,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "customConfig",
          "type": "Partial<import(\"/home/ridgetop/projects/squire/src/services/scheduler\").SchedulerConfig>",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Starts scheduler: sets config, runs tick immediately and on interval, updates stats.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.096Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function start(customConfig?: Partial<SchedulerConfig>): void {\n  if (intervalId) {\n    console.log('[Scheduler] Already running');\n    return;\n  }\n\n  config = { ...DEFAULT_CONFIG, ...customConfig };\n\n  if (!isPushConfigured()) {\n    console.warn('[Scheduler] Push notifications not configured. Reminders will be processed but not delivered.');\n  }\n\n  log(`Starting scheduler (interval: ${config.intervalMs}ms, batch: ${config.batchSize})`);\n\n  // Run immediately, then on interval\n  tick().catch(err => console.error('[Scheduler] Initial tick error:', err));\n\n  intervalId = setInterval(() => {\n    tick().catch(err => console.error('[Scheduler] Tick error:', err));\n  }, config.intervalMs);\n\n  stats.isRunning = true;\n}",
      "references": [
        "intervalId",
        "console",
        "config",
        "DEFAULT_CONFIG",
        "isPushConfigured",
        "log",
        "tick",
        "err",
        "setInterval",
        "stats"
      ]
    },
    "file:src/services/scheduler.ts:fn:stop:104": {
      "id": "file:src/services/scheduler.ts:fn:stop:104",
      "type": "function",
      "name": "stop",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 104,
      "endLine": 114,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Stops the scheduler by clearing interval, resetting ID, and updating status.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function stop(): void {\n  if (!intervalId) {\n    console.log('[Scheduler] Not running');\n    return;\n  }\n\n  clearInterval(intervalId);\n  intervalId = null;\n  stats.isRunning = false;\n  log('Scheduler stopped');\n}",
      "references": [
        "intervalId",
        "console",
        "clearInterval",
        "stats",
        "log"
      ]
    },
    "file:src/services/scheduler.ts:fn:isRunning:119": {
      "id": "file:src/services/scheduler.ts:fn:isRunning:119",
      "type": "function",
      "name": "isRunning",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 119,
      "endLine": 121,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns whether scheduler stats indicate it is running.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isRunning(): boolean {\n  return stats.isRunning;\n}",
      "references": [
        "stats"
      ]
    },
    "file:src/services/scheduler.ts:fn:getStats:126": {
      "id": "file:src/services/scheduler.ts:fn:getStats:126",
      "type": "function",
      "name": "getStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 126,
      "endLine": 128,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/scheduler\").SchedulerStats",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a shallow copy of the current scheduler stats.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getStats(): SchedulerStats {\n  return { ...stats };\n}",
      "references": [
        "stats"
      ]
    },
    "file:src/services/scheduler.ts:fn:resetStats:133": {
      "id": "file:src/services/scheduler.ts:fn:resetStats:133",
      "type": "function",
      "name": "resetStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 133,
      "endLine": 140,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Resets scheduler stats: lastRun to null and counters to 0",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function resetStats(): void {\n  stats.lastRun = null;\n  stats.totalProcessed = 0;\n  stats.totalSent = 0;\n  stats.totalFailed = 0;\n  stats.totalRetried = 0;\n  stats.totalUnsnoozed = 0;\n}",
      "references": [
        "stats"
      ]
    },
    "file:src/services/scheduler.ts:fn:runOnce:145": {
      "id": "file:src/services/scheduler.ts:fn:runOnce:145",
      "type": "function",
      "name": "runOnce",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 145,
      "endLine": 147,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<TickResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Executes and returns the result of a single scheduler tick.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function runOnce(): Promise<TickResult> {\n  return tick();\n}",
      "references": [
        "tick"
      ]
    },
    "file:src/services/scheduler.ts:fn:tick:156": {
      "id": "file:src/services/scheduler.ts:fn:tick:156",
      "type": "function",
      "name": "tick",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 156,
      "endLine": 207,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<TickResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Orchestrates processing of pending, retry, and snoozed reminders; expires candidates; updates stats",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "async function tick(): Promise<TickResult> {\n  // Prevent concurrent processing\n  if (isProcessing) {\n    log('Skipping tick - still processing previous');\n    return {\n      pending: { processed: 0, sent: 0, failed: 0 },\n      retries: { processed: 0, sent: 0, failed: 0 },\n      snoozed: { woken: 0 },\n    };\n  }\n\n  isProcessing = true;\n  stats.lastRun = new Date();\n\n  try {\n    // Process pending reminders\n    const pendingResult = await processPendingReminders();\n\n    // Process failed reminders ready for retry\n    const retryResult = await processRetryableReminders();\n\n    // Wake snoozed reminders\n    const snoozedResult = await processSnoozedReminders();\n\n    // Phase 4: Expire unconfirmed commitment candidates (24h TTL)\n    let expiredCount = 0;\n    try {\n      expiredCount = await expireCandidates();\n    } catch (err) {\n      console.error('[Scheduler] Failed to expire candidates:', err);\n    }\n\n    // Update stats\n    stats.totalProcessed += pendingResult.processed + retryResult.processed;\n    stats.totalSent += pendingResult.sent + retryResult.sent;\n    stats.totalFailed += pendingResult.failed + retryResult.failed;\n    stats.totalRetried += retryResult.processed;\n    stats.totalUnsnoozed += snoozedResult.woken;\n\n    if (config.verbose && (pendingResult.processed > 0 || retryResult.processed > 0 || snoozedResult.woken > 0 || expiredCount > 0)) {\n      log(`Tick complete: pending=${pendingResult.sent}/${pendingResult.processed}, retries=${retryResult.sent}/${retryResult.processed}, unsnoozed=${snoozedResult.woken}, expired=${expiredCount}`);\n    }\n\n    return {\n      pending: pendingResult,\n      retries: retryResult,\n      snoozed: snoozedResult,\n    };\n  } finally {\n    isProcessing = false;\n  }\n}",
      "references": [
        "isProcessing",
        "log",
        "stats",
        "Date",
        "processPendingReminders",
        "processRetryableReminders",
        "processSnoozedReminders",
        "expiredCount",
        "expireCandidates",
        "console",
        "err",
        "pendingResult",
        "retryResult",
        "snoozedResult",
        "config"
      ]
    },
    "file:src/services/scheduler.ts:fn:processPendingReminders:212": {
      "id": "file:src/services/scheduler.ts:fn:processPendingReminders:212",
      "type": "function",
      "name": "processPendingReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 212,
      "endLine": 232,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ processed: number; sent: number; failed: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pending reminders, delivers them in batch, returns counts of processed/sent/failed",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processPendingReminders(): Promise<{ processed: number; sent: number; failed: number }> {\n  const reminders = await getPendingReminders({ limit: config.batchSize });\n\n  if (reminders.length === 0) {\n    return { processed: 0, sent: 0, failed: 0 };\n  }\n\n  let sent = 0;\n  let failed = 0;\n\n  for (const reminder of reminders) {\n    const success = await deliverReminder(reminder);\n    if (success) {\n      sent++;\n    } else {\n      failed++;\n    }\n  }\n\n  return { processed: reminders.length, sent, failed };\n}",
      "references": [
        "getPendingReminders",
        "config",
        "reminders",
        "deliverReminder",
        "reminder",
        "success",
        "sent",
        "failed"
      ]
    },
    "file:src/services/scheduler.ts:fn:processRetryableReminders:237": {
      "id": "file:src/services/scheduler.ts:fn:processRetryableReminders:237",
      "type": "function",
      "name": "processRetryableReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 237,
      "endLine": 261,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ processed: number; sent: number; failed: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes batch of retryable reminders: fetches, resets, delivers, counts sent/failed.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processRetryableReminders(): Promise<{ processed: number; sent: number; failed: number }> {\n  const reminders = await getRetryableReminders({ limit: config.batchSize });\n\n  if (reminders.length === 0) {\n    return { processed: 0, sent: 0, failed: 0 };\n  }\n\n  let sent = 0;\n  let failed = 0;\n\n  for (const reminder of reminders) {\n    // Reset to pending first\n    const reset = await resetReminderForRetry(reminder.id);\n    if (!reset) continue;\n\n    const success = await deliverReminder(reset);\n    if (success) {\n      sent++;\n    } else {\n      failed++;\n    }\n  }\n\n  return { processed: reminders.length, sent, failed };\n}",
      "references": [
        "getRetryableReminders",
        "config",
        "reminders",
        "resetReminderForRetry",
        "reminder",
        "reset",
        "deliverReminder",
        "success",
        "sent",
        "failed"
      ]
    },
    "file:src/services/scheduler.ts:fn:processSnoozedReminders:266": {
      "id": "file:src/services/scheduler.ts:fn:processSnoozedReminders:266",
      "type": "function",
      "name": "processSnoozedReminders",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 266,
      "endLine": 282,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ woken: number; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches and unsnoozes batch of ready snoozed reminders, returns count woken",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function processSnoozedReminders(): Promise<{ woken: number }> {\n  const reminders = await getSnoozedRemindersToWake({ limit: config.batchSize });\n\n  if (reminders.length === 0) {\n    return { woken: 0 };\n  }\n\n  let woken = 0;\n  for (const reminder of reminders) {\n    const result = await unsnoozeReminder(reminder.id);\n    if (result) {\n      woken++;\n    }\n  }\n\n  return { woken };\n}",
      "references": [
        "getSnoozedRemindersToWake",
        "config",
        "reminders",
        "unsnoozeReminder",
        "reminder",
        "result",
        "woken"
      ]
    },
    "file:src/services/scheduler.ts:fn:deliverReminder:287": {
      "id": "file:src/services/scheduler.ts:fn:deliverReminder:287",
      "type": "function",
      "name": "deliverReminder",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 287,
      "endLine": 355,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "reminder",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/reminders\").Reminder",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Delivers push reminder notification, fetches commitment details if linked, marks sent or failed in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": true,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function deliverReminder(reminder: Reminder): Promise<boolean> {\n  try {\n    // Build notification content\n    let title = reminder.title || 'Reminder';\n    let body = reminder.body || '';\n    let commitmentId: string | undefined;\n\n    // If linked to a commitment, get its details\n    if (reminder.commitment_id) {\n      const commitment = await getCommitment(reminder.commitment_id);\n      if (commitment) {\n        title = commitment.title;\n        body = commitment.description || '';\n        commitmentId = commitment.id;\n\n        // Add due date context\n        if (commitment.due_at) {\n          const dueDate = new Date(commitment.due_at);\n          const now = new Date();\n          const diffMs = dueDate.getTime() - now.getTime();\n          const diffMins = Math.round(diffMs / 60000);\n\n          if (diffMins > 0 && diffMins <= 60) {\n            body = `Due in ${diffMins} minutes. ${body}`.trim();\n          } else if (diffMins > 60 && diffMins <= 1440) {\n            const hours = Math.round(diffMins / 60);\n            body = `Due in ${hours} hour${hours > 1 ? 's' : ''}. ${body}`.trim();\n          } else if (diffMins < 0) {\n            body = `Overdue! ${body}`.trim();\n          }\n        }\n      }\n    }\n\n    // Send push notification\n    const results = await sendReminderNotification(\n      reminder.id,\n      title,\n      body,\n      {\n        commitmentId,\n        url: commitmentId ? `/app/commitments/${commitmentId}` : '/app/commitments',\n      }\n    );\n\n    // Check if any notification was sent successfully\n    const anySent = results.some(r => r.success);\n\n    if (anySent) {\n      await markReminderSent(reminder.id);\n      log(`Delivered reminder ${reminder.id}: \"${title}\"`);\n      return true;\n    } else {\n      // No active subscriptions or all failed\n      const errorMsg = results.length === 0\n        ? 'No active push subscriptions'\n        : results.map(r => r.error).join('; ');\n\n      await markReminderFailed(reminder.id, errorMsg);\n      log(`Failed to deliver reminder ${reminder.id}: ${errorMsg}`);\n      return false;\n    }\n  } catch (error) {\n    const err = error as Error;\n    await markReminderFailed(reminder.id, err.message);\n    console.error(`[Scheduler] Error delivering reminder ${reminder.id}:`, err);\n    return false;\n  }\n}",
      "references": [
        "getCommitment",
        "commitment",
        "title",
        "body",
        "commitmentId",
        "Date",
        "dueDate",
        "now",
        "Math",
        "diffMs",
        "diffMins",
        "hours",
        "sendReminderNotification",
        "results",
        "r",
        "anySent",
        "markReminderSent",
        "log",
        "markReminderFailed",
        "errorMsg",
        "error",
        "err",
        "console"
      ]
    },
    "file:src/services/scheduler.ts:fn:log:360": {
      "id": "file:src/services/scheduler.ts:fn:log:360",
      "type": "function",
      "name": "log",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 360,
      "endLine": 364,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Logs a message to console if verbose mode is enabled.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function log(message: string): void {\n  if (config.verbose) {\n    console.log(`[Scheduler] ${message}`);\n  }\n}",
      "references": [
        "config",
        "console"
      ]
    },
    "file:src/services/scheduler.ts:fn:initScheduler:374": {
      "id": "file:src/services/scheduler.ts:fn:initScheduler:374",
      "type": "function",
      "name": "initScheduler",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 374,
      "endLine": 379,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "customConfig",
          "type": "Partial<import(\"/home/ridgetop/projects/squire/src/services/scheduler\").SchedulerConfig>",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Initializes scheduler if not already running by calling start.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function initScheduler(customConfig?: Partial<SchedulerConfig>): void {\n  // Only start if not already running\n  if (!isRunning()) {\n    start(customConfig);\n  }\n}",
      "references": [
        "isRunning",
        "start"
      ]
    },
    "file:src/services/scheduler.ts:fn:shutdownScheduler:385": {
      "id": "file:src/services/scheduler.ts:fn:shutdownScheduler:385",
      "type": "function",
      "name": "shutdownScheduler",
      "filePath": "/home/ridgetop/projects/squire/src/services/scheduler.ts",
      "line": 385,
      "endLine": 387,
      "parentFileId": "file:src/services/scheduler.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Stops the scheduler by calling the stop() function.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function shutdownScheduler(): void {\n  stop();\n}",
      "references": [
        "stop"
      ]
    },
    "file:src/services/sessions.ts": {
      "id": "file:src/services/sessions.ts",
      "type": "file",
      "name": "sessions.ts",
      "filePath": "src/services/sessions.ts",
      "line": 1,
      "endLine": 215,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "startSession",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "endSession",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCurrentSession",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getOrCreateSession",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listSessions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingConsolidationSessions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateConsolidationStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSessionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "Session",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SessionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateSessionInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/sessions.ts:fn:startSession:32",
        "file:src/services/sessions.ts:fn:endSession:48",
        "file:src/services/sessions.ts:fn:getCurrentSession:92",
        "file:src/services/sessions.ts:fn:getOrCreateSession:107",
        "file:src/services/sessions.ts:fn:listSessions:118",
        "file:src/services/sessions.ts:fn:getPendingConsolidationSessions:149",
        "file:src/services/sessions.ts:fn:updateConsolidationStatus:162",
        "file:src/services/sessions.ts:fn:getSessionStats:189"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/sessions.ts:fn:startSession:32": {
      "id": "file:src/services/sessions.ts:fn:startSession:32",
      "type": "function",
      "name": "startSession",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 32,
      "endLine": 43,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/sessions\").CreateSessionInput",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new session into the database with type and metadata, returns it.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function startSession(input: CreateSessionInput = {}): Promise<Session> {\n  const { session_type = 'interactive', metadata = {} } = input;\n\n  const result = await pool.query(\n    `INSERT INTO sessions (session_type, metadata)\n     VALUES ($1, $2)\n     RETURNING *`,\n    [session_type, JSON.stringify(metadata)]\n  );\n\n  return result.rows[0] as Session;\n}",
      "references": [
        "session_type",
        "metadata",
        "pool",
        "JSON",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:endSession:48": {
      "id": "file:src/services/sessions.ts:fn:endSession:48",
      "type": "function",
      "name": "endSession",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 48,
      "endLine": 87,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "sessionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Ends session by fetching data, calculating stats, and updating ended_at/stats in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function endSession(sessionId: string): Promise<Session | null> {\n  // First get the session to calculate stats\n  const sessionResult = await pool.query(\n    `SELECT * FROM sessions WHERE id = $1`,\n    [sessionId]\n  );\n\n  if (sessionResult.rows.length === 0) {\n    return null;\n  }\n\n  const session = sessionResult.rows[0] as Session;\n\n  // Count memories created during this session\n  const memCountResult = await pool.query(\n    `SELECT COUNT(*) as count FROM memories WHERE session_id = $1`,\n    [sessionId]\n  );\n  const memoriesCreated = parseInt(memCountResult.rows[0]?.count ?? '0', 10);\n\n  // Calculate duration\n  const durationMs = Date.now() - new Date(session.started_at).getTime();\n  const durationMinutes = Math.round(durationMs / 60000);\n\n  // Update the session\n  const result = await pool.query(\n    `UPDATE sessions\n     SET ended_at = NOW(),\n         stats = jsonb_set(\n           COALESCE(stats, '{}'),\n           '{memories_created}',\n           $2::jsonb\n         ) || jsonb_build_object('duration_minutes', $3::int)\n     WHERE id = $1\n     RETURNING *`,\n    [sessionId, memoriesCreated.toString(), durationMinutes]\n  );\n\n  return (result.rows[0] as Session) ?? null;\n}",
      "references": [
        "pool",
        "sessionResult",
        "parseInt",
        "memCountResult",
        "Date",
        "session",
        "Math",
        "durationMs",
        "memoriesCreated",
        "durationMinutes",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:getCurrentSession:92": {
      "id": "file:src/services/sessions.ts:fn:getCurrentSession:92",
      "type": "function",
      "name": "getCurrentSession",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 92,
      "endLine": 101,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves the most recent active session from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCurrentSession(): Promise<Session | null> {\n  const result = await pool.query(\n    `SELECT * FROM sessions\n     WHERE ended_at IS NULL\n     ORDER BY started_at DESC\n     LIMIT 1`\n  );\n\n  return (result.rows[0] as Session) ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:getOrCreateSession:107": {
      "id": "file:src/services/sessions.ts:fn:getOrCreateSession:107",
      "type": "function",
      "name": "getOrCreateSession",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 107,
      "endLine": 113,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves current session or creates a new one if none exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getOrCreateSession(): Promise<Session> {\n  const current = await getCurrentSession();\n  if (current) {\n    return current;\n  }\n  return startSession();\n}",
      "references": [
        "getCurrentSession",
        "current",
        "startSession"
      ]
    },
    "file:src/services/sessions.ts:fn:listSessions:118": {
      "id": "file:src/services/sessions.ts:fn:listSessions:118",
      "type": "function",
      "name": "listSessions",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 118,
      "endLine": 144,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ limit?: number; status?: \"completed\" | \"pending\" | \"failed\"; includeActive?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for sessions with optional status, active filter, and limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listSessions(options: {\n  limit?: number;\n  status?: 'pending' | 'completed' | 'failed';\n  includeActive?: boolean;\n} = {}): Promise<Session[]> {\n  const { limit = 20, status, includeActive = true } = options;\n\n  let query = `SELECT * FROM sessions WHERE 1=1`;\n  const params: (string | number)[] = [];\n  let paramIndex = 1;\n\n  if (status) {\n    query += ` AND consolidation_status = $${paramIndex}`;\n    params.push(status);\n    paramIndex++;\n  }\n\n  if (!includeActive) {\n    query += ` AND ended_at IS NOT NULL`;\n  }\n\n  query += ` ORDER BY started_at DESC LIMIT $${paramIndex}`;\n  params.push(limit);\n\n  const result = await pool.query(query, params);\n  return result.rows as Session[];\n}",
      "references": [
        "limit",
        "status",
        "includeActive",
        "query",
        "paramIndex",
        "params",
        "pool",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:getPendingConsolidationSessions:149": {
      "id": "file:src/services/sessions.ts:fn:getPendingConsolidationSessions:149",
      "type": "function",
      "name": "getPendingConsolidationSessions",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 149,
      "endLine": 157,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for sessions with ended_at not null and consolidation_status 'pending', ordered by ended_at ASC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPendingConsolidationSessions(): Promise<Session[]> {\n  const result = await pool.query(\n    `SELECT * FROM sessions\n     WHERE ended_at IS NOT NULL\n       AND consolidation_status = 'pending'\n     ORDER BY ended_at ASC`\n  );\n  return result.rows as Session[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:updateConsolidationStatus:162": {
      "id": "file:src/services/sessions.ts:fn:updateConsolidationStatus:162",
      "type": "function",
      "name": "updateConsolidationStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 162,
      "endLine": 184,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "sessionId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "\"in_progress\" | \"completed\" | \"pending\" | \"failed\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "stats",
          "type": "Partial<import(\"/home/ridgetop/projects/squire/src/services/sessions\").SessionStats>",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/sessions\").Session>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates session's consolidation_status, optionally stats and timestamp, returns updated session",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateConsolidationStatus(\n  sessionId: string,\n  status: 'pending' | 'in_progress' | 'completed' | 'failed',\n  stats?: Partial<SessionStats>\n): Promise<Session | null> {\n  let query = `UPDATE sessions SET consolidation_status = $2`;\n  const params: (string | Record<string, unknown>)[] = [sessionId, status];\n  let paramIndex = 3;\n\n  if (status === 'completed') {\n    query += `, consolidated_at = NOW()`;\n  }\n\n  if (stats) {\n    query += `, stats = COALESCE(stats, '{}') || $${paramIndex}::jsonb`;\n    params.push(JSON.stringify(stats));\n  }\n\n  query += ` WHERE id = $1 RETURNING *`;\n\n  const result = await pool.query(query, params);\n  return (result.rows[0] as Session) ?? null;\n}",
      "references": [
        "query",
        "paramIndex",
        "params",
        "JSON",
        "pool",
        "result"
      ]
    },
    "file:src/services/sessions.ts:fn:getSessionStats:189": {
      "id": "file:src/services/sessions.ts:fn:getSessionStats:189",
      "type": "function",
      "name": "getSessionStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/sessions.ts",
      "line": 189,
      "endLine": 214,
      "parentFileId": "file:src/services/sessions.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; active: number; pending: number; completed: number; averageDuration: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves session stats (total, active, pending, completed, avg duration) from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSessionStats(): Promise<{\n  total: number;\n  active: number;\n  pending: number;\n  completed: number;\n  averageDuration: number;\n}> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE ended_at IS NULL) as active,\n      COUNT(*) FILTER (WHERE consolidation_status = 'pending' AND ended_at IS NOT NULL) as pending,\n      COUNT(*) FILTER (WHERE consolidation_status = 'completed') as completed,\n      AVG((stats->>'duration_minutes')::int) FILTER (WHERE stats->>'duration_minutes' IS NOT NULL) as avg_duration\n    FROM sessions\n  `);\n\n  const row = result.rows[0];\n  return {\n    total: parseInt(row.total ?? '0', 10),\n    active: parseInt(row.active ?? '0', 10),\n    pending: parseInt(row.pending ?? '0', 10),\n    completed: parseInt(row.completed ?? '0', 10),\n    averageDuration: parseFloat(row.avg_duration ?? '0'),\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/storyCache.ts": {
      "id": "file:src/services/storyCache.ts",
      "type": "file",
      "name": "storyCache.ts",
      "filePath": "src/services/storyCache.ts",
      "line": 1,
      "endLine": 277,
      "imports": [
        {
          "source": "./storyEngine.js",
          "items": [
            {
              "name": "StoryResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./storyIntent.js",
          "items": [
            {
              "name": "StoryIntent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "crypto",
          "items": [
            {
              "name": "crypto",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getCachedStory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "cacheStory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "smartInvalidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/storyCache.ts:fn:generateCacheKey:56",
        "file:src/services/storyCache.ts:fn:serializeIntent:66",
        "file:src/services/storyCache.ts:fn:getCachedStory:88",
        "file:src/services/storyCache.ts:fn:cacheStory:116",
        "file:src/services/storyCache.ts:fn:evictLeastRecentlyUsed:145",
        "file:src/services/storyCache.ts:fn:invalidateByIntentKind:168",
        "file:src/services/storyCache.ts:fn:invalidateSelfStories:188",
        "file:src/services/storyCache.ts:fn:invalidateRelationshipStories:196",
        "file:src/services/storyCache.ts:fn:invalidateDateStories:204",
        "file:src/services/storyCache.ts:fn:smartInvalidate:212",
        "file:src/services/storyCache.ts:fn:cleanupExpired:247",
        "file:src/services/storyCache.ts:fn:startCleanupInterval:269"
      ],
      "classes": [],
      "topLevelReferences": [
        "Map",
        "startCleanupInterval"
      ]
    },
    "file:src/services/storyCache.ts:fn:generateCacheKey:56": {
      "id": "file:src/services/storyCache.ts:fn:generateCacheKey:56",
      "type": "function",
      "name": "generateCacheKey",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 56,
      "endLine": 61,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates MD5 hash cache key from normalized query and serialized intent.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateCacheKey(query: string, intent: StoryIntent): string {\n  const normalizedQuery = query.toLowerCase().trim().replace(/\\s+/g, ' ');\n  const intentStr = serializeIntent(intent);\n  const combined = `${normalizedQuery}|${intentStr}`;\n  return crypto.createHash('md5').update(combined).digest('hex');\n}",
      "references": [
        "serializeIntent",
        "normalizedQuery",
        "intentStr",
        "crypto",
        "combined"
      ]
    },
    "file:src/services/storyCache.ts:fn:serializeIntent:66": {
      "id": "file:src/services/storyCache.ts:fn:serializeIntent:66",
      "type": "function",
      "name": "serializeIntent",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 66,
      "endLine": 81,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Serializes StoryIntent object into a string based on its kind.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function serializeIntent(intent: StoryIntent): string {\n  switch (intent.kind) {\n    case 'none':\n      return 'none';\n    case 'date_meaning':\n      return `date:${intent.dateText.toLowerCase()}`;\n    case 'origin_story':\n      return `origin:${(intent.topic ?? '').toLowerCase()}`;\n    case 'relationship_story':\n      return `relationship:${(intent.personName ?? '').toLowerCase()}`;\n    case 'self_story':\n      return 'self';\n    default:\n      return 'unknown';\n  }\n}",
      "references": []
    },
    "file:src/services/storyCache.ts:fn:getCachedStory:88": {
      "id": "file:src/services/storyCache.ts:fn:getCachedStory:88",
      "type": "function",
      "name": "getCachedStory",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 88,
      "endLine": 111,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryResult",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves cached story by query and intent, checks expiration, updates stats on hit/miss.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function getCachedStory(query: string, intent: StoryIntent): StoryResult | null {\n  const key = generateCacheKey(query, intent);\n  const entry = cache.get(key);\n\n  if (!entry) {\n    stats.misses++;\n    return null;\n  }\n\n  // Check expiration\n  if (Date.now() > entry.expiresAt) {\n    cache.delete(key);\n    stats.misses++;\n    return null;\n  }\n\n  // Cache hit\n  entry.hitCount++;\n  stats.hits++;\n  stats.totalHitCount++;\n\n  console.log(`[StoryCache] Hit for intent ${entry.intentKind} (hits: ${entry.hitCount})`);\n  return entry.result;\n}",
      "references": [
        "generateCacheKey",
        "cache",
        "key",
        "entry",
        "stats",
        "Date",
        "console"
      ]
    },
    "file:src/services/storyCache.ts:fn:cacheStory:116": {
      "id": "file:src/services/storyCache.ts:fn:cacheStory:116",
      "type": "function",
      "name": "cacheStory",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 116,
      "endLine": 140,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "result",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryResult",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "ttlMs",
          "type": "number",
          "isOptional": true,
          "defaultValue": "CACHE_TTL_MS"
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Caches story result in LRU cache with TTL, evicts if full, updates stats and logs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function cacheStory(\n  query: string,\n  intent: StoryIntent,\n  result: StoryResult,\n  ttlMs: number = CACHE_TTL_MS\n): void {\n  const key = generateCacheKey(query, intent);\n  const now = Date.now();\n\n  // Enforce max cache size (LRU eviction)\n  if (cache.size >= MAX_CACHE_SIZE) {\n    evictLeastRecentlyUsed();\n  }\n\n  cache.set(key, {\n    result,\n    createdAt: now,\n    expiresAt: now + ttlMs,\n    hitCount: 0,\n    intentKind: intent.kind,\n  });\n\n  stats.size = cache.size;\n  console.log(`[StoryCache] Cached story for intent ${intent.kind} (TTL: ${ttlMs / 1000}s)`);\n}",
      "references": [
        "generateCacheKey",
        "Date",
        "cache",
        "MAX_CACHE_SIZE",
        "evictLeastRecentlyUsed",
        "key",
        "now",
        "stats",
        "console"
      ]
    },
    "file:src/services/storyCache.ts:fn:evictLeastRecentlyUsed:145": {
      "id": "file:src/services/storyCache.ts:fn:evictLeastRecentlyUsed:145",
      "type": "function",
      "name": "evictLeastRecentlyUsed",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 145,
      "endLine": 160,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Evicts the oldest entry from the cache by createdAt time and logs it.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function evictLeastRecentlyUsed(): void {\n  let oldestKey: string | null = null;\n  let oldestTime = Infinity;\n\n  for (const [key, entry] of cache) {\n    if (entry.createdAt < oldestTime) {\n      oldestTime = entry.createdAt;\n      oldestKey = key;\n    }\n  }\n\n  if (oldestKey) {\n    cache.delete(oldestKey);\n    console.log('[StoryCache] Evicted oldest entry (LRU)');\n  }\n}",
      "references": [
        "key",
        "entry",
        "cache",
        "oldestTime",
        "oldestKey",
        "console"
      ]
    },
    "file:src/services/storyCache.ts:fn:invalidateByIntentKind:168": {
      "id": "file:src/services/storyCache.ts:fn:invalidateByIntentKind:168",
      "type": "function",
      "name": "invalidateByIntentKind",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 168,
      "endLine": 182,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intentKind",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Invalidates cache entries by intentKind, updates stats, and logs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.098Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function invalidateByIntentKind(intentKind: string): number {\n  let count = 0;\n  for (const [key, entry] of cache) {\n    if (entry.intentKind === intentKind) {\n      cache.delete(key);\n      count++;\n    }\n  }\n  if (count > 0) {\n    stats.invalidations += count;\n    stats.size = cache.size;\n    console.log(`[StoryCache] Invalidated ${count} entries for intent kind: ${intentKind}`);\n  }\n  return count;\n}",
      "references": [
        "key",
        "entry",
        "cache",
        "count",
        "stats",
        "console"
      ]
    },
    "file:src/services/storyCache.ts:fn:invalidateSelfStories:188": {
      "id": "file:src/services/storyCache.ts:fn:invalidateSelfStories:188",
      "type": "function",
      "name": "invalidateSelfStories",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 188,
      "endLine": 190,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Invalidates cache for 'self_story' intent and returns count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.098Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function invalidateSelfStories(): number {\n  return invalidateByIntentKind('self_story');\n}",
      "references": [
        "invalidateByIntentKind"
      ]
    },
    "file:src/services/storyCache.ts:fn:invalidateRelationshipStories:196": {
      "id": "file:src/services/storyCache.ts:fn:invalidateRelationshipStories:196",
      "type": "function",
      "name": "invalidateRelationshipStories",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 196,
      "endLine": 198,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Invalidates relationship story cache by intent kind and returns count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.098Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function invalidateRelationshipStories(): number {\n  return invalidateByIntentKind('relationship_story');\n}",
      "references": [
        "invalidateByIntentKind"
      ]
    },
    "file:src/services/storyCache.ts:fn:invalidateDateStories:204": {
      "id": "file:src/services/storyCache.ts:fn:invalidateDateStories:204",
      "type": "function",
      "name": "invalidateDateStories",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 204,
      "endLine": 206,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Invalidates date stories cache by calling invalidateByIntentKind('date_meaning').",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.098Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function invalidateDateStories(): number {\n  return invalidateByIntentKind('date_meaning');\n}",
      "references": [
        "invalidateByIntentKind"
      ]
    },
    "file:src/services/storyCache.ts:fn:smartInvalidate:212": {
      "id": "file:src/services/storyCache.ts:fn:smartInvalidate:212",
      "type": "function",
      "name": "smartInvalidate",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 212,
      "endLine": 240,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryContent",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Invalidates story caches based on regex matches for self, relationships, and dates in text.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.955Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function smartInvalidate(memoryContent: string): void {\n  const content = memoryContent.toLowerCase();\n\n  // Check for self/identity content\n  const selfPatterns = [\n    /\\b(i am|i'm|my name|i work|i live|i was born)\\b/i,\n    /\\b(user is|user's name|user works|user lives)\\b/i,\n  ];\n  if (selfPatterns.some(p => p.test(content))) {\n    invalidateSelfStories();\n  }\n\n  // Check for relationship content\n  const relationshipPatterns = [\n    /\\b(wife|husband|spouse|partner|son|daughter|mother|father|friend|colleague)\\b/i,\n  ];\n  if (relationshipPatterns.some(p => p.test(content))) {\n    invalidateRelationshipStories();\n  }\n\n  // Check for significant date content\n  const datePatterns = [\n    /\\b(birthday|anniversary|wedding|graduated|died|born)\\b/i,\n    /\\b(february|january|march|april|may|june|july|august|september|october|november|december)\\s+\\d{1,2}\\b/i,\n  ];\n  if (datePatterns.some(p => p.test(content))) {\n    invalidateDateStories();\n  }\n}",
      "references": [
        "selfPatterns",
        "p",
        "content",
        "invalidateSelfStories",
        "relationshipPatterns",
        "invalidateRelationshipStories",
        "datePatterns",
        "invalidateDateStories"
      ]
    },
    "file:src/services/storyCache.ts:fn:cleanupExpired:247": {
      "id": "file:src/services/storyCache.ts:fn:cleanupExpired:247",
      "type": "function",
      "name": "cleanupExpired",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 247,
      "endLine": 264,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Removes expired entries from story cache, updates stats, logs cleanup",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.572Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function cleanupExpired(): number {\n  const now = Date.now();\n  let removed = 0;\n\n  for (const [key, entry] of cache) {\n    if (now > entry.expiresAt) {\n      cache.delete(key);\n      removed++;\n    }\n  }\n\n  if (removed > 0) {\n    stats.size = cache.size;\n    console.log(`[StoryCache] Cleaned up ${removed} expired entries`);\n  }\n\n  return removed;\n}",
      "references": [
        "Date",
        "key",
        "entry",
        "cache",
        "now",
        "removed",
        "stats",
        "console"
      ]
    },
    "file:src/services/storyCache.ts:fn:startCleanupInterval:269": {
      "id": "file:src/services/storyCache.ts:fn:startCleanupInterval:269",
      "type": "function",
      "name": "startCleanupInterval",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyCache.ts",
      "line": 269,
      "endLine": 273,
      "parentFileId": "file:src/services/storyCache.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Starts periodic cleanup interval with setInterval if not already running, logs message",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.580Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function startCleanupInterval(): void {\n  if (cleanupInterval) return;\n  cleanupInterval = setInterval(cleanupExpired, CLEANUP_INTERVAL_MS);\n  console.log('[StoryCache] Started cleanup interval');\n}",
      "references": [
        "cleanupInterval",
        "setInterval",
        "cleanupExpired",
        "CLEANUP_INTERVAL_MS",
        "console"
      ]
    },
    "file:src/services/storyEngine.ts": {
      "id": "file:src/services/storyEngine.ts",
      "type": "file",
      "name": "storyEngine.ts",
      "filePath": "src/services/storyEngine.ts",
      "line": 1,
      "endLine": 512,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./storyIntent.js",
          "items": [
            {
              "name": "StoryIntent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./memories.js",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./summaries.js",
          "items": [
            {
              "name": "getNonEmptySummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./memoryGraph.js",
          "items": [
            {
              "name": "getNeighborhoodFromMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "flattenNeighborhoods",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./storyCache.js",
          "items": [
            {
              "name": "getCachedStory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "cacheStory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "smartInvalidate",
              "alias": "invalidateStoryCache",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "generateStory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "invalidateStoryCache",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "StoryRequest",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EvidenceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "StoryEvidenceNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "StoryResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/storyEngine.ts:fn:fetchMemoriesForDate:87",
        "file:src/services/storyEngine.ts:fn:generateDatePatterns:117",
        "file:src/services/storyEngine.ts:fn:fetchMemoriesForTopic:166",
        "file:src/services/storyEngine.ts:fn:fetchMemoriesForPerson:198",
        "file:src/services/storyEngine.ts:fn:fetchMemoriesForSelf:230",
        "file:src/services/storyEngine.ts:fn:expandEvidenceViaGraph:255",
        "file:src/services/storyEngine.ts:fn:graphNodeToEvidence:303",
        "file:src/services/storyEngine.ts:fn:fetchRelevantSummaries:318",
        "file:src/services/storyEngine.ts:fn:generateStory:364",
        "file:src/services/storyEngine.ts:fn:deduplicateEvidence:427",
        "file:src/services/storyEngine.ts:fn:synthesizeNarrative:443",
        "file:src/services/storyEngine.ts:fn:formatIntentContext:493"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/storyEngine.ts:fn:fetchMemoriesForDate:87": {
      "id": "file:src/services/storyEngine.ts:fn:fetchMemoriesForDate:87",
      "type": "function",
      "name": "fetchMemoriesForDate",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 87,
      "endLine": 112,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "dateText",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches memories from DB matching date patterns with salience threshold",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function fetchMemoriesForDate(dateText: string): Promise<StoryEvidenceNode[]> {\n  const normalizedPatterns = generateDatePatterns(dateText);\n\n  const placeholders = normalizedPatterns.map((_, i) => `content ILIKE $${i + 1}`).join(' OR ');\n  const likePatterns = normalizedPatterns.map((p) => `%${p}%`);\n\n  const result = await pool.query<Memory & { similarity?: number }>(\n    `SELECT id, content, source, created_at, salience_score\n     FROM memories\n     WHERE (${placeholders})\n       AND salience_score >= $${normalizedPatterns.length + 1}\n     ORDER BY salience_score DESC, created_at ASC\n     LIMIT $${normalizedPatterns.length + 2}`,\n    [...likePatterns, MIN_EVIDENCE_SALIENCE, MAX_EVIDENCE_NODES]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    type: 'memory' as EvidenceType,\n    source: row.source,\n    content: row.content,\n    weight: row.salience_score / 10,\n    created_at: row.created_at,\n    salience: row.salience_score,\n  }));\n}",
      "references": [
        "generateDatePatterns",
        "normalizedPatterns",
        "i",
        "p",
        "pool",
        "placeholders",
        "likePatterns",
        "MIN_EVIDENCE_SALIENCE",
        "MAX_EVIDENCE_NODES",
        "result",
        "row"
      ]
    },
    "file:src/services/storyEngine.ts:fn:generateDatePatterns:117": {
      "id": "file:src/services/storyEngine.ts:fn:generateDatePatterns:117",
      "type": "function",
      "name": "generateDatePatterns",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 117,
      "endLine": 161,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "dateText",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates multiple date pattern variations from input date text.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateDatePatterns(dateText: string): string[] {\n  const patterns: string[] = [dateText.toLowerCase()];\n\n  // Parse common date formats\n  const monthNames = [\n    'january', 'february', 'march', 'april', 'may', 'june',\n    'july', 'august', 'september', 'october', 'november', 'december',\n  ];\n  const monthAbbrevs = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];\n\n  // Check for month name in the text\n  for (let i = 0; i < monthNames.length; i++) {\n    const monthName = monthNames[i]!;\n    const monthAbbrev = monthAbbrevs[i]!;\n    if (dateText.toLowerCase().includes(monthName) || dateText.toLowerCase().includes(monthAbbrev)) {\n      const monthNum = i + 1;\n      // Extract day if present\n      const dayMatch = dateText.match(/(\\d{1,2})/);\n      if (dayMatch && dayMatch[1]) {\n        const day = parseInt(dayMatch[1], 10);\n        // Add numeric formats\n        patterns.push(`${monthNum}/${day}`);\n        patterns.push(`${monthNum}-${day}`);\n        patterns.push(`${monthName} ${day}`);\n        patterns.push(`${monthAbbrev} ${day}`);\n      }\n    }\n  }\n\n  // Check for numeric dates like 2/16 or 02/16\n  const numericMatch = dateText.match(/(\\d{1,2})[\\/\\-](\\d{1,2})/);\n  if (numericMatch && numericMatch[1] && numericMatch[2]) {\n    const month = parseInt(numericMatch[1], 10);\n    const day = parseInt(numericMatch[2], 10);\n    if (month >= 1 && month <= 12) {\n      const monthName = monthNames[month - 1];\n      if (monthName) {\n        patterns.push(`${monthName} ${day}`);\n      }\n      patterns.push(`${month}/${day}`);\n    }\n  }\n\n  return [...new Set(patterns)];\n}",
      "references": [
        "i",
        "monthNames",
        "monthAbbrevs",
        "monthName",
        "monthAbbrev",
        "dayMatch",
        "parseInt",
        "patterns",
        "monthNum",
        "day",
        "numericMatch",
        "month",
        "Set"
      ]
    },
    "file:src/services/storyEngine.ts:fn:fetchMemoriesForTopic:166": {
      "id": "file:src/services/storyEngine.ts:fn:fetchMemoriesForTopic:166",
      "type": "function",
      "name": "fetchMemoriesForTopic",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 166,
      "endLine": 193,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "topic",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches relevant memories from DB using topic embedding similarity and salience.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function fetchMemoriesForTopic(topic: string): Promise<StoryEvidenceNode[]> {\n  const embedding = await generateEmbedding(topic);\n  const embeddingStr = `[${embedding.join(',')}]`;\n\n  const result = await pool.query<Memory & { similarity: number }>(\n    `SELECT id, content, source, created_at, salience_score,\n            1 - (embedding <=> $1::vector) as similarity\n     FROM memories\n     WHERE embedding IS NOT NULL\n       AND salience_score >= $2\n       AND (salience_score >= 6.0 OR 1 - (embedding <=> $1::vector) >= 0.2)\n     ORDER BY \n       CASE WHEN salience_score >= 8.0 THEN 0 ELSE 1 END,\n       similarity DESC, salience_score DESC\n     LIMIT $3`,\n    [embeddingStr, MIN_EVIDENCE_SALIENCE, MAX_EVIDENCE_NODES]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    type: 'memory' as EvidenceType,\n    source: row.source,\n    content: row.content,\n    weight: (row.similarity * 0.6 + row.salience_score / 10 * 0.4),\n    created_at: row.created_at,\n    salience: row.salience_score,\n  }));\n}",
      "references": [
        "generateEmbedding",
        "embedding",
        "pool",
        "embeddingStr",
        "MIN_EVIDENCE_SALIENCE",
        "MAX_EVIDENCE_NODES",
        "result",
        "row"
      ]
    },
    "file:src/services/storyEngine.ts:fn:fetchMemoriesForPerson:198": {
      "id": "file:src/services/storyEngine.ts:fn:fetchMemoriesForPerson:198",
      "type": "function",
      "name": "fetchMemoriesForPerson",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 198,
      "endLine": 225,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "personName",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches person-related memories from DB, filtered by name match, salience, ordered and limited",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function fetchMemoriesForPerson(personName: string | null): Promise<StoryEvidenceNode[]> {\n  if (!personName) {\n    return [];\n  }\n\n  const result = await pool.query<Memory>(\n    `SELECT m.id, m.content, m.source, m.created_at, m.salience_score\n     FROM memories m\n     JOIN entity_mentions em ON em.memory_id = m.id\n     JOIN entities e ON e.id = em.entity_id\n     WHERE (e.name ILIKE $1 OR e.canonical_name ILIKE $1 OR $1 = ANY(e.aliases))\n       AND e.entity_type = 'person'\n       AND m.salience_score >= $2\n     ORDER BY m.salience_score DESC, m.created_at DESC\n     LIMIT $3`,\n    [`%${personName}%`, MIN_EVIDENCE_SALIENCE, MAX_EVIDENCE_NODES]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    type: 'memory' as EvidenceType,\n    source: row.source,\n    content: row.content,\n    weight: row.salience_score / 10,\n    created_at: row.created_at,\n    salience: row.salience_score,\n  }));\n}",
      "references": [
        "pool",
        "MIN_EVIDENCE_SALIENCE",
        "MAX_EVIDENCE_NODES",
        "result",
        "row"
      ]
    },
    "file:src/services/storyEngine.ts:fn:fetchMemoriesForSelf:230": {
      "id": "file:src/services/storyEngine.ts:fn:fetchMemoriesForSelf:230",
      "type": "function",
      "name": "fetchMemoriesForSelf",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 230,
      "endLine": 249,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches high-salience memories from DB and maps to StoryEvidenceNode[]",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function fetchMemoriesForSelf(): Promise<StoryEvidenceNode[]> {\n  const result = await pool.query<Memory>(\n    `SELECT id, content, source, created_at, salience_score\n     FROM memories\n     WHERE salience_score >= 6.0\n     ORDER BY salience_score DESC, created_at DESC\n     LIMIT $1`,\n    [MAX_EVIDENCE_NODES]\n  );\n\n  return result.rows.map((row) => ({\n    id: row.id,\n    type: 'memory' as EvidenceType,\n    source: row.source,\n    content: row.content,\n    weight: row.salience_score / 10,\n    created_at: row.created_at,\n    salience: row.salience_score,\n  }));\n}",
      "references": [
        "pool",
        "MAX_EVIDENCE_NODES",
        "result",
        "row"
      ]
    },
    "file:src/services/storyEngine.ts:fn:expandEvidenceViaGraph:255": {
      "id": "file:src/services/storyEngine.ts:fn:expandEvidenceViaGraph:255",
      "type": "function",
      "name": "expandEvidenceViaGraph",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 255,
      "endLine": 298,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "seedNodes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "maxAdditional",
          "type": "number",
          "isOptional": true,
          "defaultValue": "20"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Expands seed evidence nodes via memory graph neighborhood traversal.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function expandEvidenceViaGraph(\n  seedNodes: StoryEvidenceNode[],\n  maxAdditional: number = 20\n): Promise<StoryEvidenceNode[]> {\n  if (seedNodes.length === 0) return [];\n\n  const seenIds = new Set(seedNodes.map((n) => n.id));\n\n  // Get memory IDs from seed nodes\n  const memorySeeds = seedNodes\n    .filter((n) => n.type === 'memory')\n    .slice(0, 5)\n    .map((n) => n.id);\n\n  if (memorySeeds.length === 0) return [];\n\n  try {\n    // Use memoryGraph for multi-edge-type traversal\n    const neighborhoods = await getNeighborhoodFromMemories(memorySeeds, {\n      maxDepth: 2,\n      maxNodes: maxAdditional + 10,\n      minWeight: 0.3,\n      minSalience: 1.0,\n      edgeTypes: ['SIMILAR', 'ENTITY', 'SUMMARY'],\n    });\n\n    // Flatten and convert to StoryEvidenceNode\n    const graphNodes = flattenNeighborhoods(neighborhoods);\n\n    const additionalNodes: StoryEvidenceNode[] = [];\n    for (const node of graphNodes) {\n      if (seenIds.has(node.id)) continue;\n      if (additionalNodes.length >= maxAdditional) break;\n\n      seenIds.add(node.id);\n      additionalNodes.push(graphNodeToEvidence(node));\n    }\n\n    return additionalNodes;\n  } catch (error) {\n    console.error('[StoryEngine] Graph traversal failed:', error);\n    return [];\n  }\n}",
      "references": [
        "Set",
        "n",
        "memorySeeds",
        "getNeighborhoodFromMemories",
        "flattenNeighborhoods",
        "neighborhoods",
        "graphNodes",
        "seenIds",
        "node",
        "additionalNodes",
        "graphNodeToEvidence",
        "console",
        "error"
      ]
    },
    "file:src/services/storyEngine.ts:fn:graphNodeToEvidence:303": {
      "id": "file:src/services/storyEngine.ts:fn:graphNodeToEvidence:303",
      "type": "function",
      "name": "graphNodeToEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 303,
      "endLine": 313,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "node",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/memoryGraph\").GraphNode",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms GraphNode to StoryEvidenceNode with adjusted weight",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function graphNodeToEvidence(node: GraphNode): StoryEvidenceNode {\n  return {\n    id: node.id,\n    type: node.kind as EvidenceType,\n    source: node.source ?? `${node.kind}`,\n    content: node.content,\n    weight: node.score * 0.8, // Slightly lower weight for graph-discovered nodes\n    created_at: node.created_at ?? undefined,\n    salience: node.salience,\n  };\n}",
      "references": []
    },
    "file:src/services/storyEngine.ts:fn:fetchRelevantSummaries:318": {
      "id": "file:src/services/storyEngine.ts:fn:fetchRelevantSummaries:318",
      "type": "function",
      "name": "fetchRelevantSummaries",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 318,
      "endLine": 350,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches non-empty summaries and filters/maps them by categories relevant to story intent",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function fetchRelevantSummaries(intent: StoryIntent): Promise<StoryEvidenceNode[]> {\n  const summaries = await getNonEmptySummaries();\n\n  // Filter summaries based on intent\n  const relevantCategories: string[] = [];\n  switch (intent.kind) {\n    case 'self_story':\n      relevantCategories.push('personality', 'goals', 'interests');\n      break;\n    case 'relationship_story':\n      relevantCategories.push('relationships');\n      break;\n    case 'origin_story':\n      relevantCategories.push('personality', 'projects', 'goals');\n      break;\n    case 'date_meaning':\n      relevantCategories.push('personality', 'relationships', 'commitments');\n      break;\n    default:\n      return [];\n  }\n\n  return summaries\n    .filter((s) => relevantCategories.includes(s.category))\n    .map((s) => ({\n      id: s.id,\n      type: 'summary' as EvidenceType,\n      source: `summary:${s.category}`,\n      content: s.content,\n      weight: 0.7,\n      salience: 7,\n    }));\n}",
      "references": [
        "getNonEmptySummaries",
        "relevantCategories",
        "summaries",
        "s"
      ]
    },
    "file:src/services/storyEngine.ts:fn:generateStory:364": {
      "id": "file:src/services/storyEngine.ts:fn:generateStory:364",
      "type": "function",
      "name": "generateStory",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 364,
      "endLine": 422,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "request",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryRequest",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates story from cache or by fetching/processing memories, evidence, synthesizing narrative, and caching result",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateStory(request: StoryRequest): Promise<StoryResult> {\n  const { query, intent } = request;\n\n  // Step 0: Check cache first\n  const cached = getCachedStory(query, intent);\n  if (cached) {\n    console.log(`[StoryEngine] Cache hit - returning cached story`);\n    return cached;\n  }\n\n  // Step 1: Gather seed evidence based on intent\n  let seedEvidence: StoryEvidenceNode[] = [];\n\n  switch (intent.kind) {\n    case 'date_meaning':\n      seedEvidence = await fetchMemoriesForDate(intent.dateText);\n      break;\n    case 'origin_story':\n      seedEvidence = await fetchMemoriesForTopic(intent.topic ?? query);\n      break;\n    case 'relationship_story':\n      seedEvidence = await fetchMemoriesForPerson(intent.personName);\n      break;\n    case 'self_story':\n      seedEvidence = await fetchMemoriesForSelf();\n      break;\n    default:\n      seedEvidence = await fetchMemoriesForTopic(query);\n  }\n\n  // Step 2: Expand evidence via graph traversal\n  const graphEvidence = await expandEvidenceViaGraph(seedEvidence);\n\n  // Step 3: Fetch relevant summaries\n  const summaryEvidence = await fetchRelevantSummaries(intent);\n\n  // Combine and deduplicate evidence\n  const allEvidence = [...seedEvidence, ...graphEvidence, ...summaryEvidence];\n  const uniqueEvidence = deduplicateEvidence(allEvidence);\n\n  // Sort by weight and limit\n  const sortedEvidence = uniqueEvidence\n    .sort((a, b) => b.weight - a.weight)\n    .slice(0, MAX_EVIDENCE_NODES);\n\n  // Step 4: Synthesize narrative\n  const narrative = await synthesizeNarrative(query, intent, sortedEvidence);\n\n  const result: StoryResult = {\n    narrative,\n    evidence: sortedEvidence,\n    intent,\n  };\n\n  // Step 5: Cache the result\n  cacheStory(query, intent, result);\n\n  return result;\n}",
      "references": [
        "query",
        "intent",
        "getCachedStory",
        "cached",
        "console",
        "seedEvidence",
        "fetchMemoriesForDate",
        "fetchMemoriesForTopic",
        "fetchMemoriesForPerson",
        "fetchMemoriesForSelf",
        "expandEvidenceViaGraph",
        "fetchRelevantSummaries",
        "graphEvidence",
        "summaryEvidence",
        "deduplicateEvidence",
        "allEvidence",
        "uniqueEvidence",
        "b",
        "a",
        "MAX_EVIDENCE_NODES",
        "synthesizeNarrative",
        "sortedEvidence",
        "narrative",
        "cacheStory",
        "result"
      ]
    },
    "file:src/services/storyEngine.ts:fn:deduplicateEvidence:427": {
      "id": "file:src/services/storyEngine.ts:fn:deduplicateEvidence:427",
      "type": "function",
      "name": "deduplicateEvidence",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 427,
      "endLine": 438,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "nodes",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Deduplicates StoryEvidenceNode array by id, keeping highest weight node.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function deduplicateEvidence(nodes: StoryEvidenceNode[]): StoryEvidenceNode[] {\n  const seen = new Map<string, StoryEvidenceNode>();\n\n  for (const node of nodes) {\n    const existing = seen.get(node.id);\n    if (!existing || node.weight > existing.weight) {\n      seen.set(node.id, node);\n    }\n  }\n\n  return Array.from(seen.values());\n}",
      "references": [
        "Map",
        "seen",
        "node",
        "existing",
        "Array"
      ]
    },
    "file:src/services/storyEngine.ts:fn:synthesizeNarrative:443": {
      "id": "file:src/services/storyEngine.ts:fn:synthesizeNarrative:443",
      "type": "function",
      "name": "synthesizeNarrative",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 443,
      "endLine": 488,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "evidence",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyEngine\").StoryEvidenceNode[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Synthesizes a personal narrative from query, intent, and evidence using LLM.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function synthesizeNarrative(\n  query: string,\n  intent: StoryIntent,\n  evidence: StoryEvidenceNode[]\n): Promise<string> {\n  if (evidence.length === 0) {\n    return \"I don't have enough memories to tell you about this. Could you share more about it with me?\";\n  }\n\n  // Format evidence for the LLM\n  const evidenceText = evidence\n    .map((e, i) => {\n      const dateStr = e.created_at ? ` (${e.created_at.toLocaleDateString()})` : '';\n      return `[${i + 1}] ${e.content}${dateStr}`;\n    })\n    .join('\\n\\n');\n\n  const intentContext = formatIntentContext(intent);\n\n  const userPrompt = `The user asked: \"${query}\"\n\n${intentContext}\n\nHere is what I know about this from their memories and summaries:\n\n${evidenceText}\n\nPlease synthesize a personal, meaningful narrative that answers their question. Speak directly to the user in second person.`;\n\n  const messages: LLMMessage[] = [\n    { role: 'system', content: STORY_NARRATOR_PROMPT },\n    { role: 'user', content: userPrompt },\n  ];\n\n  try {\n    const result = await complete(messages, {\n      temperature: 0.7,\n      maxTokens: 800,\n    });\n\n    return result.content;\n  } catch (error) {\n    console.error('[StoryEngine] Narrative synthesis failed:', error);\n    return 'I had trouble piecing together this story. Let me try again later.';\n  }\n}",
      "references": [
        "e",
        "i",
        "dateStr",
        "formatIntentContext",
        "intentContext",
        "evidenceText",
        "STORY_NARRATOR_PROMPT",
        "userPrompt",
        "complete",
        "messages",
        "result",
        "console",
        "error"
      ]
    },
    "file:src/services/storyEngine.ts:fn:formatIntentContext:493": {
      "id": "file:src/services/storyEngine.ts:fn:formatIntentContext:493",
      "type": "function",
      "name": "formatIntentContext",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyEngine.ts",
      "line": 493,
      "endLine": 510,
      "parentFileId": "file:src/services/storyEngine.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats StoryIntent into a descriptive string based on its kind.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatIntentContext(intent: StoryIntent): string {\n  switch (intent.kind) {\n    case 'date_meaning':\n      return `This is a question about the personal significance of a date: \"${intent.dateText}\"`;\n    case 'origin_story':\n      return intent.topic\n        ? `This is a question about the origin/beginning of: ${intent.topic}`\n        : 'This is a question about an origin story or how something began';\n    case 'relationship_story':\n      return intent.personName\n        ? `This is a question about their relationship with: ${intent.personName}`\n        : 'This is a question about a personal relationship';\n    case 'self_story':\n      return 'This is a question about their identity, who they are, or their personal journey';\n    default:\n      return 'This is a question requiring personal narrative context';\n  }\n}",
      "references": []
    },
    "file:src/services/storyIntent.ts": {
      "id": "file:src/services/storyIntent.ts",
      "type": "file",
      "name": "storyIntent.ts",
      "filePath": "src/services/storyIntent.ts",
      "line": 1,
      "endLine": 230,
      "imports": [
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "detectStoryIntent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isStoryIntent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "describeIntent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "StoryIntent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        }
      ],
      "functions": [
        "file:src/services/storyIntent.ts:fn:safeParseJSON:65",
        "file:src/services/storyIntent.ts:fn:mightBeStoryQuery:93",
        "file:src/services/storyIntent.ts:fn:detectStoryIntent:151",
        "file:src/services/storyIntent.ts:fn:isStoryIntent:205",
        "file:src/services/storyIntent.ts:fn:describeIntent:212"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/storyIntent.ts:fn:safeParseJSON:65": {
      "id": "file:src/services/storyIntent.ts:fn:safeParseJSON:65",
      "type": "function",
      "name": "safeParseJSON",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyIntent.ts",
      "line": 65,
      "endLine": 87,
      "parentFileId": "file:src/services/storyIntent.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "T",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Safely parses JSON from string, stripping markdown, extracting objects, fixing trailing commas.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function safeParseJSON<T>(content: string): T | null {\n  let jsonStr = content.trim();\n\n  // Remove markdown code blocks if present\n  jsonStr = jsonStr.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '');\n\n  // Try to extract JSON object\n  const jsonMatch = jsonStr.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[0];\n  }\n\n  try {\n    return JSON.parse(jsonStr) as T;\n  } catch {\n    try {\n      const fixed = jsonStr.replace(/,\\s*([}\\]])/g, '$1');\n      return JSON.parse(fixed) as T;\n    } catch {\n      return null;\n    }\n  }\n}",
      "references": [
        "jsonStr",
        "jsonMatch",
        "JSON",
        "fixed"
      ]
    },
    "file:src/services/storyIntent.ts:fn:mightBeStoryQuery:93": {
      "id": "file:src/services/storyIntent.ts:fn:mightBeStoryQuery:93",
      "type": "function",
      "name": "mightBeStoryQuery",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyIntent.ts",
      "line": 93,
      "endLine": 141,
      "parentFileId": "file:src/services/storyIntent.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if query matches regex patterns for story-related questions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mightBeStoryQuery(query: string): boolean {\n  const q = query.toLowerCase();\n\n  // Date patterns\n  const datePatterns = [\n    /what does .+ mean to me/,\n    /what happened on/,\n    /why is .+ (special|significant|important)/,\n    /tell me about .+ (day|date)/,\n    /\\b(january|february|march|april|may|june|july|august|september|october|november|december)\\s+\\d/i,\n    /\\d{1,2}\\/\\d{1,2}/,\n  ];\n\n  // Origin patterns\n  const originPatterns = [\n    /how did .+ (start|begin)/,\n    /when did .+ (start|begin)/,\n    /tell me (about )?how/,\n    /what was my first/,\n    /origin (of|story)/,\n    /how i (got into|started|began)/,\n  ];\n\n  // Relationship patterns\n  const relationshipPatterns = [\n    /tell me about \\w+/,\n    /how did i meet/,\n    /my (history|relationship) with/,\n    /who is \\w+ to me/,\n  ];\n\n  // Self patterns\n  const selfPatterns = [\n    /who am i/,\n    /tell me about (myself|me)/,\n    /what makes me/,\n    /what.?s my story/,\n    /my (identity|journey)/,\n  ];\n\n  const allPatterns = [\n    ...datePatterns,\n    ...originPatterns,\n    ...relationshipPatterns,\n    ...selfPatterns,\n  ];\n\n  return allPatterns.some((pattern) => pattern.test(q));\n}",
      "references": [
        "datePatterns",
        "originPatterns",
        "relationshipPatterns",
        "selfPatterns",
        "allPatterns",
        "pattern",
        "q"
      ]
    },
    "file:src/services/storyIntent.ts:fn:detectStoryIntent:151": {
      "id": "file:src/services/storyIntent.ts:fn:detectStoryIntent:151",
      "type": "function",
      "name": "detectStoryIntent",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyIntent.ts",
      "line": 151,
      "endLine": 200,
      "parentFileId": "file:src/services/storyIntent.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects story intent in query using LLM completion and returns typed StoryIntent.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function detectStoryIntent(query: string): Promise<StoryIntent> {\n  // Quick check - skip LLM for obviously non-story queries\n  if (!mightBeStoryQuery(query)) {\n    return { kind: 'none' };\n  }\n\n  try {\n    const messages: LLMMessage[] = [\n      { role: 'system', content: STORY_INTENT_PROMPT },\n      { role: 'user', content: query },\n    ];\n\n    const result = await complete(messages, {\n      temperature: 0.1,\n      maxTokens: 150,\n    });\n\n    const parsed = safeParseJSON<StoryIntentDetection>(result.content);\n    if (!parsed || !parsed.kind) {\n      console.error('[StoryIntent] Failed to parse intent JSON:', result.content.substring(0, 200));\n      return { kind: 'none' };\n    }\n\n    // Build the typed StoryIntent based on kind\n    switch (parsed.kind) {\n      case 'date_meaning':\n        return {\n          kind: 'date_meaning',\n          dateText: parsed.dateText ?? '',\n        };\n      case 'origin_story':\n        return {\n          kind: 'origin_story',\n          topic: parsed.topic,\n        };\n      case 'relationship_story':\n        return {\n          kind: 'relationship_story',\n          personName: parsed.personName ?? null,\n        };\n      case 'self_story':\n        return { kind: 'self_story' };\n      default:\n        return { kind: 'none' };\n    }\n  } catch (error) {\n    console.error('[StoryIntent] Detection failed:', error);\n    return { kind: 'none' };\n  }\n}",
      "references": [
        "mightBeStoryQuery",
        "STORY_INTENT_PROMPT",
        "complete",
        "messages",
        "safeParseJSON",
        "result",
        "parsed",
        "console",
        "error"
      ]
    },
    "file:src/services/storyIntent.ts:fn:isStoryIntent:205": {
      "id": "file:src/services/storyIntent.ts:fn:isStoryIntent:205",
      "type": "function",
      "name": "isStoryIntent",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyIntent.ts",
      "line": 205,
      "endLine": 207,
      "parentFileId": "file:src/services/storyIntent.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if a StoryIntent's kind is not 'none'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isStoryIntent(intent: StoryIntent): boolean {\n  return intent.kind !== 'none';\n}",
      "references": []
    },
    "file:src/services/storyIntent.ts:fn:describeIntent:212": {
      "id": "file:src/services/storyIntent.ts:fn:describeIntent:212",
      "type": "function",
      "name": "describeIntent",
      "filePath": "/home/ridgetop/projects/squire/src/services/storyIntent.ts",
      "line": 212,
      "endLine": 229,
      "parentFileId": "file:src/services/storyIntent.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "intent",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/storyIntent\").StoryIntent",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a string description of the given StoryIntent based on its kind.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function describeIntent(intent: StoryIntent): string {\n  switch (intent.kind) {\n    case 'date_meaning':\n      return `Date meaning query: \"${intent.dateText}\"`;\n    case 'origin_story':\n      return intent.topic\n        ? `Origin story query about: ${intent.topic}`\n        : 'Origin story query (general)';\n    case 'relationship_story':\n      return intent.personName\n        ? `Relationship story about: ${intent.personName}`\n        : 'Relationship story query';\n    case 'self_story':\n      return 'Self/identity story query';\n    default:\n      return 'Not a story query';\n  }\n}",
      "references": []
    },
    "file:src/services/summaries.ts": {
      "id": "file:src/services/summaries.ts",
      "type": "file",
      "name": "summaries.ts",
      "filePath": "src/services/summaries.ts",
      "line": 1,
      "endLine": 652,
      "imports": [
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/llm.js",
          "items": [
            {
              "name": "completeText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "classifyMemoryCategories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getNonEmptySummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkMemoryToCategories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateAllSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSummaryStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isValidCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "refreshCommitmentsSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SUMMARY_CATEGORIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "SummaryCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "LivingSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CategoryClassification",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemorySummaryLink",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/summaries.ts:fn:isIdentityContent:64",
        "file:src/services/summaries.ts:fn:isSignificantDateContent:88",
        "file:src/services/summaries.ts:fn:classifyMemoryCategories:119",
        "file:src/services/summaries.ts:fn:getAllSummaries:226",
        "file:src/services/summaries.ts:fn:getSummary:236",
        "file:src/services/summaries.ts:fn:getNonEmptySummaries:249",
        "file:src/services/summaries.ts:fn:updateSummary:261",
        "file:src/services/summaries.ts:fn:linkMemoryToCategories:291",
        "file:src/services/summaries.ts:fn:getUnincorporatedMemories:331",
        "file:src/services/summaries.ts:fn:markMemoriesIncorporated:356",
        "file:src/services/summaries.ts:fn:generateSummary:394",
        "file:src/services/summaries.ts:fn:updateAllSummaries:475",
        "file:src/services/summaries.ts:fn:getCategoryDescription:498",
        "file:src/services/summaries.ts:fn:getSummaryStats:515",
        "file:src/services/summaries.ts:fn:isValidCategory:560",
        "file:src/services/summaries.ts:fn:refreshCommitmentsSummary:575"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/summaries.ts:fn:isIdentityContent:64": {
      "id": "file:src/services/summaries.ts:fn:isIdentityContent:64",
      "type": "function",
      "name": "isIdentityContent",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 64,
      "endLine": 82,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if content matches regex patterns for personal identity info.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function isIdentityContent(content: string): boolean {\n  const identityPatterns = [\n    // Standard \"The user\" format\n    /the user'?s? name is/i,\n    /user is named/i,\n    /user'?s? (?:wife|husband|spouse|partner|son|daughter|child|mother|father|parent|sibling|brother|sister) is (?:named )?/i,\n    /the user is \\d+ years? old/i,\n    /the user works at/i,\n    /the user (?:is|has|works|lives)/i,\n\n    // Name-based patterns (for memories created before identity-first fix)\n    // These catch \"Brian's wife is...\", \"Brian created...\", etc.\n    /Brian'?s?\\s+(?:wife|husband|spouse|partner|child|children|daughter|son|mother|father|family)/i,\n    /Brian\\s+(?:is|has|works|lives|created|built|developed)/i,\n    /Brian\\s+is\\s+(?:a\\s+)?\\d+\\s*(?:years?\\s*old)?/i,\n    /Brian\\s+works\\s+(?:at|for|on)/i,\n  ];\n  return identityPatterns.some(pattern => pattern.test(content));\n}",
      "references": [
        "identityPatterns",
        "pattern"
      ]
    },
    "file:src/services/summaries.ts:fn:isSignificantDateContent:88": {
      "id": "file:src/services/summaries.ts:fn:isSignificantDateContent:88",
      "type": "function",
      "name": "isSignificantDateContent",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 88,
      "endLine": 113,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if content mentions significant dates or life events using regex patterns",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function isSignificantDateContent(content: string): boolean {\n  const significantDatePatterns = [\n    // Life events\n    /\\b(?:birthday|anniversary|wedding|married|engagement|engaged)\\b/i,\n    /\\b(?:graduated|graduation|first day|last day)\\b/i,\n    /\\b(?:died|passed away|funeral|memorial)\\b/i,\n    /\\b(?:born|birth of|gave birth)\\b/i,\n    /\\b(?:retired|retirement|started (?:new )?job)\\b/i,\n\n    // Pivotal moments\n    /\\b(?:turning point|life.?changing|pivotal|watershed)\\b/i,\n    /\\b(?:where it all started|began|origin|first time)\\b/i,\n    /\\b(?:moment (?:when|that)|the day (?:when|that|I))\\b/i,\n\n    // Date patterns with context\n    /(?:on|since|remember)\\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{1,2}/i,\n    /(?:on|since|remember)\\s+\\d{1,2}\\/\\d{1,2}(?:\\/\\d{2,4})?/i,\n    /(?:on|since|remember)\\s+\\d{4}-\\d{2}-\\d{2}/i,\n\n    // Significance markers\n    /\\bsignificant (?:date|day|moment|event)\\b/i,\n    /\\bthis (?:date|day) means?\\b/i,\n    /\\bspecial (?:day|date|occasion)\\b/i,\n  ];\n  return significantDatePatterns.some(pattern => pattern.test(content));\n}",
      "references": [
        "significantDatePatterns",
        "pattern"
      ]
    },
    "file:src/services/summaries.ts:fn:classifyMemoryCategories:119": {
      "id": "file:src/services/summaries.ts:fn:classifyMemoryCategories:119",
      "type": "function",
      "name": "classifyMemoryCategories",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 119,
      "endLine": 219,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").CategoryClassification[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Classifies memory content into categories using AI prompts (likely LLM API call).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function classifyMemoryCategories(\n  content: string\n): Promise<CategoryClassification[]> {\n  // Pre-check: If this is clearly identity content, ensure personality is included\n  const isIdentity = isIdentityContent(content);\n  // Pre-check: If this is clearly about a significant date, ensure significant_dates is included\n  const isSignificantDate = isSignificantDateContent(content);\n\n  const systemPrompt = `You are a memory classifier. Given a memory/observation, determine which categories it touches.\n\nCategories:\n- personality: Identity, self-story, who you are, personal traits, values, name, age, job, core facts about the user\n- goals: Aspirations, objectives, things being worked toward\n- relationships: People, social connections, family, friends, colleagues\n- projects: Active work, tasks, professional or personal projects\n- interests: Hobbies, passions, things enjoyed, entertainment preferences\n- wellbeing: Health, mood, emotional states, physical/mental wellness\n- commitments: Promises, obligations, things owed to others or by others\n- significant_dates: Key dates in life and what they mean (birthdays, anniversaries, pivotal events, turning points, origin stories)\n\nIMPORTANT: Memories about the user's name, age, job, or core identity MUST include \"personality\" with high relevance (0.9+).\nMemories about the user's relationships (wife, husband, children) should include BOTH \"personality\" AND \"relationships\".\nMemories about specific meaningful dates (birthdays, anniversaries, pivotal moments, \"the day X happened\") should include \"significant_dates\".\n\nReturn ONLY a JSON array of relevant categories with relevance scores (0.0-1.0).\nOnly include categories that are clearly relevant (relevance >= 0.3).\nFormat: [{\"category\": \"...\", \"relevance\": 0.X, \"reason\": \"brief reason\"}]\n\nIf the memory doesn't clearly relate to any category, return an empty array: []`;\n\n  const prompt = `Memory: \"${content}\"\n\nWhich categories does this memory touch? Return JSON array only.`;\n\n  try {\n    const response = await completeText(prompt, systemPrompt, {\n      temperature: 0.1, // Low temperature for consistent classification\n      maxTokens: 300,\n    });\n\n    // Parse JSON response\n    const jsonMatch = response.match(/\\[[\\s\\S]*?\\]/);\n    if (!jsonMatch) {\n      // If LLM fails but we detected identity, return personality\n      if (isIdentity) {\n        return [{ category: 'personality', relevance: 1.0, reason: 'Identity content detected' }];\n      }\n      return [];\n    }\n\n    const classifications = JSON.parse(jsonMatch[0]) as Array<{\n      category: string;\n      relevance: number;\n      reason?: string;\n    }>;\n\n    // Validate and filter\n    let result = classifications\n      .filter(\n        (c) =>\n          SUMMARY_CATEGORIES.includes(c.category as SummaryCategory) &&\n          c.relevance >= 0.3\n      )\n      .map((c) => ({\n        category: c.category as SummaryCategory,\n        relevance: Math.min(1.0, Math.max(0.0, c.relevance)),\n        reason: c.reason || '',\n      }));\n\n    // Ensure identity content ALWAYS includes personality\n    if (isIdentity && !result.some(c => c.category === 'personality')) {\n      result.push({\n        category: 'personality',\n        relevance: 1.0,\n        reason: 'Identity content - forced inclusion',\n      });\n    }\n\n    // Ensure significant date content ALWAYS includes significant_dates\n    if (isSignificantDate && !result.some(c => c.category === 'significant_dates')) {\n      result.push({\n        category: 'significant_dates',\n        relevance: 0.9,\n        reason: 'Significant date content - forced inclusion',\n      });\n    }\n\n    return result;\n  } catch (error) {\n    console.error('Category classification failed:', error);\n    // Even on error, if we detected identity or significant date, return appropriate category\n    const fallbacks: CategoryClassification[] = [];\n    if (isIdentity) {\n      fallbacks.push({ category: 'personality', relevance: 1.0, reason: 'Identity content (fallback)' });\n    }\n    if (isSignificantDate) {\n      fallbacks.push({ category: 'significant_dates', relevance: 0.9, reason: 'Significant date content (fallback)' });\n    }\n    return fallbacks;\n  }\n}",
      "references": [
        "isIdentityContent",
        "isSignificantDateContent",
        "completeText",
        "prompt",
        "systemPrompt",
        "response",
        "jsonMatch",
        "isIdentity",
        "JSON",
        "classifications",
        "SUMMARY_CATEGORIES",
        "c",
        "Math",
        "result",
        "isSignificantDate",
        "console",
        "error",
        "fallbacks"
      ]
    },
    "file:src/services/summaries.ts:fn:getAllSummaries:226": {
      "id": "file:src/services/summaries.ts:fn:getAllSummaries:226",
      "type": "function",
      "name": "getAllSummaries",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 226,
      "endLine": 231,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves all living summaries from database ordered by category",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.306Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllSummaries(): Promise<LivingSummary[]> {\n  const result = await pool.query<LivingSummary>(\n    `SELECT * FROM living_summaries ORDER BY category`\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/summaries.ts:fn:getSummary:236": {
      "id": "file:src/services/summaries.ts:fn:getSummary:236",
      "type": "function",
      "name": "getSummary",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 236,
      "endLine": 244,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a living summary from the database by category",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.306Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSummary(\n  category: SummaryCategory\n): Promise<LivingSummary | null> {\n  const result = await pool.query<LivingSummary>(\n    `SELECT * FROM living_summaries WHERE category = $1`,\n    [category]\n  );\n  return result.rows[0] || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/summaries.ts:fn:getNonEmptySummaries:249": {
      "id": "file:src/services/summaries.ts:fn:getNonEmptySummaries:249",
      "type": "function",
      "name": "getNonEmptySummaries",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 249,
      "endLine": 256,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches non-empty living summaries from DB ordered by last_updated_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.306Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getNonEmptySummaries(): Promise<LivingSummary[]> {\n  const result = await pool.query<LivingSummary>(\n    `SELECT * FROM living_summaries\n     WHERE content != ''\n     ORDER BY last_updated_at DESC`\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/summaries.ts:fn:updateSummary:261": {
      "id": "file:src/services/summaries.ts:fn:updateSummary:261",
      "type": "function",
      "name": "updateSummary",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 261,
      "endLine": 284,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "model",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tokens",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates living summary content, version, timestamps, model, tokens for a category and returns it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.306Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateSummary(\n  category: SummaryCategory,\n  content: string,\n  model: string,\n  tokens: number\n): Promise<LivingSummary> {\n  const result = await pool.query<LivingSummary>(\n    `UPDATE living_summaries\n     SET content = $2,\n         version = version + 1,\n         last_updated_at = NOW(),\n         last_update_model = $3,\n         last_update_tokens = $4,\n         staleness_score = 0.0\n     WHERE category = $1\n     RETURNING *`,\n    [category, content, model, tokens]\n  );\n  const updated = result.rows[0];\n  if (!updated) {\n    throw new Error(`Summary category not found: ${category}`);\n  }\n  return updated;\n}",
      "references": [
        "pool",
        "result",
        "updated",
        "Error"
      ]
    },
    "file:src/services/summaries.ts:fn:linkMemoryToCategories:291": {
      "id": "file:src/services/summaries.ts:fn:linkMemoryToCategories:291",
      "type": "function",
      "name": "linkMemoryToCategories",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 291,
      "endLine": 326,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "classifications",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/summaries\").CategoryClassification[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Upserts memory-category links in DB and increments staleness scores for affected summary categories",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.306Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkMemoryToCategories(\n  memoryId: string,\n  classifications: CategoryClassification[]\n): Promise<void> {\n  if (classifications.length === 0) return;\n\n  const values = classifications\n    .map(\n      (_, i) =>\n        `($1, $${i * 2 + 2}, $${i * 2 + 3})`\n    )\n    .join(', ');\n\n  const params: (string | number)[] = [memoryId];\n  for (const c of classifications) {\n    params.push(c.category, c.relevance);\n  }\n\n  await pool.query(\n    `INSERT INTO memory_summary_links (memory_id, summary_category, relevance_score)\n     VALUES ${values}\n     ON CONFLICT (memory_id, summary_category)\n     DO UPDATE SET relevance_score = EXCLUDED.relevance_score`,\n    params\n  );\n\n  // Update staleness of affected summaries\n  for (const c of classifications) {\n    await pool.query(\n      `UPDATE living_summaries\n       SET staleness_score = LEAST(1.0, staleness_score + 0.1)\n       WHERE category = $1`,\n      [c.category]\n    );\n  }\n}",
      "references": [
        "i",
        "params",
        "c",
        "pool",
        "values"
      ]
    },
    "file:src/services/summaries.ts:fn:getUnincorporatedMemories:331": {
      "id": "file:src/services/summaries.ts:fn:getUnincorporatedMemories:331",
      "type": "function",
      "name": "getUnincorporatedMemories",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 331,
      "endLine": 351,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "20"
        }
      ],
      "returnType": "Promise<{ memory_id: string; content: string; relevance: number; created_at: Date; }[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves unincorporated memories for a category, ordered by relevance, up to limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.839Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getUnincorporatedMemories(\n  category: SummaryCategory,\n  limit: number = 20\n): Promise<Array<{ memory_id: string; content: string; relevance: number; created_at: Date }>> {\n  const result = await pool.query<{\n    memory_id: string;\n    content: string;\n    relevance: number;\n    created_at: Date;\n  }>(\n    `SELECT msl.memory_id, m.content, msl.relevance_score as relevance, m.created_at\n     FROM memory_summary_links msl\n     JOIN memories m ON m.id = msl.memory_id\n     WHERE msl.summary_category = $1\n       AND msl.incorporated = FALSE\n     ORDER BY msl.relevance_score DESC, m.created_at DESC\n     LIMIT $2`,\n    [category, limit]\n  );\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/summaries.ts:fn:markMemoriesIncorporated:356": {
      "id": "file:src/services/summaries.ts:fn:markMemoriesIncorporated:356",
      "type": "function",
      "name": "markMemoriesIncorporated",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 356,
      "endLine": 387,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "version",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Marks memories as incorporated in links and updates summary's memory count and last memory time",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function markMemoriesIncorporated(\n  memoryIds: string[],\n  category: SummaryCategory,\n  version: number\n): Promise<void> {\n  if (memoryIds.length === 0) return;\n\n  await pool.query(\n    `UPDATE memory_summary_links\n     SET incorporated = TRUE,\n         incorporated_at = NOW(),\n         incorporated_version = $3\n     WHERE memory_id = ANY($1) AND summary_category = $2`,\n    [memoryIds, category, version]\n  );\n\n  // Update memory count on summary\n  await pool.query(\n    `UPDATE living_summaries\n     SET memory_count = (\n       SELECT COUNT(*) FROM memory_summary_links\n       WHERE summary_category = $1 AND incorporated = TRUE\n     ),\n     last_memory_at = (\n       SELECT MAX(m.created_at) FROM memory_summary_links msl\n       JOIN memories m ON m.id = msl.memory_id\n       WHERE msl.summary_category = $1 AND msl.incorporated = TRUE\n     )\n     WHERE category = $1`,\n    [category]\n  );\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/summaries.ts:fn:generateSummary:394": {
      "id": "file:src/services/summaries.ts:fn:generateSummary:394",
      "type": "function",
      "name": "generateSummary",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 394,
      "endLine": 470,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ summary: import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary; memoriesProcessed: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates updated living summary for category by incorporating new memories via AI prompt",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateSummary(\n  category: SummaryCategory\n): Promise<{ summary: LivingSummary; memoriesProcessed: number }> {\n  // Get current summary\n  const current = await getSummary(category);\n  if (!current) {\n    throw new Error(`Summary category not found: ${category}`);\n  }\n\n  // Get unincorporated memories\n  const newMemories = await getUnincorporatedMemories(category);\n  if (newMemories.length === 0) {\n    return { summary: current, memoriesProcessed: 0 };\n  }\n\n  // Build prompt for incremental update - use special format for significant_dates\n  const systemPrompt = category === 'significant_dates'\n    ? `You are a personal memory summarizer. Your job is to maintain a chronological list of significant dates and what they mean.\n\nRules:\n1. Format as a chronological list - each date on its own line\n2. Format each entry as: \"**[Date]** - [What happened] | [Why it matters/emotional significance]\"\n3. If the exact date is unknown, use approximate dates or seasons (e.g., \"Early 2025\", \"Spring 2024\")\n4. Preserve all existing dates unless they are clearly duplicates\n5. Add new dates from the new memories\n6. Use second person (\"you\") when referring to the person\n7. Focus on emotional significance - why this date matters\n8. Keep entries concise but meaningful\n9. Order chronologically, oldest to newest\n\nExample format:\n**February 16, 2025** - First conversation with AI at Mills Floor Covering | The moment your journey with AI companions began\n**March 15, 2025** - Started building Squire | When you decided to create your own memory system`\n    : `You are a personal memory summarizer. Your job is to maintain a living summary of ${getCategoryDescription(category)}.\n\nRules:\n1. If there's an existing summary, UPDATE it incrementally - don't rewrite from scratch\n2. Preserve important existing information unless it's clearly outdated\n3. Add new information from the new memories\n4. Keep the summary concise but comprehensive (aim for 100-300 words)\n5. Use second person (\"you\") when referring to the person\n6. Focus on what's most relevant and actionable\n7. If information conflicts, prefer the newer information\n8. Write in a natural, conversational tone`;\n\n  const existingPart = current.content\n    ? `Current summary:\\n${current.content}\\n\\n`\n    : 'No existing summary yet.\\n\\n';\n\n  const memoriesPart = newMemories\n    .map((m, i) => `${i + 1}. ${m.content}`)\n    .join('\\n');\n\n  const prompt = `${existingPart}New memories to incorporate:\\n${memoriesPart}\\n\\nGenerate the updated summary for \"${category}\". Return ONLY the summary text, no preamble.`;\n\n  const response = await completeText(prompt, systemPrompt, {\n    temperature: 0.3,\n    maxTokens: 500,\n  });\n\n  // Update the summary\n  const updated = await updateSummary(\n    category,\n    response.trim(),\n    'llama-3.3-70b-versatile',\n    0 // Token count not easily available from completeText\n  );\n\n  // Mark memories as incorporated\n  await markMemoriesIncorporated(\n    newMemories.map((m) => m.memory_id),\n    category,\n    updated.version\n  );\n\n  return { summary: updated, memoriesProcessed: newMemories.length };\n}",
      "references": [
        "getSummary",
        "current",
        "Error",
        "getUnincorporatedMemories",
        "newMemories",
        "getCategoryDescription",
        "i",
        "m",
        "existingPart",
        "memoriesPart",
        "completeText",
        "prompt",
        "systemPrompt",
        "updateSummary",
        "response",
        "markMemoriesIncorporated",
        "updated"
      ]
    },
    "file:src/services/summaries.ts:fn:updateAllSummaries:475": {
      "id": "file:src/services/summaries.ts:fn:updateAllSummaries:475",
      "type": "function",
      "name": "updateAllSummaries",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 475,
      "endLine": 494,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ updated: (\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\")[]; memoriesProcessed: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates summaries for categories with unincorporated memories, returns updated categories and total processed.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateAllSummaries(): Promise<{\n  updated: SummaryCategory[];\n  memoriesProcessed: number;\n}> {\n  const updated: SummaryCategory[] = [];\n  let totalProcessed = 0;\n\n  for (const category of SUMMARY_CATEGORIES) {\n    const pending = await getUnincorporatedMemories(category, 1);\n    if (pending.length > 0) {\n      const result = await generateSummary(category);\n      if (result.memoriesProcessed > 0) {\n        updated.push(category);\n        totalProcessed += result.memoriesProcessed;\n      }\n    }\n  }\n\n  return { updated, memoriesProcessed: totalProcessed };\n}",
      "references": [
        "SUMMARY_CATEGORIES",
        "getUnincorporatedMemories",
        "category",
        "pending",
        "generateSummary",
        "result",
        "updated",
        "totalProcessed"
      ]
    },
    "file:src/services/summaries.ts:fn:getCategoryDescription:498": {
      "id": "file:src/services/summaries.ts:fn:getCategoryDescription:498",
      "type": "function",
      "name": "getCategoryDescription",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 498,
      "endLine": 510,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "\"personality\" | \"goals\" | \"relationships\" | \"projects\" | \"interests\" | \"wellbeing\" | \"commitments\" | \"significant_dates\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a description string for a given SummaryCategory.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCategoryDescription(category: SummaryCategory): string {\n  const descriptions: Record<SummaryCategory, string> = {\n    personality: 'your identity, self-story, personal traits, and core values',\n    goals: 'aspirations, objectives, and things you are working toward',\n    relationships: 'key people in your life, family, friends, and social connections',\n    projects: 'active work, tasks, and projects you are working on',\n    interests: 'hobbies, passions, things you enjoy, and entertainment preferences',\n    wellbeing: 'your health, mood, emotional patterns, and physical/mental wellness',\n    commitments: 'promises, obligations, and things you owe to others or are owed',\n    significant_dates: 'key dates in your life and what they mean (birthdays, anniversaries, pivotal moments, origin stories)',\n  };\n  return descriptions[category];\n}",
      "references": [
        "descriptions"
      ]
    },
    "file:src/services/summaries.ts:fn:getSummaryStats:515": {
      "id": "file:src/services/summaries.ts:fn:getSummaryStats:515",
      "type": "function",
      "name": "getSummaryStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 515,
      "endLine": 555,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ categories: number; withContent: number; totalMemoriesLinked: number; pendingMemories: number; avgStaleness: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches stats on summary categories, content, linked/pending memories, and avg staleness from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSummaryStats(): Promise<{\n  categories: number;\n  withContent: number;\n  totalMemoriesLinked: number;\n  pendingMemories: number;\n  avgStaleness: number;\n}> {\n  const result = await pool.query<{\n    categories: string;\n    with_content: string;\n    total_linked: string;\n    pending: string;\n    avg_staleness: string;\n  }>(`\n    SELECT\n      COUNT(*) as categories,\n      COUNT(*) FILTER (WHERE content != '') as with_content,\n      (SELECT COUNT(*) FROM memory_summary_links WHERE incorporated = TRUE) as total_linked,\n      (SELECT COUNT(*) FROM memory_summary_links WHERE incorporated = FALSE) as pending,\n      AVG(staleness_score) as avg_staleness\n    FROM living_summaries\n  `);\n\n  const row = result.rows[0];\n  if (!row) {\n    return {\n      categories: 0,\n      withContent: 0,\n      totalMemoriesLinked: 0,\n      pendingMemories: 0,\n      avgStaleness: 0,\n    };\n  }\n  return {\n    categories: parseInt(row.categories, 10),\n    withContent: parseInt(row.with_content, 10),\n    totalMemoriesLinked: parseInt(row.total_linked, 10),\n    pendingMemories: parseInt(row.pending, 10),\n    avgStaleness: parseFloat(row.avg_staleness) || 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "row",
        "parseInt",
        "parseFloat"
      ]
    },
    "file:src/services/summaries.ts:fn:isValidCategory:560": {
      "id": "file:src/services/summaries.ts:fn:isValidCategory:560",
      "type": "function",
      "name": "isValidCategory",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 560,
      "endLine": 562,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if string category is valid SummaryCategory via SUMMARY_CATEGORIES inclusion.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isValidCategory(category: string): category is SummaryCategory {\n  return SUMMARY_CATEGORIES.includes(category as SummaryCategory);\n}",
      "references": [
        "SUMMARY_CATEGORIES"
      ]
    },
    "file:src/services/summaries.ts:fn:refreshCommitmentsSummary:575": {
      "id": "file:src/services/summaries.ts:fn:refreshCommitmentsSummary:575",
      "type": "function",
      "name": "refreshCommitmentsSummary",
      "filePath": "/home/ridgetop/projects/squire/src/services/summaries.ts",
      "line": 575,
      "endLine": 651,
      "parentFileId": "file:src/services/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/summaries\").LivingSummary>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches open commitments from DB, builds LLM prompt for summary.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.685Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function refreshCommitmentsSummary(): Promise<LivingSummary> {\n  // Fetch current open commitments from the actual commitments table\n  const commitmentsResult = await pool.query(`\n    SELECT title, description, due_at, status, all_day\n    FROM commitments\n    WHERE status IN ('open', 'in_progress', 'snoozed')\n    ORDER BY\n      CASE WHEN due_at IS NULL THEN 1 ELSE 0 END,\n      due_at ASC\n    LIMIT 20\n  `);\n\n  const openCommitments = commitmentsResult.rows;\n\n  // Build context for LLM\n  const now = new Date();\n  const dateStr = now.toLocaleDateString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    timeZone: 'America/New_York',\n  });\n\n  let commitmentList = '';\n  if (openCommitments.length === 0) {\n    commitmentList = 'No open commitments at this time.';\n  } else {\n    commitmentList = openCommitments.map((c, i) => {\n      const dueInfo = c.due_at\n        ? ` (due: ${new Date(c.due_at).toLocaleDateString('en-US', {\n            weekday: 'short',\n            month: 'short',\n            day: 'numeric',\n            timeZone: 'America/New_York',\n          })})`\n        : '';\n      const statusInfo = c.status === 'snoozed' ? ' [snoozed]' : '';\n      return `${i + 1}. ${c.title}${dueInfo}${statusInfo}`;\n    }).join('\\n');\n  }\n\n  const systemPrompt = `You are a personal assistant summarizing someone's current commitments and obligations.\n\nRules:\n1. ONLY describe commitments that are currently OPEN - not past ones\n2. Use RELATIVE time references (\"tomorrow\", \"this Wednesday\", \"next week\") instead of absolute dates\n3. Keep it concise but actionable\n4. Use second person (\"you have\", \"you need to\")\n5. Group by urgency if possible (today, this week, upcoming, no deadline)\n6. DO NOT mention any dates that have already passed\n7. Keep it to 100-200 words maximum\n\nToday's date is: ${dateStr}`;\n\n  const prompt = `Current open commitments:\n${commitmentList}\n\nGenerate a fresh summary of current commitments. Return ONLY the summary text, no preamble.`;\n\n  const response = await completeText(prompt, systemPrompt, {\n    temperature: 0.3,\n    maxTokens: 400,\n  });\n\n  // Update the summary\n  const updated = await updateSummary(\n    'commitments',\n    response.trim(),\n    'commitments-refresh',\n    0\n  );\n\n  console.log(`[Summaries] Refreshed commitments summary with ${openCommitments.length} open items`);\n\n  return updated;\n}",
      "references": [
        "pool",
        "commitmentsResult",
        "Date",
        "now",
        "openCommitments",
        "commitmentList",
        "c",
        "i",
        "dueInfo",
        "statusInfo",
        "dateStr",
        "completeText",
        "prompt",
        "systemPrompt",
        "updateSummary",
        "response",
        "console",
        "updated"
      ]
    },
    "file:src/tools/calendar.ts": {
      "id": "file:src/tools/calendar.ts",
      "type": "file",
      "name": "calendar.ts",
      "filePath": "src/tools/calendar.ts",
      "line": 1,
      "endLine": 617,
      "imports": [
        {
          "source": "../services/google/events.js",
          "items": [
            {
              "name": "getAllEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "pushEventToGoogle",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GoogleEvent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/google/calendars.js",
          "items": [
            {
              "name": "getDefaultPushCalendar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/google/auth.js",
          "items": [
            {
              "name": "listSyncEnabledAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "getUpcomingEventsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getUpcomingEventsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getUpcomingEventsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getUpcomingEventsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getTodaysEventsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getTodaysEventsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getTodaysEventsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getTodaysEventsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getEventsDueSoonToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getEventsDueSoonToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getEventsDueSoonToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getEventsDueSoonToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createCalendarEventToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createCalendarEventToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createCalendarEventToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createCalendarEventToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/tools/calendar.ts:fn:getTodayDateString:26",
        "file:src/tools/calendar.ts:fn:getTomorrowDateString:34",
        "file:src/tools/calendar.ts:fn:getEventDateString:42",
        "file:src/tools/calendar.ts:fn:getDateLabel:56",
        "file:src/tools/calendar.ts:fn:getLocalTime:92",
        "file:src/tools/calendar.ts:fn:getDayOfWeek:105",
        "file:src/tools/calendar.ts:fn:formatEventTime:125",
        "file:src/tools/calendar.ts:fn:getCurrentContext:139",
        "file:src/tools/calendar.ts:fn:handleGetUpcomingEvents:167",
        "file:src/tools/calendar.ts:fn:handleGetTodaysEvents:268",
        "file:src/tools/calendar.ts:fn:handleGetEventsDueSoon:367",
        "file:src/tools/calendar.ts:fn:parseDateTime:466",
        "file:src/tools/calendar.ts:fn:handleCreateCalendarEvent:486"
      ],
      "classes": [],
      "topLevelReferences": [
        "handleGetUpcomingEvents",
        "handleGetTodaysEvents",
        "handleGetEventsDueSoon",
        "handleCreateCalendarEvent"
      ]
    },
    "file:src/tools/calendar.ts:fn:getTodayDateString:26": {
      "id": "file:src/tools/calendar.ts:fn:getTodayDateString:26",
      "type": "function",
      "name": "getTodayDateString",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 26,
      "endLine": 29,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns today's date as YYYY-MM-DD string using specified timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getTodayDateString(): string {\n  const now = new Date();\n  return now.toLocaleDateString('en-CA', { timeZone: config.timezone }); // en-CA gives YYYY-MM-DD\n}",
      "references": [
        "Date",
        "now",
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:getTomorrowDateString:34": {
      "id": "file:src/tools/calendar.ts:fn:getTomorrowDateString:34",
      "type": "function",
      "name": "getTomorrowDateString",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 34,
      "endLine": 37,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns tomorrow's date as a string in 'en-CA' format using config timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getTomorrowDateString(): string {\n  const tomorrow = new Date(Date.now() + 24 * 60 * 60 * 1000);\n  return tomorrow.toLocaleDateString('en-CA', { timeZone: config.timezone });\n}",
      "references": [
        "Date",
        "tomorrow",
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:getEventDateString:42": {
      "id": "file:src/tools/calendar.ts:fn:getEventDateString:42",
      "type": "function",
      "name": "getEventDateString",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 42,
      "endLine": 50,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "eventTime",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats event date to YYYY-MM-DD string: all-day in UTC, timed in user timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getEventDateString(eventTime: Date, allDay: boolean): string {\n  if (allDay) {\n    // All-day events are stored as midnight UTC on the date\n    // Use UTC date to avoid timezone shift issues\n    return eventTime.toISOString().substring(0, 10);\n  }\n  // For timed events, convert to user's timezone\n  return eventTime.toLocaleDateString('en-CA', { timeZone: config.timezone });\n}",
      "references": [
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:getDateLabel:56": {
      "id": "file:src/tools/calendar.ts:fn:getDateLabel:56",
      "type": "function",
      "name": "getDateLabel",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 56,
      "endLine": 86,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "eventTime",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns human-readable date label ('Today', 'Tomorrow', or formatted date) for an event.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDateLabel(eventTime: Date | null, allDay: boolean): string {\n  if (!eventTime) return 'Unknown date';\n\n  const eventDateStr = getEventDateString(eventTime, allDay);\n  const todayStr = getTodayDateString();\n  const tomorrowStr = getTomorrowDateString();\n\n  if (eventDateStr === todayStr) {\n    return 'Today';\n  } else if (eventDateStr === tomorrowStr) {\n    return 'Tomorrow';\n  } else {\n    // Return \"Wednesday, January 9\"\n    if (allDay) {\n      // Parse the UTC date string to avoid timezone issues\n      const [year, month, day] = eventDateStr.split('-').map(Number);\n      const date = new Date(year!, month! - 1, day!);\n      return date.toLocaleDateString('en-US', {\n        weekday: 'long',\n        month: 'long',\n        day: 'numeric',\n      });\n    }\n    return eventTime.toLocaleDateString('en-US', {\n      timeZone: config.timezone,\n      weekday: 'long',\n      month: 'long',\n      day: 'numeric',\n    });\n  }\n}",
      "references": [
        "getEventDateString",
        "getTodayDateString",
        "getTomorrowDateString",
        "eventDateStr",
        "todayStr",
        "tomorrowStr",
        "year",
        "month",
        "day",
        "Number",
        "Date",
        "date",
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:getLocalTime:92": {
      "id": "file:src/tools/calendar.ts:fn:getLocalTime:92",
      "type": "function",
      "name": "getLocalTime",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 92,
      "endLine": 100,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "eventTime",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats event time to local string in config timezone if not all-day event.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getLocalTime(eventTime: Date | null, allDay: boolean): string | null {\n  if (!eventTime || allDay) return null;\n  return eventTime.toLocaleTimeString('en-US', {\n    timeZone: config.timezone,\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZoneName: 'short',\n  });\n}",
      "references": [
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:getDayOfWeek:105": {
      "id": "file:src/tools/calendar.ts:fn:getDayOfWeek:105",
      "type": "function",
      "name": "getDayOfWeek",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 105,
      "endLine": 118,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "eventTime",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns long weekday name for event time, handling all-day events with UTC date.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDayOfWeek(eventTime: Date | null, allDay: boolean): string | null {\n  if (!eventTime) return null;\n  if (allDay) {\n    // Parse the UTC date string to avoid timezone issues\n    const dateStr = eventTime.toISOString().substring(0, 10);\n    const [year, month, day] = dateStr.split('-').map(Number);\n    const date = new Date(year!, month! - 1, day!);\n    return date.toLocaleDateString('en-US', { weekday: 'long' });\n  }\n  return eventTime.toLocaleDateString('en-US', {\n    timeZone: config.timezone,\n    weekday: 'long',\n  });\n}",
      "references": [
        "year",
        "month",
        "day",
        "dateStr",
        "Number",
        "Date",
        "date",
        "config"
      ]
    },
    "file:src/tools/calendar.ts:fn:formatEventTime:125": {
      "id": "file:src/tools/calendar.ts:fn:formatEventTime:125",
      "type": "function",
      "name": "formatEventTime",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 125,
      "endLine": 134,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "time",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats event Date to ISO string or YYYY-MM-DD for all-day events",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatEventTime(time: Date | null, allDay: boolean): string | null {\n  if (!time) return null;\n  if (allDay) {\n    // For all-day events, extract just the date portion\n    // The time is stored as midnight UTC, so we use UTC methods to get the correct date\n    const iso = time.toISOString();\n    return iso.substring(0, 10); // YYYY-MM-DD\n  }\n  return time.toISOString();\n}",
      "references": [
        "iso"
      ]
    },
    "file:src/tools/calendar.ts:fn:getCurrentContext:139": {
      "id": "file:src/tools/calendar.ts:fn:getCurrentContext:139",
      "type": "function",
      "name": "getCurrentContext",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 139,
      "endLine": 155,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ current_time: string; timezone: string; today_date: string; }",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns current context object with formatted time, timezone, and today's date string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCurrentContext() {\n  const now = new Date();\n  return {\n    current_time: now.toLocaleString('en-US', {\n      timeZone: config.timezone,\n      weekday: 'long',\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: '2-digit',\n      timeZoneName: 'short',\n    }),\n    timezone: config.timezone,\n    today_date: getTodayDateString(),\n  };\n}",
      "references": [
        "Date",
        "now",
        "config",
        "getTodayDateString"
      ]
    },
    "file:src/tools/calendar.ts:fn:handleGetUpcomingEvents:167": {
      "id": "file:src/tools/calendar.ts:fn:handleGetUpcomingEvents:167",
      "type": "function",
      "name": "handleGetUpcomingEvents",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 167,
      "endLine": 232,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "GetUpcomingEventsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches, limits, and formats upcoming Google Calendar events for the next N days.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleGetUpcomingEvents(args: GetUpcomingEventsArgs | null): Promise<string> {\n  const { days = 7, limit = 50 } = args ?? {};\n\n  try {\n    // Calculate date range\n    const now = new Date();\n    const endDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);\n\n    // Query actual Google Calendar events\n    const events = await getAllEvents({\n      timeMin: now,\n      timeMax: endDate,\n    });\n\n    // Apply limit\n    const limitedEvents = events.slice(0, limit);\n\n    const context = getCurrentContext();\n\n    if (limitedEvents.length === 0) {\n      return JSON.stringify({\n        message: `No calendar events in the next ${days} day(s)`,\n        ...context,\n        date_range: {\n          from: now.toISOString(),\n          to: endDate.toISOString(),\n        },\n        events: [],\n      });\n    }\n\n    // Format for LLM consumption with pre-computed date labels\n    const formatEvent = (e: GoogleEvent & { calendar_name?: string }) => ({\n      id: e.id,\n      title: e.summary,\n      description: e.description,\n      // Raw timestamps (for reference)\n      start_time: formatEventTime(e.start_time, e.all_day),\n      end_time: formatEventTime(e.end_time, e.all_day),\n      // PRE-COMPUTED LABELS - LLM should use these directly\n      date_label: getDateLabel(e.start_time, e.all_day),\n      time_local: getLocalTime(e.start_time, e.all_day),\n      day_of_week: getDayOfWeek(e.start_time, e.all_day),\n      all_day: e.all_day,\n      location: e.location,\n      status: e.status,\n      is_recurring: !!e.rrule || !!e.recurring_event_id,\n      calendar: e.calendar_name,\n    });\n\n    return JSON.stringify({\n      ...context,\n      date_range: {\n        from: now.toISOString(),\n        to: endDate.toISOString(),\n      },\n      count: limitedEvents.length,\n      // Instructions for LLM\n      usage_note: 'Use date_label and time_local fields when presenting events. These are pre-computed for the user\\'s timezone.',\n      events: limitedEvents.map(formatEvent),\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to get upcoming events: ${message}`, events: [] });\n  }\n}",
      "references": [
        "days",
        "limit",
        "Date",
        "now",
        "getAllEvents",
        "endDate",
        "events",
        "getCurrentContext",
        "limitedEvents",
        "JSON",
        "context",
        "e",
        "formatEventTime",
        "getDateLabel",
        "getLocalTime",
        "getDayOfWeek",
        "formatEvent",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/calendar.ts:fn:handleGetTodaysEvents:268": {
      "id": "file:src/tools/calendar.ts:fn:handleGetTodaysEvents:268",
      "type": "function",
      "name": "handleGetTodaysEvents",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 268,
      "endLine": 339,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "GetTodaysEventsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches, formats, and returns today's Google Calendar events as JSON string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleGetTodaysEvents(args: GetTodaysEventsArgs | null): Promise<string> {\n  // include_overdue not applicable for calendar events\n  void args;\n\n  try {\n    // Calculate today's range in the configured timezone\n    const now = new Date();\n    const todayStr = getTodayDateString();\n\n    // Parse today's date to get start/end of day in local timezone\n    const [year, month, day] = todayStr.split('-').map(Number);\n\n    // Create start/end of day - these will be in server's local time\n    // which should match config.timezone if server is configured correctly\n    const startOfDay = new Date(year!, month! - 1, day!, 0, 0, 0, 0);\n    const endOfDay = new Date(year!, month! - 1, day!, 23, 59, 59, 999);\n\n    // Get today's Google Calendar events\n    const events = await getAllEvents({\n      timeMin: startOfDay,\n      timeMax: endOfDay,\n    });\n\n    const context = getCurrentContext();\n\n    if (events.length === 0) {\n      return JSON.stringify({\n        message: 'No calendar events for today',\n        ...context,\n        events: [],\n      });\n    }\n\n    // Format for LLM consumption with pre-computed labels\n    const formatEvent = (e: GoogleEvent & { calendar_name?: string }) => {\n      const startTime = e.start_time ? new Date(e.start_time) : null;\n      const isPast = startTime && !e.all_day && startTime < now;\n\n      return {\n        id: e.id,\n        title: e.summary,\n        description: e.description,\n        // Raw timestamps\n        start_time: formatEventTime(e.start_time, e.all_day),\n        end_time: formatEventTime(e.end_time, e.all_day),\n        // PRE-COMPUTED LABELS\n        date_label: 'Today',\n        time_local: getLocalTime(e.start_time, e.all_day),\n        day_of_week: getDayOfWeek(e.start_time, e.all_day),\n        all_day: e.all_day,\n        location: e.location,\n        status: e.status,\n        is_past: isPast,\n        calendar: e.calendar_name,\n      };\n    };\n\n    const formattedEvents = events.map(formatEvent);\n    const upcomingCount = formattedEvents.filter((e) => !e.is_past).length;\n\n    return JSON.stringify({\n      ...context,\n      count: formattedEvents.length,\n      upcoming_count: upcomingCount,\n      usage_note: 'All events are for today. Use time_local field when presenting times.',\n      events: formattedEvents,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to get today's events: ${message}`, events: [] });\n  }\n}",
      "references": [
        "Date",
        "getTodayDateString",
        "year",
        "month",
        "day",
        "todayStr",
        "Number",
        "getAllEvents",
        "startOfDay",
        "endOfDay",
        "getCurrentContext",
        "events",
        "JSON",
        "context",
        "e",
        "startTime",
        "now",
        "formatEventTime",
        "getLocalTime",
        "getDayOfWeek",
        "isPast",
        "formatEvent",
        "formattedEvents",
        "upcomingCount",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/calendar.ts:fn:handleGetEventsDueSoon:367": {
      "id": "file:src/tools/calendar.ts:fn:handleGetEventsDueSoon:367",
      "type": "function",
      "name": "handleGetEventsDueSoon",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 367,
      "endLine": 429,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "GetEventsDueSoonArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches and formats Google Calendar events due within specified hours.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleGetEventsDueSoon(args: GetEventsDueSoonArgs | null): Promise<string> {\n  const { within_hours = 24 } = args ?? {};\n\n  try {\n    const now = new Date();\n    const endTime = new Date(now.getTime() + within_hours * 60 * 60 * 1000);\n\n    // Get Google Calendar events within the time window\n    const events = await getAllEvents({\n      timeMin: now,\n      timeMax: endTime,\n    });\n\n    const context = getCurrentContext();\n\n    if (events.length === 0) {\n      return JSON.stringify({\n        message: `No calendar events within the next ${within_hours} hour(s)`,\n        ...context,\n        within_hours,\n        events: [],\n      });\n    }\n\n    // Format for LLM consumption with pre-computed labels\n    const formattedEvents = events.map((e: GoogleEvent & { calendar_name?: string }) => {\n      const startTime = e.start_time ? new Date(e.start_time) : null;\n      // For all-day events, don't calculate minutes (not meaningful)\n      const minutesUntilStart = startTime && !e.all_day\n        ? Math.round((startTime.getTime() - now.getTime()) / (1000 * 60))\n        : null;\n\n      return {\n        id: e.id,\n        title: e.summary,\n        description: e.description,\n        // Raw timestamps\n        start_time: formatEventTime(e.start_time, e.all_day),\n        end_time: formatEventTime(e.end_time, e.all_day),\n        // PRE-COMPUTED LABELS\n        date_label: getDateLabel(e.start_time, e.all_day),\n        time_local: getLocalTime(e.start_time, e.all_day),\n        day_of_week: getDayOfWeek(e.start_time, e.all_day),\n        all_day: e.all_day,\n        location: e.location,\n        minutes_until_start: minutesUntilStart,\n        status: e.status,\n        calendar: e.calendar_name,\n      };\n    });\n\n    return JSON.stringify({\n      ...context,\n      count: formattedEvents.length,\n      within_hours,\n      usage_note: 'Use date_label and time_local fields when presenting events.',\n      events: formattedEvents,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to get events due soon: ${message}`, events: [] });\n  }\n}",
      "references": [
        "within_hours",
        "Date",
        "now",
        "getAllEvents",
        "endTime",
        "getCurrentContext",
        "events",
        "JSON",
        "context",
        "e",
        "startTime",
        "Math",
        "formatEventTime",
        "getDateLabel",
        "getLocalTime",
        "getDayOfWeek",
        "minutesUntilStart",
        "formattedEvents",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/calendar.ts:fn:parseDateTime:466": {
      "id": "file:src/tools/calendar.ts:fn:parseDateTime:466",
      "type": "function",
      "name": "parseDateTime",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 466,
      "endLine": 484,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Date",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses date string to Date, handling YYYY-MM-DD for all-day or ISO 8601.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.686Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function parseDateTime(input: string, allDay: boolean): Date {\n  // If all-day, just parse the date portion\n  if (allDay) {\n    // Handle YYYY-MM-DD format\n    const dateMatch = input.match(/^(\\d{4})-(\\d{2})-(\\d{2})/);\n    if (dateMatch) {\n      const [, year, month, day] = dateMatch;\n      return new Date(parseInt(year!, 10), parseInt(month!, 10) - 1, parseInt(day!, 10));\n    }\n  }\n\n  // Try parsing as ISO 8601 first\n  const date = new Date(input);\n  if (!isNaN(date.getTime())) {\n    return date;\n  }\n\n  throw new Error(`Unable to parse date/time: ${input}`);\n}",
      "references": [
        "dateMatch",
        "year",
        "month",
        "day",
        "Date",
        "parseInt",
        "isNaN",
        "date",
        "Error"
      ]
    },
    "file:src/tools/calendar.ts:fn:handleCreateCalendarEvent:486": {
      "id": "file:src/tools/calendar.ts:fn:handleCreateCalendarEvent:486",
      "type": "function",
      "name": "handleCreateCalendarEvent",
      "filePath": "/home/ridgetop/projects/squire/src/tools/calendar.ts",
      "line": 486,
      "endLine": 578,
      "parentFileId": "file:src/tools/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "CreateCalendarEventArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates Google Calendar event via default push calendar after validation.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleCreateCalendarEvent(args: CreateCalendarEventArgs): Promise<string> {\n  const {\n    title,\n    start_time,\n    duration_minutes = 60,\n    all_day = false,\n    description,\n    location\n  } = args;\n\n  if (!title || title.trim().length === 0) {\n    return JSON.stringify({ error: 'Title is required', event: null });\n  }\n\n  if (!start_time) {\n    return JSON.stringify({ error: 'Start time is required', event: null });\n  }\n\n  try {\n    // Get the first sync-enabled Google account\n    const accounts = await listSyncEnabledAccounts();\n    if (accounts.length === 0) {\n      return JSON.stringify({\n        error: 'No Google account connected. Please connect a Google account first.',\n        event: null\n      });\n    }\n    const account = accounts[0]!;\n\n    // Get the default calendar for pushing events\n    const calendar = await getDefaultPushCalendar(account.id);\n    if (!calendar) {\n      return JSON.stringify({\n        error: 'No calendar available for creating events. Please configure a default calendar.',\n        event: null\n      });\n    }\n\n    // Check if calendar supports writes\n    if (calendar.sync_direction === 'read_only') {\n      return JSON.stringify({\n        error: `Calendar \"${calendar.summary}\" is read-only. Please configure a writable calendar.`,\n        event: null\n      });\n    }\n\n    // Parse the start time\n    let startDate: Date;\n    try {\n      startDate = parseDateTime(start_time, all_day);\n    } catch (parseError) {\n      return JSON.stringify({\n        error: `Invalid start_time format: ${start_time}. Use ISO 8601 format (e.g., \"2026-01-09T08:00:00\" or \"2026-01-09\" for all-day).`,\n        event: null\n      });\n    }\n\n    // Create the event in Google Calendar\n    // Note: Not linking to a commitment - this is a standalone calendar event\n    const result = await pushEventToGoogle(calendar, {\n      title: title.trim(),\n      description: description?.trim(),\n      due_at: startDate,\n      duration_minutes: all_day ? 24 * 60 : duration_minutes, // All-day = 24 hours\n      all_day,\n      timezone: config.timezone,\n    });\n\n    // Calculate end time for response\n    const endDate = new Date(startDate.getTime() + (all_day ? 24 * 60 : duration_minutes) * 60 * 1000);\n\n    return JSON.stringify({\n      message: `Event \"${title}\" created successfully in \"${calendar.summary}\"`,\n      event: {\n        id: result.event_id,\n        title: title.trim(),\n        description: description?.trim() || null,\n        location: location || null,\n        start_time: all_day ? startDate.toISOString().split('T')[0] : startDate.toISOString(),\n        end_time: all_day ? endDate.toISOString().split('T')[0] : endDate.toISOString(),\n        // Include pre-computed labels for confirmation\n        date_label: getDateLabel(startDate, all_day),\n        time_local: getLocalTime(startDate, all_day),\n        all_day,\n        calendar: calendar.summary,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    console.error('[CreateCalendarEvent] Error:', error);\n    return JSON.stringify({ error: `Failed to create calendar event: ${message}`, event: null });\n  }\n}",
      "references": [
        "title",
        "start_time",
        "duration_minutes",
        "all_day",
        "description",
        "location",
        "JSON",
        "listSyncEnabledAccounts",
        "accounts",
        "getDefaultPushCalendar",
        "account",
        "calendar",
        "startDate",
        "parseDateTime",
        "pushEventToGoogle",
        "config",
        "Date",
        "result",
        "endDate",
        "getDateLabel",
        "getLocalTime",
        "error",
        "Error",
        "String",
        "console",
        "message"
      ]
    },
    "file:src/tools/commitments.ts": {
      "id": "file:src/tools/commitments.ts",
      "type": "file",
      "name": "commitments.ts",
      "filePath": "src/tools/commitments.ts",
      "line": 1,
      "endLine": 399,
      "imports": [
        {
          "source": "../services/commitments.js",
          "items": [
            {
              "name": "listCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "resolveCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findMatchingCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Commitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ResolutionType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../services/reminders.js",
          "items": [
            {
              "name": "listReminders",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markReminderAcknowledged",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Reminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "listOpenCommitmentsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listOpenCommitmentsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listOpenCommitmentsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listOpenCommitmentsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "completeCommitmentToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "completeCommitmentToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "completeCommitmentToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "completeCommitmentToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/tools/commitments.ts:fn:findMatchingReminders:34",
        "file:src/tools/commitments.ts:fn:formatCommitment:90",
        "file:src/tools/commitments.ts:fn:handleListOpenCommitments:123",
        "file:src/tools/commitments.ts:fn:handleCompleteCommitment:222"
      ],
      "classes": [],
      "topLevelReferences": [
        "handleListOpenCommitments",
        "handleCompleteCommitment"
      ]
    },
    "file:src/tools/commitments.ts:fn:findMatchingReminders:34": {
      "id": "file:src/tools/commitments.ts:fn:findMatchingReminders:34",
      "type": "function",
      "name": "findMatchingReminders",
      "filePath": "/home/ridgetop/projects/squire/src/tools/commitments.ts",
      "line": 34,
      "endLine": 84,
      "parentFileId": "file:src/tools/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSimilarity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<ReminderMatch[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches reminders by text match or vector embedding similarity.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function findMatchingReminders(\n  text: string,\n  options: { limit?: number; minSimilarity?: number } = {}\n): Promise<ReminderMatch[]> {\n  const { limit = 5, minSimilarity = 0.4 } = options;\n\n  // Search reminders by text similarity (no embedding on reminders, use text search)\n  // First try exact/partial match\n  const textResult = await pool.query<Reminder>(\n    `SELECT * FROM reminders\n     WHERE status IN ('pending', 'sent')\n       AND (title ILIKE $1 OR title ILIKE $2)\n     ORDER BY scheduled_for DESC\n     LIMIT $3`,\n    [`%${text}%`, `%${text.split(' ').join('%')}%`, limit]\n  );\n\n  if (textResult.rows.length > 0) {\n    return textResult.rows.map((r) => ({\n      reminder: r,\n      similarity: 0.7, // Text match gets decent similarity\n    }));\n  }\n\n  // Fall back to embedding search if we have the embedding column\n  try {\n    const embedding = await generateEmbedding(text);\n    const embeddingStr = `[${embedding.join(',')}]`;\n\n    // Check if reminders have embeddings (they might not)\n    const result = await pool.query<Reminder & { similarity: number }>(\n      `SELECT r.*,\n              1 - (r.embedding <=> $1::vector) as similarity\n       FROM reminders r\n       WHERE r.status IN ('pending', 'sent')\n         AND r.embedding IS NOT NULL\n         AND 1 - (r.embedding <=> $1::vector) >= $2\n       ORDER BY similarity DESC\n       LIMIT $3`,\n      [embeddingStr, minSimilarity, limit]\n    );\n\n    return result.rows.map((r) => ({\n      reminder: r,\n      similarity: r.similarity,\n    }));\n  } catch {\n    // Embedding search failed, return empty\n    return [];\n  }\n}",
      "references": [
        "limit",
        "minSimilarity",
        "pool",
        "textResult",
        "r",
        "generateEmbedding",
        "embedding",
        "embeddingStr",
        "result"
      ]
    },
    "file:src/tools/commitments.ts:fn:formatCommitment:90": {
      "id": "file:src/tools/commitments.ts:fn:formatCommitment:90",
      "type": "function",
      "name": "formatCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/tools/commitments.ts",
      "line": 90,
      "endLine": 112,
      "parentFileId": "file:src/tools/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "c",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").Commitment",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ id: string; title: string; description: string; status: import(\"/home/ridgetop/projects/squire/src/services/commitments\").CommitmentStatus; due_at: string; due_label: string; is_overdue: boolean; tags: string[]; }",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats Commitment object with formatted due date label and overdue status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatCommitment(c: Commitment) {\n  const dueLabel = c.due_at\n    ? c.due_at.toLocaleDateString('en-US', {\n        timeZone: config.timezone,\n        weekday: 'short',\n        month: 'short',\n        day: 'numeric',\n      })\n    : 'No due date';\n\n  const isOverdue = c.due_at && new Date(c.due_at) < new Date();\n\n  return {\n    id: c.id,\n    title: c.title,\n    description: c.description,\n    status: c.status,\n    due_at: c.due_at?.toISOString() ?? null,\n    due_label: dueLabel,\n    is_overdue: isOverdue,\n    tags: c.tags,\n  };\n}",
      "references": [
        "config",
        "Date",
        "dueLabel",
        "isOverdue"
      ]
    },
    "file:src/tools/commitments.ts:fn:handleListOpenCommitments:123": {
      "id": "file:src/tools/commitments.ts:fn:handleListOpenCommitments:123",
      "type": "function",
      "name": "handleListOpenCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/tools/commitments.ts",
      "line": 123,
      "endLine": 188,
      "parentFileId": "file:src/tools/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "ListOpenCommitmentsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Lists open commitments and pending/sent reminders, formats them, and returns JSON summary.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleListOpenCommitments(args: ListOpenCommitmentsArgs | null): Promise<string> {\n  const { limit = 20 } = args ?? {};\n\n  try {\n    // Get open commitments\n    const commitments = await listCommitments({\n      status: ['open', 'in_progress'],\n      limit,\n    });\n\n    // Get pending/sent reminders\n    const reminders = await listReminders({\n      status: ['pending', 'sent'],\n      limit,\n    });\n\n    const formattedCommitments = commitments.map((c) => ({\n      ...formatCommitment(c),\n      type: 'commitment',\n    }));\n\n    const formattedReminders = reminders.map((r) => ({\n      id: r.id,\n      title: r.title ?? 'Untitled reminder',\n      description: r.body,\n      status: r.status,\n      due_at: r.scheduled_for?.toISOString() ?? null,\n      due_label: r.scheduled_for\n        ? r.scheduled_for.toLocaleDateString('en-US', {\n            timeZone: config.timezone,\n            weekday: 'short',\n            month: 'short',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: '2-digit',\n          })\n        : 'No time set',\n      is_overdue: r.scheduled_for && new Date(r.scheduled_for) < new Date(),\n      type: 'reminder',\n    }));\n\n    const allItems = [...formattedCommitments, ...formattedReminders];\n\n    if (allItems.length === 0) {\n      return JSON.stringify({\n        message: 'No open commitments, tasks, or reminders',\n        count: 0,\n        items: [],\n      });\n    }\n\n    const overdueCount = allItems.filter((c) => c.is_overdue).length;\n\n    return JSON.stringify({\n      count: allItems.length,\n      commitment_count: formattedCommitments.length,\n      reminder_count: formattedReminders.length,\n      overdue_count: overdueCount,\n      usage_note: 'Use complete_commitment with id or title_match to mark items done. Works for both commitments and reminders.',\n      items: allItems,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to list items: ${message}`, items: [] });\n  }\n}",
      "references": [
        "limit",
        "listCommitments",
        "listReminders",
        "commitments",
        "formatCommitment",
        "c",
        "reminders",
        "r",
        "config",
        "Date",
        "formattedCommitments",
        "formattedReminders",
        "allItems",
        "JSON",
        "overdueCount",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/commitments.ts:fn:handleCompleteCommitment:222": {
      "id": "file:src/tools/commitments.ts:fn:handleCompleteCommitment:222",
      "type": "function",
      "name": "handleCompleteCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/tools/commitments.ts",
      "line": 222,
      "endLine": 371,
      "parentFileId": "file:src/tools/commitments.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "CompleteCommitmentArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Completes commitment by ID or fuzzy title match via DB searches",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleCompleteCommitment(args: CompleteCommitmentArgs | null): Promise<string> {\n  const { commitment_id, title_match, resolution_type = 'completed' } = args ?? {};\n\n  if (!commitment_id && !title_match) {\n    return JSON.stringify({\n      error: 'Either commitment_id or title_match is required',\n      resolved: null,\n    });\n  }\n\n  try {\n    let targetId: string | null = null;\n    let targetType: 'commitment' | 'reminder' = 'commitment';\n\n    // If we have a direct ID, try commitment first, then reminder\n    if (commitment_id) {\n      targetId = commitment_id;\n      // We'll try commitment first in the resolution step\n    } else if (title_match) {\n      // Search commitments first\n      const commitmentMatches = await findMatchingCommitments(title_match, {\n        limit: 3,\n        minSimilarity: 0.4,\n      });\n\n      // Also search reminders\n      const reminderMatches = await findMatchingReminders(title_match, {\n        limit: 3,\n        minSimilarity: 0.4,\n      });\n\n      // Combine and sort by similarity\n      type Match = { id: string; title: string; similarity: number; type: 'commitment' | 'reminder' };\n      const allMatches: Match[] = [\n        ...commitmentMatches.map((m) => ({\n          id: m.id,\n          title: m.title,\n          similarity: m.similarity,\n          type: 'commitment' as const,\n        })),\n        ...reminderMatches.map((m) => ({\n          id: m.reminder.id,\n          title: m.reminder.title ?? 'Untitled reminder',\n          similarity: m.similarity,\n          type: 'reminder' as const,\n        })),\n      ].sort((a, b) => b.similarity - a.similarity);\n\n      if (allMatches.length === 0) {\n        return JSON.stringify({\n          error: `No open commitment or reminder found matching \"${title_match}\"`,\n          resolved: null,\n          suggestion: 'Use list_open_commitments to see all open items',\n        });\n      }\n\n      const bestMatch = allMatches[0]!;\n      const secondMatch = allMatches[1];\n\n      // Use best match if it's clearly the winner\n      const isClearWinner =\n        allMatches.length === 1 ||\n        bestMatch.similarity >= 0.6 ||\n        (secondMatch && bestMatch.similarity - secondMatch.similarity >= 0.15);\n\n      if (!isClearWinner && allMatches.length > 1) {\n        return JSON.stringify({\n          error: 'Multiple similar items found. Which one did you mean?',\n          matches: allMatches.slice(0, 5).map((m) => ({\n            id: m.id,\n            title: m.title,\n            type: m.type,\n            similarity: Math.round(m.similarity * 100) + '%',\n          })),\n          resolved: null,\n        });\n      }\n\n      targetId = bestMatch.id;\n      targetType = bestMatch.type;\n    }\n\n    if (!targetId) {\n      return JSON.stringify({\n        error: 'Could not determine which item to complete',\n        resolved: null,\n      });\n    }\n\n    // Try to resolve based on type\n    if (targetType === 'reminder' || commitment_id) {\n      // If it's a reminder OR we have a direct ID (try both)\n      if (targetType === 'reminder') {\n        const reminder = await markReminderAcknowledged(targetId);\n        if (reminder) {\n          return JSON.stringify({\n            message: `Marked reminder \"${reminder.title}\" as done`,\n            resolved: {\n              id: reminder.id,\n              title: reminder.title,\n              type: 'reminder',\n              status: 'acknowledged',\n            },\n          });\n        }\n      }\n    }\n\n    // Try commitment resolution\n    const resolved = await resolveCommitment(targetId, {\n      resolution_type,\n    });\n\n    if (resolved) {\n      return JSON.stringify({\n        message: `Marked \"${resolved.title}\" as ${resolution_type}`,\n        resolved: {\n          id: resolved.id,\n          title: resolved.title,\n          type: 'commitment',\n          status: resolved.status,\n          resolution_type: resolved.resolution_type,\n          resolved_at: resolved.resolved_at?.toISOString(),\n        },\n      });\n    }\n\n    // Last resort: try as reminder if commitment failed\n    const reminder = await markReminderAcknowledged(targetId);\n    if (reminder) {\n      return JSON.stringify({\n        message: `Marked reminder \"${reminder.title}\" as done`,\n        resolved: {\n          id: reminder.id,\n          title: reminder.title,\n          type: 'reminder',\n          status: 'acknowledged',\n        },\n      });\n    }\n\n    return JSON.stringify({\n      error: `Item ${targetId} not found or already completed`,\n      resolved: null,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to complete item: ${message}`, resolved: null });\n  }\n}",
      "references": [
        "commitment_id",
        "title_match",
        "resolution_type",
        "JSON",
        "targetId",
        "findMatchingCommitments",
        "findMatchingReminders",
        "commitmentMatches",
        "m",
        "reminderMatches",
        "b",
        "a",
        "allMatches",
        "bestMatch",
        "secondMatch",
        "isClearWinner",
        "Math",
        "targetType",
        "markReminderAcknowledged",
        "reminder",
        "resolveCommitment",
        "resolved",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/index.ts": {
      "id": "file:src/tools/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/tools/index.ts",
      "line": 1,
      "endLine": 272,
      "imports": [
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolDefinition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolCall",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "RegisteredTool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./time.js",
          "items": [
            {
              "name": "timeToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "timeToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "timeToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "timeToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./notes.js",
          "items": [
            {
              "name": "searchNotesToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchNotesToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchNotesToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchNotesToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotesToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotesToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotesToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotesToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listRecentNotesToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listRecentNotesToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listRecentNotesToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listRecentNotesToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNoteToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNoteToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNoteToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNoteToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "appendToNoteToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "appendToNoteToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "appendToNoteToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "appendToNoteToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./lists.js",
          "items": [
            {
              "name": "searchListsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchListsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchListsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchListsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListItemsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListItemsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListItemsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListItemsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listAllListsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listAllListsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listAllListsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listAllListsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createListToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createListToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createListToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createListToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addListItemToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addListItemToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addListItemToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addListItemToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleListItemToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleListItemToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleListItemToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleListItemToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./calendar.js",
          "items": [
            {
              "name": "getUpcomingEventsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUpcomingEventsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUpcomingEventsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUpcomingEventsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getTodaysEventsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getTodaysEventsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getTodaysEventsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getTodaysEventsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEventsDueSoonToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEventsDueSoonToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEventsDueSoonToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEventsDueSoonToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCalendarEventToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCalendarEventToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCalendarEventToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCalendarEventToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./commitments.js",
          "items": [
            {
              "name": "listOpenCommitmentsToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listOpenCommitmentsToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listOpenCommitmentsToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listOpenCommitmentsToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeCommitmentToolName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeCommitmentToolDescription",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeCommitmentToolParameters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeCommitmentToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "registerTool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getToolDefinitions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "hasTools",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getToolCount",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "executeTool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "executeTools",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ToolDefinition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolCall",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "RegisteredTool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AssistantMessageWithTools",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolDefinition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "ToolCall",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "ToolResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "ToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "RegisteredTool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "ToolMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "AssistantMessageWithTools",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./types.js"
        }
      ],
      "functions": [
        "file:src/tools/index.ts:fn:registerTool:39",
        "file:src/tools/index.ts:fn:getToolDefinitions:67",
        "file:src/tools/index.ts:fn:hasTools:74",
        "file:src/tools/index.ts:fn:getToolCount:81",
        "file:src/tools/index.ts:fn:executeTool:93",
        "file:src/tools/index.ts:fn:executeTools:147"
      ],
      "classes": [],
      "topLevelReferences": [
        "Map",
        "registerTool"
      ]
    },
    "file:src/tools/index.ts:fn:registerTool:39": {
      "id": "file:src/tools/index.ts:fn:registerTool:39",
      "type": "function",
      "name": "registerTool",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 39,
      "endLine": 62,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "name",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "description",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "parameters",
          "type": "Record<string, unknown>",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "handler",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolHandler<T>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Registers a tool with name, description, parameters, and handler in global 'tools' map, overwriting if exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function registerTool<T = unknown>(\n  name: string,\n  description: string,\n  parameters: Record<string, unknown>,\n  handler: ToolHandler<T>\n): void {\n  if (tools.has(name)) {\n    console.warn(`Tool '${name}' is already registered. Overwriting.`);\n  }\n\n  tools.set(name, {\n    definition: {\n      type: 'function',\n      function: {\n        name,\n        description,\n        parameters,\n      },\n    },\n    handler: handler as ToolHandler,\n  });\n\n  console.log(`Tool registered: ${name}`);\n}",
      "references": [
        "tools",
        "console"
      ]
    },
    "file:src/tools/index.ts:fn:getToolDefinitions:67": {
      "id": "file:src/tools/index.ts:fn:getToolDefinitions:67",
      "type": "function",
      "name": "getToolDefinitions",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 67,
      "endLine": 69,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolDefinition[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns array of tool definitions from the 'tools' collection.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getToolDefinitions(): ToolDefinition[] {\n  return Array.from(tools.values()).map((t) => t.definition);\n}",
      "references": [
        "Array",
        "tools",
        "t"
      ]
    },
    "file:src/tools/index.ts:fn:hasTools:74": {
      "id": "file:src/tools/index.ts:fn:hasTools:74",
      "type": "function",
      "name": "hasTools",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 74,
      "endLine": 76,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if tools collection has any items by comparing size to 0.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function hasTools(): boolean {\n  return tools.size > 0;\n}",
      "references": [
        "tools"
      ]
    },
    "file:src/tools/index.ts:fn:getToolCount:81": {
      "id": "file:src/tools/index.ts:fn:getToolCount:81",
      "type": "function",
      "name": "getToolCount",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 81,
      "endLine": 83,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "number",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the size of the global tools collection.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getToolCount(): number {\n  return tools.size;\n}",
      "references": [
        "tools"
      ]
    },
    "file:src/tools/index.ts:fn:executeTool:93": {
      "id": "file:src/tools/index.ts:fn:executeTool:93",
      "type": "function",
      "name": "executeTool",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 93,
      "endLine": 139,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "call",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolCall",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Executes tool handler with parsed JSON args from ToolCall, handles errors.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function executeTool(call: ToolCall): Promise<ToolResult> {\n  const tool = tools.get(call.function.name);\n\n  if (!tool) {\n    return {\n      toolCallId: call.id,\n      name: call.function.name,\n      result: `Error: Unknown tool '${call.function.name}'`,\n      success: false,\n    };\n  }\n\n  try {\n    // Parse arguments from JSON string\n    let args: unknown = {};\n    if (call.function.arguments) {\n      try {\n        args = JSON.parse(call.function.arguments);\n      } catch {\n        return {\n          toolCallId: call.id,\n          name: call.function.name,\n          result: `Error: Invalid JSON arguments: ${call.function.arguments}`,\n          success: false,\n        };\n      }\n    }\n\n    // Execute handler\n    const result = await tool.handler(args);\n\n    return {\n      toolCallId: call.id,\n      name: call.function.name,\n      result,\n      success: true,\n    };\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return {\n      toolCallId: call.id,\n      name: call.function.name,\n      result: `Error executing tool: ${message}`,\n      success: false,\n    };\n  }\n}",
      "references": [
        "tools",
        "tool",
        "args",
        "JSON",
        "result",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/index.ts:fn:executeTools:147": {
      "id": "file:src/tools/index.ts:fn:executeTools:147",
      "type": "function",
      "name": "executeTools",
      "filePath": "/home/ridgetop/projects/squire/src/tools/index.ts",
      "line": 147,
      "endLine": 149,
      "parentFileId": "file:src/tools/index.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calls",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolCall[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolResult[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Executes multiple tool calls in parallel via Promise.all and returns results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function executeTools(calls: ToolCall[]): Promise<ToolResult[]> {\n  return Promise.all(calls.map(executeTool));\n}",
      "references": [
        "Promise",
        "executeTool"
      ]
    },
    "file:src/tools/lists.ts": {
      "id": "file:src/tools/lists.ts",
      "type": "file",
      "name": "lists.ts",
      "filePath": "src/tools/lists.ts",
      "line": 1,
      "endLine": 577,
      "imports": [
        {
          "source": "../services/lists.js",
          "items": [
            {
              "name": "listLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findListByName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCompletionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "searchListsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchListsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchListsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchListsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getListItemsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getListItemsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getListItemsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getListItemsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listAllListsToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listAllListsToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listAllListsToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listAllListsToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createListToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createListToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createListToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createListToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "addListItemToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "addListItemToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "addListItemToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "addListItemToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "toggleListItemToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "toggleListItemToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "toggleListItemToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "toggleListItemToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/tools/lists.ts:fn:handleSearchLists:28",
        "file:src/tools/lists.ts:fn:handleGetListItems:99",
        "file:src/tools/lists.ts:fn:handleListAllLists:200",
        "file:src/tools/lists.ts:fn:handleCreateList:276",
        "file:src/tools/lists.ts:fn:handleAddListItem:381",
        "file:src/tools/lists.ts:fn:handleToggleListItem:475"
      ],
      "classes": [],
      "topLevelReferences": [
        "handleSearchLists",
        "handleGetListItems",
        "handleListAllLists",
        "handleCreateList",
        "handleAddListItem",
        "handleToggleListItem"
      ]
    },
    "file:src/tools/lists.ts:fn:handleSearchLists:28": {
      "id": "file:src/tools/lists.ts:fn:handleSearchLists:28",
      "type": "function",
      "name": "handleSearchLists",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 28,
      "endLine": 66,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "SearchListsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches lists by query, formats results, and returns JSON (error if invalid query).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleSearchLists(args: SearchListsArgs): Promise<string> {\n  const { query, limit = 10 } = args;\n\n  if (!query || query.trim().length === 0) {\n    return JSON.stringify({ error: 'Query is required', lists: [] });\n  }\n\n  try {\n    const lists = await searchLists(query, limit);\n\n    if (lists.length === 0) {\n      return JSON.stringify({\n        message: `No lists found matching \"${query}\"`,\n        lists: [],\n      });\n    }\n\n    // Format lists for LLM consumption\n    const formattedLists = lists.map((list) => ({\n      id: list.id,\n      name: list.name,\n      description: list.description,\n      list_type: list.list_type,\n      category: list.category,\n      tags: list.tags,\n      is_pinned: list.is_pinned,\n      created_at: list.created_at,\n      similarity: Math.round(list.similarity * 100) / 100,\n    }));\n\n    return JSON.stringify({\n      count: lists.length,\n      lists: formattedLists,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to search lists: ${message}`, lists: [] });\n  }\n}",
      "references": [
        "query",
        "limit",
        "JSON",
        "searchLists",
        "lists",
        "list",
        "Math",
        "formattedLists",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/lists.ts:fn:handleGetListItems:99": {
      "id": "file:src/tools/lists.ts:fn:handleGetListItems:99",
      "type": "function",
      "name": "handleGetListItems",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 99,
      "endLine": 166,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "GetListItemsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves list items by ID or name with stats, formats, returns JSON",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleGetListItems(args: GetListItemsArgs): Promise<string> {\n  const { name, id } = args;\n\n  if (!name && !id) {\n    return JSON.stringify({ error: 'Either name or id is required', list: null });\n  }\n\n  try {\n    let list;\n\n    if (id) {\n      // Direct ID lookup\n      list = await getListWithItems(id);\n    } else if (name) {\n      // Find by name (supports fuzzy matching)\n      const foundList = await findListByName(name);\n      if (foundList) {\n        list = await getListWithItems(foundList.id);\n      }\n    }\n\n    if (!list) {\n      return JSON.stringify({\n        message: id ? `List with ID \"${id}\" not found` : `List \"${name}\" not found`,\n        list: null,\n      });\n    }\n\n    // Get completion stats for checklists\n    let stats = null;\n    if (list.list_type === 'checklist') {\n      stats = await getCompletionStats(list.id);\n    }\n\n    // Format items for LLM consumption\n    const formattedItems = list.items\n      .filter((item) => !item.archived_at) // Exclude archived items\n      .map((item) => ({\n        id: item.id,\n        content: item.content,\n        notes: item.notes,\n        is_completed: item.is_completed,\n        completed_at: item.completed_at,\n        priority: item.priority,\n        due_at: item.due_at,\n        sort_order: item.sort_order,\n      }));\n\n    return JSON.stringify({\n      list: {\n        id: list.id,\n        name: list.name,\n        description: list.description,\n        list_type: list.list_type,\n        category: list.category,\n        tags: list.tags,\n        is_pinned: list.is_pinned,\n        created_at: list.created_at,\n        item_count: formattedItems.length,\n        completion_stats: stats,\n      },\n      items: formattedItems,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to get list items: ${message}`, list: null });\n  }\n}",
      "references": [
        "name",
        "id",
        "JSON",
        "list",
        "getListWithItems",
        "findListByName",
        "foundList",
        "stats",
        "getCompletionStats",
        "item",
        "formattedItems",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/lists.ts:fn:handleListAllLists:200": {
      "id": "file:src/tools/lists.ts:fn:handleListAllLists:200",
      "type": "function",
      "name": "handleListAllLists",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 200,
      "endLine": 233,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "ListAllListsArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves and formats lists from storage with optional filters, returns JSON.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleListAllLists(args: ListAllListsArgs | null): Promise<string> {\n  const { limit = 20, list_type, category } = args ?? {};\n\n  try {\n    const lists = await listLists({ limit, list_type, category });\n\n    if (lists.length === 0) {\n      return JSON.stringify({\n        message: 'No lists found',\n        lists: [],\n      });\n    }\n\n    // Format lists for LLM consumption\n    const formattedLists = lists.map((list) => ({\n      id: list.id,\n      name: list.name,\n      description: list.description,\n      list_type: list.list_type,\n      category: list.category,\n      tags: list.tags,\n      is_pinned: list.is_pinned,\n      created_at: list.created_at,\n    }));\n\n    return JSON.stringify({\n      count: lists.length,\n      lists: formattedLists,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to list all lists: ${message}`, lists: [] });\n  }\n}",
      "references": [
        "limit",
        "list_type",
        "category",
        "listLists",
        "lists",
        "JSON",
        "list",
        "formattedLists",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/lists.ts:fn:handleCreateList:276": {
      "id": "file:src/tools/lists.ts:fn:handleCreateList:276",
      "type": "function",
      "name": "handleCreateList",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 276,
      "endLine": 322,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "CreateListArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a list with optional items via DB ops, returns JSON success/error response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleCreateList(args: CreateListArgs): Promise<string> {\n  const { name, description, list_type = 'checklist', category, tags, is_pinned, items } = args;\n\n  if (!name || name.trim().length === 0) {\n    return JSON.stringify({ error: 'List name is required', list: null });\n  }\n\n  try {\n    const list = await createList({\n      name: name.trim(),\n      description: description?.trim(),\n      list_type,\n      category: category?.trim(),\n      tags,\n      is_pinned,\n    });\n\n    // Add initial items if provided\n    const addedItems: Array<{ id: string; content: string }> = [];\n    if (items && items.length > 0) {\n      for (const itemContent of items) {\n        if (itemContent && itemContent.trim()) {\n          const item = await addItem(list.id, { content: itemContent.trim() });\n          addedItems.push({ id: item.id, content: item.content });\n        }\n      }\n    }\n\n    return JSON.stringify({\n      message: `List \"${list.name}\" created successfully${addedItems.length > 0 ? ` with ${addedItems.length} items` : ''}`,\n      list: {\n        id: list.id,\n        name: list.name,\n        description: list.description,\n        list_type: list.list_type,\n        category: list.category,\n        tags: list.tags,\n        is_pinned: list.is_pinned,\n        created_at: list.created_at,\n        items: addedItems,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to create list: ${message}`, list: null });\n  }\n}",
      "references": [
        "name",
        "description",
        "list_type",
        "category",
        "tags",
        "is_pinned",
        "items",
        "JSON",
        "createList",
        "itemContent",
        "addItem",
        "list",
        "addedItems",
        "item",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/lists.ts:fn:handleAddListItem:381": {
      "id": "file:src/tools/lists.ts:fn:handleAddListItem:381",
      "type": "function",
      "name": "handleAddListItem",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 381,
      "endLine": 428,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "AddListItemArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Adds item to list by ID or name (finding list if needed) and returns JSON response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleAddListItem(args: AddListItemArgs): Promise<string> {\n  const { list_name, list_id, content, notes, priority } = args;\n\n  if (!list_name && !list_id) {\n    return JSON.stringify({ error: 'Either list_name or list_id is required', item: null });\n  }\n\n  if (!content || content.trim().length === 0) {\n    return JSON.stringify({ error: 'Item content is required', item: null });\n  }\n\n  try {\n    let listId = list_id;\n\n    // Find list by name if not provided by ID\n    if (!listId && list_name) {\n      const foundList = await findListByName(list_name);\n      if (!foundList) {\n        return JSON.stringify({\n          error: `List \"${list_name}\" not found. Use create_list to create it first, or check the name with list_all_lists.`,\n          item: null,\n        });\n      }\n      listId = foundList.id;\n    }\n\n    const item = await addItem(listId!, {\n      content: content.trim(),\n      notes: notes?.trim(),\n      priority,\n    });\n\n    return JSON.stringify({\n      message: `Item added to list successfully`,\n      item: {\n        id: item.id,\n        content: item.content,\n        notes: item.notes,\n        is_completed: item.is_completed,\n        priority: item.priority,\n        created_at: item.created_at,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to add item: ${message}`, item: null });\n  }\n}",
      "references": [
        "list_name",
        "list_id",
        "content",
        "notes",
        "priority",
        "JSON",
        "listId",
        "findListByName",
        "foundList",
        "addItem",
        "item",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/lists.ts:fn:handleToggleListItem:475": {
      "id": "file:src/tools/lists.ts:fn:handleToggleListItem:475",
      "type": "function",
      "name": "handleToggleListItem",
      "filePath": "/home/ridgetop/projects/squire/src/tools/lists.ts",
      "line": 475,
      "endLine": 546,
      "parentFileId": "file:src/tools/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "ToggleListItemArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Toggles list item completion by ID or searches list by content to toggle.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleToggleListItem(args: ToggleListItemArgs): Promise<string> {\n  const { list_name, list_id, item_content, item_id } = args;\n\n  // Need either item_id directly, or list + item_content to find it\n  if (!item_id && (!item_content || (!list_name && !list_id))) {\n    return JSON.stringify({\n      error: 'Either provide item_id, OR provide item_content with list_name/list_id to find the item',\n      item: null,\n    });\n  }\n\n  try {\n    let targetItemId = item_id;\n\n    // If no item_id, find the item by searching the list\n    if (!targetItemId) {\n      let listId = list_id;\n\n      // Find list by name if needed\n      if (!listId && list_name) {\n        const foundList = await findListByName(list_name);\n        if (!foundList) {\n          return JSON.stringify({ error: `List \"${list_name}\" not found`, item: null });\n        }\n        listId = foundList.id;\n      }\n\n      // Get list with items\n      const listWithItems = await getListWithItems(listId!);\n      if (!listWithItems) {\n        return JSON.stringify({ error: 'List not found', item: null });\n      }\n\n      // Find item by content (case-insensitive partial match)\n      const searchContent = item_content!.toLowerCase();\n      const matchingItem = listWithItems.items.find(\n        (item) => !item.archived_at && item.content.toLowerCase().includes(searchContent)\n      );\n\n      if (!matchingItem) {\n        return JSON.stringify({\n          error: `No item matching \"${item_content}\" found in list \"${listWithItems.name}\"`,\n          item: null,\n        });\n      }\n\n      targetItemId = matchingItem.id;\n    }\n\n    // Toggle the item\n    const updatedItem = await toggleItem(targetItemId);\n\n    if (!updatedItem) {\n      return JSON.stringify({ error: 'Failed to toggle item', item: null });\n    }\n\n    const statusText = updatedItem.is_completed ? 'completed' : 'marked incomplete';\n\n    return JSON.stringify({\n      message: `Item ${statusText}`,\n      item: {\n        id: updatedItem.id,\n        content: updatedItem.content,\n        is_completed: updatedItem.is_completed,\n        completed_at: updatedItem.completed_at,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to toggle item: ${message}`, item: null });\n  }\n}",
      "references": [
        "list_name",
        "list_id",
        "item_content",
        "item_id",
        "JSON",
        "targetItemId",
        "listId",
        "findListByName",
        "foundList",
        "getListWithItems",
        "listWithItems",
        "item",
        "searchContent",
        "matchingItem",
        "toggleItem",
        "updatedItem",
        "statusText",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/notes.ts": {
      "id": "file:src/tools/notes.ts",
      "type": "file",
      "name": "notes.ts",
      "filePath": "src/tools/notes.ts",
      "line": 1,
      "endLine": 378,
      "imports": [
        {
          "source": "../services/notes.js",
          "items": [
            {
              "name": "searchNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findNoteByTitle",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "searchNotesToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchNotesToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchNotesToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchNotesToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getPinnedNotesToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getPinnedNotesToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getPinnedNotesToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getPinnedNotesToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listRecentNotesToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listRecentNotesToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listRecentNotesToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "listRecentNotesToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createNoteToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createNoteToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createNoteToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "createNoteToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "appendToNoteToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "appendToNoteToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "appendToNoteToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "appendToNoteToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/tools/notes.ts:fn:handleSearchNotes:20",
        "file:src/tools/notes.ts:fn:handleGetPinnedNotes:93",
        "file:src/tools/notes.ts:fn:handleListRecentNotes:146",
        "file:src/tools/notes.ts:fn:handleCreateNote:214",
        "file:src/tools/notes.ts:fn:handleAppendToNote:295"
      ],
      "classes": [],
      "topLevelReferences": [
        "handleSearchNotes",
        "handleGetPinnedNotes",
        "handleListRecentNotes",
        "handleCreateNote",
        "handleAppendToNote"
      ]
    },
    "file:src/tools/notes.ts:fn:handleSearchNotes:20": {
      "id": "file:src/tools/notes.ts:fn:handleSearchNotes:20",
      "type": "function",
      "name": "handleSearchNotes",
      "filePath": "/home/ridgetop/projects/squire/src/tools/notes.ts",
      "line": 20,
      "endLine": 57,
      "parentFileId": "file:src/tools/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "SearchNotesArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches notes by query with optional limit/category, formats and returns JSON.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.687Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleSearchNotes(args: SearchNotesArgs): Promise<string> {\n  const { query, limit = 10, category } = args;\n\n  if (!query || query.trim().length === 0) {\n    return JSON.stringify({ error: 'Query is required', notes: [] });\n  }\n\n  try {\n    const notes = await searchNotes(query, { limit, category });\n\n    if (notes.length === 0) {\n      return JSON.stringify({\n        message: `No notes found matching \"${query}\"`,\n        notes: [],\n      });\n    }\n\n    // Format notes for LLM consumption\n    const formattedNotes = notes.map((note) => ({\n      id: note.id,\n      title: note.title,\n      content: note.content,\n      category: note.category,\n      tags: note.tags,\n      is_pinned: note.is_pinned,\n      created_at: note.created_at,\n      similarity: Math.round(note.similarity * 100) / 100,\n    }));\n\n    return JSON.stringify({\n      count: notes.length,\n      notes: formattedNotes,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to search notes: ${message}`, notes: [] });\n  }\n}",
      "references": [
        "query",
        "limit",
        "category",
        "JSON",
        "searchNotes",
        "notes",
        "note",
        "Math",
        "formattedNotes",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/notes.ts:fn:handleGetPinnedNotes:93": {
      "id": "file:src/tools/notes.ts:fn:handleGetPinnedNotes:93",
      "type": "function",
      "name": "handleGetPinnedNotes",
      "filePath": "/home/ridgetop/projects/squire/src/tools/notes.ts",
      "line": 93,
      "endLine": 122,
      "parentFileId": "file:src/tools/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "_args",
          "type": "GetPinnedNotesArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves pinned notes from storage, formats them, and returns as JSON string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleGetPinnedNotes(_args: GetPinnedNotesArgs | null): Promise<string> {\n  try {\n    const notes = await getPinnedNotes();\n\n    if (notes.length === 0) {\n      return JSON.stringify({\n        message: 'No pinned notes found',\n        notes: [],\n      });\n    }\n\n    // Format notes for LLM consumption\n    const formattedNotes = notes.map((note) => ({\n      id: note.id,\n      title: note.title,\n      content: note.content,\n      category: note.category,\n      tags: note.tags,\n      created_at: note.created_at,\n    }));\n\n    return JSON.stringify({\n      count: notes.length,\n      notes: formattedNotes,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to get pinned notes: ${message}`, notes: [] });\n  }\n}",
      "references": [
        "getPinnedNotes",
        "notes",
        "JSON",
        "note",
        "formattedNotes",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/notes.ts:fn:handleListRecentNotes:146": {
      "id": "file:src/tools/notes.ts:fn:handleListRecentNotes:146",
      "type": "function",
      "name": "handleListRecentNotes",
      "filePath": "/home/ridgetop/projects/squire/src/tools/notes.ts",
      "line": 146,
      "endLine": 178,
      "parentFileId": "file:src/tools/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "ListRecentNotesArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Lists recent notes by limit and optional category, returns formatted JSON.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleListRecentNotes(args: ListRecentNotesArgs | null): Promise<string> {\n  const { limit = 10, category } = args ?? {};\n\n  try {\n    const notes = await listNotes({ limit, category });\n\n    if (notes.length === 0) {\n      return JSON.stringify({\n        message: category ? `No notes found in category \"${category}\"` : 'No notes found',\n        notes: [],\n      });\n    }\n\n    // Format notes for LLM consumption\n    const formattedNotes = notes.map((note) => ({\n      id: note.id,\n      title: note.title,\n      content: note.content,\n      category: note.category,\n      tags: note.tags,\n      is_pinned: note.is_pinned,\n      created_at: note.created_at,\n    }));\n\n    return JSON.stringify({\n      count: notes.length,\n      notes: formattedNotes,\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to list notes: ${message}`, notes: [] });\n  }\n}",
      "references": [
        "limit",
        "category",
        "listNotes",
        "notes",
        "JSON",
        "note",
        "formattedNotes",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/notes.ts:fn:handleCreateNote:214": {
      "id": "file:src/tools/notes.ts:fn:handleCreateNote:214",
      "type": "function",
      "name": "handleCreateNote",
      "filePath": "/home/ridgetop/projects/squire/src/tools/notes.ts",
      "line": 214,
      "endLine": 247,
      "parentFileId": "file:src/tools/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "CreateNoteArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a note from args via createNote and returns JSON success/error response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleCreateNote(args: CreateNoteArgs): Promise<string> {\n  const { content, title, category, tags, is_pinned } = args;\n\n  if (!content || content.trim().length === 0) {\n    return JSON.stringify({ error: 'Content is required', note: null });\n  }\n\n  try {\n    const note = await createNote({\n      content: content.trim(),\n      title: title?.trim(),\n      category: category?.trim(),\n      tags,\n      is_pinned,\n      source_type: 'chat',\n    });\n\n    return JSON.stringify({\n      message: 'Note created successfully',\n      note: {\n        id: note.id,\n        title: note.title,\n        content: note.content,\n        category: note.category,\n        tags: note.tags,\n        is_pinned: note.is_pinned,\n        created_at: note.created_at,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to create note: ${message}`, note: null });\n  }\n}",
      "references": [
        "content",
        "title",
        "category",
        "tags",
        "is_pinned",
        "JSON",
        "createNote",
        "note",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/notes.ts:fn:handleAppendToNote:295": {
      "id": "file:src/tools/notes.ts:fn:handleAppendToNote:295",
      "type": "function",
      "name": "handleAppendToNote",
      "filePath": "/home/ridgetop/projects/squire/src/tools/notes.ts",
      "line": 295,
      "endLine": 347,
      "parentFileId": "file:src/tools/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "AppendToNoteArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Appends content to existing note by ID or title and updates database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleAppendToNote(args: AppendToNoteArgs): Promise<string> {\n  const { note_id, note_title, content, separator = '\\n\\n' } = args;\n\n  if (!note_id && !note_title) {\n    return JSON.stringify({ error: 'Either note_id or note_title is required', note: null });\n  }\n\n  if (!content || content.trim().length === 0) {\n    return JSON.stringify({ error: 'Content to append is required', note: null });\n  }\n\n  try {\n    let existingNote;\n\n    if (note_id) {\n      // Direct ID lookup\n      existingNote = await getNote(note_id);\n    } else if (note_title) {\n      // Find by title (fuzzy match)\n      existingNote = await findNoteByTitle(note_title);\n    }\n\n    if (!existingNote) {\n      const identifier = note_id ? `ID \"${note_id}\"` : `title \"${note_title}\"`;\n      return JSON.stringify({\n        error: `Note with ${identifier} not found. Use search_notes to find the note, or create_note to create a new one.`,\n        note: null,\n      });\n    }\n\n    // Append content\n    const newContent = existingNote.content + separator + content.trim();\n    const updatedNote = await updateNote(existingNote.id, { content: newContent });\n\n    if (!updatedNote) {\n      return JSON.stringify({ error: 'Failed to update note', note: null });\n    }\n\n    return JSON.stringify({\n      message: `Content appended to \"${updatedNote.title || 'Untitled'}\" successfully`,\n      note: {\n        id: updatedNote.id,\n        title: updatedNote.title,\n        content: updatedNote.content,\n        category: updatedNote.category,\n        updated_at: updatedNote.updated_at,\n      },\n    });\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return JSON.stringify({ error: `Failed to append to note: ${message}`, note: null });\n  }\n}",
      "references": [
        "note_id",
        "note_title",
        "content",
        "separator",
        "JSON",
        "existingNote",
        "getNote",
        "findNoteByTitle",
        "identifier",
        "updateNote",
        "newContent",
        "updatedNote",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/tools/time.ts": {
      "id": "file:src/tools/time.ts",
      "type": "file",
      "name": "time.ts",
      "filePath": "src/tools/time.ts",
      "line": 1,
      "endLine": 89,
      "imports": [
        {
          "source": "../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ToolHandler",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "timeToolName",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "timeToolDescription",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "timeToolParameters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "timeToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/tools/time.ts:fn:getCurrentTime:19"
      ],
      "classes": [],
      "topLevelReferences": [
        "getCurrentTime"
      ]
    },
    "file:src/tools/time.ts:fn:getCurrentTime:19": {
      "id": "file:src/tools/time.ts:fn:getCurrentTime:19",
      "type": "function",
      "name": "getCurrentTime",
      "filePath": "/home/ridgetop/projects/squire/src/tools/time.ts",
      "line": 19,
      "endLine": 66,
      "parentFileId": "file:src/tools/time.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "args",
          "type": "GetCurrentTimeArgs",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns current date/time as string in specified format and timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCurrentTime(args: GetCurrentTimeArgs): string {\n  const now = new Date();\n  const format = args.format ?? 'full';\n\n  const baseOptions: Intl.DateTimeFormatOptions = {\n    timeZone: config.timezone,\n  };\n\n  let options: Intl.DateTimeFormatOptions;\n\n  switch (format) {\n    case 'date':\n      options = {\n        ...baseOptions,\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n      };\n      break;\n\n    case 'time':\n      options = {\n        ...baseOptions,\n        hour: 'numeric',\n        minute: '2-digit',\n        second: '2-digit',\n        timeZoneName: 'short',\n      };\n      break;\n\n    case 'full':\n    default:\n      options = {\n        ...baseOptions,\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n        hour: 'numeric',\n        minute: '2-digit',\n        timeZoneName: 'short',\n      };\n      break;\n  }\n\n  return now.toLocaleString('en-US', options);\n}",
      "references": [
        "Date",
        "config",
        "format",
        "options",
        "baseOptions",
        "now"
      ]
    },
    "file:src/tools/types.ts": {
      "id": "file:src/tools/types.ts",
      "type": "file",
      "name": "types.ts",
      "filePath": "src/tools/types.ts",
      "line": 1,
      "endLine": 83,
      "imports": [],
      "exports": [
        {
          "name": "ToolDefinition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolCall",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolHandler",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "RegisteredTool",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ToolMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AssistantMessageWithTools",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/api/routes/beliefs.ts": {
      "id": "file:src/api/routes/beliefs.ts",
      "type": "file",
      "name": "beliefs.ts",
      "filePath": "src/api/routes/beliefs.ts",
      "line": 1,
      "endLine": 228,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/beliefs.js",
          "items": [
            {
              "name": "getAllBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBelief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefsByType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefsByEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefEvidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBeliefStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUnresolvedConflicts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "resolveConflict",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidBeliefType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BELIEF_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseFloat",
        "parseInt",
        "res",
        "status",
        "minConfidence",
        "limit",
        "beliefs",
        "console",
        "error",
        "stats",
        "conflicts",
        "entityId",
        "id",
        "belief",
        "evidence",
        "resolution",
        "notes",
        "validResolutions",
        "conflict"
      ]
    },
    "file:src/api/routes/calendar.ts": {
      "id": "file:src/api/routes/calendar.ts",
      "type": "file",
      "name": "calendar.ts",
      "filePath": "src/api/routes/calendar.ts",
      "line": 1,
      "endLine": 385,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/commitments.js",
          "items": [
            {
              "name": "listCommitmentsExpanded",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExpandedCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/google/events.js",
          "items": [
            {
              "name": "getAllEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/google/auth.js",
          "items": [
            {
              "name": "listSyncEnabledAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "CalendarEvent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/api/routes/calendar.ts:fn:adjustAllDayTime:13",
        "file:src/api/routes/calendar.ts:fn:commitmentToCalendarEvent:279",
        "file:src/api/routes/calendar.ts:fn:getEventsInRange:306",
        "file:src/api/routes/calendar.ts:fn:getStatusColor:367"
      ],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "Date",
        "start",
        "end",
        "commitments",
        "commitment",
        "events",
        "commitmentToCalendarEvent",
        "accounts",
        "googleEvents",
        "event",
        "adjustAllDayTime",
        "console",
        "err",
        "a",
        "b",
        "res",
        "error",
        "dateParam",
        "baseDate",
        "getEventsInRange",
        "i",
        "day",
        "days",
        "key",
        "eventsRes",
        "parseInt",
        "year",
        "month",
        "daysInMonth",
        "String",
        "today",
        "limit",
        "Math"
      ]
    },
    "file:src/api/routes/calendar.ts:fn:adjustAllDayTime:13": {
      "id": "file:src/api/routes/calendar.ts:fn:adjustAllDayTime:13",
      "type": "function",
      "name": "adjustAllDayTime",
      "filePath": "/home/ridgetop/projects/squire/src/api/routes/calendar.ts",
      "line": 13,
      "endLine": 18,
      "parentFileId": "file:src/api/routes/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "time",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Date",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Adjusts all-day event time to noon UTC if allDay is true, otherwise returns input unchanged.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function adjustAllDayTime(time: Date | null, allDay: boolean): Date | null {\n  if (!time || !allDay) return time;\n  const adjusted = new Date(time);\n  adjusted.setUTCHours(12, 0, 0, 0);\n  return adjusted;\n}",
      "references": [
        "Date",
        "adjusted"
      ]
    },
    "file:src/api/routes/calendar.ts:fn:commitmentToCalendarEvent:279": {
      "id": "file:src/api/routes/calendar.ts:fn:commitmentToCalendarEvent:279",
      "type": "function",
      "name": "commitmentToCalendarEvent",
      "filePath": "/home/ridgetop/projects/squire/src/api/routes/calendar.ts",
      "line": 279,
      "endLine": 303,
      "parentFileId": "file:src/api/routes/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitment",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/commitments\").ExpandedCommitment",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/api/routes/calendar\").CalendarEvent",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms ExpandedCommitment into CalendarEvent with computed end time and recurrence data",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function commitmentToCalendarEvent(commitment: ExpandedCommitment): CalendarEvent {\n  const duration = commitment.duration_minutes || 60;\n  const endTime = commitment.due_at\n    ? new Date(commitment.due_at.getTime() + duration * 60 * 1000)\n    : null;\n\n  return {\n    id: `squire-${commitment.id}`,\n    source: 'squire',\n    title: commitment.title,\n    description: commitment.description || null,\n    start: commitment.due_at!,\n    end: endTime,\n    allDay: commitment.all_day || false,\n    timezone: commitment.timezone || null,\n    status: commitment.status,\n    color: getStatusColor(commitment.status),\n    commitmentId: commitment.recurring_commitment_id,\n    // Recurrence data\n    isRecurring: !!commitment.rrule,\n    isOccurrence: commitment.is_occurrence,\n    occurrenceIndex: commitment.occurrence_index,\n    rrule: commitment.rrule,\n  };\n}",
      "references": [
        "Date",
        "duration",
        "endTime",
        "getStatusColor"
      ]
    },
    "file:src/api/routes/calendar.ts:fn:getEventsInRange:306": {
      "id": "file:src/api/routes/calendar.ts:fn:getEventsInRange:306",
      "type": "function",
      "name": "getEventsInRange",
      "filePath": "/home/ridgetop/projects/squire/src/api/routes/calendar.ts",
      "line": 306,
      "endLine": 364,
      "parentFileId": "file:src/api/routes/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "start",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "end",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/api/routes/calendar\").CalendarEvent[]>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches Squire commitments and Google events in date range, converts to CalendarEvent[], sorts by start time",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getEventsInRange(start: Date, end: Date): Promise<CalendarEvent[]> {\n  const events: CalendarEvent[] = [];\n\n  // Get Squire commitments with recurring ones expanded\n  const commitments = await listCommitmentsExpanded({\n    due_after: start,\n    due_before: end,\n    include_resolved: false,\n    expand_recurring: true,\n    max_occurrences: 100,\n    limit: 500,\n  });\n\n  for (const commitment of commitments) {\n    if (!commitment.due_at) continue;\n\n    events.push(commitmentToCalendarEvent(commitment));\n  }\n\n  // Get Google events\n  try {\n    const accounts = await listSyncEnabledAccounts();\n    if (accounts.length > 0) {\n      const googleEvents = await getAllEvents({\n        timeMin: start,\n        timeMax: end,\n      });\n\n      for (const event of googleEvents) {\n        if (!event.start_time) continue;\n\n        events.push({\n          id: `google-${event.id}`,\n          source: 'google',\n          title: event.summary || '(No title)',\n          description: event.description || null,\n          start: adjustAllDayTime(event.start_time, event.all_day) || event.start_time,\n          end: adjustAllDayTime(event.end_time, event.all_day),\n          allDay: event.all_day,\n          timezone: event.timezone || null,\n          status: event.status,\n          color: (event as unknown as { background_color?: string }).background_color || '#4285f4',\n          googleEventId: event.event_id,\n          googleCalendarName: (event as unknown as { calendar_name?: string }).calendar_name,\n          location: event.location,\n          htmlLink: event.html_link,\n          commitmentId: event.commitment_id || undefined,\n        });\n      }\n    }\n  } catch (err) {\n    console.error('Failed to get Google events:', err);\n  }\n\n  // Sort by start time\n  events.sort((a, b) => a.start.getTime() - b.start.getTime());\n\n  return events;\n}",
      "references": [
        "listCommitmentsExpanded",
        "commitments",
        "commitment",
        "events",
        "commitmentToCalendarEvent",
        "listSyncEnabledAccounts",
        "accounts",
        "getAllEvents",
        "googleEvents",
        "event",
        "adjustAllDayTime",
        "console",
        "err",
        "a",
        "b"
      ]
    },
    "file:src/api/routes/calendar.ts:fn:getStatusColor:367": {
      "id": "file:src/api/routes/calendar.ts:fn:getStatusColor:367",
      "type": "function",
      "name": "getStatusColor",
      "filePath": "/home/ridgetop/projects/squire/src/api/routes/calendar.ts",
      "line": 367,
      "endLine": 382,
      "parentFileId": "file:src/api/routes/calendar.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "status",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps status string to hex color code via switch statement",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getStatusColor(status: string): string {\n  switch (status) {\n    case 'open':\n      return '#3b82f6'; // Blue\n    case 'in_progress':\n      return '#f59e0b'; // Amber\n    case 'completed':\n      return '#10b981'; // Green\n    case 'canceled':\n      return '#6b7280'; // Gray\n    case 'snoozed':\n      return '#8b5cf6'; // Purple\n    default:\n      return '#3b82f6';\n  }\n}",
      "references": []
    },
    "file:src/api/routes/chat.ts": {
      "id": "file:src/api/routes/chat.ts",
      "type": "file",
      "name": "chat.ts",
      "filePath": "src/api/routes/chat.ts",
      "line": 1,
      "endLine": 329,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/chat.js",
          "items": [
            {
              "name": "chat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "chatSimple",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatRequest",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../providers/llm.js",
          "items": [
            {
              "name": "checkLLMHealth",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getLLMInfo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/conversations.js",
          "items": [
            {
              "name": "createConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listConversations",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "archiveConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateConversationTitle",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMessages",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getRecentConversationWithMessages",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "body",
        "res",
        "chatRequest",
        "response",
        "console",
        "error",
        "Error",
        "message",
        "llmHealthy",
        "llmInfo",
        "Promise",
        "parseInt",
        "limit",
        "offset",
        "status",
        "conversations",
        "result",
        "conversation",
        "messages",
        "clientId",
        "title",
        "id"
      ]
    },
    "file:src/api/routes/commitments.ts": {
      "id": "file:src/api/routes/commitments.ts",
      "type": "file",
      "name": "commitments.ts",
      "filePath": "src/api/routes/commitments.ts",
      "line": 1,
      "endLine": 448,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/commitments.js",
          "items": [
            {
              "name": "createCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listCommitmentsExpanded",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "resolveCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "snoozeCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unsnoozeCommitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countCommitmentsByStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getOverdueCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getUpcomingCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findMatchingCommitments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNextCommitmentOccurrence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "parseOccurrenceId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CommitmentStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "parseInt",
        "req",
        "Date",
        "limit",
        "offset",
        "status",
        "include_resolved",
        "due_before",
        "due_after",
        "res",
        "commitments",
        "console",
        "error",
        "expand_recurring",
        "max_occurrences",
        "id",
        "commitmentId",
        "after",
        "nextOccurrence",
        "counts",
        "withinMinutes",
        "query",
        "parseFloat",
        "minSimilarity",
        "title",
        "description",
        "memory_id",
        "source_type",
        "due_at",
        "timezone",
        "all_day",
        "duration_minutes",
        "rrule",
        "recurrence_end_at",
        "tags",
        "metadata",
        "commitment",
        "google_sync_status",
        "deleted",
        "resolution_type",
        "resolution_memory_id",
        "validTypes",
        "snooze_until"
      ]
    },
    "file:src/api/routes/consolidation.ts": {
      "id": "file:src/api/routes/consolidation.ts",
      "type": "file",
      "name": "consolidation.ts",
      "filePath": "src/api/routes/consolidation.ts",
      "line": 1,
      "endLine": 170,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/consolidation.js",
          "items": [
            {
              "name": "consolidateAll",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "consolidatePendingSessions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getConsolidationStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CONSOLIDATION_CONFIG",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/sessions.js",
          "items": [
            {
              "name": "startSession",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "endSession",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCurrentSession",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listSessions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSessionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/edges.js",
          "items": [
            {
              "name": "getRelatedMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEdgeStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "res",
        "result",
        "console",
        "error",
        "results",
        "consolidationStats",
        "edgeStats",
        "sessionStats",
        "Promise",
        "parseInt",
        "req",
        "limit",
        "status",
        "sessions",
        "session",
        "session_type",
        "metadata",
        "sessionId",
        "memoryId",
        "parseFloat",
        "minWeight",
        "related"
      ]
    },
    "file:src/api/routes/context.ts": {
      "id": "file:src/api/routes/context.ts",
      "type": "file",
      "name": "context.ts",
      "filePath": "src/api/routes/context.ts",
      "line": 1,
      "endLine": 100,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/context.js",
          "items": [
            {
              "name": "generateContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listProfiles",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getDisclosureLog",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "profile",
        "query",
        "max_tokens",
        "conversation_id",
        "req",
        "res",
        "contextPackage",
        "console",
        "error",
        "Error",
        "message",
        "parseInt",
        "maxTokens",
        "conversationId",
        "profiles",
        "limit",
        "entries"
      ]
    },
    "file:src/api/routes/documents.ts": {
      "id": "file:src/api/routes/documents.ts",
      "type": "file",
      "name": "documents.ts",
      "filePath": "src/api/routes/documents.ts",
      "line": 1,
      "endLine": 1230,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "multer",
          "items": [
            {
              "name": "multer",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/documents/index.js",
          "items": [
            {
              "name": "extractFromBuffer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isSupported",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSupportedMimeTypes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "hybridChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fixedChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "semanticChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "storeChunks",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getChunksByObjectId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getChunkStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteChunksByObjectId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchChunksBySimilarity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchChunksByText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateChunkEmbeddings",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "embedAndStoreChunks",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateQueryEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchDocumentsOptimized",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSearchStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "summarizeDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "askDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCacheStats",
              "alias": "getEphemeralCacheStats",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/objects.js",
          "items": [
            {
              "name": "getObjectById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/documents/factExtraction/index.js",
          "items": [
            {
              "name": "extractFactsFromDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "extractFactsFromChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getExtractionProgress",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFactsByDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPendingFacts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateFactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "bulkUpdateFactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateFactContent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFactStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBatch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getBatchesByDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/documents/chunker/chunkStorage.js",
          "items": [
            {
              "name": "getChunkById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "upload",
        "req",
        "file",
        "res",
        "options",
        "parseInt",
        "parseFloat",
        "result",
        "isDuplicate",
        "console",
        "error",
        "Error",
        "String",
        "mimeType",
        "id",
        "strategy",
        "maxTokens",
        "overlapTokens",
        "generateEmbeddings",
        "shouldEmbed",
        "replaceExisting",
        "chunker",
        "chunks",
        "chunk",
        "includeContent",
        "includeEmbeddings",
        "stats",
        "deletedCount",
        "embeddedCount",
        "query",
        "limit",
        "threshold",
        "documentId",
        "response",
        "r",
        "objectId",
        "queryEmbedding",
        "results",
        "searchText",
        "style",
        "focus",
        "maxSummaryTokens",
        "question",
        "maxAnswerTokens",
        "includeCitations",
        "Number",
        "Boolean",
        "Array",
        "chunkId",
        "facts",
        "progress",
        "batches",
        "factId",
        "fact",
        "status",
        "notes",
        "factIds",
        "count",
        "content",
        "deleted",
        "batchId",
        "batch"
      ]
    },
    "file:src/api/routes/entities.ts": {
      "id": "file:src/api/routes/entities.ts",
      "type": "file",
      "name": "entities.ts",
      "filePath": "src/api/routes/entities.ts",
      "line": 1,
      "endLine": 198,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/entities.js",
          "items": [
            {
              "name": "listEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findEntityByName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntityWithMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMemoryEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countEntitiesByType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseInt",
        "entities",
        "counts",
        "Promise",
        "limit",
        "offset",
        "search",
        "Object",
        "a",
        "b",
        "res",
        "total",
        "console",
        "error",
        "query",
        "name",
        "result",
        "id",
        "includeFull",
        "enrichedEntity",
        "entity",
        "memoryId"
      ]
    },
    "file:src/api/routes/google.ts": {
      "id": "file:src/api/routes/google.ts",
      "type": "file",
      "name": "google.ts",
      "filePath": "src/api/routes/google.ts",
      "line": 1,
      "endLine": 310,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/google/auth.js",
          "items": [
            {
              "name": "getAuthUrl",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "handleOAuthCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isGoogleConfigured",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getConnectionStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAccount",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "disconnectAccount",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "setSyncEnabled",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/google/calendars.js",
          "items": [
            {
              "name": "listCalendars",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCalendar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateCalendarSettings",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "syncCalendarList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCalendarStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/google/sync.js",
          "items": [
            {
              "name": "fullSync",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "incrementalSync",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSyncHistory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getLastSuccessfulSync",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "res",
        "status",
        "console",
        "error",
        "req",
        "state",
        "authUrl",
        "encodeURIComponent",
        "code",
        "account",
        "syncError",
        "Error",
        "message",
        "accountId",
        "success",
        "accounts",
        "a",
        "sync_enabled",
        "updated",
        "calendars",
        "stats",
        "sync_direction",
        "is_default_for_push",
        "calendarId",
        "calendar",
        "full",
        "result",
        "parseInt",
        "limit",
        "history",
        "lastSuccess"
      ]
    },
    "file:src/api/routes/graph.ts": {
      "id": "file:src/api/routes/graph.ts",
      "type": "file",
      "name": "graph.ts",
      "filePath": "src/api/routes/graph.ts",
      "line": 1,
      "endLine": 521,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/graph.js",
          "items": [
            {
              "name": "findEntityNeighbors",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findSharedMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "traverseEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "traverseMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findPathBetweenEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findPathBetweenMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntitySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMemorySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGraphStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFullGraphVisualization",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityNeighbor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/entities.js",
          "items": [
            {
              "name": "getEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/edges.js",
          "items": [
            {
              "name": "EdgeType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "res",
        "stats",
        "console",
        "error",
        "req",
        "parseInt",
        "parseFloat",
        "entityTypesParam",
        "nodeLimit",
        "entityLimit",
        "memoryLimit",
        "minSalience",
        "entityTypes",
        "includeEdges",
        "subgraph",
        "id",
        "entity",
        "limit",
        "minShared",
        "entityType",
        "neighbors",
        "n",
        "id1",
        "id2",
        "entity1",
        "entity2",
        "Promise",
        "memories",
        "m",
        "maxHops",
        "minStrength",
        "results",
        "r",
        "edgeTypesParam",
        "edgeTypes",
        "minWeight",
        "start",
        "end",
        "startEntity",
        "endEntity",
        "result",
        "e",
        "mems",
        "includeEntities"
      ]
    },
    "file:src/api/routes/health.ts": {
      "id": "file:src/api/routes/health.ts",
      "type": "file",
      "name": "health.ts",
      "filePath": "src/api/routes/health.ts",
      "line": 1,
      "endLine": 37,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "checkConnection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../providers/embeddings.js",
          "items": [
            {
              "name": "checkEmbeddingHealth",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "dbHealthy",
        "embeddingHealthy",
        "Promise",
        "allHealthy",
        "Date",
        "res",
        "status"
      ]
    },
    "file:src/api/routes/identity.ts": {
      "id": "file:src/api/routes/identity.ts",
      "type": "file",
      "name": "identity.ts",
      "filePath": "src/api/routes/identity.ts",
      "line": 1,
      "endLine": 171,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/identity.js",
          "items": [
            {
              "name": "getUserIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "renameUser",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "setInitialIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "lockIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unlockIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "identity",
        "res",
        "console",
        "error",
        "Error",
        "name",
        "reason",
        "req",
        "trimmedName",
        "existing"
      ]
    },
    "file:src/api/routes/insights.ts": {
      "id": "file:src/api/routes/insights.ts",
      "type": "file",
      "name": "insights.ts",
      "filePath": "src/api/routes/insights.ts",
      "line": 1,
      "endLine": 258,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/insights.js",
          "items": [
            {
              "name": "getAllInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightsByType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightsBySource",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getInsightStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "actionInsight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidInsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "INSIGHT_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "INSIGHT_PRIORITIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "INSIGHT_STATUSES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SOURCE_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightPriority",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SourceType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseFloat",
        "parseInt",
        "res",
        "status",
        "priority",
        "minConfidence",
        "limit",
        "insights",
        "console",
        "error",
        "stats",
        "sourceType",
        "sourceId",
        "id",
        "insight",
        "sources",
        "reason",
        "Error",
        "message"
      ]
    },
    "file:src/api/routes/lists.ts": {
      "id": "file:src/api/routes/lists.ts",
      "type": "file",
      "name": "lists.ts",
      "filePath": "src/api/routes/lists.ts",
      "line": 1,
      "endLine": 626,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/lists.js",
          "items": [
            {
              "name": "createList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "archiveList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getListsByEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "findListByName",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "removeItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "reorderItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "uncompleteItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCompletionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeAllItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "clearCompletedItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "exportList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "exportAllLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SortType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "parseInt",
        "req",
        "list_type",
        "validListTypes",
        "res",
        "limit",
        "offset",
        "category",
        "entity_id",
        "is_pinned",
        "include_archived",
        "lists",
        "console",
        "error",
        "query",
        "name",
        "list",
        "format",
        "include_completed",
        "only_completed",
        "include_metadata",
        "contentTypes",
        "data",
        "entityId",
        "description",
        "primary_entity_id",
        "tags",
        "color",
        "default_sort",
        "validSortTypes",
        "withItems",
        "id",
        "stats",
        "count",
        "item_ids",
        "Array",
        "content",
        "notes",
        "priority",
        "due_at",
        "sort_order",
        "listId",
        "Date",
        "item",
        "itemId",
        "is_completed",
        "hard"
      ]
    },
    "file:src/api/routes/memories.ts": {
      "id": "file:src/api/routes/memories.ts",
      "type": "file",
      "name": "memories.ts",
      "filePath": "src/api/routes/memories.ts",
      "line": 1,
      "endLine": 148,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/memories.js",
          "items": [
            {
              "name": "createMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "content",
        "source",
        "content_type",
        "source_metadata",
        "occurred_at",
        "skipEntityExtraction",
        "req",
        "res",
        "Date",
        "result",
        "console",
        "error",
        "parseInt",
        "memories",
        "total",
        "Promise",
        "limit",
        "offset",
        "query",
        "parseFloat",
        "minSimilarity",
        "results",
        "id",
        "memory",
        "deleted"
      ]
    },
    "file:src/api/routes/notes.ts": {
      "id": "file:src/api/routes/notes.ts",
      "type": "file",
      "name": "notes.ts",
      "filePath": "src/api/routes/notes.ts",
      "line": 1,
      "endLine": 389,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/notes.js",
          "items": [
            {
              "name": "createNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "archiveNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNotesByEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPinnedNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkNoteToEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unlinkNoteFromEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "pinNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unpinNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "exportNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "NoteSourceType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "parseInt",
        "req",
        "limit",
        "offset",
        "category",
        "entity_id",
        "is_pinned",
        "include_archived",
        "tags",
        "res",
        "notes",
        "console",
        "error",
        "query",
        "parseFloat",
        "threshold",
        "format",
        "include_metadata",
        "contentTypes",
        "result",
        "entityId",
        "title",
        "content",
        "source_type",
        "source_context",
        "primary_entity_id",
        "entity_ids",
        "color",
        "create_memory",
        "validSourceTypes",
        "note",
        "id",
        "is_primary"
      ]
    },
    "file:src/api/routes/notifications.ts": {
      "id": "file:src/api/routes/notifications.ts",
      "type": "file",
      "name": "notifications.ts",
      "filePath": "src/api/routes/notifications.ts",
      "line": 1,
      "endLine": 227,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/push.js",
          "items": [
            {
              "name": "subscribe",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unsubscribe",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getVapidPublicKey",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isPushConfigured",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSubscriptionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listSubscriptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSubscriptionByEndpoint",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "res",
        "publicKey",
        "console",
        "error",
        "configured",
        "stats",
        "endpoint",
        "p256dh",
        "auth",
        "user_agent",
        "device_name",
        "req",
        "URL",
        "subscription",
        "deleted",
        "parseInt",
        "active_only",
        "limit",
        "offset",
        "subscriptions",
        "sub",
        "safeSubscriptions"
      ]
    },
    "file:src/api/routes/objects.ts": {
      "id": "file:src/api/routes/objects.ts",
      "type": "file",
      "name": "objects.ts",
      "filePath": "src/api/routes/objects.ts",
      "line": 1,
      "endLine": 760,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "multer",
          "items": [
            {
              "name": "multer",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/objects.js",
          "items": [
            {
              "name": "createObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listObjects",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkToMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unlinkFromMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectsForMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getMemoriesForObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "linkToEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unlinkFromEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectsForEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntitiesForObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addTag",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "removeTag",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectTags",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAllTags",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCollectionById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listCollections",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addToCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "removeFromCollection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCollectionObjects",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchObjectsSemantic",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateObjectEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "OBJECT_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "OBJECT_STATUSES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PROCESSING_STATUSES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MEMORY_LINK_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ENTITY_LINK_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ObjectType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ObjectStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ProcessingStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoryLinkType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityLinkType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseInt",
        "objectType",
        "res",
        "status",
        "processingStatus",
        "tag",
        "search",
        "limit",
        "offset",
        "objects",
        "console",
        "error",
        "stats",
        "tags",
        "query",
        "collections",
        "name",
        "description",
        "collection",
        "collectionId",
        "objectId",
        "position",
        "added",
        "removed",
        "memoryId",
        "entityId",
        "upload",
        "file",
        "tagsStr",
        "t",
        "Boolean",
        "result",
        "id",
        "memoryLinks",
        "entityLinks",
        "data",
        "metadata",
        "deleted",
        "success",
        "links",
        "parseFloat",
        "linkType",
        "relevance",
        "notes",
        "link",
        "unlinked",
        "confidence"
      ]
    },
    "file:src/api/routes/patterns.ts": {
      "id": "file:src/api/routes/patterns.ts",
      "type": "file",
      "name": "patterns.ts",
      "filePath": "src/api/routes/patterns.ts",
      "line": 1,
      "endLine": 194,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/patterns.js",
          "items": [
            {
              "name": "getAllPatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternsByType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternsByEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternEvidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPatternStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidPatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PATTERN_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TIME_OF_DAY",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DAY_OF_WEEK",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TimeOfDay",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DayOfWeek",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseFloat",
        "parseInt",
        "res",
        "timeOfDay",
        "dayOfWeek",
        "status",
        "minConfidence",
        "limit",
        "patterns",
        "console",
        "error",
        "stats",
        "entityId",
        "id",
        "pattern",
        "evidence"
      ]
    },
    "file:src/api/routes/reminders.ts": {
      "id": "file:src/api/routes/reminders.ts",
      "type": "file",
      "name": "reminders.ts",
      "filePath": "src/api/routes/reminders.ts",
      "line": 1,
      "endLine": 333,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/reminders.js",
          "items": [
            {
              "name": "createReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createStandaloneReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createScheduledReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listReminders",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "cancelReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "snoozeReminder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markReminderAcknowledged",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getCommitmentReminders",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getReminderStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReminderStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReminderChannel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "parseInt",
        "req",
        "Date",
        "limit",
        "offset",
        "status",
        "commitment_id",
        "channel",
        "scheduled_before",
        "scheduled_after",
        "res",
        "reminders",
        "console",
        "error",
        "stats",
        "commitmentId",
        "title",
        "body",
        "scheduled_for",
        "timezone",
        "offset_type",
        "offset_minutes",
        "metadata",
        "reminder",
        "delay_minutes",
        "scheduled_at",
        "isNaN",
        "scheduledDate",
        "id",
        "deleted",
        "snooze_until",
        "snooze_minutes",
        "snoozeTime"
      ]
    },
    "file:src/api/routes/research.ts": {
      "id": "file:src/api/routes/research.ts",
      "type": "file",
      "name": "research.ts",
      "filePath": "src/api/routes/research.ts",
      "line": 1,
      "endLine": 574,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/research.js",
          "items": [
            {
              "name": "getAllGaps",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGapSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getGapStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fillGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "partiallyFillGap",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getAllQuestions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestionSources",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getQuestionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "askQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "answerQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissQuestion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GAP_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GAP_PRIORITIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GAP_STATUSES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QUESTION_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QUESTION_STATUSES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TIMING_HINTS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GapType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GapPriority",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GapStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QuestionType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QuestionStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TimingHint",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "parseFloat",
        "parseInt",
        "res",
        "status",
        "priority",
        "entityId",
        "minSeverity",
        "limit",
        "gaps",
        "console",
        "error",
        "stats",
        "id",
        "gap",
        "sources",
        "reason",
        "Error",
        "message",
        "timingHint",
        "gapId",
        "questions",
        "hint",
        "question",
        "answer",
        "memoryId",
        "usefulness",
        "gapStats",
        "questionStats",
        "Promise"
      ]
    },
    "file:src/api/routes/summaries.ts": {
      "id": "file:src/api/routes/summaries.ts",
      "type": "file",
      "name": "summaries.ts",
      "filePath": "src/api/routes/summaries.ts",
      "line": 1,
      "endLine": 150,
      "imports": [
        {
          "source": "express",
          "items": [
            {
              "name": "Router",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Request",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Response",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/summaries.js",
          "items": [
            {
              "name": "getAllSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getNonEmptySummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateAllSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getSummaryStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isValidCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SUMMARY_CATEGORIES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "refreshCommitmentsSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SummaryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "router",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "router",
        "req",
        "nonEmptyOnly",
        "res",
        "summaries",
        "console",
        "error",
        "stats",
        "category",
        "summary",
        "result"
      ]
    },
    "file:src/api/socket/broadcast.ts": {
      "id": "file:src/api/socket/broadcast.ts",
      "type": "file",
      "name": "broadcast.ts",
      "filePath": "src/api/socket/broadcast.ts",
      "line": 1,
      "endLine": 84,
      "imports": [
        {
          "source": "socket.io",
          "items": [
            {
              "name": "Server",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ServerToClientEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ClientToServerEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SocketData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "setSocketServer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastMemoryCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastInsightCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/api/socket/broadcast.ts:fn:setSocketServer:20",
        "file:src/api/socket/broadcast.ts:fn:broadcastMemoryCreated:28",
        "file:src/api/socket/broadcast.ts:fn:broadcastInsightCreated:58"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/api/socket/broadcast.ts:fn:setSocketServer:20": {
      "id": "file:src/api/socket/broadcast.ts:fn:setSocketServer:20",
      "type": "function",
      "name": "setSocketServer",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/broadcast.ts",
      "line": 20,
      "endLine": 23,
      "parentFileId": "file:src/api/socket/broadcast.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Sets Socket.IO server instance to module global and logs registration message",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function setSocketServer(io: TypedIO): void {\n  ioInstance = io;\n  console.log('[Broadcast] Socket.IO server registered for broadcasts');\n}",
      "references": [
        "ioInstance",
        "console"
      ]
    },
    "file:src/api/socket/broadcast.ts:fn:broadcastMemoryCreated:28": {
      "id": "file:src/api/socket/broadcast.ts:fn:broadcastMemoryCreated:28",
      "type": "function",
      "name": "broadcastMemoryCreated",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/broadcast.ts",
      "line": 28,
      "endLine": 53,
      "parentFileId": "file:src/api/socket/broadcast.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "{ id: string; content: string; salience_score: number; source: string; created_at: string | Date; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Broadcasts 'memory:created' Socket.IO event with memory data to all clients",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function broadcastMemoryCreated(memory: {\n  id: string;\n  content: string;\n  salience_score: number;\n  source: string;\n  created_at: Date | string;\n}): void {\n  if (!ioInstance) {\n    console.warn('[Broadcast] Cannot broadcast memory:created - Socket.IO not initialized');\n    return;\n  }\n\n  ioInstance.emit('memory:created', {\n    memory: {\n      id: memory.id,\n      content: memory.content,\n      salience: memory.salience_score,\n      source: memory.source,\n      created_at: typeof memory.created_at === 'string'\n        ? memory.created_at\n        : memory.created_at.toISOString(),\n    },\n  });\n\n  console.log(`[Broadcast] memory:created - ${memory.id}`);\n}",
      "references": [
        "ioInstance",
        "console"
      ]
    },
    "file:src/api/socket/broadcast.ts:fn:broadcastInsightCreated:58": {
      "id": "file:src/api/socket/broadcast.ts:fn:broadcastInsightCreated:58",
      "type": "function",
      "name": "broadcastInsightCreated",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/broadcast.ts",
      "line": 58,
      "endLine": 83,
      "parentFileId": "file:src/api/socket/broadcast.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "insight",
          "type": "{ id: string; content: string; insight_type: string; priority: string; created_at: string | Date; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Broadcasts 'insight:created' Socket.IO event with insight data if ioInstance available",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function broadcastInsightCreated(insight: {\n  id: string;\n  content: string;\n  insight_type: string;\n  priority: string;\n  created_at: Date | string;\n}): void {\n  if (!ioInstance) {\n    console.warn('[Broadcast] Cannot broadcast insight:created - Socket.IO not initialized');\n    return;\n  }\n\n  ioInstance.emit('insight:created', {\n    insight: {\n      id: insight.id,\n      content: insight.content,\n      type: insight.insight_type,\n      priority: insight.priority,\n      created_at: typeof insight.created_at === 'string'\n        ? insight.created_at\n        : insight.created_at.toISOString(),\n    },\n  });\n\n  console.log(`[Broadcast] insight:created - ${insight.id}`);\n}",
      "references": [
        "ioInstance",
        "console"
      ]
    },
    "file:src/api/socket/handlers.ts": {
      "id": "file:src/api/socket/handlers.ts",
      "type": "file",
      "name": "handlers.ts",
      "filePath": "src/api/socket/handlers.ts",
      "line": 1,
      "endLine": 1193,
      "imports": [
        {
          "source": "socket.io",
          "items": [
            {
              "name": "Server",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Socket",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/context.js",
          "items": [
            {
              "name": "generateContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/storyIntent.js",
          "items": [
            {
              "name": "detectStoryIntent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isStoryIntent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "describeIntent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/storyEngine.js",
          "items": [
            {
              "name": "generateStory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "StoryResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/conversations.js",
          "items": [
            {
              "name": "getOrCreateConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/consolidation.js",
          "items": [
            {
              "name": "consolidateAll",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/chatExtraction.js",
          "items": [
            {
              "name": "processMessageRealTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/identity.js",
          "items": [
            {
              "name": "getUserIdentity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../services/commitments.js",
          "items": [
            {
              "name": "markConfirmationOffered",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "confirmCandidate",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "dismissCandidate",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getLastOfferedCandidate",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../tools/index.js",
          "items": [
            {
              "name": "getToolDefinitions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "hasTools",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "executeTools",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "executeTool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolCall",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ToolDefinition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ClientToServerEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ServerToClientEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SocketData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatMessagePayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatCancelPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ConversationJoinPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ConversationLeavePayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "registerSocketHandlers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastMemoryCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastInsightCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/api/socket/handlers.ts:fn:scheduleConsolidation:56",
        "file:src/api/socket/handlers.ts:fn:checkCandidateResponse:90",
        "file:src/api/socket/handlers.ts:fn:formatReminderAcknowledgment:169",
        "file:src/api/socket/handlers.ts:fn:formatCommitmentConfirmationPrompt:204",
        "file:src/api/socket/handlers.ts:fn:buildSystemPrompt:274",
        "file:src/api/socket/handlers.ts:fn:getCurrentTimeContext:295",
        "file:src/api/socket/handlers.ts:fn:handleChatMessage:314",
        "file:src/api/socket/handlers.ts:fn:parseLlamaFunctionCall:597",
        "file:src/api/socket/handlers.ts:fn:executeParsedToolAndContinue:664",
        "file:src/api/socket/handlers.ts:fn:streamGroqResponse:718",
        "file:src/api/socket/handlers.ts:fn:handleToolCallsAndContinue:988",
        "file:src/api/socket/handlers.ts:fn:handleChatCancel:1057",
        "file:src/api/socket/handlers.ts:fn:getConversationRoom:1075",
        "file:src/api/socket/handlers.ts:fn:handleConversationJoin:1082",
        "file:src/api/socket/handlers.ts:fn:handleConversationLeave:1093",
        "file:src/api/socket/handlers.ts:fn:broadcastMessageSynced:1104",
        "file:src/api/socket/handlers.ts:fn:registerSocketHandlers:1124",
        "file:src/api/socket/handlers.ts:fn:broadcastMemoryCreated:1161",
        "file:src/api/socket/handlers.ts:fn:broadcastInsightCreated:1179"
      ],
      "classes": [],
      "topLevelReferences": [
        "Map"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:scheduleConsolidation:56": {
      "id": "file:src/api/socket/handlers.ts:fn:scheduleConsolidation:56",
      "type": "function",
      "name": "scheduleConsolidation",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 56,
      "endLine": 77,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Schedules consolidation after 15min delay, clearing existing timer and logging status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function scheduleConsolidation(): void {\n  // Clear existing timer if any\n  if (consolidationTimer) {\n    clearTimeout(consolidationTimer);\n  }\n\n  consolidationTimer = setTimeout(async () => {\n    console.log('[AutoSleep] 15 min inactivity - running background consolidation');\n    try {\n      const result = await consolidateAll();\n      console.log(\n        `[AutoSleep] Consolidation complete: ${result.chatMemoriesCreated} memories extracted, ` +\n        `${result.memoriesProcessed} memories processed, ${result.durationMs}ms`\n      );\n    } catch (error) {\n      console.error('[AutoSleep] Consolidation error:', error);\n    }\n    consolidationTimer = null;\n  }, CONSOLIDATION_DELAY_MS);\n\n  console.log('[AutoSleep] Consolidation scheduled for 15 min from now');\n}",
      "references": [
        "consolidationTimer",
        "clearTimeout",
        "setTimeout",
        "console",
        "consolidateAll",
        "result",
        "error",
        "CONSOLIDATION_DELAY_MS"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:checkCandidateResponse:90": {
      "id": "file:src/api/socket/handlers.ts:fn:checkCandidateResponse:90",
      "type": "function",
      "name": "checkCandidateResponse",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 90,
      "endLine": 165,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Checks message to confirm/dismiss candidate task, updates DB, emits socket events",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function checkCandidateResponse(\n  message: string,\n  socket: TypedSocket,\n  io: TypedIO,\n  conversationId: string\n): Promise<boolean> {\n  // Check if there's a recently offered candidate\n  const candidate = await getLastOfferedCandidate();\n  if (!candidate) {\n    return false;\n  }\n\n  // Check if the message is a confirmation or dismissal\n  const isConfirm = CONFIRM_PATTERNS.test(message.trim());\n  const isDismiss = DISMISS_PATTERNS.test(message.trim());\n\n  if (!isConfirm && !isDismiss) {\n    return false;\n  }\n\n  let responseText: string;\n\n  if (isConfirm) {\n    const confirmed = await confirmCandidate(candidate.id);\n    if (confirmed) {\n      responseText = ` Got it! I'm now tracking \"${candidate.title}\" as a task.`;\n      socket.emit('commitment:created', {\n        id: candidate.id,\n        title: candidate.title,\n      });\n    } else {\n      responseText = `I couldn't find that task to confirm. It may have already been processed.`;\n    }\n  } else {\n    const dismissed = await dismissCandidate(candidate.id);\n    if (dismissed) {\n      responseText = `No problem, I won't track \"${candidate.title}\".`;\n      socket.emit('commitment:dismissed', {\n        id: candidate.id,\n        title: candidate.title,\n      });\n    } else {\n      responseText = `I couldn't find that task to dismiss. It may have already been processed.`;\n    }\n  }\n\n  // Send the response as a streaming chunk + done\n  socket.emit('chat:chunk', {\n    conversationId,\n    chunk: responseText,\n    done: false,\n  });\n  socket.emit('chat:done', { conversationId });\n\n  // Persist the assistant message\n  const { addMessage: addChatMessage } = await import('../../services/conversations.js');\n  await addChatMessage({\n    conversationId,\n    role: 'assistant',\n    content: responseText,\n  });\n\n  // Broadcast to other devices\n  io.to(`conversation:${conversationId}`).emit('message:synced', {\n    conversationId,\n    message: {\n      id: crypto.randomUUID(),\n      role: 'assistant',\n      content: responseText,\n      timestamp: new Date().toISOString(),\n    },\n  });\n\n  console.log(`[Socket] Candidate ${isConfirm ? 'CONFIRMED' : 'DISMISSED'}: \"${candidate.title}\"`);\n  return true;\n}",
      "references": [
        "getLastOfferedCandidate",
        "candidate",
        "CONFIRM_PATTERNS",
        "DISMISS_PATTERNS",
        "isConfirm",
        "isDismiss",
        "confirmCandidate",
        "confirmed",
        "responseText",
        "dismissCandidate",
        "dismissed",
        "addMessage",
        "addChatMessage",
        "crypto",
        "Date",
        "console"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:formatReminderAcknowledgment:169": {
      "id": "file:src/api/socket/handlers.ts:fn:formatReminderAcknowledgment:169",
      "type": "function",
      "name": "formatReminderAcknowledgment",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 169,
      "endLine": 200,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "remindAt",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats reminder acknowledgment message showing title and time until reminder.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.688Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatReminderAcknowledgment(title: string, remindAt: string): string {\n  const date = new Date(remindAt);\n  const now = new Date();\n  const diffMs = date.getTime() - now.getTime();\n  const diffMins = Math.round(diffMs / 60000);\n\n  // Use system-detected timezone for user-facing display\n  const userTimezone = config.timezone;\n\n  let timeStr: string;\n  if (diffMins < 60) {\n    timeStr = `in ${diffMins} minute${diffMins !== 1 ? 's' : ''}`;\n  } else if (diffMins < 1440) {\n    const hours = Math.round(diffMins / 60);\n    timeStr = `in ${hours} hour${hours !== 1 ? 's' : ''}`;\n  } else {\n    const dateOptions: Intl.DateTimeFormatOptions = {\n      weekday: 'short',\n      month: 'short',\n      day: 'numeric',\n      timeZone: userTimezone\n    };\n    const timeOptions: Intl.DateTimeFormatOptions = {\n      hour: 'numeric',\n      minute: '2-digit',\n      timeZone: userTimezone\n    };\n    timeStr = `on ${date.toLocaleDateString('en-US', dateOptions)} at ${date.toLocaleTimeString('en-US', timeOptions)}`;\n  }\n\n  return `\\n\\n---\\n I've set a reminder for you: \"${title}\" ${timeStr}.`;\n}",
      "references": [
        "Date",
        "date",
        "now",
        "Math",
        "diffMs",
        "config",
        "diffMins",
        "timeStr",
        "hours",
        "userTimezone",
        "dateOptions",
        "timeOptions"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:formatCommitmentConfirmationPrompt:204": {
      "id": "file:src/api/socket/handlers.ts:fn:formatCommitmentConfirmationPrompt:204",
      "type": "function",
      "name": "formatCommitmentConfirmationPrompt",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 204,
      "endLine": 206,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "title",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a confirmation prompt string for tracking a task by title.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatCommitmentConfirmationPrompt(title: string): string {\n  return `\\n\\n---\\n Would you like me to track \"${title}\" as a task?`;\n}",
      "references": []
    },
    "file:src/api/socket/handlers.ts:fn:buildSystemPrompt:274": {
      "id": "file:src/api/socket/handlers.ts:fn:buildSystemPrompt:274",
      "type": "function",
      "name": "buildSystemPrompt",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 274,
      "endLine": 289,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Builds system prompt with user identity and tool instructions if available.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function buildSystemPrompt(): Promise<string> {\n  let prompt = SQUIRE_SYSTEM_PROMPT_BASE;\n\n  // Add user identity if known\n  const identity = await getUserIdentity();\n  if (identity?.name) {\n    prompt = `You are talking to ${identity.name}.\\n\\n` + prompt;\n  }\n\n  // Add tool calling instructions\n  if (hasTools()) {\n    prompt += TOOL_CALLING_INSTRUCTIONS;\n  }\n\n  return prompt;\n}",
      "references": [
        "SQUIRE_SYSTEM_PROMPT_BASE",
        "getUserIdentity",
        "identity",
        "prompt",
        "hasTools",
        "TOOL_CALLING_INSTRUCTIONS"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:getCurrentTimeContext:295": {
      "id": "file:src/api/socket/handlers.ts:fn:getCurrentTimeContext:295",
      "type": "function",
      "name": "getCurrentTimeContext",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 295,
      "endLine": 309,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a formatted string of the current date and time using the configured timezone.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getCurrentTimeContext(): string {\n  const now = new Date();\n  const options: Intl.DateTimeFormatOptions = {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZone: config.timezone,\n    timeZoneName: 'short',\n  };\n  const formatted = now.toLocaleString('en-US', options);\n  return `\\n\\nCurrent date and time: ${formatted}`;\n}",
      "references": [
        "Date",
        "config",
        "now",
        "options",
        "formatted"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:handleChatMessage:314": {
      "id": "file:src/api/socket/handlers.ts:fn:handleChatMessage:314",
      "type": "function",
      "name": "handleChatMessage",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 314,
      "endLine": 581,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/api/socket/types\").ChatMessagePayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Handles chat messages: persists to DB, broadcasts to room, manages streams, checks responses",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "async function handleChatMessage(\n  socket: TypedSocket,\n  io: TypedIO,\n  payload: ChatMessagePayload\n): Promise<void> {\n  const { conversationId, message, history = [], includeContext = true, contextProfile } = payload;\n\n  console.log(`[Socket] chat:message from ${socket.id} - conversation: ${conversationId}`);\n\n  // Track if we've emitted chat:done to avoid duplicates\n  let chatDoneEmitted = false;\n\n  // Schedule consolidation for later (debounced - resets on each message)\n  // Consolidation will run 15 min after the last message\n  scheduleConsolidation();\n\n  // Create abort controller for this stream\n  const abortController = new AbortController();\n  activeStreams.set(conversationId, abortController);\n\n  // Track context for persistence\n  let memoryIds: string[] = [];\n  let disclosureId: string | undefined;\n\n  try {\n    console.log(`[Socket] Step 0: Getting/creating conversation...`);\n    // Step 0: Ensure conversation exists in database\n    const conversation = await getOrCreateConversation(conversationId);\n    console.log(`[Socket] Conversation ready: ${conversation.id}`);\n\n    // Step 1: Persist user message immediately\n    const userMessage = await addMessage({\n      conversationId: conversation.id,\n      role: 'user',\n      content: message,\n    });\n\n    // Broadcast user message to all devices in this conversation room\n    broadcastMessageSynced(io, conversationId, {\n      id: userMessage.id,\n      role: 'user',\n      content: message,\n      timestamp: userMessage.created_at.toISOString(),\n    }, socket.id);\n\n    // Phase 4: Check for commitment confirmation/dismissal response\n    // If user just said yes/no to a candidate prompt, handle it immediately\n    const candidateResponse = await checkCandidateResponse(message, socket, io, conversationId);\n    if (candidateResponse) {\n      // User confirmed/dismissed - we've already sent a response, skip LLM\n      return;\n    }\n\n    // Step 1.5: Start real-time extraction for commitments/reminders\n    // Runs in parallel with context fetch and LLM response - awaited after streaming\n    const extractionPromise = processMessageRealTime(message).catch((error) => {\n      console.error('[Socket] Real-time extraction error:', error);\n      return { commitmentCreated: null, reminderCreated: null };\n    });\n\n    // Step 2: Check for Story Intent and generate context\n    let contextMarkdown: string | undefined;\n    let storyResult: StoryResult | undefined;\n\n    if (includeContext) {\n      try {\n        // Phase 1: Story Engine - detect if this is a biographical/narrative query\n        console.log(`[Socket] Step 2a: Detecting story intent...`);\n        const intent = await detectStoryIntent(message);\n\n        if (isStoryIntent(intent)) {\n          // This is a story query - use Story Engine instead of RAG\n          console.log(`[Socket] Story intent detected: ${describeIntent(intent)}`);\n\n          try {\n            storyResult = await generateStory({ query: message, intent });\n            console.log(`[Socket] Story generated with ${storyResult.evidence.length} evidence nodes`);\n\n            // Use story narrative as context for the LLM\n            contextMarkdown = `## Personal Story Context\n\nThe user is asking about something personal. Here is the synthesized narrative from their memories:\n\n${storyResult.narrative}\n\n---\n\n### Evidence Used (${storyResult.evidence.length} items):\n${storyResult.evidence.slice(0, 10).map((e) => `- ${e.content.substring(0, 150)}...`).join('\\n')}\n\n---\n\nUse this narrative to respond naturally. You can expand on it or answer follow-up questions based on this context.`;\n\n            memoryIds = storyResult.evidence\n              .filter((e) => e.type === 'memory')\n              .map((e) => e.id);\n\n            // Emit story context to client\n            socket.emit('chat:context', {\n              conversationId,\n              memories: storyResult.evidence\n                .filter((e) => e.type === 'memory')\n                .slice(0, 10)\n                .map((e) => ({\n                  id: e.id,\n                  content: e.content.substring(0, 200),\n                  salience: e.salience ?? 5,\n                })),\n              entities: [],\n              summaries: [],\n            });\n          } catch (storyError) {\n            console.error('[Socket] Story generation failed, falling back to RAG:', storyError);\n            // Fall through to regular context generation\n          }\n        }\n\n        // If no story was generated, use regular RAG context\n        if (!storyResult) {\n          console.log(`[Socket] Step 2b: Generating RAG context...`);\n          const contextPackage = await generateContext({\n            query: message,\n            profile: contextProfile,\n          });\n          console.log(`[Socket] Context generated: ${contextPackage.memories.length} memories`);\n\n          contextMarkdown = contextPackage.markdown;\n          memoryIds = contextPackage.memories.map((m) => m.id);\n          disclosureId = contextPackage.disclosure_id;\n\n          // Emit context to client\n          socket.emit('chat:context', {\n            conversationId,\n            memories: contextPackage.memories.map((m) => ({\n              id: m.id,\n              content: m.content.substring(0, 200),\n              salience: m.salience_score,\n            })),\n            entities: contextPackage.entities.map((e) => ({\n              id: e.id,\n              name: e.name,\n              type: e.type,\n            })),\n            summaries: contextPackage.summaries.map((s) => s.category),\n          });\n        }\n      } catch (error) {\n        console.error('[Socket] Context generation failed:', error);\n        // Continue without context\n      }\n    }\n\n    // Step 3: Build messages\n    const messages: Array<{ role: string; content: string }> = [];\n\n    // System prompt with user identity, time grounding, tool instructions, and context\n    let systemContent = await buildSystemPrompt();\n    systemContent += getCurrentTimeContext();\n    if (contextMarkdown) {\n      systemContent += `\\n\\n---\\n\\n${contextMarkdown}`;\n    }\n    messages.push({ role: 'system', content: systemContent });\n\n    // Add conversation history\n    for (const msg of history.slice(-10)) {\n      messages.push({ role: msg.role, content: msg.content });\n    }\n\n    // Add current message\n    messages.push({ role: 'user', content: message });\n\n    // Step 4: Stream LLM response with tools\n    const tools = hasTools() ? getToolDefinitions() : undefined;\n    console.log(`[Socket] Step 4: Starting ${config.llm.provider} stream... (${tools?.length ?? 0} tools available)`);\n    const streamResult = await streamGroqResponse(socket, conversationId, messages, abortController.signal, tools);\n    console.log(`[Socket] Stream complete: ${streamResult.content.length} chars`);\n\n    // Step 5: Await extraction and stream follow-up acknowledgment if needed\n    let fullContent = streamResult.content;\n    const extracted = await extractionPromise;\n\n    if (extracted.commitmentCreated || extracted.reminderCreated) {\n      let followUp = '';\n\n      if (extracted.reminderCreated) {\n        followUp = formatReminderAcknowledgment(\n          extracted.reminderCreated.title,\n          extracted.reminderCreated.remind_at\n        );\n        socket.emit('reminder:created', {\n          id: extracted.reminderCreated.id,\n          title: extracted.reminderCreated.title,\n          remind_at: extracted.reminderCreated.remind_at,\n        });\n        console.log(`[Socket] Reminder created: \"${extracted.reminderCreated.title}\"`);\n      } else if (extracted.commitmentCreated) {\n        // Phase 4: Commitments are now candidates - prompt for confirmation\n        followUp = formatCommitmentConfirmationPrompt(extracted.commitmentCreated.title);\n        // Mark as offered so we know which candidate to confirm on user response\n        await markConfirmationOffered(extracted.commitmentCreated.id);\n        socket.emit('commitment:candidate', {\n          id: extracted.commitmentCreated.id,\n          title: extracted.commitmentCreated.title,\n        });\n        console.log(`[Socket] Commitment CANDIDATE offered: \"${extracted.commitmentCreated.title}\"`);\n      }\n\n      // Stream the follow-up as additional chunks\n      if (followUp) {\n        socket.emit('chat:chunk', {\n          conversationId,\n          chunk: followUp,\n          done: false,\n        });\n        fullContent += followUp;\n      }\n    }\n\n    // Emit chat:done after follow-up\n    socket.emit('chat:done', {\n      conversationId,\n      usage: streamResult.usage ? {\n        promptTokens: streamResult.usage.promptTokens,\n        completionTokens: streamResult.usage.completionTokens,\n        totalTokens: streamResult.usage.promptTokens + streamResult.usage.completionTokens,\n      } : undefined,\n    });\n    chatDoneEmitted = true;\n\n    // Step 6: Persist assistant message (including follow-up) after streaming completes\n    if (fullContent) {\n      const assistantMessage = await addMessage({\n        conversationId: conversation.id,\n        role: 'assistant',\n        content: fullContent,\n        memoryIds,\n        disclosureId,\n        contextProfile,\n        promptTokens: streamResult.usage?.promptTokens,\n        completionTokens: streamResult.usage?.completionTokens,\n      });\n\n      // Broadcast assistant message to all devices in this conversation room\n      broadcastMessageSynced(io, conversationId, {\n        id: assistantMessage.id,\n        role: 'assistant',\n        content: fullContent,\n        timestamp: assistantMessage.created_at.toISOString(),\n      }, socket.id);\n    }\n  } catch (error) {\n    console.error('[Socket] Chat error:', error);\n\n    socket.emit('chat:error', {\n      conversationId,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      code: 'CHAT_ERROR',\n    });\n  } finally {\n    // ALWAYS emit chat:done if not already emitted - this clears the loading state\n    if (!chatDoneEmitted) {\n      console.log(`[Socket] Emitting chat:done in finally block (error case)`);\n      socket.emit('chat:done', { conversationId });\n    }\n    activeStreams.delete(conversationId);\n  }\n}",
      "references": [
        "conversationId",
        "message",
        "history",
        "includeContext",
        "contextProfile",
        "console",
        "scheduleConsolidation",
        "AbortController",
        "activeStreams",
        "abortController",
        "getOrCreateConversation",
        "conversation",
        "addMessage",
        "broadcastMessageSynced",
        "userMessage",
        "checkCandidateResponse",
        "candidateResponse",
        "processMessageRealTime",
        "error",
        "detectStoryIntent",
        "isStoryIntent",
        "intent",
        "describeIntent",
        "storyResult",
        "generateStory",
        "contextMarkdown",
        "e",
        "memoryIds",
        "storyError",
        "generateContext",
        "contextPackage",
        "m",
        "disclosureId",
        "s",
        "buildSystemPrompt",
        "systemContent",
        "getCurrentTimeContext",
        "messages",
        "msg",
        "hasTools",
        "getToolDefinitions",
        "config",
        "tools",
        "streamGroqResponse",
        "streamResult",
        "extractionPromise",
        "extracted",
        "followUp",
        "formatReminderAcknowledgment",
        "formatCommitmentConfirmationPrompt",
        "markConfirmationOffered",
        "fullContent",
        "chatDoneEmitted",
        "assistantMessage",
        "Error"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:parseLlamaFunctionCall:597": {
      "id": "file:src/api/socket/handlers.ts:fn:parseLlamaFunctionCall:597",
      "type": "function",
      "name": "parseLlamaFunctionCall",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 597,
      "endLine": 659,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "failedGeneration",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ name: string; arguments: string; }",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses Llama function call from string, fixes incomplete JSON, validates, returns name/args or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function parseLlamaFunctionCall(failedGeneration: string): { name: string; arguments: string } | null {\n  try {\n    // Match pattern: <function=toolName{jsonArgs}>\n    // The failed_generation might be truncated, so we need to handle incomplete JSON\n    const match = failedGeneration.match(/<function=(\\w+)(\\{[\\s\\S]*)/);\n    if (!match) {\n      console.log(`[Socket] No function call pattern found in: ${failedGeneration.substring(0, 100)}`);\n      return null;\n    }\n\n    const toolName = match[1]!;\n    let argsString = match[2] ?? '{}';\n\n    // Remove trailing </function> or > if present\n    argsString = argsString.replace(/<\\/function>.*$/, '').replace(/>\\s*$/, '');\n\n    // Try to fix incomplete JSON by closing any open braces/brackets\n    let openBraces = 0;\n    let openBrackets = 0;\n    let inString = false;\n    let escaped = false;\n\n    for (const char of argsString) {\n      if (escaped) {\n        escaped = false;\n        continue;\n      }\n      if (char === '\\\\') {\n        escaped = true;\n        continue;\n      }\n      if (char === '\"') {\n        inString = !inString;\n        continue;\n      }\n      if (!inString) {\n        if (char === '{') openBraces++;\n        else if (char === '}') openBraces--;\n        else if (char === '[') openBrackets++;\n        else if (char === ']') openBrackets--;\n      }\n    }\n\n    // Close any unclosed structures\n    while (openBrackets > 0) {\n      argsString += ']';\n      openBrackets--;\n    }\n    while (openBraces > 0) {\n      argsString += '}';\n      openBraces--;\n    }\n\n    // Validate JSON\n    JSON.parse(argsString);\n\n    console.log(`[Socket] Parsed Llama function: ${toolName} with args: ${argsString.substring(0, 200)}...`);\n    return { name: toolName, arguments: argsString };\n  } catch (error) {\n    console.log(`[Socket] Failed to parse Llama function call: ${error}`);\n    return null;\n  }\n}",
      "references": [
        "match",
        "console",
        "argsString",
        "escaped",
        "char",
        "inString",
        "openBraces",
        "openBrackets",
        "JSON",
        "toolName",
        "error"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:executeParsedToolAndContinue:664": {
      "id": "file:src/api/socket/handlers.ts:fn:executeParsedToolAndContinue:664",
      "type": "function",
      "name": "executeParsedToolAndContinue",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 664,
      "endLine": 712,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "messages",
          "type": "{ role: string; content: string; tool_calls?: import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolCall[]; tool_call_id?: string; }[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "parsed",
          "type": "{ name: string; arguments: string; }",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "signal",
          "type": "AbortSignal",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tools",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolDefinition[]",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number; }; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Executes parsed tool, updates messages with result, emits socket chunk, streams continued Groq response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function executeParsedToolAndContinue(\n  socket: TypedSocket,\n  conversationId: string,\n  messages: Array<{ role: string; content: string; tool_calls?: ToolCall[]; tool_call_id?: string }>,\n  parsed: { name: string; arguments: string },\n  signal: AbortSignal,\n  tools?: ToolDefinition[]\n): Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number } }> {\n  // Create a synthetic tool call\n  const toolCallId = `call_${Date.now()}`;\n  const toolCall: ToolCall = {\n    id: toolCallId,\n    type: 'function',\n    function: {\n      name: parsed.name,\n      arguments: parsed.arguments,\n    },\n  };\n\n  // Execute the tool\n  console.log(`[Socket] Executing parsed tool: ${parsed.name}`);\n  const result = await executeTool(toolCall);\n  console.log(`[Socket] Tool result (${result.success ? 'success' : 'failed'}): ${result.result.substring(0, 200)}...`);\n\n  // Emit tool execution info to client\n  socket.emit('chat:chunk', {\n    conversationId,\n    chunk: '', // No visible chunk, tool executed silently\n    done: false,\n  });\n\n  // Add assistant message with tool call and tool result to messages\n  const updatedMessages = [\n    ...messages,\n    {\n      role: 'assistant',\n      content: '',\n      tool_calls: [toolCall],\n    },\n    {\n      role: 'tool',\n      content: result.result,\n      tool_call_id: toolCallId,\n    },\n  ];\n\n  // Continue conversation with tool result (without tools to get natural response)\n  return await streamGroqResponse(socket, conversationId, updatedMessages, signal, tools);\n}",
      "references": [
        "Date",
        "toolCallId",
        "console",
        "executeTool",
        "toolCall",
        "result",
        "streamGroqResponse",
        "updatedMessages"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:streamGroqResponse:718": {
      "id": "file:src/api/socket/handlers.ts:fn:streamGroqResponse:718",
      "type": "function",
      "name": "streamGroqResponse",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 718,
      "endLine": 983,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "messages",
          "type": "{ role: string; content: string; tool_calls?: import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolCall[]; tool_call_id?: string; }[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "signal",
          "type": "AbortSignal",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tools",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolDefinition[]",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number; }; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Streams LLM chat completion from Groq/XAI/Gemini API to socket with tools and timeout",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function streamGroqResponse(\n  socket: TypedSocket,\n  conversationId: string,\n  messages: Array<{ role: string; content: string; tool_calls?: ToolCall[]; tool_call_id?: string }>,\n  signal: AbortSignal,\n  tools?: ToolDefinition[]\n): Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number } }> {\n  // Select API key and endpoint based on provider\n  const provider = config.llm.provider;\n  let apiKey: string;\n  let apiEndpoint: string;\n\n  if (provider === 'xai') {\n    apiKey = config.llm.xaiApiKey;\n    apiEndpoint = 'https://api.x.ai/v1/chat/completions';\n  } else if (provider === 'gemini') {\n    apiKey = config.llm.geminiApiKey;\n    apiEndpoint = 'https://generativelanguage.googleapis.com/v1beta/openai/chat/completions';\n  } else {\n    // Default to Groq\n    apiKey = config.llm.groqApiKey;\n    apiEndpoint = 'https://api.groq.com/openai/v1/chat/completions';\n  }\n\n  if (!apiKey) {\n    socket.emit('chat:error', {\n      conversationId,\n      error: `LLM service not configured (${provider})`,\n      code: 'LLM_NOT_CONFIGURED',\n    });\n    return { content: '' };\n  }\n\n  // Create a combined abort signal with timeout\n  const API_TIMEOUT_MS = 30000; // 30 second timeout\n  const timeoutController = new AbortController();\n  const timeoutId = setTimeout(() => {\n    console.log(`[Socket] ${provider} API timeout after ${API_TIMEOUT_MS}ms`);\n    timeoutController.abort();\n  }, API_TIMEOUT_MS);\n\n  // Abort if either the external signal or timeout fires\n  signal.addEventListener('abort', () => timeoutController.abort());\n\n  // Build request body\n  const requestBody: Record<string, unknown> = {\n    model: config.llm.model,\n    messages,\n    max_tokens: config.llm.maxTokens,\n    temperature: config.llm.temperature,\n    stream: true,\n  };\n\n  // Add tools if available\n  if (tools && tools.length > 0) {\n    requestBody.tools = tools;\n    requestBody.tool_choice = 'auto';\n  }\n\n  try {\n    const response = await fetch(apiEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify(requestBody),\n      signal: timeoutController.signal,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`${provider} API error: ${response.status} - ${errorText}`);\n    }\n\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error('No response body');\n    }\n\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let totalTokens = 0;\n    let fullContent = '';\n\n    // Track tool calls as they stream in\n    const accumulatedToolCalls: Map<number, StreamingToolCall> = new Map();\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        const chunk = decoder.decode(value, { stream: true });\n        buffer += chunk;\n\n        // Debug: log first chunk to see raw response\n        if (totalTokens === 0 && fullContent === '') {\n          console.log(`[Socket] First stream chunk (${chunk.length} chars): ${chunk.substring(0, 500)}`);\n        }\n\n        // Process complete SSE messages\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || '';\n\n        for (const line of lines) {\n          // Handle SSE error events\n          if (line.startsWith('event: error')) {\n            console.log(`[Socket] ${provider} SSE error event received`);\n            continue; // Next line will have the error data\n          }\n\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6);\n\n            // Check if this is an error response\n            try {\n              const errorCheck = JSON.parse(data);\n              if (errorCheck.error) {\n                console.log(`[Socket] ${provider} API error: ${errorCheck.error.message}`);\n                // If tool calling failed, try to parse Llama's XML-style function call\n                if (errorCheck.error.code === 'tool_use_failed' && errorCheck.error.failed_generation) {\n                  const parsed = parseLlamaFunctionCall(errorCheck.error.failed_generation);\n                  if (parsed) {\n                    console.log(`[Socket] Parsed Llama XML function call: ${parsed.name}`);\n                    return await executeParsedToolAndContinue(\n                      socket,\n                      conversationId,\n                      messages,\n                      parsed,\n                      signal,\n                      tools\n                    );\n                  }\n                  // If parsing failed, retry without tools\n                  console.log(`[Socket] Tool use failed, could not parse, retrying without tools...`);\n                  return await streamGroqResponse(socket, conversationId, messages, signal, undefined);\n                }\n                socket.emit('chat:error', {\n                  conversationId,\n                  error: errorCheck.error.message,\n                  code: 'GROQ_API_ERROR',\n                });\n                return { content: '', usage: { promptTokens: 0, completionTokens: 0 } };\n              }\n            } catch {\n              // Not an error, continue normal processing\n            }\n\n            if (data === '[DONE]') {\n              console.log(`[Socket] Stream [DONE] received. Tool calls accumulated: ${accumulatedToolCalls.size}`);\n              // Check if we have tool calls to execute\n              if (accumulatedToolCalls.size > 0) {\n                return await handleToolCallsAndContinue(\n                  socket,\n                  conversationId,\n                  messages,\n                  fullContent,\n                  accumulatedToolCalls,\n                  signal,\n                  tools,\n                  totalTokens\n                );\n              }\n              return { content: fullContent, usage: { promptTokens: 0, completionTokens: totalTokens } };\n            }\n\n            try {\n              const parsed = JSON.parse(data) as {\n                choices: Array<{\n                  delta: {\n                    content?: string;\n                    tool_calls?: Array<{\n                      index: number;\n                      id?: string;\n                      type?: 'function';\n                      function?: {\n                        name?: string;\n                        arguments?: string;\n                      };\n                    }>;\n                  };\n                  finish_reason?: string | null;\n                }>;\n              };\n\n              const delta = parsed.choices[0]?.delta;\n              const finishReason = parsed.choices[0]?.finish_reason;\n\n              // Debug: log tool calls and finish reasons\n              if (delta?.tool_calls || finishReason) {\n                console.log(`[Socket] Stream delta: finish_reason=${finishReason}, tool_calls=${JSON.stringify(delta?.tool_calls)}`);\n              }\n\n              // Handle text content\n              if (delta?.content) {\n                fullContent += delta.content;\n                totalTokens++;\n                socket.emit('chat:chunk', {\n                  conversationId,\n                  chunk: delta.content,\n                  done: false,\n                });\n              }\n\n              // Handle streaming tool calls\n              if (delta?.tool_calls) {\n                for (const tc of delta.tool_calls) {\n                  const existing = accumulatedToolCalls.get(tc.index);\n\n                  if (existing) {\n                    // Append to existing tool call arguments\n                    if (tc.function?.arguments) {\n                      existing.function.arguments += tc.function.arguments;\n                    }\n                  } else if (tc.id && tc.function?.name) {\n                    // New tool call\n                    accumulatedToolCalls.set(tc.index, {\n                      id: tc.id,\n                      type: 'function',\n                      function: {\n                        name: tc.function.name,\n                        arguments: tc.function.arguments || '',\n                      },\n                    });\n                  }\n                }\n              }\n\n              if (finishReason === 'tool_calls') {\n                // Model wants to call tools\n                return await handleToolCallsAndContinue(\n                  socket,\n                  conversationId,\n                  messages,\n                  fullContent,\n                  accumulatedToolCalls,\n                  signal,\n                  tools,\n                  totalTokens\n                );\n              }\n\n              if (finishReason === 'stop') {\n                return { content: fullContent, usage: { promptTokens: 0, completionTokens: totalTokens } };\n              }\n            } catch {\n              // Skip malformed JSON\n            }\n          }\n        }\n      }\n\n      // If we exit the loop without explicit return, return what we have\n      console.log(`[Socket] Stream loop ended. Content: ${fullContent.length} chars, tokens: ${totalTokens}, tool calls: ${accumulatedToolCalls.size}, buffer remaining: ${buffer.length}`);\n      return { content: fullContent, usage: { promptTokens: 0, completionTokens: totalTokens } };\n    } finally {\n      reader.releaseLock();\n    }\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}",
      "references": [
        "config",
        "provider",
        "apiKey",
        "apiEndpoint",
        "AbortController",
        "setTimeout",
        "console",
        "API_TIMEOUT_MS",
        "timeoutController",
        "requestBody",
        "fetch",
        "JSON",
        "response",
        "Error",
        "errorText",
        "reader",
        "TextDecoder",
        "Map",
        "done",
        "value",
        "decoder",
        "buffer",
        "chunk",
        "totalTokens",
        "fullContent",
        "lines",
        "line",
        "data",
        "errorCheck",
        "parseLlamaFunctionCall",
        "parsed",
        "executeParsedToolAndContinue",
        "streamGroqResponse",
        "accumulatedToolCalls",
        "handleToolCallsAndContinue",
        "delta",
        "finishReason",
        "tc",
        "existing",
        "clearTimeout",
        "timeoutId"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:handleToolCallsAndContinue:988": {
      "id": "file:src/api/socket/handlers.ts:fn:handleToolCallsAndContinue:988",
      "type": "function",
      "name": "handleToolCallsAndContinue",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 988,
      "endLine": 1052,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "messages",
          "type": "{ role: string; content: string; tool_calls?: import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolCall[]; tool_call_id?: string; }[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "contentSoFar",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "accumulatedToolCalls",
          "type": "Map<number, StreamingToolCall>",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "signal",
          "type": "AbortSignal",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tools",
          "type": "import(\"/home/ridgetop/projects/squire/src/tools/types\").ToolDefinition[]",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "tokensSoFar",
          "type": "number",
          "isOptional": true,
          "defaultValue": "0"
        }
      ],
      "returnType": "Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number; }; }>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Executes tool calls, appends results to messages, and continues streaming Groq AI response via socket.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function handleToolCallsAndContinue(\n  socket: TypedSocket,\n  conversationId: string,\n  messages: Array<{ role: string; content: string; tool_calls?: ToolCall[]; tool_call_id?: string }>,\n  contentSoFar: string,\n  accumulatedToolCalls: Map<number, StreamingToolCall>,\n  signal: AbortSignal,\n  tools?: ToolDefinition[],\n  tokensSoFar: number = 0\n): Promise<{ content: string; usage?: { promptTokens: number; completionTokens: number } }> {\n  // Convert accumulated tool calls to array\n  const toolCalls: ToolCall[] = Array.from(accumulatedToolCalls.values()).map((tc) => ({\n    id: tc.id,\n    type: tc.type,\n    function: {\n      name: tc.function.name,\n      arguments: tc.function.arguments,\n    },\n  }));\n\n  console.log(`[Socket] Executing ${toolCalls.length} tool call(s): ${toolCalls.map((tc) => tc.function.name).join(', ')}`);\n\n  // Execute all tool calls\n  const toolResults = await executeTools(toolCalls);\n\n  // Log results\n  for (const result of toolResults) {\n    console.log(`[Socket] Tool ${result.name}: ${result.success ? 'success' : 'failed'} - ${result.result.substring(0, 100)}`);\n  }\n\n  // Build updated messages array\n  const updatedMessages = [\n    ...messages,\n    // Assistant message with tool calls\n    {\n      role: 'assistant',\n      content: contentSoFar || '',\n      tool_calls: toolCalls,\n    },\n    // Tool results\n    ...toolResults.map((result) => ({\n      role: 'tool',\n      tool_call_id: result.toolCallId,\n      content: result.result,\n    })),\n  ];\n\n  // Continue streaming with tool results\n  const continuedResult = await streamGroqResponse(\n    socket,\n    conversationId,\n    updatedMessages,\n    signal,\n    tools\n  );\n\n  // Combine content\n  return {\n    content: contentSoFar + continuedResult.content,\n    usage: {\n      promptTokens: 0,\n      completionTokens: tokensSoFar + (continuedResult.usage?.completionTokens || 0),\n    },\n  };\n}",
      "references": [
        "Array",
        "tc",
        "console",
        "toolCalls",
        "executeTools",
        "toolResults",
        "result",
        "streamGroqResponse",
        "updatedMessages",
        "continuedResult"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:handleChatCancel:1057": {
      "id": "file:src/api/socket/handlers.ts:fn:handleChatCancel:1057",
      "type": "function",
      "name": "handleChatCancel",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1057,
      "endLine": 1070,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/api/socket/types\").ChatCancelPayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Cancels active chat stream by aborting controller, cleans state, emits 'chat:done'",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function handleChatCancel(socket: TypedSocket, payload: ChatCancelPayload): void {\n  const { conversationId } = payload;\n  console.log(`[Socket] chat:cancel from ${socket.id} - conversation: ${conversationId}`);\n\n  const controller = activeStreams.get(conversationId);\n  if (controller) {\n    controller.abort();\n    activeStreams.delete(conversationId);\n\n    socket.emit('chat:done', {\n      conversationId,\n    });\n  }\n}",
      "references": [
        "conversationId",
        "console",
        "activeStreams",
        "controller"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:getConversationRoom:1075": {
      "id": "file:src/api/socket/handlers.ts:fn:getConversationRoom:1075",
      "type": "function",
      "name": "getConversationRoom",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1075,
      "endLine": 1077,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a room name by prefixing 'conversation:' to the given conversation ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.689Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getConversationRoom(conversationId: string): string {\n  return `conversation:${conversationId}`;\n}",
      "references": []
    },
    "file:src/api/socket/handlers.ts:fn:handleConversationJoin:1082": {
      "id": "file:src/api/socket/handlers.ts:fn:handleConversationJoin:1082",
      "type": "function",
      "name": "handleConversationJoin",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1082,
      "endLine": 1088,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/api/socket/types\").ConversationJoinPayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Joins socket to conversation room and logs the event",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function handleConversationJoin(socket: TypedSocket, payload: ConversationJoinPayload): void {\n  const { conversationId } = payload;\n  const room = getConversationRoom(conversationId);\n\n  socket.join(room);\n  console.log(`[Socket] ${socket.id} joined room ${room}`);\n}",
      "references": [
        "conversationId",
        "getConversationRoom",
        "room",
        "console"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:handleConversationLeave:1093": {
      "id": "file:src/api/socket/handlers.ts:fn:handleConversationLeave:1093",
      "type": "function",
      "name": "handleConversationLeave",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1093,
      "endLine": 1099,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "socket",
          "type": "TypedSocket",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "payload",
          "type": "import(\"/home/ridgetop/projects/squire/src/api/socket/types\").ConversationLeavePayload",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Makes socket leave conversation room and logs the event",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function handleConversationLeave(socket: TypedSocket, payload: ConversationLeavePayload): void {\n  const { conversationId } = payload;\n  const room = getConversationRoom(conversationId);\n\n  socket.leave(room);\n  console.log(`[Socket] ${socket.id} left room ${room}`);\n}",
      "references": [
        "conversationId",
        "getConversationRoom",
        "room",
        "console"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:broadcastMessageSynced:1104": {
      "id": "file:src/api/socket/handlers.ts:fn:broadcastMessageSynced:1104",
      "type": "function",
      "name": "broadcastMessageSynced",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1104,
      "endLine": 1119,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "message",
          "type": "{ id: string; role: \"user\" | \"assistant\"; content: string; timestamp: string; }",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "originSocketId",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Broadcasts a synced message to all sockets in a conversation room via Socket.IO.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function broadcastMessageSynced(\n  io: TypedIO,\n  conversationId: string,\n  message: { id: string; role: 'user' | 'assistant'; content: string; timestamp: string },\n  originSocketId?: string\n): void {\n  const room = getConversationRoom(conversationId);\n  const socketsInRoom = io.sockets.adapter.rooms.get(room);\n  const socketCount = socketsInRoom?.size ?? 0;\n  console.log(`[Broadcast] message:synced to room ${room} (${socketCount} sockets) - ${message.role} from ${originSocketId}`);\n  io.to(room).emit('message:synced', {\n    conversationId,\n    message,\n    originSocketId,\n  });\n}",
      "references": [
        "getConversationRoom",
        "room",
        "socketsInRoom",
        "console",
        "socketCount"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:registerSocketHandlers:1124": {
      "id": "file:src/api/socket/handlers.ts:fn:registerSocketHandlers:1124",
      "type": "function",
      "name": "registerSocketHandlers",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1124,
      "endLine": 1156,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Registers socket.io event handlers for connections, chat, and conversations.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function registerSocketHandlers(io: TypedIO): void {\n  io.on('connection', (socket: TypedSocket) => {\n    // Store connection timestamp\n    socket.data.connectedAt = new Date();\n\n    console.log(`[Socket] Client connected: ${socket.id}`);\n\n    // Send connection confirmation\n    socket.emit('connection:status', {\n      connected: true,\n      socketId: socket.id,\n    });\n\n    // Register event handlers\n    socket.on('chat:message', (payload) => handleChatMessage(socket, io, payload));\n    socket.on('chat:cancel', (payload) => handleChatCancel(socket, payload));\n    socket.on('conversation:join', (payload) => handleConversationJoin(socket, payload));\n    socket.on('conversation:leave', (payload) => handleConversationLeave(socket, payload));\n\n    socket.on('ping', (callback) => {\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n\n    socket.on('disconnect', (reason) => {\n      console.log(`[Socket] Client disconnected: ${socket.id} (${reason})`);\n\n      // Cancel any active streams for this socket\n      // Note: In production, you'd track streams per socket\n    });\n  });\n}",
      "references": [
        "socket",
        "Date",
        "console",
        "handleChatMessage",
        "payload",
        "handleChatCancel",
        "handleConversationJoin",
        "handleConversationLeave",
        "callback",
        "reason"
      ]
    },
    "file:src/api/socket/handlers.ts:fn:broadcastMemoryCreated:1161": {
      "id": "file:src/api/socket/handlers.ts:fn:broadcastMemoryCreated:1161",
      "type": "function",
      "name": "broadcastMemoryCreated",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1161,
      "endLine": 1174,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memory",
          "type": "{ id: string; content: string; salience_score: number; source: string; created_at: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Broadcasts 'memory:created' Socket.IO event to all clients with memory data",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function broadcastMemoryCreated(\n  io: TypedIO,\n  memory: { id: string; content: string; salience_score: number; source: string; created_at: string }\n): void {\n  io.emit('memory:created', {\n    memory: {\n      id: memory.id,\n      content: memory.content,\n      salience: memory.salience_score,\n      source: memory.source,\n      created_at: memory.created_at,\n    },\n  });\n}",
      "references": []
    },
    "file:src/api/socket/handlers.ts:fn:broadcastInsightCreated:1179": {
      "id": "file:src/api/socket/handlers.ts:fn:broadcastInsightCreated:1179",
      "type": "function",
      "name": "broadcastInsightCreated",
      "filePath": "/home/ridgetop/projects/squire/src/api/socket/handlers.ts",
      "line": 1179,
      "endLine": 1192,
      "parentFileId": "file:src/api/socket/handlers.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "io",
          "type": "TypedIO",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "insight",
          "type": "{ id: string; content: string; insight_type: string; priority: string; created_at: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Broadcasts 'insight:created' event with insight data to all Socket.IO clients",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function broadcastInsightCreated(\n  io: TypedIO,\n  insight: { id: string; content: string; insight_type: string; priority: string; created_at: string }\n): void {\n  io.emit('insight:created', {\n    insight: {\n      id: insight.id,\n      content: insight.content,\n      type: insight.insight_type,\n      priority: insight.priority,\n      created_at: insight.created_at,\n    },\n  });\n}",
      "references": []
    },
    "file:src/api/socket/index.ts": {
      "id": "file:src/api/socket/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/api/socket/index.ts",
      "line": 1,
      "endLine": 10,
      "imports": [],
      "exports": [
        {
          "name": "registerSocketHandlers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "setSocketServer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastMemoryCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "broadcastInsightCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ChatMessagePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatCancelPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationJoinPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationLeavePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ClientToServerEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatChunkPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatContextPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatErrorPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatDonePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectionStatusPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CommitmentCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ReminderCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MessageSyncedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ServerToClientEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SocketData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "registerSocketHandlers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./handlers.js"
        },
        {
          "name": "setSocketServer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./broadcast.js"
        },
        {
          "name": "broadcastMemoryCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./broadcast.js"
        },
        {
          "name": "broadcastInsightCreated",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./broadcast.js"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/api/socket/types.ts": {
      "id": "file:src/api/socket/types.ts",
      "type": "file",
      "name": "types.ts",
      "filePath": "src/api/socket/types.ts",
      "line": 1,
      "endLine": 146,
      "imports": [],
      "exports": [
        {
          "name": "ChatMessagePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatCancelPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationJoinPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConversationLeavePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ClientToServerEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatChunkPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatContextPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatErrorPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatDonePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectionStatusPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CommitmentCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ReminderCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MessageSyncedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ServerToClientEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SocketData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/csvExtractor.ts": {
      "id": "file:src/services/documents/csvExtractor.ts",
      "type": "file",
      "name": "csvExtractor.ts",
      "filePath": "src/services/documents/csvExtractor.ts",
      "line": 1,
      "endLine": 224,
      "imports": [
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentMetadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countWords",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "csvExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/services/documents/csvExtractor.ts:fn:parseCSVLine:27"
      ],
      "classes": [
        "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60"
      ],
      "topLevelReferences": [
        "CSVExtractor"
      ]
    },
    "file:src/services/documents/csvExtractor.ts:fn:parseCSVLine:27": {
      "id": "file:src/services/documents/csvExtractor.ts:fn:parseCSVLine:27",
      "type": "function",
      "name": "parseCSVLine",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/csvExtractor.ts",
      "line": 27,
      "endLine": 55,
      "parentFileId": "file:src/services/documents/csvExtractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "line",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses a single CSV line into an array of strings, handling quoted fields and escaped quotes.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function parseCSVLine(line: string): string[] {\n  const result: string[] = [];\n  let current = '';\n  let inQuotes = false;\n\n  for (let i = 0; i < line.length; i++) {\n    const char = line[i];\n    const nextChar = line[i + 1];\n\n    if (char === '\"') {\n      if (inQuotes && nextChar === '\"') {\n        // Escaped quote\n        current += '\"';\n        i++;\n      } else {\n        // Toggle quote mode\n        inQuotes = !inQuotes;\n      }\n    } else if (char === ',' && !inQuotes) {\n      result.push(current.trim());\n      current = '';\n    } else {\n      current += char;\n    }\n  }\n\n  result.push(current.trim());\n  return result;\n}",
      "references": [
        "i",
        "char",
        "inQuotes",
        "nextChar",
        "current",
        "result"
      ]
    },
    "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:canHandle:68": {
      "id": "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:canHandle:68",
      "type": "function",
      "name": "canHandle",
      "filePath": "src/services/documents/csvExtractor.ts",
      "line": 68,
      "endLine": 70,
      "parentFileId": "file:src/services/documents/csvExtractor.ts",
      "parentClassId": "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60",
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "canHandle(mimeType: string): boolean {\n    return this.supportedMimeTypes.includes(mimeType.toLowerCase());\n  }",
      "references": []
    },
    "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:extract:72": {
      "id": "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:extract:72",
      "type": "function",
      "name": "extract",
      "filePath": "src/services/documents/csvExtractor.ts",
      "line": 72,
      "endLine": 219,
      "parentFileId": "file:src/services/documents/csvExtractor.ts",
      "parentClassId": "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60",
      "params": [
        {
          "name": "input",
          "type": "string | Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async extract(\n    input: Buffer | string,\n    options?: ExtractionOptions\n  ): Promise<ExtractionResult> {\n    const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n    const startTime = Date.now();\n    const warnings: string[] = [];\n\n    try {\n      // Get text content\n      let rawText: string;\n      let fileName: string | undefined;\n      let fileSize: number | undefined;\n\n      if (typeof input === 'string') {\n        // It's a file path\n        const buffer = await fs.readFile(input);\n        rawText = buffer.toString('utf-8');\n        fileName = input.split('/').pop();\n        const stats = await fs.stat(input);\n        fileSize = stats.size;\n      } else {\n        // It's a buffer\n        rawText = input.toString('utf-8');\n        fileSize = input.length;\n      }\n\n      // Handle BOM\n      if (rawText.charCodeAt(0) === 0xFEFF) {\n        rawText = rawText.slice(1);\n      }\n\n      // Check for empty document\n      if (!rawText || rawText.trim().length === 0) {\n        return {\n          success: true,\n          document: {\n            text: '',\n            metadata: {\n              wordCount: 0,\n              charCount: 0,\n              fileName,\n              fileSize,\n            },\n            pages: [],\n            format: 'txt',\n            extractedAt: new Date(),\n            extractionDurationMs: Date.now() - startTime,\n            warnings: ['Document is empty.'],\n          },\n        };\n      }\n\n      // Parse CSV\n      const lines = rawText.split(/\\r?\\n/).filter(line => line.trim().length > 0);\n\n      if (lines.length === 0) {\n        return {\n          success: true,\n          document: {\n            text: '',\n            metadata: { wordCount: 0, charCount: 0, fileName, fileSize },\n            pages: [],\n            format: 'txt',\n            extractedAt: new Date(),\n            extractionDurationMs: Date.now() - startTime,\n            warnings: ['CSV file has no data rows.'],\n          },\n        };\n      }\n\n      // First line is header\n      const headers = parseCSVLine(lines[0]!);\n      const dataRows = lines.slice(1);\n\n      // Convert to readable format\n      const formattedRows: string[] = [];\n      let rowNum = 0;\n\n      for (const line of dataRows) {\n        rowNum++;\n        const values = parseCSVLine(line);\n\n        // Build \"Column=Value\" pairs\n        const pairs: string[] = [];\n        for (let i = 0; i < headers.length; i++) {\n          const header = headers[i] || `Column${i + 1}`;\n          const value = values[i] || '';\n          if (value) {\n            pairs.push(`${header}=${value}`);\n          }\n        }\n\n        if (pairs.length > 0) {\n          formattedRows.push(`Row ${rowNum}: ${pairs.join(', ')}`);\n        }\n\n        // Check if we're exceeding max length\n        const currentText = formattedRows.join('\\n');\n        if (currentText.length > opts.maxTextLength) {\n          warnings.push(`CSV truncated after ${rowNum} rows (max text length reached).`);\n          break;\n        }\n      }\n\n      const text = formattedRows.join('\\n');\n\n      // Build metadata\n      const metadata: DocumentMetadata = {\n        title: fileName?.replace(/\\.csv$/i, ''),\n        wordCount: countWords(text),\n        charCount: text.length,\n        fileName,\n        fileSize,\n      };\n\n      const document: ExtractedDocument = {\n        text,\n        metadata,\n        pages: [],\n        format: 'txt',\n        extractedAt: new Date(),\n        extractionDurationMs: Date.now() - startTime,\n        warnings,\n      };\n\n      return {\n        success: true,\n        document,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (message?.includes('ENOENT')) {\n        return {\n          success: false,\n          error: 'File not found',\n          errorCode: 'CORRUPTED_FILE',\n        };\n      }\n\n      return {\n        success: false,\n        error: `CSV extraction failed: ${message}`,\n        errorCode: 'UNKNOWN_ERROR',\n      };\n    }\n  }",
      "references": [
        "DEFAULT_EXTRACTION_OPTIONS",
        "Date",
        "fs",
        "rawText",
        "buffer",
        "fileName",
        "fileSize",
        "stats",
        "startTime",
        "line",
        "lines",
        "parseCSVLine",
        "dataRows",
        "rowNum",
        "i",
        "headers",
        "values",
        "value",
        "pairs",
        "header",
        "formattedRows",
        "currentText",
        "opts",
        "warnings",
        "countWords",
        "text",
        "metadata",
        "document",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60": {
      "id": "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60",
      "type": "class",
      "name": "CSVExtractor",
      "filePath": "src/services/documents/csvExtractor.ts",
      "line": 60,
      "endLine": 220,
      "parentFileId": "file:src/services/documents/csvExtractor.ts",
      "methods": [
        "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:canHandle:68",
        "file:src/services/documents/csvExtractor.ts:class:CSVExtractor:60:method:extract:72"
      ],
      "properties": [
        {
          "name": "supportedFormats",
          "type": "(\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\")[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        },
        {
          "name": "supportedMimeTypes",
          "type": "string[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "DocumentExtractor"
      ]
    },
    "file:src/services/documents/docxExtractor.ts": {
      "id": "file:src/services/documents/docxExtractor.ts",
      "type": "file",
      "name": "docxExtractor.ts",
      "filePath": "src/services/documents/docxExtractor.ts",
      "line": 1,
      "endLine": 151,
      "imports": [
        {
          "source": "mammoth",
          "items": [
            {
              "name": "mammoth",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentMetadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countWords",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "docxExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [
        "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22"
      ],
      "topLevelReferences": [
        "DocxExtractor"
      ]
    },
    "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:canHandle:28": {
      "id": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:canHandle:28",
      "type": "function",
      "name": "canHandle",
      "filePath": "src/services/documents/docxExtractor.ts",
      "line": 28,
      "endLine": 30,
      "parentFileId": "file:src/services/documents/docxExtractor.ts",
      "parentClassId": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22",
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "canHandle(mimeType: string): boolean {\n    return this.supportedMimeTypes.includes(mimeType.toLowerCase());\n  }",
      "references": []
    },
    "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extract:32": {
      "id": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extract:32",
      "type": "function",
      "name": "extract",
      "filePath": "src/services/documents/docxExtractor.ts",
      "line": 32,
      "endLine": 132,
      "parentFileId": "file:src/services/documents/docxExtractor.ts",
      "parentClassId": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22",
      "params": [
        {
          "name": "input",
          "type": "string | Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async extract(\n    input: Buffer | string,\n    options?: ExtractionOptions\n  ): Promise<ExtractionResult> {\n    const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n    const startTime = Date.now();\n    const warnings: string[] = [];\n\n    try {\n      // Prepare input for mammoth\n      let mammothInput: { buffer: Buffer } | { path: string };\n      if (typeof input === 'string') {\n        mammothInput = { path: input };\n      } else {\n        mammothInput = { buffer: input };\n      }\n\n      // Extract text using mammoth\n      const result = await mammoth.extractRawText(mammothInput);\n\n      // Collect any messages as warnings\n      if (result.messages && result.messages.length > 0) {\n        for (const msg of result.messages) {\n          warnings.push(`${msg.type}: ${msg.message}`);\n        }\n      }\n\n      let text = result.value;\n\n      // Check for empty document\n      if (!text || text.trim().length === 0) {\n        return {\n          success: true,\n          document: {\n            text: '',\n            metadata: {\n              wordCount: 0,\n              charCount: 0,\n            },\n            pages: [],\n            format: 'docx',\n            extractedAt: new Date(),\n            extractionDurationMs: Date.now() - startTime,\n            warnings: ['Document contains no text.'],\n          },\n        };\n      }\n\n      // Truncate if needed\n      if (text.length > opts.maxTextLength) {\n        text = text.slice(0, opts.maxTextLength);\n        warnings.push(`Text truncated to ${opts.maxTextLength} characters.`);\n      }\n\n      // Build metadata (DOCX doesn't expose much metadata via mammoth)\n      const metadata: DocumentMetadata = {\n        wordCount: countWords(text),\n        charCount: text.length,\n      };\n\n      // Try to extract additional metadata from core.xml if we have a buffer\n      if (typeof input !== 'string') {\n        const coreMetadata = await this.extractCoreMetadata(input);\n        if (coreMetadata.title) metadata.title = coreMetadata.title;\n        if (coreMetadata.author) metadata.author = coreMetadata.author;\n        if (coreMetadata.createdAt) metadata.createdAt = coreMetadata.createdAt;\n        if (coreMetadata.modifiedAt) metadata.modifiedAt = coreMetadata.modifiedAt;\n      }\n\n      const document: ExtractedDocument = {\n        text,\n        metadata,\n        pages: [], // DOCX doesn't have page concept in extraction\n        format: 'docx',\n        extractedAt: new Date(),\n        extractionDurationMs: Date.now() - startTime,\n        warnings,\n      };\n\n      return {\n        success: true,\n        document,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (message.includes('Could not find') || message.includes('not a valid')) {\n        return {\n          success: false,\n          error: 'File is not a valid DOCX document',\n          errorCode: 'CORRUPTED_FILE',\n        };\n      }\n\n      return {\n        success: false,\n        error: `DOCX extraction failed: ${message}`,\n        errorCode: 'UNKNOWN_ERROR',\n      };\n    }\n  }",
      "references": [
        "DEFAULT_EXTRACTION_OPTIONS",
        "Date",
        "mammothInput",
        "mammoth",
        "result",
        "warnings",
        "msg",
        "text",
        "startTime",
        "opts",
        "countWords",
        "coreMetadata",
        "metadata",
        "document",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extractCoreMetadata:137": {
      "id": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extractCoreMetadata:137",
      "type": "function",
      "name": "extractCoreMetadata",
      "filePath": "src/services/documents/docxExtractor.ts",
      "line": 137,
      "endLine": 146,
      "parentFileId": "file:src/services/documents/docxExtractor.ts",
      "parentClassId": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22",
      "params": [
        {
          "name": "_buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Partial<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").DocumentMetadata>>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "private async extractCoreMetadata(_buffer: Buffer): Promise<Partial<DocumentMetadata>> {\n    try {\n      // DOCX is a ZIP file; we could use JSZip to extract docProps/core.xml\n      // For now, return empty - this can be enhanced later\n      // The metadata extraction would require adding JSZip as a dependency\n      return {};\n    } catch {\n      return {};\n    }\n  }",
      "references": []
    },
    "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22": {
      "id": "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22",
      "type": "class",
      "name": "DocxExtractor",
      "filePath": "src/services/documents/docxExtractor.ts",
      "line": 22,
      "endLine": 147,
      "parentFileId": "file:src/services/documents/docxExtractor.ts",
      "methods": [
        "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:canHandle:28",
        "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extract:32",
        "file:src/services/documents/docxExtractor.ts:class:DocxExtractor:22:method:extractCoreMetadata:137"
      ],
      "properties": [
        {
          "name": "supportedFormats",
          "type": "(\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\")[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        },
        {
          "name": "supportedMimeTypes",
          "type": "string[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "DocumentExtractor"
      ]
    },
    "file:src/services/documents/ephemeral.ts": {
      "id": "file:src/services/documents/ephemeral.ts",
      "type": "file",
      "name": "ephemeral.ts",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 1,
      "endLine": 432,
      "imports": [
        {
          "source": "../../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./extractor.js",
          "items": [
            {
              "name": "extractFromBuffer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chunker/fixedChunker.js",
          "items": [
            {
              "name": "countTokens",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "truncateToTokens",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "crypto",
          "items": [
            {
              "name": "crypto",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "extractEphemeral",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "summarizeDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "askDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCacheStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearCaches",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearDocumentCache",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EphemeralDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarizeOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarizeResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AskOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AskResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/documents/ephemeral.ts:fn:hashBuffer:179",
        "file:src/services/documents/ephemeral.ts:fn:summaryKey:186",
        "file:src/services/documents/ephemeral.ts:fn:answerKey:193",
        "file:src/services/documents/ephemeral.ts:fn:extractEphemeral:206",
        "file:src/services/documents/ephemeral.ts:fn:summarizeDocument:253",
        "file:src/services/documents/ephemeral.ts:fn:askDocument:332",
        "file:src/services/documents/ephemeral.ts:fn:getCacheStats:400",
        "file:src/services/documents/ephemeral.ts:fn:clearCaches:415",
        "file:src/services/documents/ephemeral.ts:fn:clearDocumentCache:424"
      ],
      "classes": [
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107"
      ],
      "topLevelReferences": [
        "TTLCache",
        "setInterval",
        "documentCache",
        "summaryCache",
        "answerCache"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:hashBuffer:179": {
      "id": "file:src/services/documents/ephemeral.ts:fn:hashBuffer:179",
      "type": "function",
      "name": "hashBuffer",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 179,
      "endLine": 181,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Computes SHA256 hash of buffer and returns first 16 hex characters.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function hashBuffer(buffer: Buffer): string {\n  return crypto.createHash('sha256').update(buffer).digest('hex').slice(0, 16);\n}",
      "references": [
        "crypto"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:summaryKey:186": {
      "id": "file:src/services/documents/ephemeral.ts:fn:summaryKey:186",
      "type": "function",
      "name": "summaryKey",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 186,
      "endLine": 188,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "docHash",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").SummarizeOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a cache key for document summary based on hash and options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function summaryKey(docHash: string, options: SummarizeOptions): string {\n  return `sum:${docHash}:${options.style ?? 'brief'}:${options.focus ?? ''}`;\n}",
      "references": []
    },
    "file:src/services/documents/ephemeral.ts:fn:answerKey:193": {
      "id": "file:src/services/documents/ephemeral.ts:fn:answerKey:193",
      "type": "function",
      "name": "answerKey",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 193,
      "endLine": 196,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "docHash",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "question",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates 'ask:' prefixed key from docHash and first 8 chars of question's SHA256 hash.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function answerKey(docHash: string, question: string): string {\n  const questionHash = crypto.createHash('sha256').update(question).digest('hex').slice(0, 8);\n  return `ask:${docHash}:${questionHash}`;\n}",
      "references": [
        "crypto",
        "questionHash"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:extractEphemeral:206": {
      "id": "file:src/services/documents/ephemeral.ts:fn:extractEphemeral:206",
      "type": "function",
      "name": "extractEphemeral",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 206,
      "endLine": 245,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "filename",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").EphemeralDocument>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts text from buffer to EphemeralDocument with hash-based caching",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractEphemeral(\n  buffer: Buffer,\n  mimeType: string,\n  filename: string\n): Promise<EphemeralDocument> {\n  const hash = hashBuffer(buffer);\n\n  // Check cache\n  const cached = documentCache.get(hash);\n  if (cached) {\n    return cached;\n  }\n\n  // Extract text\n  const result = await extractFromBuffer(buffer, mimeType);\n\n  if (!result.success || !result.document) {\n    throw new Error(result.error ?? 'Document extraction failed');\n  }\n\n  const doc: EphemeralDocument = {\n    hash,\n    text: result.document.text,\n    tokenCount: countTokens(result.document.text),\n    filename,\n    mimeType,\n    extractedAt: new Date(),\n    metadata: {\n      title: result.document.metadata.title,\n      author: result.document.metadata.author,\n      pageCount: result.document.metadata.pageCount,\n      wordCount: result.document.metadata.wordCount,\n    },\n  };\n\n  // Cache the extracted document\n  documentCache.set(hash, doc);\n\n  return doc;\n}",
      "references": [
        "hashBuffer",
        "documentCache",
        "hash",
        "cached",
        "extractFromBuffer",
        "result",
        "Error",
        "countTokens",
        "Date",
        "doc"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:summarizeDocument:253": {
      "id": "file:src/services/documents/ephemeral.ts:fn:summarizeDocument:253",
      "type": "function",
      "name": "summarizeDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 253,
      "endLine": 324,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "filename",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").SummarizeOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").SummarizeResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Summarizes document from buffer using LLM after extraction and cache check",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function summarizeDocument(\n  buffer: Buffer,\n  mimeType: string,\n  filename: string,\n  options: SummarizeOptions = {}\n): Promise<SummarizeResult> {\n  const { style = 'brief', maxSummaryTokens = 500, focus } = options;\n\n  // Extract document\n  const doc = await extractEphemeral(buffer, mimeType, filename);\n\n  // Check summary cache\n  const cacheKey = summaryKey(doc.hash, options);\n  const cached = summaryCache.get(cacheKey);\n  if (cached) {\n    return { ...cached, cached: true };\n  }\n\n  // Build prompt based on style\n  let styleInstructions = '';\n  switch (style) {\n    case 'brief':\n      styleInstructions = 'Provide a concise summary in 2-3 sentences.';\n      break;\n    case 'detailed':\n      styleInstructions = 'Provide a comprehensive summary covering all main points.';\n      break;\n    case 'bullet-points':\n      styleInstructions = 'Summarize as a bulleted list of key points.';\n      break;\n  }\n\n  const focusInstructions = focus ? `\\n\\nFocus particularly on: ${focus}` : '';\n\n  // Truncate document if too long (leave room for prompt and response)\n  const maxDocTokens = 30000; // Leave room for prompt overhead\n  const docText = doc.tokenCount > maxDocTokens\n    ? truncateToTokens(doc.text, maxDocTokens) + '\\n\\n[Document truncated due to length]'\n    : doc.text;\n\n  const messages: LLMMessage[] = [\n    {\n      role: 'system',\n      content: `You are a document summarization assistant. ${styleInstructions}${focusInstructions}`,\n    },\n    {\n      role: 'user',\n      content: `Please summarize the following document:\\n\\n---\\n\\n${docText}`,\n    },\n  ];\n\n  const result = await complete(messages, {\n    maxTokens: maxSummaryTokens,\n    temperature: 0.3, // Lower temperature for more focused summaries\n  });\n\n  const summarizeResult: SummarizeResult = {\n    summary: result.content,\n    documentInfo: {\n      filename: doc.filename,\n      tokenCount: doc.tokenCount,\n      pageCount: doc.metadata.pageCount,\n    },\n    usage: result.usage,\n    cached: false,\n  };\n\n  // Cache the result\n  summaryCache.set(cacheKey, summarizeResult);\n\n  return summarizeResult;\n}",
      "references": [
        "style",
        "maxSummaryTokens",
        "focus",
        "extractEphemeral",
        "summaryKey",
        "doc",
        "summaryCache",
        "cacheKey",
        "cached",
        "styleInstructions",
        "maxDocTokens",
        "truncateToTokens",
        "focusInstructions",
        "docText",
        "complete",
        "messages",
        "result",
        "summarizeResult"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:askDocument:332": {
      "id": "file:src/services/documents/ephemeral.ts:fn:askDocument:332",
      "type": "function",
      "name": "askDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 332,
      "endLine": 393,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "filename",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "question",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").AskOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/ephemeral\").AskResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries LLM about extracted document, caches/returns answer with citations.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export async function askDocument(\n  buffer: Buffer,\n  mimeType: string,\n  filename: string,\n  question: string,\n  options: AskOptions = {}\n): Promise<AskResult> {\n  const { maxAnswerTokens = 1000, includeCitations = true } = options;\n\n  // Extract document\n  const doc = await extractEphemeral(buffer, mimeType, filename);\n\n  // Check answer cache\n  const cacheKey = answerKey(doc.hash, question);\n  const cached = answerCache.get(cacheKey);\n  if (cached) {\n    return { ...cached, cached: true };\n  }\n\n  // Build prompt\n  const citationInstructions = includeCitations\n    ? 'When possible, reference specific parts of the document to support your answer.'\n    : '';\n\n  // Truncate document if too long\n  const maxDocTokens = 30000;\n  const docText = doc.tokenCount > maxDocTokens\n    ? truncateToTokens(doc.text, maxDocTokens) + '\\n\\n[Document truncated due to length]'\n    : doc.text;\n\n  const messages: LLMMessage[] = [\n    {\n      role: 'system',\n      content: `You are a document analysis assistant. Answer questions based on the provided document. ${citationInstructions} If the document doesn't contain information to answer the question, say so clearly.`,\n    },\n    {\n      role: 'user',\n      content: `Document:\\n\\n---\\n\\n${docText}\\n\\n---\\n\\nQuestion: ${question}`,\n    },\n  ];\n\n  const result = await complete(messages, {\n    maxTokens: maxAnswerTokens,\n    temperature: 0.4,\n  });\n\n  const askResult: AskResult = {\n    answer: result.content,\n    question,\n    documentInfo: {\n      filename: doc.filename,\n      tokenCount: doc.tokenCount,\n    },\n    usage: result.usage,\n    cached: false,\n  };\n\n  // Cache the result\n  answerCache.set(cacheKey, askResult);\n\n  return askResult;\n}",
      "references": [
        "maxAnswerTokens",
        "includeCitations",
        "extractEphemeral",
        "answerKey",
        "doc",
        "answerCache",
        "cacheKey",
        "cached",
        "maxDocTokens",
        "truncateToTokens",
        "citationInstructions",
        "docText",
        "complete",
        "messages",
        "result",
        "askResult"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:getCacheStats:400": {
      "id": "file:src/services/documents/ephemeral.ts:fn:getCacheStats:400",
      "type": "function",
      "name": "getCacheStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 400,
      "endLine": 410,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ documents: number; summaries: number; answers: number; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns counts of items in document, summary, and answer caches.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getCacheStats(): {\n  documents: number;\n  summaries: number;\n  answers: number;\n} {\n  return {\n    documents: documentCache.size,\n    summaries: summaryCache.size,\n    answers: answerCache.size,\n  };\n}",
      "references": [
        "documentCache",
        "summaryCache",
        "answerCache"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:clearCaches:415": {
      "id": "file:src/services/documents/ephemeral.ts:fn:clearCaches:415",
      "type": "function",
      "name": "clearCaches",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 415,
      "endLine": 419,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Clears document, summary, and answer caches.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.690Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function clearCaches(): void {\n  documentCache.clear();\n  summaryCache.clear();\n  answerCache.clear();\n}",
      "references": [
        "documentCache",
        "summaryCache",
        "answerCache"
      ]
    },
    "file:src/services/documents/ephemeral.ts:fn:clearDocumentCache:424": {
      "id": "file:src/services/documents/ephemeral.ts:fn:clearDocumentCache:424",
      "type": "function",
      "name": "clearDocumentCache",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/ephemeral.ts",
      "line": 424,
      "endLine": 431,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Triggers auto-expiration of document cache entry for buffer hash by accessing it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function clearDocumentCache(buffer: Buffer): void {\n  const hash = hashBuffer(buffer);\n\n  // We can't selectively clear related cache entries without iterating\n  // For now, just clear the document cache entry\n  // Summary and answer caches will expire naturally\n  documentCache.get(hash); // Access to check, then it auto-expires if called\n}",
      "references": [
        "hashBuffer",
        "documentCache",
        "hash"
      ]
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:set:115": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:set:115",
      "type": "function",
      "name": "set",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 115,
      "endLine": 120,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "params": [
        {
          "name": "key",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "value",
          "type": "T",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "set(key: string, value: T): void {\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + this.ttlMs,\n    });\n  }",
      "references": [
        "Date"
      ]
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:get:122": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:get:122",
      "type": "function",
      "name": "get",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 122,
      "endLine": 132,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "params": [
        {
          "name": "key",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "T",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "get(key: string): T | undefined {\n    const entry = this.cache.get(key);\n    if (!entry) return undefined;\n\n    if (Date.now() > entry.expiresAt) {\n      this.cache.delete(key);\n      return undefined;\n    }\n\n    return entry.value;\n  }",
      "references": [
        "entry",
        "Date"
      ]
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:has:134": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:has:134",
      "type": "function",
      "name": "has",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 134,
      "endLine": 136,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "params": [
        {
          "name": "key",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "has(key: string): boolean {\n    return this.get(key) !== undefined;\n  }",
      "references": []
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:clear:138": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:clear:138",
      "type": "function",
      "name": "clear",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 138,
      "endLine": 140,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "clear(): void {\n    this.cache.clear();\n  }",
      "references": []
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:prune:143": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:prune:143",
      "type": "function",
      "name": "prune",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 143,
      "endLine": 155,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "parentClassId": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "params": [],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "prune(): number {\n    const now = Date.now();\n    let pruned = 0;\n\n    for (const [key, entry] of this.cache) {\n      if (now > entry.expiresAt) {\n        this.cache.delete(key);\n        pruned++;\n      }\n    }\n\n    return pruned;\n  }",
      "references": [
        "Date",
        "key",
        "entry",
        "now",
        "pruned"
      ]
    },
    "file:src/services/documents/ephemeral.ts:class:TTLCache:107": {
      "id": "file:src/services/documents/ephemeral.ts:class:TTLCache:107",
      "type": "class",
      "name": "TTLCache",
      "filePath": "src/services/documents/ephemeral.ts",
      "line": 107,
      "endLine": 160,
      "parentFileId": "file:src/services/documents/ephemeral.ts",
      "methods": [
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:set:115",
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:get:122",
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:has:134",
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:clear:138",
        "file:src/services/documents/ephemeral.ts:class:TTLCache:107:method:prune:143"
      ],
      "properties": [
        {
          "name": "cache",
          "type": "Map<string, CacheEntry<T>>",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        },
        {
          "name": "ttlMs",
          "type": "number",
          "visibility": "private",
          "isStatic": false,
          "isReadonly": false
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": []
    },
    "file:src/services/documents/extractor.ts": {
      "id": "file:src/services/documents/extractor.ts",
      "type": "file",
      "name": "extractor.ts",
      "filePath": "src/services/documents/extractor.ts",
      "line": 1,
      "endLine": 221,
      "imports": [
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "path",
          "items": [
            {
              "name": "path",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ExtractionInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "isExtractableMimeType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EXTRACTABLE_MIME_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./pdfExtractor.js",
          "items": [
            {
              "name": "pdfExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./docxExtractor.js",
          "items": [
            {
              "name": "docxExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./textExtractor.js",
          "items": [
            {
              "name": "textExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./csvExtractor.js",
          "items": [
            {
              "name": "csvExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./ocrExtractor.js",
          "items": [
            {
              "name": "ocrExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "extractDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isSupported",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSupportedMimeTypes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFromFile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFromBuffer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/extractor.ts:fn:findExtractor:38",
        "file:src/services/documents/extractor.ts:fn:mimeFromExtension:51",
        "file:src/services/documents/extractor.ts:fn:extractDocument:95",
        "file:src/services/documents/extractor.ts:fn:isSupported:188",
        "file:src/services/documents/extractor.ts:fn:getSupportedMimeTypes:195",
        "file:src/services/documents/extractor.ts:fn:extractFromFile:202",
        "file:src/services/documents/extractor.ts:fn:extractFromBuffer:212"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/extractor.ts:fn:findExtractor:38": {
      "id": "file:src/services/documents/extractor.ts:fn:findExtractor:38",
      "type": "function",
      "name": "findExtractor",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 38,
      "endLine": 46,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").DocumentExtractor",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Finds the first DocumentExtractor that can handle the given MIME type, or null if none.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function findExtractor(mimeType: string): DocumentExtractor | null {\n  const lowerMime = mimeType.toLowerCase();\n  for (const extractor of extractors) {\n    if (extractor.canHandle(lowerMime)) {\n      return extractor;\n    }\n  }\n  return null;\n}",
      "references": [
        "extractors",
        "extractor",
        "lowerMime"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:mimeFromExtension:51": {
      "id": "file:src/services/documents/extractor.ts:fn:mimeFromExtension:51",
      "type": "function",
      "name": "mimeFromExtension",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 51,
      "endLine": 71,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "filePath",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns MIME type from file extension or null if unknown",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mimeFromExtension(filePath: string): string | null {\n  const ext = path.extname(filePath).toLowerCase();\n  const mimeMap: Record<string, string> = {\n    '.pdf': 'application/pdf',\n    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    '.doc': 'application/msword',\n    '.txt': 'text/plain',\n    '.md': 'text/markdown',\n    '.markdown': 'text/markdown',\n    '.csv': 'text/csv',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.webp': 'image/webp',\n    '.tiff': 'image/tiff',\n    '.tif': 'image/tiff',\n    '.bmp': 'image/bmp',\n    '.gif': 'image/gif',\n  };\n  return mimeMap[ext] || null;\n}",
      "references": [
        "path",
        "mimeMap",
        "ext"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:extractDocument:95": {
      "id": "file:src/services/documents/extractor.ts:fn:extractDocument:95",
      "type": "function",
      "name": "extractDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 95,
      "endLine": 183,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionInput",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts document content from buffer, file path, or object ID input using MIME-based extractors",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": true,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractDocument(\n  input: ExtractionInput,\n  options?: ExtractionOptions\n): Promise<ExtractionResult> {\n  try {\n    let buffer: Buffer | string;\n    let mimeType: string;\n\n    switch (input.type) {\n      case 'buffer': {\n        buffer = input.buffer;\n        mimeType = input.mimeType;\n        break;\n      }\n\n      case 'path': {\n        // Verify file exists\n        try {\n          await fs.access(input.filePath);\n        } catch {\n          return {\n            success: false,\n            error: `File not found: ${input.filePath}`,\n            errorCode: 'CORRUPTED_FILE',\n          };\n        }\n\n        // Use provided MIME type or detect from extension\n        mimeType = input.mimeType || mimeFromExtension(input.filePath) || '';\n        if (!mimeType) {\n          return {\n            success: false,\n            error: `Could not determine file type for: ${input.filePath}`,\n            errorCode: 'UNSUPPORTED_FORMAT',\n          };\n        }\n\n        buffer = input.filePath;\n        break;\n      }\n\n      case 'objectId': {\n        // TODO: Integrate with objects service to fetch file data\n        return {\n          success: false,\n          error: 'Object ID extraction not yet implemented',\n          errorCode: 'UNSUPPORTED_FORMAT',\n        };\n      }\n\n      default: {\n        return {\n          success: false,\n          error: 'Invalid extraction input type',\n          errorCode: 'UNKNOWN_ERROR',\n        };\n      }\n    }\n\n    // Validate MIME type is extractable\n    if (!isExtractableMimeType(mimeType)) {\n      return {\n        success: false,\n        error: `Unsupported file type: ${mimeType}`,\n        errorCode: 'UNSUPPORTED_FORMAT',\n      };\n    }\n\n    // Find appropriate extractor\n    const extractor = findExtractor(mimeType);\n    if (!extractor) {\n      return {\n        success: false,\n        error: `No extractor available for: ${mimeType}`,\n        errorCode: 'UNSUPPORTED_FORMAT',\n      };\n    }\n\n    // Perform extraction\n    return await extractor.extract(buffer, options);\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    return {\n      success: false,\n      error: `Extraction failed: ${message}`,\n      errorCode: 'UNKNOWN_ERROR',\n    };\n  }\n}",
      "references": [
        "buffer",
        "mimeType",
        "fs",
        "mimeFromExtension",
        "isExtractableMimeType",
        "findExtractor",
        "extractor",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:isSupported:188": {
      "id": "file:src/services/documents/extractor.ts:fn:isSupported:188",
      "type": "function",
      "name": "isSupported",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 188,
      "endLine": 190,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if the given MIME type is supported for extraction.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isSupported(mimeType: string): boolean {\n  return isExtractableMimeType(mimeType);\n}",
      "references": [
        "isExtractableMimeType"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:getSupportedMimeTypes:195": {
      "id": "file:src/services/documents/extractor.ts:fn:getSupportedMimeTypes:195",
      "type": "function",
      "name": "getSupportedMimeTypes",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 195,
      "endLine": 197,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "readonly string[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a readonly array of supported extractable MIME types.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getSupportedMimeTypes(): readonly string[] {\n  return EXTRACTABLE_MIME_TYPES;\n}",
      "references": [
        "EXTRACTABLE_MIME_TYPES"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:extractFromFile:202": {
      "id": "file:src/services/documents/extractor.ts:fn:extractFromFile:202",
      "type": "function",
      "name": "extractFromFile",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 202,
      "endLine": 207,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "filePath",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Wrapper that calls extractDocument with file path for extraction.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractFromFile(\n  filePath: string,\n  options?: ExtractionOptions\n): Promise<ExtractionResult> {\n  return extractDocument({ type: 'path', filePath }, options);\n}",
      "references": [
        "extractDocument"
      ]
    },
    "file:src/services/documents/extractor.ts:fn:extractFromBuffer:212": {
      "id": "file:src/services/documents/extractor.ts:fn:extractFromBuffer:212",
      "type": "function",
      "name": "extractFromBuffer",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/extractor.ts",
      "line": 212,
      "endLine": 218,
      "parentFileId": "file:src/services/documents/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts document from buffer by calling extractDocument with buffer data.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function extractFromBuffer(\n  buffer: Buffer,\n  mimeType: string,\n  options?: ExtractionOptions\n): Promise<ExtractionResult> {\n  return extractDocument({ type: 'buffer', buffer, mimeType }, options);\n}",
      "references": [
        "extractDocument"
      ]
    },
    "file:src/services/documents/index.ts": {
      "id": "file:src/services/documents/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/services/documents/index.ts",
      "line": 1,
      "endLine": 101,
      "imports": [],
      "exports": [
        {
          "name": "extractDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFromFile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFromBuffer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isSupported",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSupportedMimeTypes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pdfExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "docxExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "textExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ocrExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "searchDocuments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchDocumentsOptimized",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchForContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSearchStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentSearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "extractEphemeral",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "summarizeDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "askDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCacheStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearCaches",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EphemeralDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarizeOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarizeResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AskOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "AskResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFactEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFactDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FactExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FACT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FACT_ENTITY_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DATE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DEFAULT_FACT_EXTRACTION_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "rowToFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFactsFromChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFactsFromDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getExtractionProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "storeFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "storeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkFactToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "mergeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateBatchProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatchesByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isExtractableMimeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countWords",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EXTRACTABLE_MIME_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ExtractableMimeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentFormat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentPage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_EXTRACTION_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionErrorCode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "fixedChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "countTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "truncateToTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "semanticChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "detectSections",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "hybridChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "storeChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksBySimilarity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksByText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "embedAndStoreChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateQueryEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "rowToChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "chunkToRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "CHUNKING_STRATEGIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingStrategy",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ChunkingOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_CHUNKING_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DocumentChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkingResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CHUNKING_ERROR_CODES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingErrorCode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentSection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunkRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "extractDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "extractFromFile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "extractFromBuffer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "isSupported",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "getSupportedMimeTypes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "pdfExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./pdfExtractor.js"
        },
        {
          "name": "docxExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./docxExtractor.js"
        },
        {
          "name": "textExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./textExtractor.js"
        },
        {
          "name": "ocrExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ocrExtractor.js"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunker/index.js"
        },
        {
          "name": "searchDocuments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "searchDocumentsOptimized",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "searchForContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "getSearchStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "DocumentSearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "SearchOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "SearchResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "ContextChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./search.js"
        },
        {
          "name": "extractEphemeral",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "summarizeDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "askDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "getCacheStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "clearCaches",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "EphemeralDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "SummarizeOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "SummarizeResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "AskOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "AskResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ephemeral.js"
        },
        {
          "name": "ExtractedFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "ExtractedFactEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "ExtractedFactDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "ExtractedRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "FactType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "FactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "FactExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "ChunkExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "DocumentExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "FACT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "ENTITY_TYPES",
          "alias": "FACT_ENTITY_TYPES",
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "DATE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "DEFAULT_EXTRACTION_OPTIONS",
          "alias": "DEFAULT_FACT_EXTRACTION_OPTIONS",
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "rowToFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "extractFactsFromChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "extractFactsFromDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getExtractionProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "storeFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "storeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getPendingFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "linkFactToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "mergeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "deleteFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "deleteFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "deleteFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "createBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "updateBatchProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getBatchesByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        },
        {
          "name": "getFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./factExtraction/index.js"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/ocrExtractor.ts": {
      "id": "file:src/services/documents/ocrExtractor.ts",
      "type": "file",
      "name": "ocrExtractor.ts",
      "filePath": "src/services/documents/ocrExtractor.ts",
      "line": 1,
      "endLine": 178,
      "imports": [
        {
          "source": "tesseract.js",
          "items": [
            {
              "name": "Tesseract",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentMetadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countWords",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ocrExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [
        "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23"
      ],
      "topLevelReferences": [
        "OcrExtractor"
      ]
    },
    "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:canHandle:35": {
      "id": "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:canHandle:35",
      "type": "function",
      "name": "canHandle",
      "filePath": "src/services/documents/ocrExtractor.ts",
      "line": 35,
      "endLine": 37,
      "parentFileId": "file:src/services/documents/ocrExtractor.ts",
      "parentClassId": "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23",
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "canHandle(mimeType: string): boolean {\n    return this.supportedMimeTypes.includes(mimeType.toLowerCase());\n  }",
      "references": []
    },
    "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:extract:39": {
      "id": "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:extract:39",
      "type": "function",
      "name": "extract",
      "filePath": "src/services/documents/ocrExtractor.ts",
      "line": 39,
      "endLine": 173,
      "parentFileId": "file:src/services/documents/ocrExtractor.ts",
      "parentClassId": "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23",
      "params": [
        {
          "name": "input",
          "type": "string | Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async extract(\n    input: Buffer | string,\n    options?: ExtractionOptions\n  ): Promise<ExtractionResult> {\n    const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n    const startTime = Date.now();\n    const warnings: string[] = [];\n\n    try {\n      // Prepare image for Tesseract\n      let imageInput: Buffer | string;\n      let fileName: string | undefined;\n      let fileSize: number | undefined;\n\n      if (typeof input === 'string') {\n        imageInput = input;\n        fileName = input.split('/').pop();\n        const stats = await fs.stat(input);\n        fileSize = stats.size;\n      } else {\n        imageInput = input;\n        fileSize = input.length;\n      }\n\n      // Create a timeout promise\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => {\n          reject(new Error('OCR timeout exceeded'));\n        }, opts.timeoutMs);\n      });\n\n      // Run OCR with language setting\n      const ocrPromise = Tesseract.recognize(imageInput, opts.ocrLanguage, {\n        logger: () => {}, // Suppress logging\n      });\n\n      // Race between OCR and timeout\n      const result = await Promise.race([ocrPromise, timeoutPromise]);\n\n      // Extract text from result\n      let text = result.data.text;\n\n      // Filter by confidence if threshold is set\n      if (opts.ocrConfidenceThreshold > 0 && result.data.confidence < opts.ocrConfidenceThreshold * 100) {\n        warnings.push(\n          `Overall OCR confidence (${result.data.confidence.toFixed(1)}%) below threshold (${opts.ocrConfidenceThreshold * 100}%)`\n        );\n      }\n\n      // Clean up text\n      text = text.trim();\n\n      // Check for empty result\n      if (!text || text.length === 0) {\n        return {\n          success: true,\n          document: {\n            text: '',\n            metadata: {\n              wordCount: 0,\n              charCount: 0,\n              fileName,\n              fileSize,\n              extra: {\n                ocrConfidence: result.data.confidence,\n              },\n            },\n            pages: [],\n            format: 'image',\n            extractedAt: new Date(),\n            extractionDurationMs: Date.now() - startTime,\n            warnings: ['No text detected in image.'],\n          },\n        };\n      }\n\n      // Truncate if needed\n      if (text.length > opts.maxTextLength) {\n        text = text.slice(0, opts.maxTextLength);\n        warnings.push(`Text truncated to ${opts.maxTextLength} characters.`);\n      }\n\n      // Build metadata\n      const metadata: DocumentMetadata = {\n        wordCount: countWords(text),\n        charCount: text.length,\n        fileName,\n        fileSize,\n        language: opts.ocrLanguage,\n        extra: {\n          ocrConfidence: result.data.confidence,\n          ocrEngine: 'tesseract.js',\n        },\n      };\n\n      const document: ExtractedDocument = {\n        text,\n        metadata,\n        pages: [], // Single image = single \"page\"\n        format: 'image',\n        extractedAt: new Date(),\n        extractionDurationMs: Date.now() - startTime,\n        warnings,\n      };\n\n      return {\n        success: true,\n        document,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (message.includes('timeout')) {\n        return {\n          success: false,\n          error: 'OCR processing timed out',\n          errorCode: 'EXTRACTION_TIMEOUT',\n        };\n      }\n\n      if (message.includes('Invalid image') || message.includes('Could not read')) {\n        return {\n          success: false,\n          error: 'Invalid or corrupted image file',\n          errorCode: 'CORRUPTED_FILE',\n        };\n      }\n\n      return {\n        success: false,\n        error: `OCR extraction failed: ${message}`,\n        errorCode: 'OCR_FAILED',\n      };\n    }\n  }",
      "references": [
        "DEFAULT_EXTRACTION_OPTIONS",
        "Date",
        "imageInput",
        "fileName",
        "fs",
        "fileSize",
        "stats",
        "Promise",
        "setTimeout",
        "reject",
        "Error",
        "opts",
        "Tesseract",
        "ocrPromise",
        "timeoutPromise",
        "result",
        "warnings",
        "text",
        "startTime",
        "countWords",
        "metadata",
        "document",
        "error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23": {
      "id": "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23",
      "type": "class",
      "name": "OcrExtractor",
      "filePath": "src/services/documents/ocrExtractor.ts",
      "line": 23,
      "endLine": 174,
      "parentFileId": "file:src/services/documents/ocrExtractor.ts",
      "methods": [
        "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:canHandle:35",
        "file:src/services/documents/ocrExtractor.ts:class:OcrExtractor:23:method:extract:39"
      ],
      "properties": [
        {
          "name": "supportedFormats",
          "type": "(\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\")[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        },
        {
          "name": "supportedMimeTypes",
          "type": "string[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "DocumentExtractor"
      ]
    },
    "file:src/services/documents/pdfExtractor.ts": {
      "id": "file:src/services/documents/pdfExtractor.ts",
      "type": "file",
      "name": "pdfExtractor.ts",
      "filePath": "src/services/documents/pdfExtractor.ts",
      "line": 1,
      "endLine": 186,
      "imports": [
        {
          "source": "pdf-parse",
          "items": [
            {
              "name": "PDFParse",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentPage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentMetadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countWords",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "pdfExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [
        "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24"
      ],
      "topLevelReferences": [
        "PdfExtractor"
      ]
    },
    "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:canHandle:28": {
      "id": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:canHandle:28",
      "type": "function",
      "name": "canHandle",
      "filePath": "src/services/documents/pdfExtractor.ts",
      "line": 28,
      "endLine": 30,
      "parentFileId": "file:src/services/documents/pdfExtractor.ts",
      "parentClassId": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24",
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "canHandle(mimeType: string): boolean {\n    return this.supportedMimeTypes.includes(mimeType.toLowerCase());\n  }",
      "references": []
    },
    "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:extract:32": {
      "id": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:extract:32",
      "type": "function",
      "name": "extract",
      "filePath": "src/services/documents/pdfExtractor.ts",
      "line": 32,
      "endLine": 159,
      "parentFileId": "file:src/services/documents/pdfExtractor.ts",
      "parentClassId": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24",
      "params": [
        {
          "name": "input",
          "type": "string | Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async extract(\n    input: Buffer | string,\n    options?: ExtractionOptions\n  ): Promise<ExtractionResult> {\n    const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n    const startTime = Date.now();\n    const warnings: string[] = [];\n\n    let parser: PDFParse | null = null;\n\n    try {\n      // Get buffer from input\n      let buffer: Buffer;\n      if (typeof input === 'string') {\n        buffer = await fs.readFile(input);\n      } else {\n        buffer = input;\n      }\n\n      // Create parser instance\n      parser = new PDFParse({ data: buffer });\n\n      // Extract text\n      const textResult = await parser.getText();\n\n      // Extract metadata\n      const infoResult = await parser.getInfo();\n\n      // Build pages array from text result\n      const pages: DocumentPage[] = textResult.pages.map((page) => ({\n        pageNumber: page.num,\n        text: page.text,\n        wordCount: countWords(page.text),\n      }));\n\n      // Get full text\n      let fullText = textResult.text;\n\n      // Check for empty document\n      if (!fullText || fullText.trim().length === 0) {\n        warnings.push(\n          'PDF contains no extractable text. This may be a scanned document requiring OCR.'\n        );\n      }\n\n      // Truncate if needed\n      if (fullText.length > opts.maxTextLength) {\n        fullText = fullText.slice(0, opts.maxTextLength);\n        warnings.push(`Text truncated to ${opts.maxTextLength} characters.`);\n      }\n\n      // Build metadata\n      const info = infoResult.info || {};\n      const metadata: DocumentMetadata = {\n        title: info.Title || undefined,\n        author: info.Author || undefined,\n        createdAt: info.CreationDate ? this.parsePdfDate(info.CreationDate) : undefined,\n        modifiedAt: info.ModDate ? this.parsePdfDate(info.ModDate) : undefined,\n        pageCount: textResult.total,\n        wordCount: countWords(fullText),\n        charCount: fullText.length,\n        extra: {\n          producer: info.Producer,\n          creator: info.Creator,\n          subject: info.Subject,\n          keywords: info.Keywords,\n          fingerprints: infoResult.fingerprints,\n        },\n      };\n\n      // Build full text with page breaks if requested\n      let finalText = fullText;\n      if (opts.preservePageBreaks && pages.length > 1) {\n        finalText = pages\n          .map((p) => p.text)\n          .join('\\n\\n--- Page Break ---\\n\\n');\n      }\n\n      const document: ExtractedDocument = {\n        text: finalText,\n        metadata,\n        pages,\n        format: 'pdf',\n        extractedAt: new Date(),\n        extractionDurationMs: Date.now() - startTime,\n        warnings,\n      };\n\n      return {\n        success: true,\n        document,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n\n      // Detect specific error types\n      if (message.includes('password') || message.includes('encrypted')) {\n        return {\n          success: false,\n          error: 'PDF is password protected',\n          errorCode: 'PASSWORD_PROTECTED',\n        };\n      }\n\n      if (message.includes('Invalid PDF') || message.includes('corrupted')) {\n        return {\n          success: false,\n          error: 'PDF file is corrupted or invalid',\n          errorCode: 'CORRUPTED_FILE',\n        };\n      }\n\n      return {\n        success: false,\n        error: `PDF extraction failed: ${message}`,\n        errorCode: 'UNKNOWN_ERROR',\n      };\n    } finally {\n      // Clean up parser\n      if (parser) {\n        try {\n          await parser.destroy();\n        } catch {\n          // Ignore cleanup errors\n        }\n      }\n    }\n  }",
      "references": [
        "DEFAULT_EXTRACTION_OPTIONS",
        "Date",
        "buffer",
        "fs",
        "parser",
        "PDFParse",
        "textResult",
        "page",
        "countWords",
        "fullText",
        "warnings",
        "opts",
        "infoResult",
        "info",
        "pages",
        "finalText",
        "p",
        "metadata",
        "startTime",
        "document",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:parsePdfDate:164": {
      "id": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:parsePdfDate:164",
      "type": "function",
      "name": "parsePdfDate",
      "filePath": "src/services/documents/pdfExtractor.ts",
      "line": 164,
      "endLine": 181,
      "parentFileId": "file:src/services/documents/pdfExtractor.ts",
      "parentClassId": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24",
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Date",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "private parsePdfDate(dateStr: string): Date | undefined {\n    try {\n      // Remove 'D:' prefix if present\n      const cleaned = dateStr.replace(/^D:/, '');\n\n      // Parse components\n      const year = parseInt(cleaned.slice(0, 4), 10);\n      const month = parseInt(cleaned.slice(4, 6), 10) - 1;\n      const day = parseInt(cleaned.slice(6, 8), 10);\n      const hour = parseInt(cleaned.slice(8, 10), 10) || 0;\n      const minute = parseInt(cleaned.slice(10, 12), 10) || 0;\n      const second = parseInt(cleaned.slice(12, 14), 10) || 0;\n\n      return new Date(year, month, day, hour, minute, second);\n    } catch {\n      return undefined;\n    }\n  }",
      "references": [
        "parseInt",
        "cleaned",
        "Date",
        "year",
        "month",
        "day",
        "hour",
        "minute",
        "second"
      ]
    },
    "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24": {
      "id": "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24",
      "type": "class",
      "name": "PdfExtractor",
      "filePath": "src/services/documents/pdfExtractor.ts",
      "line": 24,
      "endLine": 182,
      "parentFileId": "file:src/services/documents/pdfExtractor.ts",
      "methods": [
        "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:canHandle:28",
        "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:extract:32",
        "file:src/services/documents/pdfExtractor.ts:class:PdfExtractor:24:method:parsePdfDate:164"
      ],
      "properties": [
        {
          "name": "supportedFormats",
          "type": "(\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\")[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        },
        {
          "name": "supportedMimeTypes",
          "type": "string[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "DocumentExtractor"
      ]
    },
    "file:src/services/documents/search.ts": {
      "id": "file:src/services/documents/search.ts",
      "type": "file",
      "name": "search.ts",
      "filePath": "src/services/documents/search.ts",
      "line": 1,
      "endLine": 400,
      "imports": [
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chunker/chunkEmbedding.js",
          "items": [
            {
              "name": "generateQueryEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chunker/chunkStorage.js",
          "items": [
            {
              "name": "searchChunksBySimilarity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chunker/types.js",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../objects.js",
          "items": [
            {
              "name": "StoredObject",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getObjectById",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "searchDocuments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchForContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchDocumentsOptimized",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSearchStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentSearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SearchResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/documents/search.ts:fn:searchDocuments:82",
        "file:src/services/documents/search.ts:fn:searchForContext:215",
        "file:src/services/documents/search.ts:fn:searchDocumentsOptimized:292",
        "file:src/services/documents/search.ts:fn:getSearchStats:371"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/search.ts:fn:searchDocuments:82": {
      "id": "file:src/services/documents/search.ts:fn:searchDocuments:82",
      "type": "function",
      "name": "searchDocuments",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/search.ts",
      "line": 82,
      "endLine": 175,
      "parentFileId": "file:src/services/documents/search.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/search\").SearchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/search\").SearchResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches document chunks by query embedding similarity, optionally includes document metadata via DB lookups",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchDocuments(\n  query: string,\n  options: SearchOptions = {}\n): Promise<SearchResponse> {\n  const startTime = Date.now();\n  const {\n    limit = 10,\n    threshold = 0.5,\n    documentId,\n    includeDocumentMetadata = true,\n  } = options;\n\n  // Generate embedding for the query\n  const queryEmbedding = await generateQueryEmbedding(query);\n\n  // Search chunks by similarity\n  const chunks = await searchChunksBySimilarity(queryEmbedding, {\n    limit,\n    threshold,\n    objectId: documentId,\n  });\n\n  // Build results with document metadata\n  const results: DocumentSearchResult[] = [];\n\n  if (includeDocumentMetadata) {\n    // Cache document lookups to avoid duplicate queries\n    const documentCache = new Map<string, StoredObject | null>();\n\n    for (const chunk of chunks) {\n      let doc = documentCache.get(chunk.objectId);\n      if (doc === undefined) {\n        doc = await getObjectById(chunk.objectId);\n        documentCache.set(chunk.objectId, doc);\n      }\n\n      results.push({\n        chunk: {\n          id: chunk.id,\n          objectId: chunk.objectId,\n          chunkIndex: chunk.chunkIndex,\n          content: chunk.content,\n          tokenCount: chunk.tokenCount,\n          pageNumber: chunk.pageNumber,\n          sectionTitle: chunk.sectionTitle,\n          chunkingStrategy: chunk.chunkingStrategy,\n          metadata: chunk.metadata,\n          createdAt: chunk.createdAt,\n        },\n        similarity: chunk.similarity,\n        document: {\n          id: doc?.id ?? chunk.objectId,\n          name: doc?.name ?? 'Unknown',\n          filename: doc?.filename ?? 'unknown',\n          mimeType: doc?.mime_type ?? 'application/octet-stream',\n          description: doc?.description ?? null,\n        },\n      });\n    }\n  } else {\n    // Skip document metadata lookup\n    for (const chunk of chunks) {\n      results.push({\n        chunk: {\n          id: chunk.id,\n          objectId: chunk.objectId,\n          chunkIndex: chunk.chunkIndex,\n          content: chunk.content,\n          tokenCount: chunk.tokenCount,\n          pageNumber: chunk.pageNumber,\n          sectionTitle: chunk.sectionTitle,\n          chunkingStrategy: chunk.chunkingStrategy,\n          metadata: chunk.metadata,\n          createdAt: chunk.createdAt,\n        },\n        similarity: chunk.similarity,\n        document: {\n          id: chunk.objectId,\n          name: 'Unknown',\n          filename: 'unknown',\n          mimeType: 'application/octet-stream',\n          description: null,\n        },\n      });\n    }\n  }\n\n  return {\n    results,\n    query,\n    totalResults: results.length,\n    searchTimeMs: Date.now() - startTime,\n  };\n}",
      "references": [
        "Date",
        "limit",
        "threshold",
        "documentId",
        "includeDocumentMetadata",
        "generateQueryEmbedding",
        "searchChunksBySimilarity",
        "queryEmbedding",
        "Map",
        "chunks",
        "documentCache",
        "chunk",
        "doc",
        "getObjectById",
        "results",
        "startTime"
      ]
    },
    "file:src/services/documents/search.ts:fn:searchForContext:215": {
      "id": "file:src/services/documents/search.ts:fn:searchForContext:215",
      "type": "function",
      "name": "searchForContext",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/search.ts",
      "line": 215,
      "endLine": 261,
      "parentFileId": "file:src/services/documents/search.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/search\").SearchOptions & { maxTokens?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ chunks: import(\"/home/ridgetop/projects/squire/src/services/documents/search\").ContextChunk[]; totalTokens: number; query: string; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches documents for context chunks matching query, trims to max token budget",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchForContext(\n  query: string,\n  options: SearchOptions & { maxTokens?: number } = {}\n): Promise<{\n  chunks: ContextChunk[];\n  totalTokens: number;\n  query: string;\n}> {\n  const { maxTokens = 4000, ...searchOptions } = options;\n\n  // Get more results than needed, then trim to token budget\n  const response = await searchDocuments(query, {\n    ...searchOptions,\n    limit: searchOptions.limit ?? 20,\n    includeDocumentMetadata: true,\n  });\n\n  const chunks: ContextChunk[] = [];\n  let totalTokens = 0;\n\n  for (const result of response.results) {\n    // Check if adding this chunk would exceed budget\n    if (totalTokens + result.chunk.tokenCount > maxTokens) {\n      // If we have at least one chunk, stop here\n      if (chunks.length > 0) break;\n      // Otherwise include partial (first chunk always included)\n    }\n\n    chunks.push({\n      content: result.chunk.content,\n      similarity: result.similarity,\n      tokenCount: result.chunk.tokenCount,\n      documentName: result.document.name,\n      pageNumber: result.chunk.pageNumber,\n      sectionTitle: result.chunk.sectionTitle,\n      sourceId: `${result.document.filename}:${result.chunk.chunkIndex}`,\n    });\n\n    totalTokens += result.chunk.tokenCount;\n  }\n\n  return {\n    chunks,\n    totalTokens,\n    query,\n  };\n}",
      "references": [
        "maxTokens",
        "searchOptions",
        "searchDocuments",
        "response",
        "totalTokens",
        "result",
        "chunks"
      ]
    },
    "file:src/services/documents/search.ts:fn:searchDocumentsOptimized:292": {
      "id": "file:src/services/documents/search.ts:fn:searchDocumentsOptimized:292",
      "type": "function",
      "name": "searchDocumentsOptimized",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/search.ts",
      "line": 292,
      "endLine": 364,
      "parentFileId": "file:src/services/documents/search.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/search\").SearchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/search\").SearchResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches document chunks by vector similarity using query embedding and optimized SQL JOIN query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchDocumentsOptimized(\n  query: string,\n  options: SearchOptions = {}\n): Promise<SearchResponse> {\n  const startTime = Date.now();\n  const { limit = 10, threshold = 0.5, documentId } = options;\n\n  // Generate embedding for the query\n  const queryEmbedding = await generateQueryEmbedding(query);\n\n  // Build optimized query with JOIN\n  let sql = `\n    SELECT\n      dc.id as chunk_id,\n      dc.object_id,\n      dc.chunk_index,\n      dc.content,\n      dc.token_count,\n      dc.page_number,\n      dc.section_title,\n      1 - (dc.embedding <=> $1::vector) as similarity,\n      o.name as doc_name,\n      o.filename as doc_filename,\n      o.mime_type as doc_mime_type,\n      o.description as doc_description\n    FROM document_chunks dc\n    JOIN objects o ON dc.object_id = o.id\n    WHERE dc.embedding IS NOT NULL\n      AND 1 - (dc.embedding <=> $1::vector) >= $2\n  `;\n\n  const params: unknown[] = [JSON.stringify(queryEmbedding), threshold];\n\n  if (documentId) {\n    sql += ` AND dc.object_id = $3`;\n    params.push(documentId);\n  }\n\n  sql += ` ORDER BY similarity DESC LIMIT $${params.length + 1}`;\n  params.push(limit);\n\n  const result = await pool.query<SearchResultRow>(sql, params);\n\n  const results: DocumentSearchResult[] = result.rows.map((row) => ({\n    chunk: {\n      id: row.chunk_id,\n      objectId: row.object_id,\n      chunkIndex: row.chunk_index,\n      content: row.content,\n      tokenCount: row.token_count,\n      pageNumber: row.page_number ?? undefined,\n      sectionTitle: row.section_title ?? undefined,\n      chunkingStrategy: 'hybrid', // Not returned in optimized query\n      metadata: {},\n      createdAt: new Date(), // Not returned in optimized query\n    },\n    similarity: row.similarity,\n    document: {\n      id: row.object_id,\n      name: row.doc_name,\n      filename: row.doc_filename,\n      mimeType: row.doc_mime_type,\n      description: row.doc_description,\n    },\n  }));\n\n  return {\n    results,\n    query,\n    totalResults: results.length,\n    searchTimeMs: Date.now() - startTime,\n  };\n}",
      "references": [
        "Date",
        "limit",
        "threshold",
        "documentId",
        "generateQueryEmbedding",
        "JSON",
        "queryEmbedding",
        "sql",
        "params",
        "pool",
        "result",
        "row",
        "results",
        "startTime"
      ]
    },
    "file:src/services/documents/search.ts:fn:getSearchStats:371": {
      "id": "file:src/services/documents/search.ts:fn:getSearchStats:371",
      "type": "function",
      "name": "getSearchStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/search.ts",
      "line": 371,
      "endLine": 399,
      "parentFileId": "file:src/services/documents/search.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ totalChunks: number; chunksWithEmbeddings: number; totalDocuments: number; avgChunksPerDocument: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries database for stats on document chunks, embeddings, total docs, and avg chunks per doc",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:09.691Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSearchStats(): Promise<{\n  totalChunks: number;\n  chunksWithEmbeddings: number;\n  totalDocuments: number;\n  avgChunksPerDocument: number;\n}> {\n  const result = await pool.query<{\n    total_chunks: string;\n    with_embeddings: string;\n    total_docs: string;\n  }>(`\n    SELECT\n      COUNT(*) as total_chunks,\n      COUNT(*) FILTER (WHERE embedding IS NOT NULL) as with_embeddings,\n      COUNT(DISTINCT object_id) as total_docs\n    FROM document_chunks\n  `);\n\n  const row = result.rows[0];\n  const totalChunks = parseInt(row?.total_chunks ?? '0', 10);\n  const totalDocs = parseInt(row?.total_docs ?? '0', 10);\n\n  return {\n    totalChunks,\n    chunksWithEmbeddings: parseInt(row?.with_embeddings ?? '0', 10),\n    totalDocuments: totalDocs,\n    avgChunksPerDocument: totalDocs > 0 ? totalChunks / totalDocs : 0,\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row",
        "totalChunks",
        "totalDocs"
      ]
    },
    "file:src/services/documents/textExtractor.ts": {
      "id": "file:src/services/documents/textExtractor.ts",
      "type": "file",
      "name": "textExtractor.ts",
      "filePath": "src/services/documents/textExtractor.ts",
      "line": 1,
      "endLine": 160,
      "imports": [
        {
          "source": "fs/promises",
          "items": [
            {
              "name": "fs",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentExtractor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentMetadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "countWords",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "textExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [
        "file:src/services/documents/textExtractor.ts:class:TextExtractor:22"
      ],
      "topLevelReferences": [
        "TextExtractor"
      ]
    },
    "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:canHandle:30": {
      "id": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:canHandle:30",
      "type": "function",
      "name": "canHandle",
      "filePath": "src/services/documents/textExtractor.ts",
      "line": 30,
      "endLine": 32,
      "parentFileId": "file:src/services/documents/textExtractor.ts",
      "parentClassId": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22",
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "canHandle(mimeType: string): boolean {\n    return this.supportedMimeTypes.includes(mimeType.toLowerCase());\n  }",
      "references": []
    },
    "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:extract:34": {
      "id": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:extract:34",
      "type": "function",
      "name": "extract",
      "filePath": "src/services/documents/textExtractor.ts",
      "line": 34,
      "endLine": 143,
      "parentFileId": "file:src/services/documents/textExtractor.ts",
      "parentClassId": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22",
      "params": [
        {
          "name": "input",
          "type": "string | Buffer",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/types\").ExtractionResult>",
      "isExported": false,
      "isAsync": true,
      "behavioral": null,
      "source": "async extract(\n    input: Buffer | string,\n    options?: ExtractionOptions\n  ): Promise<ExtractionResult> {\n    const opts = { ...DEFAULT_EXTRACTION_OPTIONS, ...options };\n    const startTime = Date.now();\n    const warnings: string[] = [];\n\n    try {\n      // Get text content\n      let text: string;\n      let fileName: string | undefined;\n      let fileSize: number | undefined;\n\n      if (typeof input === 'string') {\n        // It's a file path\n        const buffer = await fs.readFile(input);\n        text = buffer.toString('utf-8');\n        fileName = input.split('/').pop();\n        const stats = await fs.stat(input);\n        fileSize = stats.size;\n      } else {\n        // It's a buffer\n        text = input.toString('utf-8');\n        fileSize = input.length;\n      }\n\n      // Handle BOM (Byte Order Mark) if present\n      if (text.charCodeAt(0) === 0xFEFF) {\n        text = text.slice(1);\n      }\n\n      // Check for empty document\n      if (!text || text.trim().length === 0) {\n        return {\n          success: true,\n          document: {\n            text: '',\n            metadata: {\n              wordCount: 0,\n              charCount: 0,\n              fileName,\n              fileSize,\n            },\n            pages: [],\n            format: this.detectFormat(fileName),\n            extractedAt: new Date(),\n            extractionDurationMs: Date.now() - startTime,\n            warnings: ['Document is empty.'],\n          },\n        };\n      }\n\n      // Truncate if needed\n      if (text.length > opts.maxTextLength) {\n        text = text.slice(0, opts.maxTextLength);\n        warnings.push(`Text truncated to ${opts.maxTextLength} characters.`);\n      }\n\n      // Extract title from markdown if present (first # heading)\n      let title: string | undefined;\n      const format = this.detectFormat(fileName);\n      if (format === 'md') {\n        const titleMatch = text.match(/^#\\s+(.+)$/m);\n        if (titleMatch && titleMatch[1]) {\n          title = titleMatch[1].trim();\n        }\n      }\n\n      // Build metadata\n      const metadata: DocumentMetadata = {\n        title,\n        wordCount: countWords(text),\n        charCount: text.length,\n        fileName,\n        fileSize,\n      };\n\n      const document: ExtractedDocument = {\n        text,\n        metadata,\n        pages: [], // Plain text doesn't have pages\n        format,\n        extractedAt: new Date(),\n        extractionDurationMs: Date.now() - startTime,\n        warnings,\n      };\n\n      return {\n        success: true,\n        document,\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n\n      if (message?.includes('ENOENT')) {\n        return {\n          success: false,\n          error: 'File not found',\n          errorCode: 'CORRUPTED_FILE',\n        };\n      }\n\n      return {\n        success: false,\n        error: `Text extraction failed: ${message}`,\n        errorCode: 'UNKNOWN_ERROR',\n      };\n    }\n  }",
      "references": [
        "DEFAULT_EXTRACTION_OPTIONS",
        "Date",
        "fs",
        "text",
        "buffer",
        "fileName",
        "fileSize",
        "stats",
        "startTime",
        "opts",
        "warnings",
        "format",
        "titleMatch",
        "title",
        "countWords",
        "metadata",
        "document",
        "error",
        "Error",
        "String",
        "message"
      ]
    },
    "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:detectFormat:148": {
      "id": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:detectFormat:148",
      "type": "function",
      "name": "detectFormat",
      "filePath": "src/services/documents/textExtractor.ts",
      "line": 148,
      "endLine": 155,
      "parentFileId": "file:src/services/documents/textExtractor.ts",
      "parentClassId": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22",
      "params": [
        {
          "name": "fileName",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\"",
      "isExported": false,
      "isAsync": false,
      "behavioral": null,
      "source": "private detectFormat(fileName?: string): DocumentFormat {\n    if (!fileName) return 'txt';\n    const lower = fileName.toLowerCase();\n    if (lower.endsWith('.md') || lower.endsWith('.markdown')) {\n      return 'md';\n    }\n    return 'txt';\n  }",
      "references": [
        "lower"
      ]
    },
    "file:src/services/documents/textExtractor.ts:class:TextExtractor:22": {
      "id": "file:src/services/documents/textExtractor.ts:class:TextExtractor:22",
      "type": "class",
      "name": "TextExtractor",
      "filePath": "src/services/documents/textExtractor.ts",
      "line": 22,
      "endLine": 156,
      "parentFileId": "file:src/services/documents/textExtractor.ts",
      "methods": [
        "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:canHandle:30",
        "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:extract:34",
        "file:src/services/documents/textExtractor.ts:class:TextExtractor:22:method:detectFormat:148"
      ],
      "properties": [
        {
          "name": "supportedFormats",
          "type": "(\"image\" | \"pdf\" | \"docx\" | \"doc\" | \"txt\" | \"md\")[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        },
        {
          "name": "supportedMimeTypes",
          "type": "string[]",
          "visibility": "public",
          "isStatic": false,
          "isReadonly": true
        }
      ],
      "isExported": false,
      "extends": null,
      "implements": [
        "DocumentExtractor"
      ]
    },
    "file:src/services/documents/types.ts": {
      "id": "file:src/services/documents/types.ts",
      "type": "file",
      "name": "types.ts",
      "filePath": "src/services/documents/types.ts",
      "line": 1,
      "endLine": 220,
      "imports": [],
      "exports": [
        {
          "name": "isExtractableMimeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "countWords",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EXTRACTABLE_MIME_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ExtractableMimeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentFormat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentPage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_EXTRACTION_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionErrorCode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentExtractor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractionInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        }
      ],
      "functions": [
        "file:src/services/documents/types.ts:fn:isExtractableMimeType:210",
        "file:src/services/documents/types.ts:fn:countWords:217"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/types.ts:fn:isExtractableMimeType:210": {
      "id": "file:src/services/documents/types.ts:fn:isExtractableMimeType:210",
      "type": "function",
      "name": "isExtractableMimeType",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/types.ts",
      "line": 210,
      "endLine": 212,
      "parentFileId": "file:src/services/documents/types.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if MIME type is extractable by case-insensitive inclusion in predefined list.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.591Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isExtractableMimeType(mimeType: string): boolean {\n  return (EXTRACTABLE_MIME_TYPES as readonly string[]).includes(mimeType.toLowerCase());\n}",
      "references": [
        "EXTRACTABLE_MIME_TYPES"
      ]
    },
    "file:src/services/documents/types.ts:fn:countWords:217": {
      "id": "file:src/services/documents/types.ts:fn:countWords:217",
      "type": "function",
      "name": "countWords",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/types.ts",
      "line": 217,
      "endLine": 219,
      "parentFileId": "file:src/services/documents/types.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts non-empty words in a string after trimming and splitting on whitespace.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n}",
      "references": [
        "word"
      ]
    },
    "file:src/services/google/auth.ts": {
      "id": "file:src/services/google/auth.ts",
      "type": "file",
      "name": "auth.ts",
      "filePath": "src/services/google/auth.ts",
      "line": 1,
      "endLine": 329,
      "imports": [
        {
          "source": "googleapis",
          "items": [
            {
              "name": "google",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "getAuthUrl",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "handleOAuthCallback",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ensureValidToken",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAuthenticatedClient",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAccount",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listAccounts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listSyncEnabledAccounts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "disconnectAccount",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateCalendarsSyncToken",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "markFullSyncComplete",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "setSyncEnabled",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "isGoogleConfigured",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConnectionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GoogleAccount",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/google/auth.ts:fn:createOAuth2Client:36",
        "file:src/services/google/auth.ts:fn:getAuthUrl:51",
        "file:src/services/google/auth.ts:fn:handleOAuthCallback:65",
        "file:src/services/google/auth.ts:fn:refreshAccessToken:125",
        "file:src/services/google/auth.ts:fn:ensureValidToken:162",
        "file:src/services/google/auth.ts:fn:getAuthenticatedClient:180",
        "file:src/services/google/auth.ts:fn:getAccount:196",
        "file:src/services/google/auth.ts:fn:listAccounts:207",
        "file:src/services/google/auth.ts:fn:listSyncEnabledAccounts:217",
        "file:src/services/google/auth.ts:fn:disconnectAccount:227",
        "file:src/services/google/auth.ts:fn:updateCalendarsSyncToken:254",
        "file:src/services/google/auth.ts:fn:markFullSyncComplete:269",
        "file:src/services/google/auth.ts:fn:setSyncEnabled:281",
        "file:src/services/google/auth.ts:fn:isGoogleConfigured:293",
        "file:src/services/google/auth.ts:fn:getConnectionStatus:300"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:src/services/google/auth.ts:fn:createOAuth2Client:36": {
      "id": "file:src/services/google/auth.ts:fn:createOAuth2Client:36",
      "type": "function",
      "name": "createOAuth2Client",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 36,
      "endLine": 46,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/node_modules/google-auth-library/build/src/auth/oauth2client\").OAuth2Client",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates Google OAuth2 client using environment credentials or throws error if missing.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createOAuth2Client() {\n  if (!GOOGLE_CLIENT_ID || !GOOGLE_CLIENT_SECRET) {\n    throw new Error('Google OAuth credentials not configured. Set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET.');\n  }\n\n  return new google.auth.OAuth2(\n    GOOGLE_CLIENT_ID,\n    GOOGLE_CLIENT_SECRET,\n    GOOGLE_REDIRECT_URI\n  );\n}",
      "references": [
        "GOOGLE_CLIENT_ID",
        "GOOGLE_CLIENT_SECRET",
        "Error",
        "google",
        "GOOGLE_REDIRECT_URI"
      ]
    },
    "file:src/services/google/auth.ts:fn:getAuthUrl:51": {
      "id": "file:src/services/google/auth.ts:fn:getAuthUrl:51",
      "type": "function",
      "name": "getAuthUrl",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 51,
      "endLine": 60,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "state",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates Google OAuth2 auth URL for calendar scopes with offline access and consent prompt.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getAuthUrl(state?: string): string {\n  const oauth2Client = createOAuth2Client();\n\n  return oauth2Client.generateAuthUrl({\n    access_type: 'offline',\n    scope: CALENDAR_SCOPES,\n    prompt: 'consent', // Force consent to get refresh token\n    state: state,\n  });\n}",
      "references": [
        "createOAuth2Client",
        "oauth2Client",
        "CALENDAR_SCOPES"
      ]
    },
    "file:src/services/google/auth.ts:fn:handleOAuthCallback:65": {
      "id": "file:src/services/google/auth.ts:fn:handleOAuthCallback:65",
      "type": "function",
      "name": "handleOAuthCallback",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 65,
      "endLine": 120,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "code",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Handles Google OAuth callback: exchanges code for tokens, fetches user info, upserts account in DB.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function handleOAuthCallback(code: string): Promise<GoogleAccount> {\n  const oauth2Client = createOAuth2Client();\n\n  // Exchange code for tokens\n  const { tokens } = await oauth2Client.getToken(code);\n  oauth2Client.setCredentials(tokens);\n\n  if (!tokens.access_token || !tokens.refresh_token) {\n    throw new Error('Failed to get tokens from Google');\n  }\n\n  // Get user info\n  const oauth2 = google.oauth2({ version: 'v2', auth: oauth2Client });\n  const userInfo = await oauth2.userinfo.get();\n\n  if (!userInfo.data.id || !userInfo.data.email) {\n    throw new Error('Failed to get user info from Google');\n  }\n\n  const tokenExpiresAt = tokens.expiry_date\n    ? new Date(tokens.expiry_date)\n    : new Date(Date.now() + 3600 * 1000); // Default 1 hour\n\n  // Upsert account (update if exists, insert if new)\n  const result = await pool.query(`\n    INSERT INTO google_accounts (\n      google_user_id,\n      email,\n      display_name,\n      access_token,\n      refresh_token,\n      token_expires_at,\n      scopes\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7)\n    ON CONFLICT (google_user_id) DO UPDATE SET\n      email = EXCLUDED.email,\n      display_name = EXCLUDED.display_name,\n      access_token = EXCLUDED.access_token,\n      refresh_token = COALESCE(EXCLUDED.refresh_token, google_accounts.refresh_token),\n      token_expires_at = EXCLUDED.token_expires_at,\n      scopes = EXCLUDED.scopes,\n      sync_enabled = TRUE,\n      updated_at = NOW()\n    RETURNING *\n  `, [\n    userInfo.data.id,\n    userInfo.data.email,\n    userInfo.data.name || null,\n    tokens.access_token,\n    tokens.refresh_token,\n    tokenExpiresAt,\n    CALENDAR_SCOPES,\n  ]);\n\n  return result.rows[0] as GoogleAccount;\n}",
      "references": [
        "createOAuth2Client",
        "tokens",
        "oauth2Client",
        "Error",
        "google",
        "oauth2",
        "userInfo",
        "Date",
        "pool",
        "tokenExpiresAt",
        "CALENDAR_SCOPES",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:refreshAccessToken:125": {
      "id": "file:src/services/google/auth.ts:fn:refreshAccessToken:125",
      "type": "function",
      "name": "refreshAccessToken",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 125,
      "endLine": 156,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Refreshes Google OAuth access token via HTTP and updates database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function refreshAccessToken(accountId: string): Promise<GoogleAccount> {\n  const account = await getAccount(accountId);\n  if (!account) {\n    throw new Error(`Google account not found: ${accountId}`);\n  }\n\n  const oauth2Client = createOAuth2Client();\n  oauth2Client.setCredentials({\n    refresh_token: account.refresh_token,\n  });\n\n  const { credentials } = await oauth2Client.refreshAccessToken();\n\n  if (!credentials.access_token) {\n    throw new Error('Failed to refresh access token');\n  }\n\n  const tokenExpiresAt = credentials.expiry_date\n    ? new Date(credentials.expiry_date)\n    : new Date(Date.now() + 3600 * 1000);\n\n  const result = await pool.query(`\n    UPDATE google_accounts\n    SET access_token = $1,\n        token_expires_at = $2,\n        updated_at = NOW()\n    WHERE id = $3\n    RETURNING *\n  `, [credentials.access_token, tokenExpiresAt, accountId]);\n\n  return result.rows[0] as GoogleAccount;\n}",
      "references": [
        "getAccount",
        "account",
        "Error",
        "createOAuth2Client",
        "oauth2Client",
        "credentials",
        "Date",
        "pool",
        "tokenExpiresAt",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:ensureValidToken:162": {
      "id": "file:src/services/google/auth.ts:fn:ensureValidToken:162",
      "type": "function",
      "name": "ensureValidToken",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 162,
      "endLine": 175,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Ensures Google account token is valid by fetching and refreshing if near expiry",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function ensureValidToken(accountId: string): Promise<GoogleAccount> {\n  const account = await getAccount(accountId);\n  if (!account) {\n    throw new Error(`Google account not found: ${accountId}`);\n  }\n\n  // Check if token is expired or will expire in next 5 minutes\n  const expiryBuffer = 5 * 60 * 1000; // 5 minutes\n  if (account.token_expires_at.getTime() - Date.now() < expiryBuffer) {\n    return refreshAccessToken(accountId);\n  }\n\n  return account;\n}",
      "references": [
        "getAccount",
        "account",
        "Error",
        "Date",
        "expiryBuffer",
        "refreshAccessToken"
      ]
    },
    "file:src/services/google/auth.ts:fn:getAuthenticatedClient:180": {
      "id": "file:src/services/google/auth.ts:fn:getAuthenticatedClient:180",
      "type": "function",
      "name": "getAuthenticatedClient",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 180,
      "endLine": 191,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/node_modules/google-auth-library/build/src/auth/oauth2client\").OAuth2Client>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates OAuth2 client and sets credentials from account tokens via ensureValidToken",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAuthenticatedClient(accountId: string) {\n  const account = await ensureValidToken(accountId);\n\n  const oauth2Client = createOAuth2Client();\n  oauth2Client.setCredentials({\n    access_token: account.access_token,\n    refresh_token: account.refresh_token,\n    expiry_date: account.token_expires_at.getTime(),\n  });\n\n  return oauth2Client;\n}",
      "references": [
        "ensureValidToken",
        "createOAuth2Client",
        "oauth2Client",
        "account"
      ]
    },
    "file:src/services/google/auth.ts:fn:getAccount:196": {
      "id": "file:src/services/google/auth.ts:fn:getAccount:196",
      "type": "function",
      "name": "getAccount",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 196,
      "endLine": 202,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves Google account from database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAccount(accountId: string): Promise<GoogleAccount | null> {\n  const result = await pool.query(\n    'SELECT * FROM google_accounts WHERE id = $1',\n    [accountId]\n  );\n  return result.rows[0] as GoogleAccount || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:listAccounts:207": {
      "id": "file:src/services/google/auth.ts:fn:listAccounts:207",
      "type": "function",
      "name": "listAccounts",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 207,
      "endLine": 212,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves all Google accounts from database ordered by created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listAccounts(): Promise<GoogleAccount[]> {\n  const result = await pool.query(\n    'SELECT * FROM google_accounts ORDER BY created_at DESC'\n  );\n  return result.rows as GoogleAccount[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:listSyncEnabledAccounts:217": {
      "id": "file:src/services/google/auth.ts:fn:listSyncEnabledAccounts:217",
      "type": "function",
      "name": "listSyncEnabledAccounts",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 217,
      "endLine": 222,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/auth\").GoogleAccount[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Queries DB for sync-enabled Google accounts, ordered by created_at DESC",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listSyncEnabledAccounts(): Promise<GoogleAccount[]> {\n  const result = await pool.query(\n    'SELECT * FROM google_accounts WHERE sync_enabled = TRUE ORDER BY created_at DESC'\n  );\n  return result.rows as GoogleAccount[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:disconnectAccount:227": {
      "id": "file:src/services/google/auth.ts:fn:disconnectAccount:227",
      "type": "function",
      "name": "disconnectAccount",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 227,
      "endLine": 249,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Revokes Google OAuth token and deletes account from database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function disconnectAccount(accountId: string): Promise<boolean> {\n  // Also revoke token with Google\n  try {\n    const account = await getAccount(accountId);\n    if (account) {\n      const oauth2Client = createOAuth2Client();\n      oauth2Client.setCredentials({\n        access_token: account.access_token,\n      });\n      await oauth2Client.revokeToken(account.access_token);\n    }\n  } catch (err) {\n    // Token revocation is best-effort, continue with deletion\n    console.warn('Failed to revoke Google token:', err);\n  }\n\n  const result = await pool.query(\n    'DELETE FROM google_accounts WHERE id = $1',\n    [accountId]\n  );\n\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "getAccount",
        "account",
        "createOAuth2Client",
        "oauth2Client",
        "console",
        "err",
        "pool",
        "result"
      ]
    },
    "file:src/services/google/auth.ts:fn:updateCalendarsSyncToken:254": {
      "id": "file:src/services/google/auth.ts:fn:updateCalendarsSyncToken:254",
      "type": "function",
      "name": "updateCalendarsSyncToken",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 254,
      "endLine": 264,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "syncToken",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates calendars_sync_token and updated_at for a Google account in the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.719Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateCalendarsSyncToken(\n  accountId: string,\n  syncToken: string | null\n): Promise<void> {\n  await pool.query(`\n    UPDATE google_accounts\n    SET calendars_sync_token = $1,\n        updated_at = NOW()\n    WHERE id = $2\n  `, [syncToken, accountId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/auth.ts:fn:markFullSyncComplete:269": {
      "id": "file:src/services/google/auth.ts:fn:markFullSyncComplete:269",
      "type": "function",
      "name": "markFullSyncComplete",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 269,
      "endLine": 276,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates google_accounts to set last_full_sync_at and updated_at for given accountId",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function markFullSyncComplete(accountId: string): Promise<void> {\n  await pool.query(`\n    UPDATE google_accounts\n    SET last_full_sync_at = NOW(),\n        updated_at = NOW()\n    WHERE id = $1\n  `, [accountId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/auth.ts:fn:setSyncEnabled:281": {
      "id": "file:src/services/google/auth.ts:fn:setSyncEnabled:281",
      "type": "function",
      "name": "setSyncEnabled",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 281,
      "endLine": 288,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "enabled",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates sync_enabled and updated_at for a Google account in the database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function setSyncEnabled(accountId: string, enabled: boolean): Promise<void> {\n  await pool.query(`\n    UPDATE google_accounts\n    SET sync_enabled = $1,\n        updated_at = NOW()\n    WHERE id = $2\n  `, [enabled, accountId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/auth.ts:fn:isGoogleConfigured:293": {
      "id": "file:src/services/google/auth.ts:fn:isGoogleConfigured:293",
      "type": "function",
      "name": "isGoogleConfigured",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 293,
      "endLine": 295,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if Google Client ID and Secret are configured.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function isGoogleConfigured(): boolean {\n  return !!(GOOGLE_CLIENT_ID && GOOGLE_CLIENT_SECRET);\n}",
      "references": [
        "GOOGLE_CLIENT_ID",
        "GOOGLE_CLIENT_SECRET"
      ]
    },
    "file:src/services/google/auth.ts:fn:getConnectionStatus:300": {
      "id": "file:src/services/google/auth.ts:fn:getConnectionStatus:300",
      "type": "function",
      "name": "getConnectionStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/auth.ts",
      "line": 300,
      "endLine": 328,
      "parentFileId": "file:src/services/google/auth.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ configured: boolean; accounts: { id: string; email: string; display_name: string; sync_enabled: boolean; last_full_sync_at: Date; }[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Gets Google auth status and maps list of accounts if configured.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConnectionStatus(): Promise<{\n  configured: boolean;\n  accounts: Array<{\n    id: string;\n    email: string;\n    display_name: string | null;\n    sync_enabled: boolean;\n    last_full_sync_at: Date | null;\n  }>;\n}> {\n  const configured = isGoogleConfigured();\n\n  if (!configured) {\n    return { configured, accounts: [] };\n  }\n\n  const accounts = await listAccounts();\n\n  return {\n    configured,\n    accounts: accounts.map(a => ({\n      id: a.id,\n      email: a.email,\n      display_name: a.display_name,\n      sync_enabled: a.sync_enabled,\n      last_full_sync_at: a.last_full_sync_at,\n    })),\n  };\n}",
      "references": [
        "isGoogleConfigured",
        "configured",
        "listAccounts",
        "accounts",
        "a"
      ]
    },
    "file:src/services/google/calendars.ts": {
      "id": "file:src/services/google/calendars.ts",
      "type": "file",
      "name": "calendars.ts",
      "filePath": "src/services/google/calendars.ts",
      "line": 1,
      "endLine": 302,
      "imports": [
        {
          "source": "googleapis",
          "items": [
            {
              "name": "google",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "calendar_v3",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./auth.js",
          "items": [
            {
              "name": "getAuthenticatedClient",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateCalendarsSyncToken",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "syncCalendarList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listCalendars",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listSyncEnabledCalendars",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCalendar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDefaultPushCalendar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateCalendarSettings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateEventsSyncToken",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getCalendarStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GoogleCalendar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CalendarSyncSettings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/google/calendars.ts:fn:syncCalendarList:35",
        "file:src/services/google/calendars.ts:fn:listCalendars:145",
        "file:src/services/google/calendars.ts:fn:listSyncEnabledCalendars:157",
        "file:src/services/google/calendars.ts:fn:getCalendar:169",
        "file:src/services/google/calendars.ts:fn:getDefaultPushCalendar:180",
        "file:src/services/google/calendars.ts:fn:updateCalendarSettings:205",
        "file:src/services/google/calendars.ts:fn:updateEventsSyncToken:265",
        "file:src/services/google/calendars.ts:fn:getCalendarStats:281"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/google/calendars.ts:fn:syncCalendarList:35": {
      "id": "file:src/services/google/calendars.ts:fn:syncCalendarList:35",
      "type": "function",
      "name": "syncCalendarList",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 35,
      "endLine": 140,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Syncs Google calendar list for account via API, handles incremental/full sync, upserts/deletes in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function syncCalendarList(accountId: string): Promise<GoogleCalendar[]> {\n  const authClient = await getAuthenticatedClient(accountId);\n  const calendar = google.calendar({ version: 'v3', auth: authClient });\n\n  // Get account for sync token\n  const accountResult = await pool.query(\n    'SELECT calendars_sync_token FROM google_accounts WHERE id = $1',\n    [accountId]\n  );\n  const syncToken = accountResult.rows[0]?.calendars_sync_token;\n\n  let calendars: calendar_v3.Schema$CalendarListEntry[] = [];\n  let nextPageToken: string | undefined;\n  let nextSyncToken: string | undefined;\n\n  try {\n    // Incremental sync if we have a token\n    if (syncToken) {\n      const response = await calendar.calendarList.list({\n        syncToken: syncToken,\n      });\n      calendars = response.data.items || [];\n      nextSyncToken = response.data.nextSyncToken || undefined;\n    } else {\n      // Full sync - paginate through all calendars\n      do {\n        const response = await calendar.calendarList.list({\n          pageToken: nextPageToken,\n          showHidden: true,\n        });\n        calendars.push(...(response.data.items || []));\n        nextPageToken = response.data.nextPageToken || undefined;\n        nextSyncToken = response.data.nextSyncToken || undefined;\n      } while (nextPageToken);\n    }\n  } catch (err: unknown) {\n    // If sync token is invalid, do full sync\n    if (err instanceof Error && 'code' in err && (err as { code: number }).code === 410) {\n      // Token expired, do full sync\n      await updateCalendarsSyncToken(accountId, null);\n      return syncCalendarList(accountId);\n    }\n    throw err;\n  }\n\n  // Upsert each calendar\n  const synced: GoogleCalendar[] = [];\n  for (const cal of calendars) {\n    if (!cal.id) continue;\n\n    // Check if calendar was deleted\n    if (cal.deleted) {\n      await pool.query(`\n        DELETE FROM google_calendars\n        WHERE google_account_id = $1 AND calendar_id = $2\n      `, [accountId, cal.id]);\n      continue;\n    }\n\n    const result = await pool.query(`\n      INSERT INTO google_calendars (\n        google_account_id,\n        calendar_id,\n        summary,\n        description,\n        color_id,\n        background_color,\n        foreground_color,\n        timezone,\n        access_role,\n        is_primary\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n      ON CONFLICT (google_account_id, calendar_id) DO UPDATE SET\n        summary = EXCLUDED.summary,\n        description = EXCLUDED.description,\n        color_id = EXCLUDED.color_id,\n        background_color = EXCLUDED.background_color,\n        foreground_color = EXCLUDED.foreground_color,\n        timezone = EXCLUDED.timezone,\n        access_role = EXCLUDED.access_role,\n        is_primary = EXCLUDED.is_primary,\n        updated_at = NOW()\n      RETURNING *\n    `, [\n      accountId,\n      cal.id,\n      cal.summary || null,\n      cal.description || null,\n      cal.colorId || null,\n      cal.backgroundColor || null,\n      cal.foregroundColor || null,\n      cal.timeZone || null,\n      cal.accessRole || null,\n      cal.primary || false,\n    ]);\n\n    synced.push(result.rows[0] as GoogleCalendar);\n  }\n\n  // Update sync token\n  if (nextSyncToken) {\n    await updateCalendarsSyncToken(accountId, nextSyncToken);\n  }\n\n  return synced;\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "pool",
        "accountResult",
        "syncToken",
        "calendar",
        "calendars",
        "response",
        "nextSyncToken",
        "nextPageToken",
        "err",
        "Error",
        "updateCalendarsSyncToken",
        "syncCalendarList",
        "cal",
        "synced",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:listCalendars:145": {
      "id": "file:src/services/google/calendars.ts:fn:listCalendars:145",
      "type": "function",
      "name": "listCalendars",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 145,
      "endLine": 152,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves Google calendars for an account from database via SELECT query",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listCalendars(accountId: string): Promise<GoogleCalendar[]> {\n  const result = await pool.query(`\n    SELECT * FROM google_calendars\n    WHERE google_account_id = $1\n    ORDER BY is_primary DESC, summary ASC\n  `, [accountId]);\n  return result.rows as GoogleCalendar[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:listSyncEnabledCalendars:157": {
      "id": "file:src/services/google/calendars.ts:fn:listSyncEnabledCalendars:157",
      "type": "function",
      "name": "listSyncEnabledCalendars",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 157,
      "endLine": 164,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves sync-enabled Google calendars for a given account ID from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listSyncEnabledCalendars(accountId: string): Promise<GoogleCalendar[]> {\n  const result = await pool.query(`\n    SELECT * FROM google_calendars\n    WHERE google_account_id = $1 AND sync_enabled = TRUE\n    ORDER BY is_primary DESC, summary ASC\n  `, [accountId]);\n  return result.rows as GoogleCalendar[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:getCalendar:169": {
      "id": "file:src/services/google/calendars.ts:fn:getCalendar:169",
      "type": "function",
      "name": "getCalendar",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 169,
      "endLine": 175,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendarId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a GoogleCalendar from database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCalendar(calendarId: string): Promise<GoogleCalendar | null> {\n  const result = await pool.query(\n    'SELECT * FROM google_calendars WHERE id = $1',\n    [calendarId]\n  );\n  return result.rows[0] as GoogleCalendar || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:getDefaultPushCalendar:180": {
      "id": "file:src/services/google/calendars.ts:fn:getDefaultPushCalendar:180",
      "type": "function",
      "name": "getDefaultPushCalendar",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 180,
      "endLine": 200,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches default push or primary Google calendar for account from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDefaultPushCalendar(accountId: string): Promise<GoogleCalendar | null> {\n  // First try explicit default\n  let result = await pool.query(`\n    SELECT * FROM google_calendars\n    WHERE google_account_id = $1 AND is_default_for_push = TRUE\n    LIMIT 1\n  `, [accountId]);\n\n  if (result.rows[0]) {\n    return result.rows[0] as GoogleCalendar;\n  }\n\n  // Fall back to primary calendar\n  result = await pool.query(`\n    SELECT * FROM google_calendars\n    WHERE google_account_id = $1 AND is_primary = TRUE\n    LIMIT 1\n  `, [accountId]);\n\n  return result.rows[0] as GoogleCalendar || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:updateCalendarSettings:205": {
      "id": "file:src/services/google/calendars.ts:fn:updateCalendarSettings:205",
      "type": "function",
      "name": "updateCalendarSettings",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 205,
      "endLine": 260,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendarId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "settings",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").CalendarSyncSettings",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates Google calendar sync settings in DB, clears other defaults if setting as push default",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateCalendarSettings(\n  calendarId: string,\n  settings: CalendarSyncSettings\n): Promise<GoogleCalendar> {\n  const updates: string[] = [];\n  const values: unknown[] = [];\n  let paramIndex = 1;\n\n  if (settings.sync_enabled !== undefined) {\n    updates.push(`sync_enabled = $${paramIndex++}`);\n    values.push(settings.sync_enabled);\n  }\n\n  if (settings.sync_direction !== undefined) {\n    updates.push(`sync_direction = $${paramIndex++}`);\n    values.push(settings.sync_direction);\n  }\n\n  if (settings.is_default_for_push !== undefined) {\n    // If setting as default, clear other defaults first\n    if (settings.is_default_for_push) {\n      const calendar = await getCalendar(calendarId);\n      if (calendar) {\n        await pool.query(`\n          UPDATE google_calendars\n          SET is_default_for_push = FALSE\n          WHERE google_account_id = $1 AND id != $2\n        `, [calendar.google_account_id, calendarId]);\n      }\n    }\n    updates.push(`is_default_for_push = $${paramIndex++}`);\n    values.push(settings.is_default_for_push);\n  }\n\n  if (updates.length === 0) {\n    const calendar = await getCalendar(calendarId);\n    if (!calendar) throw new Error(`Calendar not found: ${calendarId}`);\n    return calendar;\n  }\n\n  updates.push(`updated_at = NOW()`);\n  values.push(calendarId);\n\n  const result = await pool.query(`\n    UPDATE google_calendars\n    SET ${updates.join(', ')}\n    WHERE id = $${paramIndex}\n    RETURNING *\n  `, values);\n\n  if (result.rows.length === 0) {\n    throw new Error(`Calendar not found: ${calendarId}`);\n  }\n\n  return result.rows[0] as GoogleCalendar;\n}",
      "references": [
        "updates",
        "paramIndex",
        "values",
        "getCalendar",
        "calendar",
        "pool",
        "Error",
        "result"
      ]
    },
    "file:src/services/google/calendars.ts:fn:updateEventsSyncToken:265": {
      "id": "file:src/services/google/calendars.ts:fn:updateEventsSyncToken:265",
      "type": "function",
      "name": "updateEventsSyncToken",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 265,
      "endLine": 276,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendarId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "syncToken",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates events sync token and timestamps for a Google calendar in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateEventsSyncToken(\n  calendarId: string,\n  syncToken: string | null\n): Promise<void> {\n  await pool.query(`\n    UPDATE google_calendars\n    SET events_sync_token = $1,\n        last_synced_at = NOW(),\n        updated_at = NOW()\n    WHERE id = $2\n  `, [syncToken, calendarId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/calendars.ts:fn:getCalendarStats:281": {
      "id": "file:src/services/google/calendars.ts:fn:getCalendarStats:281",
      "type": "function",
      "name": "getCalendarStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/calendars.ts",
      "line": 281,
      "endLine": 301,
      "parentFileId": "file:src/services/google/calendars.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ total: number; syncEnabled: number; lastSyncedAt: Date; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves total, sync-enabled count, and last sync time for Google calendars by account ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getCalendarStats(accountId: string): Promise<{\n  total: number;\n  syncEnabled: number;\n  lastSyncedAt: Date | null;\n}> {\n  const result = await pool.query(`\n    SELECT\n      COUNT(*) as total,\n      COUNT(*) FILTER (WHERE sync_enabled = TRUE) as sync_enabled,\n      MAX(last_synced_at) as last_synced_at\n    FROM google_calendars\n    WHERE google_account_id = $1\n  `, [accountId]);\n\n  const row = result.rows[0];\n  return {\n    total: parseInt(row.total, 10),\n    syncEnabled: parseInt(row.sync_enabled, 10),\n    lastSyncedAt: row.last_synced_at,\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row"
      ]
    },
    "file:src/services/google/events.ts": {
      "id": "file:src/services/google/events.ts",
      "type": "file",
      "name": "events.ts",
      "filePath": "src/services/google/events.ts",
      "line": 1,
      "endLine": 586,
      "imports": [
        {
          "source": "googleapis",
          "items": [
            {
              "name": "google",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "calendar_v3",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./auth.js",
          "items": [
            {
              "name": "getAuthenticatedClient",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./calendars.js",
          "items": [
            {
              "name": "GoogleCalendar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateEventsSyncToken",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "pullEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pushEventToGoogle",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateEventInGoogle",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteEventFromGoogle",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getAllEvents",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEventByCommitmentId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkEventToCommitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "detectConflict",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GoogleEvent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SyncResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PushResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/google/events.ts:fn:pullEvents:50",
        "file:src/services/google/events.ts:fn:pushEventToGoogle:246",
        "file:src/services/google/events.ts:fn:updateEventInGoogle:342",
        "file:src/services/google/events.ts:fn:deleteEventFromGoogle:432",
        "file:src/services/google/events.ts:fn:getEvents:454",
        "file:src/services/google/events.ts:fn:getAllEvents:499",
        "file:src/services/google/events.ts:fn:getEventByCommitmentId:537",
        "file:src/services/google/events.ts:fn:linkEventToCommitment:548",
        "file:src/services/google/events.ts:fn:detectConflict:562"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/google/events.ts:fn:pullEvents:50": {
      "id": "file:src/services/google/events.ts:fn:pullEvents:50",
      "type": "function",
      "name": "pullEvents",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 50,
      "endLine": 240,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendar",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ timeMin?: Date; timeMax?: Date; fullSync?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/events\").SyncResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Pulls Google Calendar events via API incrementally or full sync with pagination and error handling",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function pullEvents(\n  calendar: GoogleCalendar,\n  options: {\n    timeMin?: Date;\n    timeMax?: Date;\n    fullSync?: boolean;\n  } = {}\n): Promise<SyncResult> {\n  const authClient = await getAuthenticatedClient(calendar.google_account_id);\n  const calendarApi = google.calendar({ version: 'v3', auth: authClient });\n\n  const syncToken = options.fullSync ? null : calendar.events_sync_token;\n  let events: calendar_v3.Schema$Event[] = [];\n  let nextPageToken: string | undefined;\n  let nextSyncToken: string | null = null;\n\n  try {\n    if (syncToken) {\n      // Incremental sync\n      const response = await calendarApi.events.list({\n        calendarId: calendar.calendar_id,\n        syncToken: syncToken,\n      });\n      events = response.data.items || [];\n      nextSyncToken = response.data.nextSyncToken || null;\n    } else {\n      // Full sync - paginate through events\n      const timeMin = options.timeMin || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000); // 30 days ago\n      const timeMax = options.timeMax || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000); // 1 year ahead\n\n      do {\n        const response = await calendarApi.events.list({\n          calendarId: calendar.calendar_id,\n          timeMin: timeMin.toISOString(),\n          timeMax: timeMax.toISOString(),\n          singleEvents: false, // Get recurring event templates\n          showDeleted: true,\n          pageToken: nextPageToken,\n          maxResults: 250,\n        });\n        events.push(...(response.data.items || []));\n        nextPageToken = response.data.nextPageToken || undefined;\n        nextSyncToken = response.data.nextSyncToken || null;\n      } while (nextPageToken);\n    }\n  } catch (err: unknown) {\n    // If sync token is invalid (410 Gone), do full sync\n    if (err instanceof Error && 'code' in err && (err as { code: number }).code === 410) {\n      await updateEventsSyncToken(calendar.id, null);\n      return pullEvents(calendar, { ...options, fullSync: true });\n    }\n    throw err;\n  }\n\n  let pulled = 0;\n  let updated = 0;\n  let deleted = 0;\n\n  for (const event of events) {\n    if (!event.id) continue;\n\n    // Handle deleted events\n    if (event.status === 'cancelled') {\n      const result = await pool.query(`\n        DELETE FROM google_events\n        WHERE google_calendar_id = $1 AND event_id = $2\n      `, [calendar.id, event.id]);\n      if ((result.rowCount ?? 0) > 0) deleted++;\n      continue;\n    }\n\n    // Parse timing\n    const startTime = event.start?.dateTime\n      ? new Date(event.start.dateTime)\n      : event.start?.date\n        ? new Date(event.start.date)\n        : null;\n\n    const endTime = event.end?.dateTime\n      ? new Date(event.end.dateTime)\n      : event.end?.date\n        ? new Date(event.end.date)\n        : null;\n\n    const allDay = !!(event.start?.date && !event.start?.dateTime);\n    const timezone = event.start?.timeZone || null;\n\n    // Extract recurrence rule\n    const rrule = event.recurrence?.find(r => r.startsWith('RRULE:'))?.replace('RRULE:', '') || null;\n\n    // Get organizer and attendee info\n    const organizerEmail = event.organizer?.email || null;\n    const attendeeCount = event.attendees?.length || 0;\n    const userResponse = event.attendees?.find(a => a.self)?.responseStatus || null;\n\n    // Check if exists\n    const existing = await pool.query(`\n      SELECT id FROM google_events\n      WHERE google_calendar_id = $1 AND event_id = $2\n    `, [calendar.id, event.id]);\n\n    if (existing.rows.length > 0) {\n      // Update\n      await pool.query(`\n        UPDATE google_events SET\n          summary = $1,\n          description = $2,\n          location = $3,\n          html_link = $4,\n          start_time = $5,\n          end_time = $6,\n          all_day = $7,\n          timezone = $8,\n          rrule = $9,\n          recurring_event_id = $10,\n          original_start_time = $11,\n          status = $12,\n          visibility = $13,\n          etag = $14,\n          organizer_email = $15,\n          attendee_count = $16,\n          user_response_status = $17,\n          raw = $18,\n          updated_at = NOW()\n        WHERE google_calendar_id = $19 AND event_id = $20\n      `, [\n        event.summary || null,\n        event.description || null,\n        event.location || null,\n        event.htmlLink || null,\n        startTime,\n        endTime,\n        allDay,\n        timezone,\n        rrule,\n        event.recurringEventId || null,\n        event.originalStartTime?.dateTime ? new Date(event.originalStartTime.dateTime) : null,\n        event.status || 'confirmed',\n        event.visibility || 'default',\n        event.etag || null,\n        organizerEmail,\n        attendeeCount,\n        userResponse,\n        JSON.stringify(event),\n        calendar.id,\n        event.id,\n      ]);\n      updated++;\n    } else {\n      // Insert\n      await pool.query(`\n        INSERT INTO google_events (\n          google_calendar_id, event_id, summary, description, location,\n          html_link, start_time, end_time, all_day, timezone,\n          rrule, recurring_event_id, original_start_time,\n          status, visibility, etag, organizer_email, attendee_count,\n          user_response_status, raw\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)\n      `, [\n        calendar.id,\n        event.id,\n        event.summary || null,\n        event.description || null,\n        event.location || null,\n        event.htmlLink || null,\n        startTime,\n        endTime,\n        allDay,\n        timezone,\n        rrule,\n        event.recurringEventId || null,\n        event.originalStartTime?.dateTime ? new Date(event.originalStartTime.dateTime) : null,\n        event.status || 'confirmed',\n        event.visibility || 'default',\n        event.etag || null,\n        organizerEmail,\n        attendeeCount,\n        userResponse,\n        JSON.stringify(event),\n      ]);\n      pulled++;\n    }\n  }\n\n  // Update sync token\n  if (nextSyncToken) {\n    await updateEventsSyncToken(calendar.id, nextSyncToken);\n  }\n\n  return { pulled, updated, deleted, nextSyncToken };\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "syncToken",
        "calendarApi",
        "events",
        "response",
        "nextSyncToken",
        "Date",
        "timeMin",
        "timeMax",
        "nextPageToken",
        "err",
        "Error",
        "updateEventsSyncToken",
        "pullEvents",
        "event",
        "pool",
        "result",
        "deleted",
        "r",
        "a",
        "existing",
        "startTime",
        "endTime",
        "allDay",
        "timezone",
        "rrule",
        "organizerEmail",
        "attendeeCount",
        "userResponse",
        "JSON",
        "updated",
        "pulled"
      ]
    },
    "file:src/services/google/events.ts:fn:pushEventToGoogle:246": {
      "id": "file:src/services/google/events.ts:fn:pushEventToGoogle:246",
      "type": "function",
      "name": "pushEventToGoogle",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 246,
      "endLine": 337,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendar",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "event",
          "type": "{ id?: string; title: string; description?: string; due_at: Date; duration_minutes?: number; all_day?: boolean; timezone?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/events\").PushResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Pushes event to Google Calendar via API and caches in local DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function pushEventToGoogle(\n  calendar: GoogleCalendar,\n  event: {\n    id?: string; // Optional commitment ID to link to\n    title: string;\n    description?: string;\n    due_at: Date;\n    duration_minutes?: number;\n    all_day?: boolean;\n    timezone?: string;\n  }\n): Promise<PushResult> {\n  const authClient = await getAuthenticatedClient(calendar.google_account_id);\n  const calendarApi = google.calendar({ version: 'v3', auth: authClient });\n\n  const duration = event.duration_minutes || 60; // Default 1 hour\n  const endTime = new Date(event.due_at.getTime() + duration * 60 * 1000);\n\n  const eventResource: calendar_v3.Schema$Event = {\n    summary: event.title,\n    description: event.description,\n  };\n\n  if (event.all_day) {\n    // All-day event uses date format\n    eventResource.start = {\n      date: event.due_at.toISOString().split('T')[0],\n      timeZone: event.timezone || config.timezone,\n    };\n    eventResource.end = {\n      date: endTime.toISOString().split('T')[0],\n      timeZone: event.timezone || config.timezone,\n    };\n  } else {\n    // Timed event uses dateTime\n    eventResource.start = {\n      dateTime: event.due_at.toISOString(),\n      timeZone: event.timezone || config.timezone,\n    };\n    eventResource.end = {\n      dateTime: endTime.toISOString(),\n      timeZone: event.timezone || config.timezone,\n    };\n  }\n\n  const response = await calendarApi.events.insert({\n    calendarId: calendar.calendar_id,\n    requestBody: eventResource,\n  });\n\n  if (!response.data.id || !response.data.etag) {\n    throw new Error('Failed to create event in Google Calendar');\n  }\n\n  // Cache the event locally\n  await pool.query(`\n    INSERT INTO google_events (\n      google_calendar_id, event_id, summary, description,\n      start_time, end_time, all_day, timezone, status, etag,\n      commitment_id, raw\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)\n    ON CONFLICT (google_calendar_id, event_id) DO UPDATE SET\n      summary = EXCLUDED.summary,\n      description = EXCLUDED.description,\n      start_time = EXCLUDED.start_time,\n      end_time = EXCLUDED.end_time,\n      all_day = EXCLUDED.all_day,\n      etag = EXCLUDED.etag,\n      commitment_id = EXCLUDED.commitment_id,\n      raw = EXCLUDED.raw,\n      updated_at = NOW()\n  `, [\n    calendar.id,\n    response.data.id,\n    event.title,\n    event.description || null,\n    event.due_at,\n    endTime,\n    event.all_day || false,\n    event.timezone || config.timezone,\n    'confirmed',\n    response.data.etag,\n    event.id || null,  // commitment_id is optional\n    JSON.stringify(response.data),\n  ]);\n\n  return {\n    created: true,\n    event_id: response.data.id,\n    etag: response.data.etag,\n  };\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "Date",
        "duration",
        "eventResource",
        "config",
        "endTime",
        "calendarApi",
        "response",
        "Error",
        "pool",
        "JSON"
      ]
    },
    "file:src/services/google/events.ts:fn:updateEventInGoogle:342": {
      "id": "file:src/services/google/events.ts:fn:updateEventInGoogle:342",
      "type": "function",
      "name": "updateEventInGoogle",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 342,
      "endLine": 427,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendar",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "eventId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "updates",
          "type": "{ title?: string; description?: string; due_at?: Date; duration_minutes?: number; all_day?: boolean; timezone?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ etag: string; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates Google Calendar event via API and local DB cache.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.720Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateEventInGoogle(\n  calendar: GoogleCalendar,\n  eventId: string,\n  updates: {\n    title?: string;\n    description?: string;\n    due_at?: Date;\n    duration_minutes?: number;\n    all_day?: boolean;\n    timezone?: string;\n  }\n): Promise<{ etag: string }> {\n  const authClient = await getAuthenticatedClient(calendar.google_account_id);\n  const calendarApi = google.calendar({ version: 'v3', auth: authClient });\n\n  // Get existing event first\n  const existing = await calendarApi.events.get({\n    calendarId: calendar.calendar_id,\n    eventId: eventId,\n  });\n\n  const eventResource = { ...existing.data };\n\n  if (updates.title !== undefined) {\n    eventResource.summary = updates.title;\n  }\n  if (updates.description !== undefined) {\n    eventResource.description = updates.description;\n  }\n  if (updates.due_at !== undefined) {\n    const duration = updates.duration_minutes || 60;\n    const endTime = new Date(updates.due_at.getTime() + duration * 60 * 1000);\n\n    if (updates.all_day) {\n      eventResource.start = {\n        date: updates.due_at.toISOString().split('T')[0],\n        timeZone: updates.timezone || config.timezone,\n      };\n      eventResource.end = {\n        date: endTime.toISOString().split('T')[0],\n        timeZone: updates.timezone || config.timezone,\n      };\n    } else {\n      eventResource.start = {\n        dateTime: updates.due_at.toISOString(),\n        timeZone: updates.timezone || config.timezone,\n      };\n      eventResource.end = {\n        dateTime: endTime.toISOString(),\n        timeZone: updates.timezone || config.timezone,\n      };\n    }\n  }\n\n  const response = await calendarApi.events.update({\n    calendarId: calendar.calendar_id,\n    eventId: eventId,\n    requestBody: eventResource,\n  });\n\n  // Update local cache\n  await pool.query(`\n    UPDATE google_events SET\n      summary = $1,\n      description = $2,\n      start_time = $3,\n      end_time = $4,\n      all_day = $5,\n      etag = $6,\n      raw = $7,\n      updated_at = NOW()\n    WHERE google_calendar_id = $8 AND event_id = $9\n  `, [\n    eventResource.summary,\n    eventResource.description,\n    eventResource.start?.dateTime ? new Date(eventResource.start.dateTime) : null,\n    eventResource.end?.dateTime ? new Date(eventResource.end.dateTime) : null,\n    !!(eventResource.start?.date),\n    response.data.etag,\n    JSON.stringify(response.data),\n    calendar.id,\n    eventId,\n  ]);\n\n  return { etag: response.data.etag || '' };\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "calendarApi",
        "existing",
        "eventResource",
        "Date",
        "duration",
        "config",
        "endTime",
        "pool",
        "response",
        "JSON"
      ]
    },
    "file:src/services/google/events.ts:fn:deleteEventFromGoogle:432": {
      "id": "file:src/services/google/events.ts:fn:deleteEventFromGoogle:432",
      "type": "function",
      "name": "deleteEventFromGoogle",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 432,
      "endLine": 449,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendar",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "eventId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes Google Calendar event via API and removes from local DB cache",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.721Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteEventFromGoogle(\n  calendar: GoogleCalendar,\n  eventId: string\n): Promise<void> {\n  const authClient = await getAuthenticatedClient(calendar.google_account_id);\n  const calendarApi = google.calendar({ version: 'v3', auth: authClient });\n\n  await calendarApi.events.delete({\n    calendarId: calendar.calendar_id,\n    eventId: eventId,\n  });\n\n  // Remove from local cache\n  await pool.query(`\n    DELETE FROM google_events\n    WHERE google_calendar_id = $1 AND event_id = $2\n  `, [calendar.id, eventId]);\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "calendarApi",
        "pool"
      ]
    },
    "file:src/services/google/events.ts:fn:getEvents:454": {
      "id": "file:src/services/google/events.ts:fn:getEvents:454",
      "type": "function",
      "name": "getEvents",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 454,
      "endLine": 494,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendarId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ timeMin?: Date; timeMax?: Date; limit?: number; includeDeleted?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/events\").GoogleEvent[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves Google events from database for a calendar with optional time range, limit, and deleted filters",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.721Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEvents(\n  calendarId: string,\n  options: {\n    timeMin?: Date;\n    timeMax?: Date;\n    limit?: number;\n    includeDeleted?: boolean;\n  } = {}\n): Promise<GoogleEvent[]> {\n  const conditions = ['google_calendar_id = $1'];\n  const values: unknown[] = [calendarId];\n  let paramIndex = 2;\n\n  if (options.timeMin) {\n    conditions.push(`end_time >= $${paramIndex++}`);\n    values.push(options.timeMin);\n  }\n\n  if (options.timeMax) {\n    conditions.push(`start_time <= $${paramIndex++}`);\n    values.push(options.timeMax);\n  }\n\n  if (!options.includeDeleted) {\n    conditions.push(`status != 'cancelled'`);\n  }\n\n  let query = `\n    SELECT * FROM google_events\n    WHERE ${conditions.join(' AND ')}\n    ORDER BY start_time ASC\n  `;\n\n  if (options.limit) {\n    query += ` LIMIT $${paramIndex}`;\n    values.push(options.limit);\n  }\n\n  const result = await pool.query(query, values);\n  return result.rows as GoogleEvent[];\n}",
      "references": [
        "conditions",
        "paramIndex",
        "values",
        "query",
        "pool",
        "result"
      ]
    },
    "file:src/services/google/events.ts:fn:getAllEvents:499": {
      "id": "file:src/services/google/events.ts:fn:getAllEvents:499",
      "type": "function",
      "name": "getAllEvents",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 499,
      "endLine": 532,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ timeMin?: Date; timeMax?: Date; accountId?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/events\").GoogleEvent[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches Google events from database with optional time and account filters",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.721Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getAllEvents(options: {\n  timeMin?: Date;\n  timeMax?: Date;\n  accountId?: string;\n}): Promise<GoogleEvent[]> {\n  const conditions = [`status != 'cancelled'`];\n  const values: unknown[] = [];\n  let paramIndex = 1;\n\n  if (options.timeMin) {\n    conditions.push(`ge.end_time >= $${paramIndex++}`);\n    values.push(options.timeMin);\n  }\n\n  if (options.timeMax) {\n    conditions.push(`ge.start_time <= $${paramIndex++}`);\n    values.push(options.timeMax);\n  }\n\n  if (options.accountId) {\n    conditions.push(`gc.google_account_id = $${paramIndex++}`);\n    values.push(options.accountId);\n  }\n\n  const result = await pool.query(`\n    SELECT ge.*, gc.summary as calendar_name, gc.background_color\n    FROM google_events ge\n    JOIN google_calendars gc ON ge.google_calendar_id = gc.id\n    WHERE ${conditions.join(' AND ')} AND gc.sync_enabled = TRUE\n    ORDER BY ge.start_time ASC\n  `, values);\n\n  return result.rows as GoogleEvent[];\n}",
      "references": [
        "conditions",
        "paramIndex",
        "values",
        "pool",
        "result"
      ]
    },
    "file:src/services/google/events.ts:fn:getEventByCommitmentId:537": {
      "id": "file:src/services/google/events.ts:fn:getEventByCommitmentId:537",
      "type": "function",
      "name": "getEventByCommitmentId",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 537,
      "endLine": 543,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/events\").GoogleEvent>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves GoogleEvent from database by commitmentId",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.721Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getEventByCommitmentId(commitmentId: string): Promise<GoogleEvent | null> {\n  const result = await pool.query(\n    'SELECT * FROM google_events WHERE commitment_id = $1',\n    [commitmentId]\n  );\n  return result.rows[0] as GoogleEvent || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/events.ts:fn:linkEventToCommitment:548": {
      "id": "file:src/services/google/events.ts:fn:linkEventToCommitment:548",
      "type": "function",
      "name": "linkEventToCommitment",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 548,
      "endLine": 557,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "eventId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "commitmentId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates commitment_id and updated_at for a Google event in the database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkEventToCommitment(\n  eventId: string,\n  commitmentId: string\n): Promise<void> {\n  await pool.query(`\n    UPDATE google_events\n    SET commitment_id = $1, updated_at = NOW()\n    WHERE id = $2\n  `, [commitmentId, eventId]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/events.ts:fn:detectConflict:562": {
      "id": "file:src/services/google/events.ts:fn:detectConflict:562",
      "type": "function",
      "name": "detectConflict",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/events.ts",
      "line": 562,
      "endLine": 585,
      "parentFileId": "file:src/services/google/events.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "calendar",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/google/calendars\").GoogleCalendar",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "eventId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "localEtag",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Detects Google Calendar event conflict by fetching event and comparing etags, or if deleted (404).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function detectConflict(\n  calendar: GoogleCalendar,\n  eventId: string,\n  localEtag: string\n): Promise<boolean> {\n  const authClient = await getAuthenticatedClient(calendar.google_account_id);\n  const calendarApi = google.calendar({ version: 'v3', auth: authClient });\n\n  try {\n    const response = await calendarApi.events.get({\n      calendarId: calendar.calendar_id,\n      eventId: eventId,\n    });\n\n    // If etags differ, there's a conflict\n    return response.data.etag !== localEtag;\n  } catch (err: unknown) {\n    if (err instanceof Error && 'code' in err && (err as { code: number }).code === 404) {\n      // Event was deleted on Google\n      return true;\n    }\n    throw err;\n  }\n}",
      "references": [
        "getAuthenticatedClient",
        "google",
        "authClient",
        "calendarApi",
        "response",
        "err",
        "Error"
      ]
    },
    "file:src/services/google/sync.ts": {
      "id": "file:src/services/google/sync.ts",
      "type": "file",
      "name": "sync.ts",
      "filePath": "src/services/google/sync.ts",
      "line": 1,
      "endLine": 375,
      "imports": [
        {
          "source": "../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./auth.js",
          "items": [
            {
              "name": "listSyncEnabledAccounts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "markFullSyncComplete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ensureValidToken",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./calendars.js",
          "items": [
            {
              "name": "syncCalendarList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "listSyncEnabledCalendars",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getDefaultPushCalendar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./events.js",
          "items": [
            {
              "name": "pullEvents",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "pushEventToGoogle",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEventByCommitmentId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateEventInGoogle",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "fullSync",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "incrementalSync",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "syncAllAccounts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSyncHistory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getLastSuccessfulSync",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FullSyncResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SyncHistoryEntry",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/google/sync.ts:fn:startSyncHistory:39",
        "file:src/services/google/sync.ts:fn:completeSyncHistory:56",
        "file:src/services/google/sync.ts:fn:failSyncHistory:92",
        "file:src/services/google/sync.ts:fn:fullSync:113",
        "file:src/services/google/sync.ts:fn:incrementalSync:173",
        "file:src/services/google/sync.ts:fn:pushPendingCommitments:231",
        "file:src/services/google/sync.ts:fn:syncAllAccounts:321",
        "file:src/services/google/sync.ts:fn:getSyncHistory:348",
        "file:src/services/google/sync.ts:fn:getLastSuccessfulSync:364"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/google/sync.ts:fn:startSyncHistory:39": {
      "id": "file:src/services/google/sync.ts:fn:startSyncHistory:39",
      "type": "function",
      "name": "startSyncHistory",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 39,
      "endLine": 51,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "calendarId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "syncType",
          "type": "\"full\" | \"incremental\" | \"push\" | \"pull\"",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new Google sync history record into DB and returns its ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function startSyncHistory(\n  accountId: string,\n  calendarId: string | null,\n  syncType: 'full' | 'incremental' | 'push' | 'pull'\n): Promise<string> {\n  const result = await pool.query(`\n    INSERT INTO google_sync_history (\n      google_account_id, google_calendar_id, sync_type, status\n    ) VALUES ($1, $2, $3, 'started')\n    RETURNING id\n  `, [accountId, calendarId, syncType]);\n  return result.rows[0].id;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/sync.ts:fn:completeSyncHistory:56": {
      "id": "file:src/services/google/sync.ts:fn:completeSyncHistory:56",
      "type": "function",
      "name": "completeSyncHistory",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 56,
      "endLine": 87,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "historyId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "results",
          "type": "{ events_pulled?: number; events_pushed?: number; events_updated?: number; events_deleted?: number; conflicts_found?: number; conflicts_resolved?: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates google_sync_history table with sync completion status and event counts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function completeSyncHistory(\n  historyId: string,\n  results: {\n    events_pulled?: number;\n    events_pushed?: number;\n    events_updated?: number;\n    events_deleted?: number;\n    conflicts_found?: number;\n    conflicts_resolved?: number;\n  }\n): Promise<void> {\n  await pool.query(`\n    UPDATE google_sync_history SET\n      status = 'completed',\n      events_pulled = $1,\n      events_pushed = $2,\n      events_updated = $3,\n      events_deleted = $4,\n      conflicts_found = $5,\n      conflicts_resolved = $6,\n      completed_at = NOW()\n    WHERE id = $7\n  `, [\n    results.events_pulled || 0,\n    results.events_pushed || 0,\n    results.events_updated || 0,\n    results.events_deleted || 0,\n    results.conflicts_found || 0,\n    results.conflicts_resolved || 0,\n    historyId,\n  ]);\n}",
      "references": [
        "pool"
      ]
    },
    "file:src/services/google/sync.ts:fn:failSyncHistory:92": {
      "id": "file:src/services/google/sync.ts:fn:failSyncHistory:92",
      "type": "function",
      "name": "failSyncHistory",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 92,
      "endLine": 105,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "historyId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "error",
          "type": "Error",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "details",
          "type": "Record<string, unknown>",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates google_sync_history table to mark sync as failed with error details",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function failSyncHistory(\n  historyId: string,\n  error: Error,\n  details?: Record<string, unknown>\n): Promise<void> {\n  await pool.query(`\n    UPDATE google_sync_history SET\n      status = 'failed',\n      error_message = $1,\n      error_details = $2,\n      completed_at = NOW()\n    WHERE id = $3\n  `, [error.message, details ? JSON.stringify(details) : null, historyId]);\n}",
      "references": [
        "pool",
        "JSON"
      ]
    },
    "file:src/services/google/sync.ts:fn:fullSync:113": {
      "id": "file:src/services/google/sync.ts:fn:fullSync:113",
      "type": "function",
      "name": "fullSync",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 113,
      "endLine": 167,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/sync\").FullSyncResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Orchestrates full Google Calendar sync: pulls events, pushes commitments, updates history",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fullSync(accountId: string): Promise<FullSyncResult> {\n  const historyId = await startSyncHistory(accountId, null, 'full');\n  const result: FullSyncResult = {\n    accountId,\n    calendars: 0,\n    events: { pulled: 0, updated: 0, deleted: 0 },\n    commitmentsPushed: 0,\n    errors: [],\n  };\n\n  try {\n    // Ensure valid token\n    await ensureValidToken(accountId);\n\n    // Sync calendar list\n    const calendars = await syncCalendarList(accountId);\n    result.calendars = calendars.length;\n\n    // Get sync-enabled calendars\n    const syncCalendars = await listSyncEnabledCalendars(accountId);\n\n    // Pull events from each calendar\n    for (const calendar of syncCalendars) {\n      try {\n        const syncResult = await pullEvents(calendar, { fullSync: true });\n        result.events.pulled += syncResult.pulled;\n        result.events.updated += syncResult.updated;\n        result.events.deleted += syncResult.deleted;\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        result.errors.push(`Failed to pull from ${calendar.summary}: ${msg}`);\n      }\n    }\n\n    // Push pending commitments\n    const pushed = await pushPendingCommitments(accountId);\n    result.commitmentsPushed = pushed;\n\n    // Mark full sync complete\n    await markFullSyncComplete(accountId);\n\n    await completeSyncHistory(historyId, {\n      events_pulled: result.events.pulled,\n      events_updated: result.events.updated,\n      events_deleted: result.events.deleted,\n      events_pushed: result.commitmentsPushed,\n    });\n\n    return result;\n  } catch (err) {\n    const error = err instanceof Error ? err : new Error(String(err));\n    await failSyncHistory(historyId, error, { result });\n    throw err;\n  }\n}",
      "references": [
        "startSyncHistory",
        "ensureValidToken",
        "syncCalendarList",
        "result",
        "calendars",
        "listSyncEnabledCalendars",
        "syncCalendars",
        "pullEvents",
        "calendar",
        "syncResult",
        "err",
        "Error",
        "String",
        "msg",
        "pushPendingCommitments",
        "pushed",
        "markFullSyncComplete",
        "completeSyncHistory",
        "historyId",
        "failSyncHistory",
        "error"
      ]
    },
    "file:src/services/google/sync.ts:fn:incrementalSync:173": {
      "id": "file:src/services/google/sync.ts:fn:incrementalSync:173",
      "type": "function",
      "name": "incrementalSync",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 173,
      "endLine": 226,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/sync\").FullSyncResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Performs incremental Google calendar/event sync: pull events, push commitments",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:10.723Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function incrementalSync(accountId: string): Promise<FullSyncResult> {\n  const historyId = await startSyncHistory(accountId, null, 'incremental');\n  const result: FullSyncResult = {\n    accountId,\n    calendars: 0,\n    events: { pulled: 0, updated: 0, deleted: 0 },\n    commitmentsPushed: 0,\n    errors: [],\n  };\n\n  try {\n    // Ensure valid token\n    await ensureValidToken(accountId);\n\n    // Sync calendar list (incremental)\n    const calendars = await syncCalendarList(accountId);\n    result.calendars = calendars.length;\n\n    // Get sync-enabled calendars\n    const syncCalendars = await listSyncEnabledCalendars(accountId);\n\n    // Pull events from each calendar (incremental)\n    for (const calendar of syncCalendars) {\n      if (calendar.sync_direction === 'write_only') continue;\n\n      try {\n        const syncResult = await pullEvents(calendar);\n        result.events.pulled += syncResult.pulled;\n        result.events.updated += syncResult.updated;\n        result.events.deleted += syncResult.deleted;\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err);\n        result.errors.push(`Failed to pull from ${calendar.summary}: ${msg}`);\n      }\n    }\n\n    // Push pending commitments\n    const pushed = await pushPendingCommitments(accountId);\n    result.commitmentsPushed = pushed;\n\n    await completeSyncHistory(historyId, {\n      events_pulled: result.events.pulled,\n      events_updated: result.events.updated,\n      events_deleted: result.events.deleted,\n      events_pushed: result.commitmentsPushed,\n    });\n\n    return result;\n  } catch (err) {\n    const error = err instanceof Error ? err : new Error(String(err));\n    await failSyncHistory(historyId, error, { result });\n    throw err;\n  }\n}",
      "references": [
        "startSyncHistory",
        "ensureValidToken",
        "syncCalendarList",
        "result",
        "calendars",
        "listSyncEnabledCalendars",
        "syncCalendars",
        "calendar",
        "pullEvents",
        "syncResult",
        "err",
        "Error",
        "String",
        "msg",
        "pushPendingCommitments",
        "pushed",
        "completeSyncHistory",
        "historyId",
        "failSyncHistory",
        "error"
      ]
    },
    "file:src/services/google/sync.ts:fn:pushPendingCommitments:231": {
      "id": "file:src/services/google/sync.ts:fn:pushPendingCommitments:231",
      "type": "function",
      "name": "pushPendingCommitments",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 231,
      "endLine": 316,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Pushes pending commitments to Google Calendar and updates DB sync status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.960Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function pushPendingCommitments(accountId: string): Promise<number> {\n  // Get default push calendar\n  const calendar = await getDefaultPushCalendar(accountId);\n  if (!calendar) {\n    return 0; // No calendar to push to\n  }\n\n  if (calendar.sync_direction === 'read_only') {\n    return 0; // Calendar is read-only\n  }\n\n  // Find commitments that need to be pushed\n  // pending_push status OR have google_account_id set but no google_event_id\n  const pendingResult = await pool.query(`\n    SELECT * FROM commitments\n    WHERE google_account_id = $1\n      AND google_sync_status = 'pending_push'\n      AND due_at IS NOT NULL\n      AND status IN ('open', 'in_progress')\n  `, [accountId]);\n\n  let pushed = 0;\n\n  for (const commitment of pendingResult.rows) {\n    try {\n      // Check if already synced\n      const existingEvent = await getEventByCommitmentId(commitment.id);\n\n      if (existingEvent) {\n        // Update existing event\n        await updateEventInGoogle(calendar, existingEvent.event_id, {\n          title: commitment.title,\n          description: commitment.description,\n          due_at: commitment.due_at,\n          duration_minutes: commitment.duration_minutes,\n          all_day: commitment.all_day,\n          timezone: commitment.timezone,\n        });\n      } else {\n        // Create new event\n        const result = await pushEventToGoogle(calendar, {\n          id: commitment.id,\n          title: commitment.title,\n          description: commitment.description,\n          due_at: commitment.due_at,\n          duration_minutes: commitment.duration_minutes,\n          all_day: commitment.all_day,\n          timezone: commitment.timezone,\n        });\n\n        // Update commitment with Google info\n        await pool.query(`\n          UPDATE commitments SET\n            google_calendar_id = $1,\n            google_event_id = $2,\n            google_sync_status = 'synced',\n            last_synced_at = NOW(),\n            updated_at = NOW()\n          WHERE id = $3\n        `, [calendar.calendar_id, result.event_id, commitment.id]);\n      }\n\n      // Mark as synced\n      await pool.query(`\n        UPDATE commitments SET\n          google_sync_status = 'synced',\n          last_synced_at = NOW(),\n          updated_at = NOW()\n        WHERE id = $1\n      `, [commitment.id]);\n\n      pushed++;\n    } catch (err) {\n      console.error(`Failed to push commitment ${commitment.id}:`, err);\n      // Mark as failed but don't stop\n      await pool.query(`\n        UPDATE commitments SET\n          google_sync_status = 'local_only',\n          updated_at = NOW()\n        WHERE id = $1\n      `, [commitment.id]);\n    }\n  }\n\n  return pushed;\n}",
      "references": [
        "getDefaultPushCalendar",
        "calendar",
        "pool",
        "pendingResult",
        "getEventByCommitmentId",
        "commitment",
        "existingEvent",
        "updateEventInGoogle",
        "pushEventToGoogle",
        "result",
        "pushed",
        "console",
        "err"
      ]
    },
    "file:src/services/google/sync.ts:fn:syncAllAccounts:321": {
      "id": "file:src/services/google/sync.ts:fn:syncAllAccounts:321",
      "type": "function",
      "name": "syncAllAccounts",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 321,
      "endLine": 343,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<Map<string, import(\"/home/ridgetop/projects/squire/src/services/google/sync\").FullSyncResult>>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Syncs all sync-enabled Google accounts incrementally and returns results map",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function syncAllAccounts(): Promise<Map<string, FullSyncResult>> {\n  const accounts = await listSyncEnabledAccounts();\n  const results = new Map<string, FullSyncResult>();\n\n  for (const account of accounts) {\n    try {\n      // Use incremental sync for regular updates\n      const result = await incrementalSync(account.id);\n      results.set(account.id, result);\n    } catch (err) {\n      console.error(`Failed to sync account ${account.email}:`, err);\n      results.set(account.id, {\n        accountId: account.id,\n        calendars: 0,\n        events: { pulled: 0, updated: 0, deleted: 0 },\n        commitmentsPushed: 0,\n        errors: [err instanceof Error ? err.message : String(err)],\n      });\n    }\n  }\n\n  return results;\n}",
      "references": [
        "listSyncEnabledAccounts",
        "Map",
        "accounts",
        "incrementalSync",
        "account",
        "results",
        "result",
        "console",
        "err",
        "Error",
        "String"
      ]
    },
    "file:src/services/google/sync.ts:fn:getSyncHistory:348": {
      "id": "file:src/services/google/sync.ts:fn:getSyncHistory:348",
      "type": "function",
      "name": "getSyncHistory",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 348,
      "endLine": 359,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "20"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/google/sync\").SyncHistoryEntry[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves recent Google sync history for an account from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getSyncHistory(\n  accountId: string,\n  limit = 20\n): Promise<SyncHistoryEntry[]> {\n  const result = await pool.query(`\n    SELECT * FROM google_sync_history\n    WHERE google_account_id = $1\n    ORDER BY started_at DESC\n    LIMIT $2\n  `, [accountId, limit]);\n  return result.rows as SyncHistoryEntry[];\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/google/sync.ts:fn:getLastSuccessfulSync:364": {
      "id": "file:src/services/google/sync.ts:fn:getLastSuccessfulSync:364",
      "type": "function",
      "name": "getLastSuccessfulSync",
      "filePath": "/home/ridgetop/projects/squire/src/services/google/sync.ts",
      "line": 364,
      "endLine": 373,
      "parentFileId": "file:src/services/google/sync.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "accountId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Date>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves the most recent successful sync completion date for a Google account from DB.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getLastSuccessfulSync(accountId: string): Promise<Date | null> {\n  const result = await pool.query(`\n    SELECT completed_at FROM google_sync_history\n    WHERE google_account_id = $1\n      AND status = 'completed'\n    ORDER BY completed_at DESC\n    LIMIT 1\n  `, [accountId]);\n  return result.rows[0]?.completed_at || null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:web/src/app/layout.tsx": {
      "id": "file:web/src/app/layout.tsx",
      "type": "file",
      "name": "layout.tsx",
      "filePath": "web/src/app/layout.tsx",
      "line": 1,
      "endLine": 57,
      "imports": [
        {
          "source": "next",
          "items": [
            {
              "name": "Metadata",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Viewport",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "next/font/google",
          "items": [
            {
              "name": "Geist",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Geist_Mono",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/providers/QueryProvider",
          "items": [
            {
              "name": "QueryProvider",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/providers/WebSocketProvider",
          "items": [
            {
              "name": "WebSocketProvider",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./globals.css",
          "items": [],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "RootLayout",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "metadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "viewport",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/app/layout.tsx:fn:RootLayout:40"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/layout.tsx:fn:RootLayout:40": {
      "id": "file:web/src/app/layout.tsx:fn:RootLayout:40",
      "type": "function",
      "name": "RootLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/layout.tsx",
      "line": 40,
      "endLine": 56,
      "parentFileId": "file:web/src/app/layout.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  children,\n}",
          "type": "Readonly<{ children: React.ReactNode; }>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders root HTML layout with font classes and Query/WebSocket providers.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\">\n      <body\n        className={`${geistSans.variable} ${geistMono.variable} antialiased`}\n      >\n        <QueryProvider>\n          <WebSocketProvider>{children}</WebSocketProvider>\n        </QueryProvider>\n      </body>\n    </html>\n  );\n}",
      "references": [
        "html",
        "lang",
        "body",
        "className",
        "geistSans",
        "geistMono",
        "QueryProvider",
        "WebSocketProvider",
        "children"
      ]
    },
    "file:web/src/app/page.tsx": {
      "id": "file:web/src/app/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/page.tsx",
      "line": 1,
      "endLine": 6,
      "imports": [
        {
          "source": "next/navigation",
          "items": [
            {
              "name": "redirect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "Home",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/page.tsx:fn:Home:3"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/page.tsx:fn:Home:3": {
      "id": "file:web/src/app/page.tsx:fn:Home:3",
      "type": "function",
      "name": "Home",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/page.tsx",
      "line": 3,
      "endLine": 5,
      "parentFileId": "file:web/src/app/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Redirects to '/app/chat' page.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.322Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function Home() {\n  redirect('/app/chat');\n}",
      "references": [
        "redirect"
      ]
    },
    "file:src/services/documents/chunker/chunkEmbedding.ts": {
      "id": "file:src/services/documents/chunker/chunkEmbedding.ts",
      "type": "file",
      "name": "chunkEmbedding.ts",
      "filePath": "src/services/documents/chunker/chunkEmbedding.ts",
      "line": 1,
      "endLine": 113,
      "imports": [
        {
          "source": "../../../providers/embeddings.js",
          "items": [
            {
              "name": "generateEmbedding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateEmbeddings",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./chunkStorage.js",
          "items": [
            {
              "name": "updateChunkEmbeddings",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getChunksByObjectId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "generateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "embedAndStoreChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateQueryEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateChunkEmbeddings:18",
        "file:src/services/documents/chunker/chunkEmbedding.ts:fn:embedAndStoreChunks:55",
        "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateQueryEmbedding:109"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateChunkEmbeddings:18": {
      "id": "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateChunkEmbeddings:18",
      "type": "function",
      "name": "generateChunkEmbeddings",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkEmbedding.ts",
      "line": 18,
      "endLine": 48,
      "parentFileId": "file:src/services/documents/chunker/chunkEmbedding.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunks",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ batchSize?: number; onProgress?: (completed: number, total: number) => void; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embeddings for document chunks in batches and mutates them with results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.323Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateChunkEmbeddings(\n  chunks: DocumentChunk[],\n  options: {\n    batchSize?: number;\n    onProgress?: (completed: number, total: number) => void;\n  } = {}\n): Promise<DocumentChunk[]> {\n  const { batchSize = 10, onProgress } = options;\n\n  if (chunks.length === 0) return chunks;\n\n  // Process in batches to avoid overwhelming the embedding service\n  for (let i = 0; i < chunks.length; i += batchSize) {\n    const batch = chunks.slice(i, i + batchSize);\n    const texts = batch.map((c) => c.content);\n\n    const embeddings = await generateEmbeddings(texts);\n\n    // Update chunks with embeddings\n    batch.forEach((chunk, idx) => {\n      chunk.embedding = embeddings[idx];\n    });\n\n    // Report progress\n    if (onProgress) {\n      onProgress(Math.min(i + batchSize, chunks.length), chunks.length);\n    }\n  }\n\n  return chunks;\n}",
      "references": [
        "batchSize",
        "onProgress",
        "i",
        "batch",
        "c",
        "generateEmbeddings",
        "texts",
        "chunk",
        "embeddings",
        "idx",
        "Math"
      ]
    },
    "file:src/services/documents/chunker/chunkEmbedding.ts:fn:embedAndStoreChunks:55": {
      "id": "file:src/services/documents/chunker/chunkEmbedding.ts:fn:embedAndStoreChunks:55",
      "type": "function",
      "name": "embedAndStoreChunks",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkEmbedding.ts",
      "line": 55,
      "endLine": 101,
      "parentFileId": "file:src/services/documents/chunker/chunkEmbedding.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ batchSize?: number; onProgress?: (completed: number, total: number) => void; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embeddings for document chunks lacking them in batches and stores in DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:17.689Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function embedAndStoreChunks(\n  objectId: string,\n  options: {\n    batchSize?: number;\n    onProgress?: (completed: number, total: number) => void;\n  } = {}\n): Promise<number> {\n  const { batchSize = 10, onProgress } = options;\n\n  // Get chunks for this document\n  const chunks = await getChunksByObjectId(objectId);\n\n  if (chunks.length === 0) return 0;\n\n  // Filter to chunks without embeddings\n  const chunksToEmbed = chunks.filter((c) => !c.embedding);\n\n  if (chunksToEmbed.length === 0) return 0;\n\n  // Generate embeddings in batches\n  const updates: Array<{ chunkId: string; embedding: number[] }> = [];\n\n  for (let i = 0; i < chunksToEmbed.length; i += batchSize) {\n    const batch = chunksToEmbed.slice(i, i + batchSize);\n    const texts = batch.map((c) => c.content);\n\n    const embeddings = await generateEmbeddings(texts);\n\n    batch.forEach((chunk, idx) => {\n      const embedding = embeddings[idx];\n      if (embedding) {\n        updates.push({ chunkId: chunk.id, embedding });\n      }\n    });\n\n    if (onProgress) {\n      onProgress(Math.min(i + batchSize, chunksToEmbed.length), chunksToEmbed.length);\n    }\n  }\n\n  // Batch update all embeddings\n  if (updates.length > 0) {\n    await updateChunkEmbeddings(updates);\n  }\n\n  return updates.length;\n}",
      "references": [
        "batchSize",
        "onProgress",
        "getChunksByObjectId",
        "chunks",
        "c",
        "chunksToEmbed",
        "i",
        "batch",
        "generateEmbeddings",
        "texts",
        "embeddings",
        "idx",
        "embedding",
        "updates",
        "chunk",
        "Math",
        "updateChunkEmbeddings"
      ]
    },
    "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateQueryEmbedding:109": {
      "id": "file:src/services/documents/chunker/chunkEmbedding.ts:fn:generateQueryEmbedding:109",
      "type": "function",
      "name": "generateQueryEmbedding",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkEmbedding.ts",
      "line": 109,
      "endLine": 111,
      "parentFileId": "file:src/services/documents/chunker/chunkEmbedding.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Generates embedding vector for query by delegating to generateEmbedding.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.560Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export async function generateQueryEmbedding(query: string): Promise<number[]> {\n  return generateEmbedding(query);\n}",
      "references": [
        "generateEmbedding"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts",
      "type": "file",
      "name": "chunkStorage.ts",
      "filePath": "src/services/documents/chunker/chunkStorage.ts",
      "line": 1,
      "endLine": 276,
      "imports": [
        {
          "source": "../../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentChunkRow",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingStrategy",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "rowToChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "storeChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksBySimilarity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksByText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/chunkStorage.ts:fn:storeChunks:21",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunksByObjectId:80",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkById:94",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:updateChunkEmbeddings:110",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:deleteChunksByObjectId:142",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksBySimilarity:156",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksByText:198",
        "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkStats:231"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:storeChunks:21": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:storeChunks:21",
      "type": "function",
      "name": "storeChunks",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 21,
      "endLine": 73,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunks",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Batch upserts document chunks into database with transaction handling",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:12.726Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function storeChunks(chunks: DocumentChunk[]): Promise<void> {\n  if (chunks.length === 0) return;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    // Build batch insert\n    const values: unknown[] = [];\n    const placeholders: string[] = [];\n\n    chunks.forEach((chunk, idx) => {\n      const offset = idx * 9;\n      placeholders.push(\n        `($${offset + 1}, $${offset + 2}, $${offset + 3}, $${offset + 4}, $${offset + 5}, $${offset + 6}, $${offset + 7}, $${offset + 8}, $${offset + 9})`\n      );\n      values.push(\n        chunk.id,\n        chunk.objectId,\n        chunk.chunkIndex,\n        chunk.content,\n        chunk.tokenCount,\n        chunk.pageNumber ?? null,\n        chunk.sectionTitle ?? null,\n        chunk.chunkingStrategy,\n        JSON.stringify(chunk.metadata)\n      );\n    });\n\n    const query = `\n      INSERT INTO document_chunks (\n        id, object_id, chunk_index, content, token_count,\n        page_number, section_title, chunking_strategy, metadata\n      )\n      VALUES ${placeholders.join(', ')}\n      ON CONFLICT (object_id, chunk_index) DO UPDATE SET\n        content = EXCLUDED.content,\n        token_count = EXCLUDED.token_count,\n        page_number = EXCLUDED.page_number,\n        section_title = EXCLUDED.section_title,\n        chunking_strategy = EXCLUDED.chunking_strategy,\n        metadata = EXCLUDED.metadata\n    `;\n\n    await client.query(query, values);\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}",
      "references": [
        "pool",
        "client",
        "idx",
        "placeholders",
        "offset",
        "values",
        "chunk",
        "JSON",
        "query",
        "error"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunksByObjectId:80": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunksByObjectId:80",
      "type": "function",
      "name": "getChunksByObjectId",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 80,
      "endLine": 89,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves document chunks from DB by object ID, ordered by chunk index",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.395Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getChunksByObjectId(objectId: string): Promise<DocumentChunk[]> {\n  const result = await pool.query<DocumentChunkRow>(\n    `SELECT * FROM document_chunks\n     WHERE object_id = $1\n     ORDER BY chunk_index ASC`,\n    [objectId]\n  );\n\n  return result.rows.map(rowToChunk);\n}",
      "references": [
        "pool",
        "result",
        "rowToChunk"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkById:94": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkById:94",
      "type": "function",
      "name": "getChunkById",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 94,
      "endLine": 103,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunkId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a document chunk by ID from the database or returns null if not found.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.984Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getChunkById(chunkId: string): Promise<DocumentChunk | null> {\n  const result = await pool.query<DocumentChunkRow>(\n    'SELECT * FROM document_chunks WHERE id = $1',\n    [chunkId]\n  );\n\n  if (result.rows.length === 0) return null;\n  const row = result.rows[0];\n  return row ? rowToChunk(row) : null;\n}",
      "references": [
        "pool",
        "result",
        "row",
        "rowToChunk"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:updateChunkEmbeddings:110": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:updateChunkEmbeddings:110",
      "type": "function",
      "name": "updateChunkEmbeddings",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 110,
      "endLine": 135,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "updates",
          "type": "{ chunkId: string; embedding: number[]; }[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates embeddings for multiple document chunks in database via transaction.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.243Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateChunkEmbeddings(\n  updates: Array<{ chunkId: string; embedding: number[] }>\n): Promise<void> {\n  if (updates.length === 0) return;\n\n  const client = await pool.connect();\n  try {\n    await client.query('BEGIN');\n\n    for (const update of updates) {\n      await client.query(\n        `UPDATE document_chunks\n         SET embedding = $2\n         WHERE id = $1`,\n        [update.chunkId, JSON.stringify(update.embedding)]\n      );\n    }\n\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n}",
      "references": [
        "pool",
        "client",
        "update",
        "JSON",
        "error"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:deleteChunksByObjectId:142": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:deleteChunksByObjectId:142",
      "type": "function",
      "name": "deleteChunksByObjectId",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 142,
      "endLine": 149,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes document chunks from DB by objectId and returns row count deleted",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteChunksByObjectId(objectId: string): Promise<number> {\n  const result = await pool.query(\n    'DELETE FROM document_chunks WHERE object_id = $1',\n    [objectId]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksBySimilarity:156": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksBySimilarity:156",
      "type": "function",
      "name": "searchChunksBySimilarity",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 156,
      "endLine": 193,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "queryEmbedding",
          "type": "number[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; threshold?: number; objectId?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<(import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk & { similarity: number; })[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches document chunks by cosine similarity to query embedding using pgvector in PostgreSQL",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.244Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchChunksBySimilarity(\n  queryEmbedding: number[],\n  options: {\n    limit?: number;\n    threshold?: number;\n    objectId?: string;\n  } = {}\n): Promise<Array<DocumentChunk & { similarity: number }>> {\n  const { limit = 10, threshold = 0.5, objectId } = options;\n\n  let query = `\n    SELECT *,\n      1 - (embedding <=> $1::vector) as similarity\n    FROM document_chunks\n    WHERE embedding IS NOT NULL\n      AND 1 - (embedding <=> $1::vector) >= $2\n  `;\n\n  const params: unknown[] = [JSON.stringify(queryEmbedding), threshold];\n\n  if (objectId) {\n    query += ` AND object_id = $3`;\n    params.push(objectId);\n  }\n\n  query += ` ORDER BY similarity DESC LIMIT $${params.length + 1}`;\n  params.push(limit);\n\n  const result = await pool.query<DocumentChunkRow & { similarity: number }>(\n    query,\n    params\n  );\n\n  return result.rows.map((row) => ({\n    ...rowToChunk(row),\n    similarity: row.similarity,\n  }));\n}",
      "references": [
        "limit",
        "threshold",
        "objectId",
        "JSON",
        "query",
        "params",
        "pool",
        "result",
        "rowToChunk",
        "row"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksByText:198": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:searchChunksByText:198",
      "type": "function",
      "name": "searchChunksByText",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 198,
      "endLine": 226,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "searchText",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; objectId?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches document chunks by text using SQL ILIKE with optional objectId filter and limit",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.483Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchChunksByText(\n  searchText: string,\n  options: {\n    limit?: number;\n    objectId?: string;\n  } = {}\n): Promise<DocumentChunk[]> {\n  const { limit = 10, objectId } = options;\n\n  let query = `\n    SELECT *\n    FROM document_chunks\n    WHERE content ILIKE $1\n  `;\n\n  const params: unknown[] = [`%${searchText}%`];\n\n  if (objectId) {\n    query += ` AND object_id = $2`;\n    params.push(objectId);\n  }\n\n  query += ` ORDER BY chunk_index ASC LIMIT $${params.length + 1}`;\n  params.push(limit);\n\n  const result = await pool.query<DocumentChunkRow>(query, params);\n\n  return result.rows.map(rowToChunk);\n}",
      "references": [
        "limit",
        "objectId",
        "query",
        "params",
        "pool",
        "result",
        "rowToChunk"
      ]
    },
    "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkStats:231": {
      "id": "file:src/services/documents/chunker/chunkStorage.ts:fn:getChunkStats:231",
      "type": "function",
      "name": "getChunkStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/chunkStorage.ts",
      "line": 231,
      "endLine": 274,
      "parentFileId": "file:src/services/documents/chunker/chunkStorage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ chunkCount: number; totalTokens: number; avgTokensPerChunk: number; hasEmbeddings: boolean; chunkingStrategy: \"fixed\" | \"semantic\" | \"hybrid\"; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves chunk statistics (count, tokens, avg, embeddings, strategy) for an object ID from DB",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.926Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getChunkStats(objectId: string): Promise<{\n  chunkCount: number;\n  totalTokens: number;\n  avgTokensPerChunk: number;\n  hasEmbeddings: boolean;\n  chunkingStrategy: ChunkingStrategy | null;\n}> {\n  const result = await pool.query<{\n    chunk_count: string;\n    total_tokens: string;\n    avg_tokens: string;\n    has_embeddings: boolean;\n    chunking_strategy: ChunkingStrategy | null;\n  }>(\n    `SELECT\n      COUNT(*) as chunk_count,\n      COALESCE(SUM(token_count), 0) as total_tokens,\n      COALESCE(AVG(token_count), 0) as avg_tokens,\n      BOOL_OR(embedding IS NOT NULL) as has_embeddings,\n      (SELECT chunking_strategy FROM document_chunks WHERE object_id = $1 LIMIT 1) as chunking_strategy\n    FROM document_chunks\n    WHERE object_id = $1`,\n    [objectId]\n  );\n\n  const row = result.rows[0];\n  if (!row) {\n    return {\n      chunkCount: 0,\n      totalTokens: 0,\n      avgTokensPerChunk: 0,\n      hasEmbeddings: false,\n      chunkingStrategy: null,\n    };\n  }\n\n  return {\n    chunkCount: parseInt(row.chunk_count, 10),\n    totalTokens: parseInt(row.total_tokens, 10),\n    avgTokensPerChunk: parseFloat(row.avg_tokens),\n    hasEmbeddings: row.has_embeddings ?? false,\n    chunkingStrategy: row.chunking_strategy,\n  };\n}",
      "references": [
        "pool",
        "result",
        "row",
        "parseInt",
        "parseFloat"
      ]
    },
    "file:src/services/documents/chunker/fixedChunker.ts": {
      "id": "file:src/services/documents/chunker/fixedChunker.ts",
      "type": "file",
      "name": "fixedChunker.ts",
      "filePath": "src/services/documents/chunker/fixedChunker.ts",
      "line": 1,
      "endLine": 198,
      "imports": [
        {
          "source": "uuid",
          "items": [
            {
              "name": "v4",
              "alias": "uuidv4",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "gpt-tokenizer",
          "items": [
            {
              "name": "encode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "decode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_CHUNKING_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "countTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "truncateToTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fixedChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/fixedChunker.ts:fn:createChunk:143",
        "file:src/services/documents/chunker/fixedChunker.ts:fn:countWords:177",
        "file:src/services/documents/chunker/fixedChunker.ts:fn:countTokens:184",
        "file:src/services/documents/chunker/fixedChunker.ts:fn:truncateToTokens:191"
      ],
      "classes": [],
      "topLevelReferences": [
        "Date",
        "options",
        "text",
        "startTime",
        "tokens",
        "totalTokens",
        "opts",
        "createChunk",
        "objectId",
        "chunk",
        "startTokenIndex",
        "Math",
        "endTokenIndex",
        "chunkTokens",
        "chunkIndex",
        "chunkText",
        "isFirst",
        "isLast",
        "chunks",
        "step",
        "error",
        "Error"
      ]
    },
    "file:src/services/documents/chunker/fixedChunker.ts:fn:createChunk:143": {
      "id": "file:src/services/documents/chunker/fixedChunker.ts:fn:createChunk:143",
      "type": "function",
      "name": "createChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/fixedChunker.ts",
      "line": 143,
      "endLine": 172,
      "parentFileId": "file:src/services/documents/chunker/fixedChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "chunkIndex",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tokenCount",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "context",
          "type": "{ isFirst: boolean; isLast: boolean; startTokenIndex?: number; endTokenIndex?: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a DocumentChunk object with metadata for fixed chunking strategy",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createChunk(\n  objectId: string,\n  chunkIndex: number,\n  content: string,\n  tokenCount: number,\n  _options: ChunkingOptions,\n  context: {\n    isFirst: boolean;\n    isLast: boolean;\n    startTokenIndex?: number;\n    endTokenIndex?: number;\n  }\n): DocumentChunk {\n  return {\n    id: uuidv4(),\n    objectId,\n    chunkIndex,\n    content,\n    tokenCount,\n    chunkingStrategy: 'fixed',\n    metadata: {\n      hasOverlapBefore: !context.isFirst,\n      hasOverlapAfter: !context.isLast,\n      wordCount: countWords(content),\n      startTokenIndex: context.startTokenIndex,\n      endTokenIndex: context.endTokenIndex,\n    },\n    createdAt: new Date(),\n  };\n}",
      "references": [
        "uuidv4",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/fixedChunker.ts:fn:countWords:177": {
      "id": "file:src/services/documents/chunker/fixedChunker.ts:fn:countWords:177",
      "type": "function",
      "name": "countWords",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/fixedChunker.ts",
      "line": 177,
      "endLine": 179,
      "parentFileId": "file:src/services/documents/chunker/fixedChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts the number of non-empty words in a given text string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n}",
      "references": [
        "word"
      ]
    },
    "file:src/services/documents/chunker/fixedChunker.ts:fn:countTokens:184": {
      "id": "file:src/services/documents/chunker/fixedChunker.ts:fn:countTokens:184",
      "type": "function",
      "name": "countTokens",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/fixedChunker.ts",
      "line": 184,
      "endLine": 186,
      "parentFileId": "file:src/services/documents/chunker/fixedChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts the number of tokens in the given text using encode function.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function countTokens(text: string): number {\n  return encode(text).length;\n}",
      "references": [
        "encode"
      ]
    },
    "file:src/services/documents/chunker/fixedChunker.ts:fn:truncateToTokens:191": {
      "id": "file:src/services/documents/chunker/fixedChunker.ts:fn:truncateToTokens:191",
      "type": "function",
      "name": "truncateToTokens",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/fixedChunker.ts",
      "line": 191,
      "endLine": 197,
      "parentFileId": "file:src/services/documents/chunker/fixedChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "maxTokens",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Truncates input text to maxTokens by tokenizing, slicing, and decoding.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function truncateToTokens(text: string, maxTokens: number): string {\n  const tokens = encode(text);\n  if (tokens.length <= maxTokens) {\n    return text;\n  }\n  return decode(tokens.slice(0, maxTokens));\n}",
      "references": [
        "encode",
        "tokens",
        "decode"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts",
      "type": "file",
      "name": "hybridChunker.ts",
      "filePath": "src/services/documents/chunker/hybridChunker.ts",
      "line": 1,
      "endLine": 427,
      "imports": [
        {
          "source": "uuid",
          "items": [
            {
              "name": "v4",
              "alias": "uuidv4",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "gpt-tokenizer",
          "items": [
            {
              "name": "encode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "decode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentSection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_CHUNKING_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./semanticChunker.js",
          "items": [
            {
              "name": "detectSections",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "hybridChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/hybridChunker.ts:fn:splitIntoSemanticUnits:111",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:groupUnitsWithOverlap:146",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:getOverlapTokens:245",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:splitLargeUnit:257",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:createChunkFromUnits:333",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:createSingleChunk:384",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:findSectionForPosition:408",
        "file:src/services/documents/chunker/hybridChunker.ts:fn:countWords:424"
      ],
      "classes": [],
      "topLevelReferences": [
        "Date",
        "options",
        "text",
        "startTime",
        "tokens",
        "totalTokens",
        "opts",
        "createSingleChunk",
        "objectId",
        "splitIntoSemanticUnits",
        "groupUnitsWithOverlap",
        "units",
        "sections",
        "chunks",
        "error",
        "Error"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:splitIntoSemanticUnits:111": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:splitIntoSemanticUnits:111",
      "type": "function",
      "name": "splitIntoSemanticUnits",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 111,
      "endLine": 141,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "SemanticUnit[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Splits text into paragraph-based semantic units with tokenization and heading detection",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function splitIntoSemanticUnits(text: string): SemanticUnit[] {\n  const units: SemanticUnit[] = [];\n\n  // Split on paragraph breaks\n  const paragraphs = text.split(/\\n\\s*\\n/);\n\n  let currentPos = 0;\n  for (const para of paragraphs) {\n    const trimmed = para.trim();\n    if (trimmed.length === 0) continue;\n\n    const startChar = text.indexOf(para, currentPos);\n    const tokens = encode(trimmed);\n\n    // Check if this is a heading\n    const isHeading = /^#{1,6}\\s/.test(trimmed) || /^.+\\n[=-]{2,}$/.test(trimmed);\n\n    units.push({\n      text: trimmed,\n      tokens,\n      tokenCount: tokens.length,\n      startChar,\n      endChar: startChar + para.length,\n      isHeading,\n    });\n\n    currentPos = startChar + para.length;\n  }\n\n  return units;\n}",
      "references": [
        "paragraphs",
        "para",
        "trimmed",
        "currentPos",
        "encode",
        "units",
        "tokens",
        "startChar",
        "isHeading"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:groupUnitsWithOverlap:146": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:groupUnitsWithOverlap:146",
      "type": "function",
      "name": "groupUnitsWithOverlap",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 146,
      "endLine": 240,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "units",
          "type": "SemanticUnit[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Groups semantic units into overlapping document chunks respecting token limits",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function groupUnitsWithOverlap(\n  units: SemanticUnit[],\n  sections: DocumentSection[],\n  objectId: string,\n  options: ChunkingOptions\n): DocumentChunk[] {\n  const chunks: DocumentChunk[] = [];\n  let chunkIndex = 0;\n\n  // Track tokens for overlap\n  let overlapTokens: number[] = [];\n\n  let currentUnits: SemanticUnit[] = [];\n  let currentTokenCount = 0;\n\n  for (let i = 0; i < units.length; i++) {\n    const unit = units[i];\n    if (!unit) continue;\n\n    // If this unit alone exceeds max, split it\n    if (unit.tokenCount > options.maxTokens) {\n      // Flush current chunk if any\n      if (currentUnits.length > 0) {\n        const chunk = createChunkFromUnits(\n          currentUnits,\n          sections,\n          objectId,\n          chunkIndex++,\n          overlapTokens,\n          options\n        );\n        chunks.push(chunk);\n\n        // Prepare overlap for next chunk\n        overlapTokens = getOverlapTokens(currentUnits, options.overlapTokens);\n        currentUnits = [];\n        currentTokenCount = 0;\n      }\n\n      // Split large unit by tokens\n      const splitChunks = splitLargeUnit(unit, sections, objectId, chunkIndex, overlapTokens, options);\n      chunks.push(...splitChunks);\n      chunkIndex += splitChunks.length;\n\n      // Prepare overlap from last split chunk\n      const lastSplit = splitChunks[splitChunks.length - 1];\n      if (lastSplit) {\n        overlapTokens = encode(lastSplit.content).slice(-options.overlapTokens);\n      }\n      continue;\n    }\n\n    // Check if adding this unit would exceed max (accounting for overlap)\n    const projectedTokens = currentTokenCount + unit.tokenCount +\n      (currentUnits.length === 0 ? overlapTokens.length : 0);\n\n    if (projectedTokens > options.maxTokens && currentUnits.length > 0) {\n      // Flush current chunk\n      const chunk = createChunkFromUnits(\n        currentUnits,\n        sections,\n        objectId,\n        chunkIndex++,\n        overlapTokens,\n        options\n      );\n      chunks.push(chunk);\n\n      // Prepare overlap for next chunk\n      overlapTokens = getOverlapTokens(currentUnits, options.overlapTokens);\n      currentUnits = [];\n      currentTokenCount = 0;\n    }\n\n    // Add unit to current chunk\n    currentUnits.push(unit);\n    currentTokenCount += unit.tokenCount;\n  }\n\n  // Flush final chunk\n  if (currentUnits.length > 0) {\n    const chunk = createChunkFromUnits(\n      currentUnits,\n      sections,\n      objectId,\n      chunkIndex++,\n      overlapTokens,\n      options\n    );\n    chunk.metadata.hasOverlapAfter = false;\n    chunks.push(chunk);\n  }\n\n  return chunks;\n}",
      "references": [
        "i",
        "unit",
        "currentUnits",
        "createChunkFromUnits",
        "chunkIndex",
        "overlapTokens",
        "chunks",
        "chunk",
        "getOverlapTokens",
        "currentTokenCount",
        "splitLargeUnit",
        "splitChunks",
        "lastSplit",
        "encode",
        "projectedTokens"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:getOverlapTokens:245": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:getOverlapTokens:245",
      "type": "function",
      "name": "getOverlapTokens",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 245,
      "endLine": 252,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "units",
          "type": "SemanticUnit[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "maxOverlap",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Concatenates tokens from semantic units and returns the last maxOverlap tokens.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getOverlapTokens(units: SemanticUnit[], maxOverlap: number): number[] {\n  // Collect tokens from the end of units\n  const allTokens: number[] = [];\n  for (const unit of units) {\n    allTokens.push(...unit.tokens);\n  }\n  return allTokens.slice(-maxOverlap);\n}",
      "references": [
        "allTokens",
        "unit"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:splitLargeUnit:257": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:splitLargeUnit:257",
      "type": "function",
      "name": "splitLargeUnit",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 257,
      "endLine": 328,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "unit",
          "type": "SemanticUnit",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "startIndex",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "leadingOverlap",
          "type": "number[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Splits large semantic unit into sentence-based document chunks with token limits and overlaps",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function splitLargeUnit(\n  unit: SemanticUnit,\n  sections: DocumentSection[],\n  objectId: string,\n  startIndex: number,\n  leadingOverlap: number[],\n  options: ChunkingOptions\n): DocumentChunk[] {\n  const chunks: DocumentChunk[] = [];\n  let chunkIndex = startIndex;\n\n  // Try to split on sentences first\n  const sentences = unit.text.match(/[^.!?]+[.!?]+\\s*/g) || [unit.text];\n\n  let currentTokens: number[] = [...leadingOverlap];\n  let currentText = leadingOverlap.length > 0 ? decode(leadingOverlap) : '';\n\n  for (const sentence of sentences) {\n    const sentenceTokens = encode(sentence);\n\n    if (currentTokens.length + sentenceTokens.length > options.maxTokens) {\n      // Flush current chunk if we have content beyond overlap\n      if (currentText.length > (leadingOverlap.length > 0 ? decode(leadingOverlap).length : 0)) {\n        const section = findSectionForPosition(unit.startChar, sections);\n        chunks.push({\n          id: uuidv4(),\n          objectId,\n          chunkIndex: chunkIndex++,\n          content: currentText.trim(),\n          tokenCount: currentTokens.length,\n          sectionTitle: section?.title,\n          chunkingStrategy: 'hybrid',\n          metadata: {\n            hasOverlapBefore: chunks.length > 0 || leadingOverlap.length > 0,\n            hasOverlapAfter: true,\n            wordCount: countWords(currentText),\n          },\n          createdAt: new Date(),\n        });\n\n        // New overlap from current chunk\n        currentTokens = currentTokens.slice(-options.overlapTokens);\n        currentText = decode(currentTokens);\n      }\n    }\n\n    currentTokens.push(...sentenceTokens);\n    currentText += sentence;\n  }\n\n  // Final chunk from remaining text\n  if (currentText.trim()) {\n    const section = findSectionForPosition(unit.startChar, sections);\n    chunks.push({\n      id: uuidv4(),\n      objectId,\n      chunkIndex: chunkIndex++,\n      content: currentText.trim(),\n      tokenCount: currentTokens.length,\n      sectionTitle: section?.title,\n      chunkingStrategy: 'hybrid',\n      metadata: {\n        hasOverlapBefore: chunks.length > 0 || leadingOverlap.length > 0,\n        hasOverlapAfter: false,\n        wordCount: countWords(currentText),\n      },\n      createdAt: new Date(),\n    });\n  }\n\n  return chunks;\n}",
      "references": [
        "decode",
        "sentences",
        "encode",
        "sentence",
        "currentTokens",
        "sentenceTokens",
        "currentText",
        "findSectionForPosition",
        "chunks",
        "uuidv4",
        "chunkIndex",
        "section",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:createChunkFromUnits:333": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:createChunkFromUnits:333",
      "type": "function",
      "name": "createChunkFromUnits",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 333,
      "endLine": 379,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "units",
          "type": "SemanticUnit[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "chunkIndex",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "leadingOverlap",
          "type": "number[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "_options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a DocumentChunk from semantic units with leading overlap, token count, section, and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createChunkFromUnits(\n  units: SemanticUnit[],\n  sections: DocumentSection[],\n  objectId: string,\n  chunkIndex: number,\n  leadingOverlap: number[],\n  _options: ChunkingOptions\n): DocumentChunk {\n  // Build content with overlap\n  let content = '';\n  let tokenCount = 0;\n\n  // Add overlap text at the start if this isn't the first chunk\n  if (leadingOverlap.length > 0 && chunkIndex > 0) {\n    const overlapText = decode(leadingOverlap);\n    content = overlapText + '\\n\\n';\n    tokenCount = leadingOverlap.length;\n  }\n\n  // Add unit texts\n  content += units.map(u => u.text).join('\\n\\n');\n  tokenCount += units.reduce((sum, u) => sum + u.tokenCount, 0);\n\n  // Find section\n  const firstUnit = units[0];\n  const section = firstUnit\n    ? findSectionForPosition(firstUnit.startChar, sections)\n    : undefined;\n\n  return {\n    id: uuidv4(),\n    objectId,\n    chunkIndex,\n    content: content.trim(),\n    tokenCount,\n    sectionTitle: section?.title,\n    chunkingStrategy: 'hybrid',\n    metadata: {\n      hasOverlapBefore: chunkIndex > 0,\n      hasOverlapAfter: true,\n      wordCount: countWords(content),\n      unitCount: units.length,\n      overlapTokens: leadingOverlap.length,\n    },\n    createdAt: new Date(),\n  };\n}",
      "references": [
        "decode",
        "content",
        "overlapText",
        "tokenCount",
        "u",
        "sum",
        "firstUnit",
        "findSectionForPosition",
        "uuidv4",
        "section",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:createSingleChunk:384": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:createSingleChunk:384",
      "type": "function",
      "name": "createSingleChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 384,
      "endLine": 403,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "tokenCount",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a single DocumentChunk with text, objectId, tokenCount, and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createSingleChunk(\n  text: string,\n  objectId: string,\n  tokenCount: number\n): DocumentChunk {\n  return {\n    id: uuidv4(),\n    objectId,\n    chunkIndex: 0,\n    content: text,\n    tokenCount,\n    chunkingStrategy: 'hybrid',\n    metadata: {\n      hasOverlapBefore: false,\n      hasOverlapAfter: false,\n      wordCount: countWords(text),\n    },\n    createdAt: new Date(),\n  };\n}",
      "references": [
        "uuidv4",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:findSectionForPosition:408": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:findSectionForPosition:408",
      "type": "function",
      "name": "findSectionForPosition",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 408,
      "endLine": 419,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "position",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Finds DocumentSection where startChar <= position, searching from end.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function findSectionForPosition(\n  position: number,\n  sections: DocumentSection[]\n): DocumentSection | undefined {\n  for (let i = sections.length - 1; i >= 0; i--) {\n    const section = sections[i];\n    if (section && section.startChar <= position) {\n      return section;\n    }\n  }\n  return undefined;\n}",
      "references": [
        "i",
        "section"
      ]
    },
    "file:src/services/documents/chunker/hybridChunker.ts:fn:countWords:424": {
      "id": "file:src/services/documents/chunker/hybridChunker.ts:fn:countWords:424",
      "type": "function",
      "name": "countWords",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/hybridChunker.ts",
      "line": 424,
      "endLine": 426,
      "parentFileId": "file:src/services/documents/chunker/hybridChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts the number of non-empty words in a given text string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(w => w.length > 0).length;\n}",
      "references": [
        "w"
      ]
    },
    "file:src/services/documents/chunker/index.ts": {
      "id": "file:src/services/documents/chunker/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/services/documents/chunker/index.ts",
      "line": 1,
      "endLine": 34,
      "imports": [],
      "exports": [
        {
          "name": "fixedChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "countTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "truncateToTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "semanticChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "detectSections",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "hybridChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "storeChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksBySimilarity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchChunksByText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getChunkStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "embedAndStoreChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateQueryEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "rowToChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "chunkToRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "CHUNKING_STRATEGIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingStrategy",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ChunkingOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_CHUNKING_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DocumentChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkingResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CHUNKING_ERROR_CODES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingErrorCode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentSection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunkRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "fixedChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./fixedChunker.js"
        },
        {
          "name": "countTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./fixedChunker.js"
        },
        {
          "name": "truncateToTokens",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./fixedChunker.js"
        },
        {
          "name": "semanticChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./semanticChunker.js"
        },
        {
          "name": "detectSections",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./semanticChunker.js"
        },
        {
          "name": "hybridChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hybridChunker.js"
        },
        {
          "name": "storeChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "getChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "getChunkById",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "updateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "deleteChunksByObjectId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "searchChunksBySimilarity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "searchChunksByText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "getChunkStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkStorage.js"
        },
        {
          "name": "generateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkEmbedding.js"
        },
        {
          "name": "embedAndStoreChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkEmbedding.js"
        },
        {
          "name": "generateQueryEmbedding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chunkEmbedding.js"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/chunker/semanticChunker.ts": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts",
      "type": "file",
      "name": "semanticChunker.ts",
      "filePath": "src/services/documents/chunker/semanticChunker.ts",
      "line": 1,
      "endLine": 407,
      "imports": [
        {
          "source": "uuid",
          "items": [
            {
              "name": "v4",
              "alias": "uuidv4",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "gpt-tokenizer",
          "items": [
            {
              "name": "encode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "DocumentChunker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentSection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_CHUNKING_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "semanticChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "detectSections",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/semanticChunker.ts:fn:detectSections:93",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:splitIntoParagraphs:162",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:groupParagraphsIntoChunks:196",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:splitParagraphBySentences:273",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:createChunkFromParagraphs:344",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:findSectionForPosition:382",
        "file:src/services/documents/chunker/semanticChunker.ts:fn:countWords:399"
      ],
      "classes": [],
      "topLevelReferences": [
        "Date",
        "options",
        "text",
        "startTime",
        "detectSections",
        "splitIntoParagraphs",
        "groupParagraphsIntoChunks",
        "paragraphs",
        "sections",
        "objectId",
        "opts",
        "chunks",
        "sum",
        "c",
        "totalTokens",
        "error",
        "Error"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:detectSections:93": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:detectSections:93",
      "type": "function",
      "name": "detectSections",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 93,
      "endLine": 157,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Detects markdown and setext headings in text, extracts sections with positions and levels",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function detectSections(text: string): DocumentSection[] {\n  const sections: DocumentSection[] = [];\n\n  // Find markdown headings\n  const mdHeadingRegex = /^(#{1,6})\\s+(.+)$/gm;\n  let match;\n\n  while ((match = mdHeadingRegex.exec(text)) !== null) {\n    const hashes = match[1];\n    const title = match[2];\n    if (hashes && title) {\n      sections.push({\n        title: title.trim(),\n        level: hashes.length,\n        startChar: match.index,\n        endChar: match.index + match[0].length,\n      });\n    }\n  }\n\n  // Find setext headings (underlined)\n  const setextH1 = /^(.+)\\n[=]{2,}$/gm;\n  while ((match = setextH1.exec(text)) !== null) {\n    const title = match[1];\n    if (title) {\n      sections.push({\n        title: title.trim(),\n        level: 1,\n        startChar: match.index,\n        endChar: match.index + match[0].length,\n      });\n    }\n  }\n\n  const setextH2 = /^(.+)\\n[-]{2,}$/gm;\n  while ((match = setextH2.exec(text)) !== null) {\n    const title = match[1];\n    if (title) {\n      sections.push({\n        title: title.trim(),\n        level: 2,\n        startChar: match.index,\n        endChar: match.index + match[0].length,\n      });\n    }\n  }\n\n  // Sort by position\n  sections.sort((a, b) => a.startChar - b.startChar);\n\n  // Set endChar for each section to the start of the next section\n  for (let i = 0; i < sections.length - 1; i++) {\n    const current = sections[i];\n    const next = sections[i + 1];\n    if (current && next) {\n      current.endChar = next.startChar;\n    }\n  }\n  const lastSection = sections[sections.length - 1];\n  if (lastSection) {\n    lastSection.endChar = text.length;\n  }\n\n  return sections;\n}",
      "references": [
        "match",
        "mdHeadingRegex",
        "hashes",
        "title",
        "sections",
        "setextH1",
        "setextH2",
        "a",
        "b",
        "i",
        "current",
        "next",
        "lastSection"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:splitIntoParagraphs:162": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:splitIntoParagraphs:162",
      "type": "function",
      "name": "splitIntoParagraphs",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 162,
      "endLine": 184,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Paragraph[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Splits text into paragraphs by double newlines, computing positions and token counts.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function splitIntoParagraphs(text: string): Paragraph[] {\n  const paragraphs: Paragraph[] = [];\n\n  // Split on double newlines (paragraph breaks)\n  const parts = text.split(/\\n\\s*\\n/);\n\n  let currentPos = 0;\n  for (const part of parts) {\n    const trimmed = part.trim();\n    if (trimmed.length > 0) {\n      const startChar = text.indexOf(part, currentPos);\n      paragraphs.push({\n        text: trimmed,\n        startChar,\n        endChar: startChar + part.length,\n        tokenCount: encode(trimmed).length,\n      });\n      currentPos = startChar + part.length;\n    }\n  }\n\n  return paragraphs;\n}",
      "references": [
        "parts",
        "part",
        "trimmed",
        "currentPos",
        "paragraphs",
        "startChar",
        "encode"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:groupParagraphsIntoChunks:196": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:groupParagraphsIntoChunks:196",
      "type": "function",
      "name": "groupParagraphsIntoChunks",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 196,
      "endLine": 268,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "paragraphs",
          "type": "Paragraph[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Groups paragraphs into token-limited chunks, splitting oversized ones by sentences",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.592Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function groupParagraphsIntoChunks(\n  paragraphs: Paragraph[],\n  sections: DocumentSection[],\n  objectId: string,\n  options: ChunkingOptions\n): DocumentChunk[] {\n  const chunks: DocumentChunk[] = [];\n\n  let currentChunkParagraphs: Paragraph[] = [];\n  let currentTokenCount = 0;\n  let chunkIndex = 0;\n\n  for (const paragraph of paragraphs) {\n    // Check if adding this paragraph would exceed the limit\n    if (currentTokenCount + paragraph.tokenCount > options.maxTokens) {\n      // If current chunk has content, finalize it\n      if (currentChunkParagraphs.length > 0) {\n        chunks.push(\n          createChunkFromParagraphs(\n            currentChunkParagraphs,\n            sections,\n            objectId,\n            chunkIndex++,\n            chunks.length === 0,\n            false\n          )\n        );\n        currentChunkParagraphs = [];\n        currentTokenCount = 0;\n      }\n\n      // If single paragraph exceeds max, split it by sentences\n      if (paragraph.tokenCount > options.maxTokens) {\n        const sentenceChunks = splitParagraphBySentences(\n          paragraph,\n          sections,\n          objectId,\n          chunkIndex,\n          options\n        );\n        chunks.push(...sentenceChunks);\n        chunkIndex += sentenceChunks.length;\n        continue;\n      }\n    }\n\n    // Add paragraph to current chunk\n    currentChunkParagraphs.push(paragraph);\n    currentTokenCount += paragraph.tokenCount;\n  }\n\n  // Finalize last chunk\n  if (currentChunkParagraphs.length > 0) {\n    chunks.push(\n      createChunkFromParagraphs(\n        currentChunkParagraphs,\n        sections,\n        objectId,\n        chunkIndex++,\n        chunks.length === 0,\n        true\n      )\n    );\n  }\n\n  // Mark last chunk\n  const lastChunk = chunks[chunks.length - 1];\n  if (lastChunk) {\n    lastChunk.metadata.hasOverlapAfter = false;\n  }\n\n  return chunks;\n}",
      "references": [
        "currentTokenCount",
        "paragraph",
        "currentChunkParagraphs",
        "chunks",
        "createChunkFromParagraphs",
        "chunkIndex",
        "splitParagraphBySentences",
        "sentenceChunks",
        "lastChunk"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:splitParagraphBySentences:273": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:splitParagraphBySentences:273",
      "type": "function",
      "name": "splitParagraphBySentences",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 273,
      "endLine": 339,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "paragraph",
          "type": "Paragraph",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "startIndex",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").ChunkingOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Splits paragraph into sentence-based chunks respecting max token limits",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function splitParagraphBySentences(\n  paragraph: Paragraph,\n  sections: DocumentSection[],\n  objectId: string,\n  startIndex: number,\n  options: ChunkingOptions\n): DocumentChunk[] {\n  const chunks: DocumentChunk[] = [];\n\n  // Split on sentence boundaries\n  const sentences = paragraph.text.match(/[^.!?]+[.!?]+\\s*/g) || [paragraph.text];\n\n  let currentText = '';\n  let currentTokenCount = 0;\n  let chunkIndex = startIndex;\n\n  for (const sentence of sentences) {\n    const sentenceTokens = encode(sentence).length;\n\n    if (currentTokenCount + sentenceTokens > options.maxTokens && currentText) {\n      // Finalize current chunk\n      const section = findSectionForPosition(paragraph.startChar, sections);\n      chunks.push({\n        id: uuidv4(),\n        objectId,\n        chunkIndex: chunkIndex++,\n        content: currentText.trim(),\n        tokenCount: currentTokenCount,\n        sectionTitle: section?.title,\n        chunkingStrategy: 'semantic',\n        metadata: {\n          hasOverlapBefore: chunks.length > 0,\n          hasOverlapAfter: true,\n          wordCount: countWords(currentText),\n        },\n        createdAt: new Date(),\n      });\n      currentText = '';\n      currentTokenCount = 0;\n    }\n\n    currentText += sentence;\n    currentTokenCount += sentenceTokens;\n  }\n\n  // Final chunk from remaining text\n  if (currentText.trim()) {\n    const section = findSectionForPosition(paragraph.startChar, sections);\n    chunks.push({\n      id: uuidv4(),\n      objectId,\n      chunkIndex: chunkIndex++,\n      content: currentText.trim(),\n      tokenCount: currentTokenCount,\n      sectionTitle: section?.title,\n      chunkingStrategy: 'semantic',\n      metadata: {\n        hasOverlapBefore: chunks.length > 0,\n        hasOverlapAfter: false,\n        wordCount: countWords(currentText),\n      },\n      createdAt: new Date(),\n    });\n  }\n\n  return chunks;\n}",
      "references": [
        "sentences",
        "encode",
        "sentence",
        "currentTokenCount",
        "sentenceTokens",
        "currentText",
        "findSectionForPosition",
        "chunks",
        "uuidv4",
        "chunkIndex",
        "section",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:createChunkFromParagraphs:344": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:createChunkFromParagraphs:344",
      "type": "function",
      "name": "createChunkFromParagraphs",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 344,
      "endLine": 377,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "paragraphs",
          "type": "Paragraph[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "chunkIndex",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "isFirst",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "isLast",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a DocumentChunk from paragraphs with content, tokens, section, and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createChunkFromParagraphs(\n  paragraphs: Paragraph[],\n  sections: DocumentSection[],\n  objectId: string,\n  chunkIndex: number,\n  isFirst: boolean,\n  isLast: boolean\n): DocumentChunk {\n  const content = paragraphs.map(p => p.text).join('\\n\\n');\n  const tokenCount = paragraphs.reduce((sum, p) => sum + p.tokenCount, 0);\n\n  // Find section for the first paragraph\n  const firstParagraph = paragraphs[0];\n  const section = firstParagraph\n    ? findSectionForPosition(firstParagraph.startChar, sections)\n    : undefined;\n\n  return {\n    id: uuidv4(),\n    objectId,\n    chunkIndex,\n    content,\n    tokenCount,\n    sectionTitle: section?.title,\n    chunkingStrategy: 'semantic',\n    metadata: {\n      hasOverlapBefore: !isFirst,\n      hasOverlapAfter: !isLast,\n      wordCount: countWords(content),\n      paragraphCount: paragraphs.length,\n    },\n    createdAt: new Date(),\n  };\n}",
      "references": [
        "p",
        "sum",
        "firstParagraph",
        "findSectionForPosition",
        "uuidv4",
        "content",
        "tokenCount",
        "section",
        "countWords",
        "Date"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:findSectionForPosition:382": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:findSectionForPosition:382",
      "type": "function",
      "name": "findSectionForPosition",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 382,
      "endLine": 394,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "position",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "sections",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentSection",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Finds the last section starting before or at the given position in document sections.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function findSectionForPosition(\n  position: number,\n  sections: DocumentSection[]\n): DocumentSection | undefined {\n  // Find the last section that starts before this position\n  for (let i = sections.length - 1; i >= 0; i--) {\n    const section = sections[i];\n    if (section && section.startChar <= position) {\n      return section;\n    }\n  }\n  return undefined;\n}",
      "references": [
        "i",
        "section"
      ]
    },
    "file:src/services/documents/chunker/semanticChunker.ts:fn:countWords:399": {
      "id": "file:src/services/documents/chunker/semanticChunker.ts:fn:countWords:399",
      "type": "function",
      "name": "countWords",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/semanticChunker.ts",
      "line": 399,
      "endLine": 401,
      "parentFileId": "file:src/services/documents/chunker/semanticChunker.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "number",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Counts the number of non-empty words in a given text string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function countWords(text: string): number {\n  return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n}",
      "references": [
        "word"
      ]
    },
    "file:src/services/documents/chunker/types.ts": {
      "id": "file:src/services/documents/chunker/types.ts",
      "type": "file",
      "name": "types.ts",
      "filePath": "src/services/documents/chunker/types.ts",
      "line": 1,
      "endLine": 251,
      "imports": [],
      "exports": [
        {
          "name": "rowToChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "chunkToRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "CHUNKING_STRATEGIES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingStrategy",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ChunkingOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_CHUNKING_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DocumentChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkingResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CHUNKING_ERROR_CODES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkingErrorCode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentSection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunkRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/documents/chunker/types.ts:fn:rowToChunk:218",
        "file:src/services/documents/chunker/types.ts:fn:chunkToRow:237"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/chunker/types.ts:fn:rowToChunk:218": {
      "id": "file:src/services/documents/chunker/types.ts:fn:rowToChunk:218",
      "type": "function",
      "name": "rowToChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/types.ts",
      "line": 218,
      "endLine": 232,
      "parentFileId": "file:src/services/documents/chunker/types.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunkRow",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts DocumentChunkRow to DocumentChunk by mapping properties",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function rowToChunk(row: DocumentChunkRow): DocumentChunk {\n  return {\n    id: row.id,\n    objectId: row.object_id,\n    chunkIndex: row.chunk_index,\n    content: row.content,\n    tokenCount: row.token_count,\n    pageNumber: row.page_number ?? undefined,\n    sectionTitle: row.section_title ?? undefined,\n    chunkingStrategy: row.chunking_strategy,\n    embedding: row.embedding ?? undefined,\n    metadata: row.metadata as ChunkMetadata,\n    createdAt: row.created_at,\n  };\n}",
      "references": []
    },
    "file:src/services/documents/chunker/types.ts:fn:chunkToRow:237": {
      "id": "file:src/services/documents/chunker/types.ts:fn:chunkToRow:237",
      "type": "function",
      "name": "chunkToRow",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/chunker/types.ts",
      "line": 237,
      "endLine": 250,
      "parentFileId": "file:src/services/documents/chunker/types.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunk",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Omit<import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunkRow, \"created_at\">",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms DocumentChunk to DocumentChunkRow omitting 'created_at'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function chunkToRow(chunk: DocumentChunk): Omit<DocumentChunkRow, 'created_at'> {\n  return {\n    id: chunk.id,\n    object_id: chunk.objectId,\n    chunk_index: chunk.chunkIndex,\n    content: chunk.content,\n    token_count: chunk.tokenCount,\n    page_number: chunk.pageNumber ?? null,\n    section_title: chunk.sectionTitle ?? null,\n    chunking_strategy: chunk.chunkingStrategy,\n    embedding: chunk.embedding ?? null,\n    metadata: chunk.metadata,\n  };\n}",
      "references": []
    },
    "file:src/services/documents/factExtraction/batch.ts": {
      "id": "file:src/services/documents/factExtraction/batch.ts",
      "type": "file",
      "name": "batch.ts",
      "filePath": "src/services/documents/factExtraction/batch.ts",
      "line": 1,
      "endLine": 166,
      "imports": [
        {
          "source": "../chunker/chunkStorage.js",
          "items": [
            {
              "name": "getChunksByObjectId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../chunker/types.js",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./extractor.js",
          "items": [
            {
              "name": "extractFactsFromChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./storage.js",
          "items": [
            {
              "name": "storeFacts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createBatch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateBatchProgress",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFactStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "FactExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "extractFactsFromDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getExtractionProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/factExtraction/batch.ts:fn:extractFactsFromDocument:26",
        "file:src/services/documents/factExtraction/batch.ts:fn:getExtractionProgress:145"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/factExtraction/batch.ts:fn:extractFactsFromDocument:26": {
      "id": "file:src/services/documents/factExtraction/batch.ts:fn:extractFactsFromDocument:26",
      "type": "function",
      "name": "extractFactsFromDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/batch.ts",
      "line": 26,
      "endLine": 140,
      "parentFileId": "file:src/services/documents/factExtraction/batch.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "Partial<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionOptions>",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").DocumentExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts facts from document chunks in batches, stores them, and updates progress",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractFactsFromDocument(\n  objectId: string,\n  options: Partial<FactExtractionOptions> = {}\n): Promise<DocumentExtractionResult> {\n  const startTime = Date.now();\n\n  // Get all chunks for the document\n  const chunks = await getChunksByObjectId(objectId);\n\n  if (chunks.length === 0) {\n    return {\n      success: true,\n      objectId,\n      batchId: '',\n      chunksProcessed: 0,\n      factsExtracted: 0,\n      factsAutoApproved: 0,\n      chunkResults: [],\n      totalDurationMs: Date.now() - startTime,\n      errors: [],\n    };\n  }\n\n  // Create batch tracking record\n  const batch = await createBatch(objectId, chunks.length, options);\n\n  // Update batch status to processing\n  await updateBatchProgress(batch.id, { status: 'processing' });\n\n  const chunkResults: ChunkExtractionResult[] = [];\n  const errors: string[] = [];\n  const failedChunks: string[] = [];\n  let totalFacts = 0;\n  let totalAutoApproved = 0;\n\n  // Process each chunk\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i] as DocumentChunk;\n\n    try {\n      // Extract facts from chunk\n      const result = await extractFactsFromChunk(chunk, objectId, options);\n      chunkResults.push(result);\n\n      if (result.success && result.facts.length > 0) {\n        // Store the extracted facts\n        const storedFacts = await storeFacts(result.facts);\n        totalFacts += storedFacts.length;\n\n        // Count auto-approved\n        const autoApproved = storedFacts.filter((f) => f.status === 'auto_approved').length;\n        totalAutoApproved += autoApproved;\n      } else if (!result.success && result.error) {\n        errors.push(`Chunk ${chunk.id}: ${result.error}`);\n        failedChunks.push(chunk.id);\n      }\n\n      // Update batch progress periodically (every 5 chunks or at end)\n      if ((i + 1) % 5 === 0 || i === chunks.length - 1) {\n        await updateBatchProgress(batch.id, {\n          processedChunks: i + 1,\n          factsExtracted: totalFacts,\n          factsAutoApproved: totalAutoApproved,\n          failedChunks,\n        });\n      }\n    } catch (error) {\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      errors.push(`Chunk ${chunk.id}: ${errorMsg}`);\n      failedChunks.push(chunk.id);\n\n      chunkResults.push({\n        success: false,\n        chunkId: chunk.id,\n        facts: [],\n        totalEntities: 0,\n        totalDates: 0,\n        totalRelationships: 0,\n        processingDurationMs: 0,\n        error: errorMsg,\n      });\n    }\n  }\n\n  // Determine final status\n  const finalStatus = failedChunks.length === chunks.length ? 'failed' : 'completed';\n  const errorMessage = errors.length > 0 ? errors.join('; ') : undefined;\n\n  // Update final batch status\n  await updateBatchProgress(batch.id, {\n    status: finalStatus,\n    processedChunks: chunks.length,\n    factsExtracted: totalFacts,\n    factsAutoApproved: totalAutoApproved,\n    failedChunks,\n    errorMessage,\n  });\n\n  console.log(\n    `[BatchExtraction] Document ${objectId}: ${totalFacts} facts from ${chunks.length} chunks ` +\n      `(${totalAutoApproved} auto-approved, ${failedChunks.length} failed)`\n  );\n\n  return {\n    success: failedChunks.length < chunks.length,\n    objectId,\n    batchId: batch.id,\n    chunksProcessed: chunks.length,\n    factsExtracted: totalFacts,\n    factsAutoApproved: totalAutoApproved,\n    chunkResults,\n    totalDurationMs: Date.now() - startTime,\n    errors,\n  };\n}",
      "references": [
        "Date",
        "getChunksByObjectId",
        "chunks",
        "startTime",
        "createBatch",
        "updateBatchProgress",
        "batch",
        "i",
        "extractFactsFromChunk",
        "chunk",
        "chunkResults",
        "result",
        "storeFacts",
        "totalFacts",
        "storedFacts",
        "f",
        "totalAutoApproved",
        "autoApproved",
        "errors",
        "failedChunks",
        "error",
        "Error",
        "String",
        "errorMsg",
        "finalStatus",
        "errorMessage",
        "console"
      ]
    },
    "file:src/services/documents/factExtraction/batch.ts:fn:getExtractionProgress:145": {
      "id": "file:src/services/documents/factExtraction/batch.ts:fn:getExtractionProgress:145",
      "type": "function",
      "name": "getExtractionProgress",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/batch.ts",
      "line": 145,
      "endLine": 165,
      "parentFileId": "file:src/services/documents/factExtraction/batch.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ hasBeenExtracted: boolean; totalFacts: number; pendingReview: number; approved: number; rejected: number; autoApproved: number; avgConfidence: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves fact extraction progress stats for an object by calling getFactStats and transforming results",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getExtractionProgress(objectId: string): Promise<{\n  hasBeenExtracted: boolean;\n  totalFacts: number;\n  pendingReview: number;\n  approved: number;\n  rejected: number;\n  autoApproved: number;\n  avgConfidence: number;\n}> {\n  const stats = await getFactStats(objectId);\n\n  return {\n    hasBeenExtracted: stats.total > 0,\n    totalFacts: stats.total,\n    pendingReview: stats.byStatus.pending,\n    approved: stats.byStatus.approved,\n    rejected: stats.byStatus.rejected,\n    autoApproved: stats.byStatus.auto_approved,\n    avgConfidence: stats.avgConfidence,\n  };\n}",
      "references": [
        "getFactStats",
        "stats"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts": {
      "id": "file:src/services/documents/factExtraction/extractor.ts",
      "type": "file",
      "name": "extractor.ts",
      "filePath": "src/services/documents/factExtraction/extractor.ts",
      "line": 1,
      "endLine": 500,
      "imports": [
        {
          "source": "uuid",
          "items": [
            {
              "name": "v4",
              "alias": "uuidv4",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../../providers/llm.js",
          "items": [
            {
              "name": "complete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LLMMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../../../config/index.js",
          "items": [
            {
              "name": "config",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "../chunker/types.js",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedFactEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedFactDate",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedRelationship",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkExtractionResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_EXTRACTION_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FACT_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ENTITY_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DATE_TYPES",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "extractFactsFromChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/factExtraction/extractor.ts:fn:parseExtractionResponse:181",
        "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeFactType:209",
        "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeEntityType:220",
        "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeDateType:231",
        "file:src/services/documents/factExtraction/extractor.ts:fn:isValidISODate:242",
        "file:src/services/documents/factExtraction/extractor.ts:fn:processExtractionResponse:253",
        "file:src/services/documents/factExtraction/extractor.ts:fn:extractFactsFromChunk:384"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:parseExtractionResponse:181": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:parseExtractionResponse:181",
      "type": "function",
      "name": "parseExtractionResponse",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 181,
      "endLine": 204,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "LLMExtractionResponse",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Parses string content into LLMExtractionResponse JSON, handling markdown blocks and common parse errors.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function parseExtractionResponse(content: string): LLMExtractionResponse | null {\n  let jsonStr = content.trim();\n\n  // Remove markdown code blocks if present\n  jsonStr = jsonStr.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '');\n\n  // Try to extract JSON object\n  const jsonMatch = jsonStr.match(/\\{[\\s\\S]*\\}/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[0];\n  }\n\n  try {\n    return JSON.parse(jsonStr) as LLMExtractionResponse;\n  } catch {\n    // Try fixing common issues\n    try {\n      const fixed = jsonStr.replace(/,\\s*([}\\]])/g, '$1');\n      return JSON.parse(fixed) as LLMExtractionResponse;\n    } catch {\n      return null;\n    }\n  }\n}",
      "references": [
        "jsonStr",
        "jsonMatch",
        "JSON",
        "fixed"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeFactType:209": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeFactType:209",
      "type": "function",
      "name": "normalizeFactType",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 209,
      "endLine": 215,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "\"preference\" | \"organization\" | \"relationship\" | \"biographical\" | \"event\" | \"statement\" | \"date\" | \"location\"",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Normalizes fact type string to lowercase/trimmed and returns as FactType if valid, else null.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function normalizeFactType(type: string): FactType | null {\n  const normalized = type.toLowerCase().trim();\n  if (FACT_TYPES.includes(normalized as FactType)) {\n    return normalized as FactType;\n  }\n  return null;\n}",
      "references": [
        "FACT_TYPES",
        "normalized"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeEntityType:220": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeEntityType:220",
      "type": "function",
      "name": "normalizeEntityType",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 220,
      "endLine": 226,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "\"person\" | \"project\" | \"concept\" | \"place\" | \"organization\"",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Normalizes entity type to lowercase/trimmed and validates against ENTITY_TYPES, returns null if invalid.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function normalizeEntityType(type: string): ExtractedFactEntity['type'] | null {\n  const normalized = type.toLowerCase().trim();\n  if (ENTITY_TYPES.includes(normalized as ExtractedFactEntity['type'])) {\n    return normalized as ExtractedFactEntity['type'];\n  }\n  return null;\n}",
      "references": [
        "ENTITY_TYPES",
        "normalized"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeDateType:231": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:normalizeDateType:231",
      "type": "function",
      "name": "normalizeDateType",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 231,
      "endLine": 237,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "\"reference\" | \"event_date\" | \"deadline\" | \"anniversary\" | \"birth_date\" | \"death_date\" | \"start_date\" | \"end_date\"",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Normalizes date type string to lowercase/trimmed, validates against known types, defaults to 'reference'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function normalizeDateType(type: string): ExtractedFactDate['type'] | null {\n  const normalized = type.toLowerCase().trim();\n  if (DATE_TYPES.includes(normalized as ExtractedFactDate['type'])) {\n    return normalized as ExtractedFactDate['type'];\n  }\n  return 'reference'; // Default fallback\n}",
      "references": [
        "DATE_TYPES",
        "normalized"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:isValidISODate:242": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:isValidISODate:242",
      "type": "function",
      "name": "isValidISODate",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 242,
      "endLine": 248,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Validates if input string is a valid ISO date (YYYY-MM-DD format).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function isValidISODate(dateStr: string): boolean {\n  const isoPattern = /^\\d{4}-\\d{2}-\\d{2}$/;\n  if (!isoPattern.test(dateStr)) return false;\n\n  const date = new Date(dateStr);\n  return !isNaN(date.getTime());\n}",
      "references": [
        "isoPattern",
        "Date",
        "isNaN",
        "date"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:processExtractionResponse:253": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:processExtractionResponse:253",
      "type": "function",
      "name": "processExtractionResponse",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 253,
      "endLine": 377,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "response",
          "type": "LLMExtractionResponse",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "chunkId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "chunk",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "Required<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionOptions>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Processes and validates LLM-extracted facts, filtering by type, confidence, and normalizing entities/dates",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function processExtractionResponse(\n  response: LLMExtractionResponse,\n  chunkId: string,\n  objectId: string,\n  chunk: DocumentChunk,\n  options: Required<FactExtractionOptions>\n): ExtractedFact[] {\n  const facts: ExtractedFact[] = [];\n\n  for (const rawFact of response.facts) {\n    // Validate fact type\n    const factType = normalizeFactType(rawFact.type);\n    if (!factType) {\n      console.warn(`[FactExtraction] Skipping invalid fact type: ${rawFact.type}`);\n      continue;\n    }\n\n    // Check if fact type is allowed\n    if (!options.factTypes.includes(factType)) {\n      continue;\n    }\n\n    // Validate confidence\n    const confidence = Number(rawFact.confidence);\n    if (isNaN(confidence) || confidence < options.minConfidence) {\n      continue;\n    }\n\n    // Validate content\n    if (!rawFact.content || rawFact.content.length < 10) {\n      continue;\n    }\n\n    // Process entities\n    const entities: ExtractedFactEntity[] = [];\n    if (options.extractEntities && rawFact.entities) {\n      for (const entity of rawFact.entities) {\n        const entityType = normalizeEntityType(entity.type);\n        if (!entityType || !entity.name) continue;\n\n        entities.push({\n          name: entity.name.trim(),\n          type: entityType,\n          role: entity.role,\n          confidence: Math.min(1, Math.max(0, entity.confidence)),\n        });\n      }\n    }\n\n    // Process dates\n    const dates: ExtractedFactDate[] = [];\n    if (options.extractDates && rawFact.dates) {\n      for (const date of rawFact.dates) {\n        if (!date.date || !isValidISODate(date.date)) {\n          // Try to parse and normalize\n          const parsedDate = new Date(date.date);\n          if (!isNaN(parsedDate.getTime())) {\n            date.date = parsedDate.toISOString().split('T')[0] || '';\n          } else {\n            continue;\n          }\n        }\n\n        const dateType = normalizeDateType(date.type);\n        dates.push({\n          date: date.date,\n          type: dateType || 'reference',\n          confidence: Math.min(1, Math.max(0, date.confidence)),\n          rawText: date.raw_text || date.date,\n          isRecurring: date.is_recurring,\n        });\n      }\n    }\n\n    // Process relationships\n    const relationships: ExtractedRelationship[] = [];\n    if (options.extractRelationships && rawFact.relationships) {\n      for (const rel of rawFact.relationships) {\n        if (!rel.subject || !rel.object || !rel.predicate) continue;\n\n        relationships.push({\n          subject: rel.subject.trim(),\n          predicate: rel.predicate.toLowerCase().replace(/\\s+/g, '_'),\n          object: rel.object.trim(),\n          confidence: Math.min(1, Math.max(0, rel.confidence)),\n          description: rel.description,\n        });\n      }\n    }\n\n    // Determine status based on confidence\n    const status = confidence >= options.autoApproveThreshold ? 'auto_approved' : 'pending';\n\n    // Create the fact object\n    const fact: ExtractedFact = {\n      id: uuidv4(),\n      chunkId,\n      objectId,\n      factType,\n      content: rawFact.content.trim(),\n      rawText: rawFact.raw_text?.trim() || rawFact.content.trim(),\n      confidence: Math.min(1, Math.max(0, confidence)),\n      status,\n      entities,\n      dates,\n      relationships,\n      sourcePage: chunk.pageNumber,\n      sourceSection: chunk.sectionTitle,\n      extractionModel: config.llm.model,\n      extractionPromptVersion: EXTRACTION_PROMPT_VERSION,\n      metadata: {},\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n\n    facts.push(fact);\n\n    // Respect max facts per chunk\n    if (facts.length >= options.maxFactsPerChunk) {\n      break;\n    }\n  }\n\n  return facts;\n}",
      "references": [
        "normalizeFactType",
        "rawFact",
        "factType",
        "console",
        "Number",
        "isNaN",
        "confidence",
        "normalizeEntityType",
        "entity",
        "entityType",
        "entities",
        "Math",
        "date",
        "isValidISODate",
        "Date",
        "parsedDate",
        "normalizeDateType",
        "dates",
        "dateType",
        "rel",
        "relationships",
        "uuidv4",
        "status",
        "config",
        "EXTRACTION_PROMPT_VERSION",
        "facts",
        "fact"
      ]
    },
    "file:src/services/documents/factExtraction/extractor.ts:fn:extractFactsFromChunk:384": {
      "id": "file:src/services/documents/factExtraction/extractor.ts:fn:extractFactsFromChunk:384",
      "type": "function",
      "name": "extractFactsFromChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/extractor.ts",
      "line": 384,
      "endLine": 499,
      "parentFileId": "file:src/services/documents/factExtraction/extractor.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunk",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/chunker/types\").DocumentChunk",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "Partial<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionOptions>",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ChunkExtractionResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Extracts facts from document chunk using LLM API call and processes response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractFactsFromChunk(\n  chunk: DocumentChunk,\n  objectId: string,\n  options: Partial<FactExtractionOptions> = {}\n): Promise<ChunkExtractionResult> {\n  const startTime = Date.now();\n  const mergedOptions: Required<FactExtractionOptions> = {\n    ...DEFAULT_EXTRACTION_OPTIONS,\n    ...options,\n  };\n\n  // Validate chunk\n  if (!chunk.content || chunk.content.trim().length < 20) {\n    return {\n      success: true,\n      chunkId: chunk.id,\n      facts: [],\n      totalEntities: 0,\n      totalDates: 0,\n      totalRelationships: 0,\n      processingDurationMs: Date.now() - startTime,\n    };\n  }\n\n  try {\n    // Build user prompt with chunk content\n    const userPrompt = `Extract facts from this document text:\n\n---\n${chunk.content}\n---\n\n${chunk.sectionTitle ? `Section: ${chunk.sectionTitle}` : ''}\n${chunk.pageNumber ? `Page: ${chunk.pageNumber}` : ''}\n\nExtract all meaningful facts, entities, dates, and relationships from this text.`;\n\n    const messages: LLMMessage[] = [\n      {\n        role: 'system',\n        content: mergedOptions.customPrompt || FACT_EXTRACTION_SYSTEM_PROMPT,\n      },\n      { role: 'user', content: userPrompt },\n    ];\n\n    // Call LLM\n    const result = await complete(messages, {\n      temperature: 0.2, // Low temperature for consistent extraction\n      maxTokens: 3000,\n    });\n\n    // Parse response\n    const response = parseExtractionResponse(result.content);\n    if (!response) {\n      console.error('[FactExtraction] Failed to parse LLM response:', result.content.substring(0, 300));\n      return {\n        success: false,\n        chunkId: chunk.id,\n        facts: [],\n        totalEntities: 0,\n        totalDates: 0,\n        totalRelationships: 0,\n        processingDurationMs: Date.now() - startTime,\n        error: 'Failed to parse LLM response',\n      };\n    }\n\n    // Process and validate facts\n    const facts = processExtractionResponse(\n      response,\n      chunk.id,\n      objectId,\n      chunk,\n      mergedOptions\n    );\n\n    // Calculate totals\n    let totalEntities = 0;\n    let totalDates = 0;\n    let totalRelationships = 0;\n\n    for (const fact of facts) {\n      totalEntities += fact.entities.length;\n      totalDates += fact.dates.length;\n      totalRelationships += fact.relationships.length;\n    }\n\n    console.log(\n      `[FactExtraction] Extracted ${facts.length} facts (${totalEntities} entities, ${totalDates} dates, ${totalRelationships} relationships) from chunk ${chunk.id}`\n    );\n\n    return {\n      success: true,\n      chunkId: chunk.id,\n      facts,\n      totalEntities,\n      totalDates,\n      totalRelationships,\n      processingDurationMs: Date.now() - startTime,\n    };\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    console.error(`[FactExtraction] Error processing chunk ${chunk.id}:`, error);\n\n    return {\n      success: false,\n      chunkId: chunk.id,\n      facts: [],\n      totalEntities: 0,\n      totalDates: 0,\n      totalRelationships: 0,\n      processingDurationMs: Date.now() - startTime,\n      error: errorMsg,\n    };\n  }\n}",
      "references": [
        "Date",
        "DEFAULT_EXTRACTION_OPTIONS",
        "startTime",
        "mergedOptions",
        "FACT_EXTRACTION_SYSTEM_PROMPT",
        "userPrompt",
        "complete",
        "messages",
        "parseExtractionResponse",
        "result",
        "response",
        "console",
        "processExtractionResponse",
        "facts",
        "totalEntities",
        "fact",
        "totalDates",
        "totalRelationships",
        "error",
        "Error",
        "String",
        "errorMsg"
      ]
    },
    "file:src/services/documents/factExtraction/index.ts": {
      "id": "file:src/services/documents/factExtraction/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "src/services/documents/factExtraction/index.ts",
      "line": 1,
      "endLine": 51,
      "imports": [],
      "exports": [
        {
          "name": "extractFactsFromChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractFactsFromDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getExtractionProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "storeFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "storeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkFactToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "mergeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateBatchProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatchesByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "rowToFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FACT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FactType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ENTITY_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "EntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractedFactEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DATE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DateType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractedFactDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_EXTRACTION_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFactRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionBatchRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./types.js"
        },
        {
          "name": "extractFactsFromChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./extractor.js"
        },
        {
          "name": "extractFactsFromDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./batch.js"
        },
        {
          "name": "getExtractionProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./batch.js"
        },
        {
          "name": "storeFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "storeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getPendingFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "linkFactToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "mergeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "deleteFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "deleteFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "deleteFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "createBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "updateBatchProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getBatchesByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        },
        {
          "name": "getFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./storage.js"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/factExtraction/storage.ts": {
      "id": "file:src/services/documents/factExtraction/storage.ts",
      "type": "file",
      "name": "storage.ts",
      "filePath": "src/services/documents/factExtraction/storage.ts",
      "line": 1,
      "endLine": 556,
      "imports": [
        {
          "source": "../../../db/pool.js",
          "items": [
            {
              "name": "pool",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./types.js",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExtractedFactRow",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionBatchRow",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "rowToFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "storeFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "storeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "linkFactToMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "mergeFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteFactsByChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateBatchProgress",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getBatchesByDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:src/services/documents/factExtraction/storage.ts:fn:storeFact:23",
        "file:src/services/documents/factExtraction/storage.ts:fn:storeFacts:61",
        "file:src/services/documents/factExtraction/storage.ts:fn:getFact:116",
        "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByDocument:128",
        "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByChunk:182",
        "file:src/services/documents/factExtraction/storage.ts:fn:getPendingFacts:194",
        "file:src/services/documents/factExtraction/storage.ts:fn:updateFactStatus:233",
        "file:src/services/documents/factExtraction/storage.ts:fn:bulkUpdateFactStatus:254",
        "file:src/services/documents/factExtraction/storage.ts:fn:linkFactToMemory:276",
        "file:src/services/documents/factExtraction/storage.ts:fn:mergeFacts:294",
        "file:src/services/documents/factExtraction/storage.ts:fn:updateFactContent:315",
        "file:src/services/documents/factExtraction/storage.ts:fn:deleteFact:338",
        "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByDocument:350",
        "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByChunk:362",
        "file:src/services/documents/factExtraction/storage.ts:fn:createBatch:376",
        "file:src/services/documents/factExtraction/storage.ts:fn:updateBatchProgress:394",
        "file:src/services/documents/factExtraction/storage.ts:fn:getBatch:467",
        "file:src/services/documents/factExtraction/storage.ts:fn:getBatchesByDocument:479",
        "file:src/services/documents/factExtraction/storage.ts:fn:getFactStats:495"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:storeFact:23": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:storeFact:23",
      "type": "function",
      "name": "storeFact",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 23,
      "endLine": 56,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "fact",
          "type": "Omit<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact, \"id\" | \"createdAt\" | \"updatedAt\">",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts an extracted fact into the database and returns the inserted record.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function storeFact(\n  fact: Omit<ExtractedFact, 'id' | 'createdAt' | 'updatedAt'>\n): Promise<ExtractedFact> {\n  const result = await pool.query<ExtractedFactRow>(\n    `INSERT INTO extracted_facts (\n      chunk_id, object_id, fact_type, content, raw_text,\n      confidence, status, entities, dates, relationships,\n      source_page, source_section, position_start, position_end,\n      extraction_model, extraction_prompt_version, metadata\n    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)\n    RETURNING *`,\n    [\n      fact.chunkId,\n      fact.objectId,\n      fact.factType,\n      fact.content,\n      fact.rawText,\n      fact.confidence,\n      fact.status,\n      JSON.stringify(fact.entities),\n      JSON.stringify(fact.dates),\n      JSON.stringify(fact.relationships),\n      fact.sourcePage ?? null,\n      fact.sourceSection ?? null,\n      fact.positionStart ?? null,\n      fact.positionEnd ?? null,\n      fact.extractionModel ?? null,\n      fact.extractionPromptVersion ?? null,\n      JSON.stringify(fact.metadata),\n    ]\n  );\n\n  return rowToFact(result.rows[0]!);\n}",
      "references": [
        "pool",
        "JSON",
        "rowToFact",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:storeFacts:61": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:storeFacts:61",
      "type": "function",
      "name": "storeFacts",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 61,
      "endLine": 109,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "facts",
          "type": "Omit<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact, \"id\" | \"createdAt\" | \"updatedAt\">[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Batches and inserts extracted facts into PostgreSQL database using parameterized query.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.593Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function storeFacts(\n  facts: Array<Omit<ExtractedFact, 'id' | 'createdAt' | 'updatedAt'>>\n): Promise<ExtractedFact[]> {\n  if (facts.length === 0) return [];\n\n  // Build batch INSERT using unnest for efficiency\n  const values = facts.map((fact) => [\n    fact.chunkId,\n    fact.objectId,\n    fact.factType,\n    fact.content,\n    fact.rawText,\n    fact.confidence,\n    fact.status,\n    JSON.stringify(fact.entities),\n    JSON.stringify(fact.dates),\n    JSON.stringify(fact.relationships),\n    fact.sourcePage ?? null,\n    fact.sourceSection ?? null,\n    fact.positionStart ?? null,\n    fact.positionEnd ?? null,\n    fact.extractionModel ?? null,\n    fact.extractionPromptVersion ?? null,\n    JSON.stringify(fact.metadata),\n  ]);\n\n  // Use parameterized query with array\n  const placeholders = values\n    .map(\n      (_, i) =>\n        `($${i * 17 + 1}, $${i * 17 + 2}, $${i * 17 + 3}, $${i * 17 + 4}, $${i * 17 + 5}, $${i * 17 + 6}, $${i * 17 + 7}, $${i * 17 + 8}, $${i * 17 + 9}, $${i * 17 + 10}, $${i * 17 + 11}, $${i * 17 + 12}, $${i * 17 + 13}, $${i * 17 + 14}, $${i * 17 + 15}, $${i * 17 + 16}, $${i * 17 + 17})`\n    )\n    .join(', ');\n\n  const flatValues = values.flat();\n\n  const result = await pool.query<ExtractedFactRow>(\n    `INSERT INTO extracted_facts (\n      chunk_id, object_id, fact_type, content, raw_text,\n      confidence, status, entities, dates, relationships,\n      source_page, source_section, position_start, position_end,\n      extraction_model, extraction_prompt_version, metadata\n    ) VALUES ${placeholders}\n    RETURNING *`,\n    flatValues\n  );\n\n  return result.rows.map(rowToFact);\n}",
      "references": [
        "fact",
        "JSON",
        "values",
        "i",
        "pool",
        "placeholders",
        "flatValues",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getFact:116": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getFact:116",
      "type": "function",
      "name": "getFact",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 116,
      "endLine": 123,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves an extracted fact from the database by its ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getFact(factId: string): Promise<ExtractedFact | null> {\n  const result = await pool.query<ExtractedFactRow>(\n    `SELECT * FROM extracted_facts WHERE id = $1`,\n    [factId]\n  );\n\n  return result.rows[0] ? rowToFact(result.rows[0]) : null;\n}",
      "references": [
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByDocument:128": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByDocument:128",
      "type": "function",
      "name": "getFactsByDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 128,
      "endLine": 177,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ status?: \"merged\" | \"pending\" | \"approved\" | \"rejected\" | \"auto_approved\" | (\"merged\" | \"pending\" | \"approved\" | \"rejected\" | \"auto_approved\")[]; factType?: \"preference\" | \"organization\" | \"relationship\" | \"biographical\" | \"event\" | \"statement\" | \"date\" | \"location\" | (\"preference\" | \"organization\" | \"relationship\" | \"biographical\" | \"event\" | \"statement\" | \"date\" | \"location\")[]; minConfidence?: number; limit?: number; offset?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves extracted facts for a document by ID with optional filters, sorting, and pagination",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getFactsByDocument(\n  objectId: string,\n  options: {\n    status?: FactStatus | FactStatus[];\n    factType?: FactType | FactType[];\n    minConfidence?: number;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ExtractedFact[]> {\n  let query = `SELECT * FROM extracted_facts WHERE object_id = $1`;\n  const params: unknown[] = [objectId];\n  let paramIndex = 2;\n\n  if (options.status) {\n    const statuses = Array.isArray(options.status) ? options.status : [options.status];\n    query += ` AND status = ANY($${paramIndex})`;\n    params.push(statuses);\n    paramIndex++;\n  }\n\n  if (options.factType) {\n    const types = Array.isArray(options.factType) ? options.factType : [options.factType];\n    query += ` AND fact_type = ANY($${paramIndex})`;\n    params.push(types);\n    paramIndex++;\n  }\n\n  if (options.minConfidence !== undefined) {\n    query += ` AND confidence >= $${paramIndex}`;\n    params.push(options.minConfidence);\n    paramIndex++;\n  }\n\n  query += ` ORDER BY created_at DESC`;\n\n  if (options.limit) {\n    query += ` LIMIT $${paramIndex}`;\n    params.push(options.limit);\n    paramIndex++;\n  }\n\n  if (options.offset) {\n    query += ` OFFSET $${paramIndex}`;\n    params.push(options.offset);\n  }\n\n  const result = await pool.query<ExtractedFactRow>(query, params);\n  return result.rows.map(rowToFact);\n}",
      "references": [
        "Array",
        "query",
        "paramIndex",
        "params",
        "statuses",
        "types",
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByChunk:182": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getFactsByChunk:182",
      "type": "function",
      "name": "getFactsByChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 182,
      "endLine": 189,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunkId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves extracted facts for a given chunk ID from the database.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getFactsByChunk(chunkId: string): Promise<ExtractedFact[]> {\n  const result = await pool.query<ExtractedFactRow>(\n    `SELECT * FROM extracted_facts WHERE chunk_id = $1 ORDER BY created_at`,\n    [chunkId]\n  );\n\n  return result.rows.map(rowToFact);\n}",
      "references": [
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getPendingFacts:194": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getPendingFacts:194",
      "type": "function",
      "name": "getPendingFacts",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 194,
      "endLine": 226,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ objectId?: string; limit?: number; offset?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves pending extracted facts from DB with optional objectId filter, limit, offset",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getPendingFacts(\n  options: {\n    objectId?: string;\n    limit?: number;\n    offset?: number;\n  } = {}\n): Promise<ExtractedFact[]> {\n  let query = `SELECT * FROM extracted_facts WHERE status = 'pending'`;\n  const params: unknown[] = [];\n  let paramIndex = 1;\n\n  if (options.objectId) {\n    query += ` AND object_id = $${paramIndex}`;\n    params.push(options.objectId);\n    paramIndex++;\n  }\n\n  query += ` ORDER BY confidence DESC, created_at ASC`;\n\n  if (options.limit) {\n    query += ` LIMIT $${paramIndex}`;\n    params.push(options.limit);\n    paramIndex++;\n  }\n\n  if (options.offset) {\n    query += ` OFFSET $${paramIndex}`;\n    params.push(options.offset);\n  }\n\n  const result = await pool.query<ExtractedFactRow>(query, params);\n  return result.rows.map(rowToFact);\n}",
      "references": [
        "query",
        "paramIndex",
        "params",
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:updateFactStatus:233": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:updateFactStatus:233",
      "type": "function",
      "name": "updateFactStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 233,
      "endLine": 249,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "\"merged\" | \"pending\" | \"approved\" | \"rejected\" | \"auto_approved\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates fact status, reviewed_at, and notes in database, returns updated fact or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateFactStatus(\n  factId: string,\n  status: FactStatus,\n  notes?: string\n): Promise<ExtractedFact | null> {\n  const result = await pool.query<ExtractedFactRow>(\n    `UPDATE extracted_facts\n     SET status = $2,\n         reviewed_at = NOW(),\n         reviewer_notes = COALESCE($3, reviewer_notes)\n     WHERE id = $1\n     RETURNING *`,\n    [factId, status, notes ?? null]\n  );\n\n  return result.rows[0] ? rowToFact(result.rows[0]) : null;\n}",
      "references": [
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:bulkUpdateFactStatus:254": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:bulkUpdateFactStatus:254",
      "type": "function",
      "name": "bulkUpdateFactStatus",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 254,
      "endLine": 271,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "\"merged\" | \"pending\" | \"approved\" | \"rejected\" | \"auto_approved\"",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Bulk updates status, reviewed_at, and notes for facts by IDs in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function bulkUpdateFactStatus(\n  factIds: string[],\n  status: FactStatus,\n  notes?: string\n): Promise<number> {\n  if (factIds.length === 0) return 0;\n\n  const result = await pool.query(\n    `UPDATE extracted_facts\n     SET status = $2,\n         reviewed_at = NOW(),\n         reviewer_notes = COALESCE($3, reviewer_notes)\n     WHERE id = ANY($1)`,\n    [factIds, status, notes ?? null]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:linkFactToMemory:276": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:linkFactToMemory:276",
      "type": "function",
      "name": "linkFactToMemory",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 276,
      "endLine": 289,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates memory_id of extracted_fact by factId and returns updated fact or null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function linkFactToMemory(\n  factId: string,\n  memoryId: string\n): Promise<ExtractedFact | null> {\n  const result = await pool.query<ExtractedFactRow>(\n    `UPDATE extracted_facts\n     SET memory_id = $2\n     WHERE id = $1\n     RETURNING *`,\n    [factId, memoryId]\n  );\n\n  return result.rows[0] ? rowToFact(result.rows[0]) : null;\n}",
      "references": [
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:mergeFacts:294": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:mergeFacts:294",
      "type": "function",
      "name": "mergeFacts",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 294,
      "endLine": 310,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "sourceFactIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "targetFactId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates source facts to 'merged' status with target fact ID in database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function mergeFacts(\n  sourceFactIds: string[],\n  targetFactId: string\n): Promise<number> {\n  if (sourceFactIds.length === 0) return 0;\n\n  const result = await pool.query(\n    `UPDATE extracted_facts\n     SET status = 'merged',\n         merged_into_id = $2,\n         reviewed_at = NOW()\n     WHERE id = ANY($1) AND id != $2`,\n    [sourceFactIds, targetFactId]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:updateFactContent:315": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:updateFactContent:315",
      "type": "function",
      "name": "updateFactContent",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 315,
      "endLine": 331,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates content and optional notes for a fact by ID in DB, returns updated fact",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateFactContent(\n  factId: string,\n  content: string,\n  notes?: string\n): Promise<ExtractedFact | null> {\n  const result = await pool.query<ExtractedFactRow>(\n    `UPDATE extracted_facts\n     SET content = $2,\n         reviewer_notes = COALESCE($3, reviewer_notes),\n         updated_at = NOW()\n     WHERE id = $1\n     RETURNING *`,\n    [factId, content, notes ?? null]\n  );\n\n  return result.rows[0] ? rowToFact(result.rows[0]) : null;\n}",
      "references": [
        "pool",
        "result",
        "rowToFact"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:deleteFact:338": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:deleteFact:338",
      "type": "function",
      "name": "deleteFact",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 338,
      "endLine": 345,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a fact from the extracted_facts table by ID and returns true if successful.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteFact(factId: string): Promise<boolean> {\n  const result = await pool.query(\n    `DELETE FROM extracted_facts WHERE id = $1`,\n    [factId]\n  );\n\n  return (result.rowCount ?? 0) > 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByDocument:350": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByDocument:350",
      "type": "function",
      "name": "deleteFactsByDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 350,
      "endLine": 357,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes extracted facts from DB by objectId, returns row count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteFactsByDocument(objectId: string): Promise<number> {\n  const result = await pool.query(\n    `DELETE FROM extracted_facts WHERE object_id = $1`,\n    [objectId]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByChunk:362": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:deleteFactsByChunk:362",
      "type": "function",
      "name": "deleteFactsByChunk",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 362,
      "endLine": 369,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "chunkId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<number>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes extracted facts from DB by chunk ID, returns row count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteFactsByChunk(chunkId: string): Promise<number> {\n  const result = await pool.query(\n    `DELETE FROM extracted_facts WHERE chunk_id = $1`,\n    [chunkId]\n  );\n\n  return result.rowCount ?? 0;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:createBatch:376": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:createBatch:376",
      "type": "function",
      "name": "createBatch",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 376,
      "endLine": 389,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "totalChunks",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "config",
          "type": "Record<string, unknown>",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionBatchRow>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Inserts a new fact extraction batch into the database and returns it.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createBatch(\n  objectId: string,\n  totalChunks: number,\n  config: Record<string, unknown> = {}\n): Promise<FactExtractionBatchRow> {\n  const result = await pool.query<FactExtractionBatchRow>(\n    `INSERT INTO fact_extraction_batches (object_id, total_chunks, config)\n     VALUES ($1, $2, $3)\n     RETURNING *`,\n    [objectId, totalChunks, JSON.stringify(config)]\n  );\n\n  return result.rows[0]!;\n}",
      "references": [
        "pool",
        "JSON",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:updateBatchProgress:394": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:updateBatchProgress:394",
      "type": "function",
      "name": "updateBatchProgress",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 394,
      "endLine": 462,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "batchId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "progress",
          "type": "{ processedChunks?: number; factsExtracted?: number; factsAutoApproved?: number; status?: \"completed\" | \"processing\" | \"failed\"; errorMessage?: string; failedChunks?: string[]; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionBatchRow>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates progress fields for a fact extraction batch in the database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateBatchProgress(\n  batchId: string,\n  progress: {\n    processedChunks?: number;\n    factsExtracted?: number;\n    factsAutoApproved?: number;\n    status?: 'processing' | 'completed' | 'failed';\n    errorMessage?: string;\n    failedChunks?: string[];\n  }\n): Promise<FactExtractionBatchRow | null> {\n  const updates: string[] = [];\n  const params: unknown[] = [batchId];\n  let paramIndex = 2;\n\n  if (progress.processedChunks !== undefined) {\n    updates.push(`processed_chunks = $${paramIndex}`);\n    params.push(progress.processedChunks);\n    paramIndex++;\n  }\n\n  if (progress.factsExtracted !== undefined) {\n    updates.push(`facts_extracted = $${paramIndex}`);\n    params.push(progress.factsExtracted);\n    paramIndex++;\n  }\n\n  if (progress.factsAutoApproved !== undefined) {\n    updates.push(`facts_auto_approved = $${paramIndex}`);\n    params.push(progress.factsAutoApproved);\n    paramIndex++;\n  }\n\n  if (progress.status) {\n    updates.push(`status = $${paramIndex}`);\n    params.push(progress.status);\n    paramIndex++;\n\n    if (progress.status === 'processing') {\n      updates.push('started_at = COALESCE(started_at, NOW())');\n    } else if (progress.status === 'completed' || progress.status === 'failed') {\n      updates.push('completed_at = NOW()');\n    }\n  }\n\n  if (progress.errorMessage !== undefined) {\n    updates.push(`error_message = $${paramIndex}`);\n    params.push(progress.errorMessage);\n    paramIndex++;\n  }\n\n  if (progress.failedChunks !== undefined) {\n    updates.push(`failed_chunks = $${paramIndex}`);\n    params.push(JSON.stringify(progress.failedChunks));\n    paramIndex++;\n  }\n\n  if (updates.length === 0) return null;\n\n  const result = await pool.query<FactExtractionBatchRow>(\n    `UPDATE fact_extraction_batches\n     SET ${updates.join(', ')}\n     WHERE id = $1\n     RETURNING *`,\n    params\n  );\n\n  return result.rows[0] ?? null;\n}",
      "references": [
        "updates",
        "paramIndex",
        "params",
        "JSON",
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getBatch:467": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getBatch:467",
      "type": "function",
      "name": "getBatch",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 467,
      "endLine": 474,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "batchId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionBatchRow>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves a fact extraction batch from the database by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBatch(batchId: string): Promise<FactExtractionBatchRow | null> {\n  const result = await pool.query<FactExtractionBatchRow>(\n    `SELECT * FROM fact_extraction_batches WHERE id = $1`,\n    [batchId]\n  );\n\n  return result.rows[0] ?? null;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getBatchesByDocument:479": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getBatchesByDocument:479",
      "type": "function",
      "name": "getBatchesByDocument",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 479,
      "endLine": 488,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").FactExtractionBatchRow[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves fact extraction batches for a document by object ID from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getBatchesByDocument(\n  objectId: string\n): Promise<FactExtractionBatchRow[]> {\n  const result = await pool.query<FactExtractionBatchRow>(\n    `SELECT * FROM fact_extraction_batches WHERE object_id = $1 ORDER BY created_at DESC`,\n    [objectId]\n  );\n\n  return result.rows;\n}",
      "references": [
        "pool",
        "result"
      ]
    },
    "file:src/services/documents/factExtraction/storage.ts:fn:getFactStats:495": {
      "id": "file:src/services/documents/factExtraction/storage.ts:fn:getFactStats:495",
      "type": "function",
      "name": "getFactStats",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/storage.ts",
      "line": 495,
      "endLine": 555,
      "parentFileId": "file:src/services/documents/factExtraction/storage.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ total: number; byStatus: Record<\"merged\" | \"pending\" | \"approved\" | \"rejected\" | \"auto_approved\", number>; byType: Record<\"preference\" | \"organization\" | \"relationship\" | \"biographical\" | \"event\" | \"statement\" | \"date\" | \"location\", number>; avgConfidence: number; totalEntities: number; totalDates: number; totalRelationships: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Retrieves aggregated statistics on extracted facts for a given object ID from database",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getFactStats(objectId: string): Promise<{\n  total: number;\n  byStatus: Record<FactStatus, number>;\n  byType: Record<FactType, number>;\n  avgConfidence: number;\n  totalEntities: number;\n  totalDates: number;\n  totalRelationships: number;\n}> {\n  const result = await pool.query(\n    `SELECT\n       COUNT(*) as total,\n       COUNT(*) FILTER (WHERE status = 'pending') as pending,\n       COUNT(*) FILTER (WHERE status = 'approved') as approved,\n       COUNT(*) FILTER (WHERE status = 'rejected') as rejected,\n       COUNT(*) FILTER (WHERE status = 'merged') as merged,\n       COUNT(*) FILTER (WHERE status = 'auto_approved') as auto_approved,\n       COUNT(*) FILTER (WHERE fact_type = 'biographical') as biographical,\n       COUNT(*) FILTER (WHERE fact_type = 'event') as event,\n       COUNT(*) FILTER (WHERE fact_type = 'relationship') as relationship,\n       COUNT(*) FILTER (WHERE fact_type = 'preference') as preference,\n       COUNT(*) FILTER (WHERE fact_type = 'statement') as statement,\n       COUNT(*) FILTER (WHERE fact_type = 'date') as date_type,\n       COUNT(*) FILTER (WHERE fact_type = 'location') as location,\n       COUNT(*) FILTER (WHERE fact_type = 'organization') as organization,\n       AVG(confidence) as avg_confidence,\n       SUM(jsonb_array_length(entities)) as total_entities,\n       SUM(jsonb_array_length(dates)) as total_dates,\n       SUM(jsonb_array_length(relationships)) as total_relationships\n     FROM extracted_facts\n     WHERE object_id = $1`,\n    [objectId]\n  );\n\n  const row = result.rows[0];\n\n  return {\n    total: parseInt(row.total ?? '0', 10),\n    byStatus: {\n      pending: parseInt(row.pending ?? '0', 10),\n      approved: parseInt(row.approved ?? '0', 10),\n      rejected: parseInt(row.rejected ?? '0', 10),\n      merged: parseInt(row.merged ?? '0', 10),\n      auto_approved: parseInt(row.auto_approved ?? '0', 10),\n    },\n    byType: {\n      biographical: parseInt(row.biographical ?? '0', 10),\n      event: parseInt(row.event ?? '0', 10),\n      relationship: parseInt(row.relationship ?? '0', 10),\n      preference: parseInt(row.preference ?? '0', 10),\n      statement: parseInt(row.statement ?? '0', 10),\n      date: parseInt(row.date_type ?? '0', 10),\n      location: parseInt(row.location ?? '0', 10),\n      organization: parseInt(row.organization ?? '0', 10),\n    },\n    avgConfidence: parseFloat(row.avg_confidence ?? '0'),\n    totalEntities: parseInt(row.total_entities ?? '0', 10),\n    totalDates: parseInt(row.total_dates ?? '0', 10),\n    totalRelationships: parseInt(row.total_relationships ?? '0', 10),\n  };\n}",
      "references": [
        "pool",
        "result",
        "parseInt",
        "row",
        "parseFloat"
      ]
    },
    "file:src/services/documents/factExtraction/types.ts": {
      "id": "file:src/services/documents/factExtraction/types.ts",
      "type": "file",
      "name": "types.ts",
      "filePath": "src/services/documents/factExtraction/types.ts",
      "line": 1,
      "endLine": 400,
      "imports": [],
      "exports": [
        {
          "name": "rowToFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FACT_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FactType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ENTITY_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "EntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractedFactEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DATE_TYPES",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DateType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractedFactDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_EXTRACTION_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChunkExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentExtractionResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFactRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionBatchRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:src/services/documents/factExtraction/types.ts:fn:rowToFact:371"
      ],
      "classes": [],
      "topLevelReferences": [
        "FACT_TYPES"
      ]
    },
    "file:src/services/documents/factExtraction/types.ts:fn:rowToFact:371": {
      "id": "file:src/services/documents/factExtraction/types.ts:fn:rowToFact:371",
      "type": "function",
      "name": "rowToFact",
      "filePath": "/home/ridgetop/projects/squire/src/services/documents/factExtraction/types.ts",
      "line": 371,
      "endLine": 398,
      "parentFileId": "file:src/services/documents/factExtraction/types.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "row",
          "type": "import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFactRow",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/src/services/documents/factExtraction/types\").ExtractedFact",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms ExtractedFactRow to ExtractedFact by mapping and converting fields",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function rowToFact(row: ExtractedFactRow): ExtractedFact {\n  return {\n    id: row.id,\n    chunkId: row.chunk_id,\n    objectId: row.object_id,\n    factType: row.fact_type,\n    content: row.content,\n    rawText: row.raw_text,\n    confidence: Number(row.confidence),\n    status: row.status,\n    reviewedAt: row.reviewed_at ?? undefined,\n    reviewerNotes: row.reviewer_notes ?? undefined,\n    entities: row.entities ?? [],\n    dates: row.dates ?? [],\n    relationships: row.relationships ?? [],\n    sourcePage: row.source_page ?? undefined,\n    sourceSection: row.source_section ?? undefined,\n    positionStart: row.position_start ?? undefined,\n    positionEnd: row.position_end ?? undefined,\n    memoryId: row.memory_id ?? undefined,\n    mergedIntoId: row.merged_into_id ?? undefined,\n    extractionModel: row.extraction_model ?? undefined,\n    extractionPromptVersion: row.extraction_prompt_version ?? undefined,\n    metadata: row.metadata ?? {},\n    createdAt: row.created_at,\n    updatedAt: row.updated_at,\n  };\n}",
      "references": [
        "Number"
      ]
    },
    "file:web/src/app/app/layout.tsx": {
      "id": "file:web/src/app/app/layout.tsx",
      "type": "file",
      "name": "layout.tsx",
      "filePath": "web/src/app/app/layout.tsx",
      "line": 1,
      "endLine": 10,
      "imports": [
        {
          "source": "@/components/layout",
          "items": [
            {
              "name": "AppLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "AppRouteLayout",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/layout.tsx:fn:AppRouteLayout:3"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/layout.tsx:fn:AppRouteLayout:3": {
      "id": "file:web/src/app/app/layout.tsx:fn:AppRouteLayout:3",
      "type": "function",
      "name": "AppRouteLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/layout.tsx",
      "line": 3,
      "endLine": 9,
      "parentFileId": "file:web/src/app/app/layout.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  children,\n}",
          "type": "{ children: React.ReactNode; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders children inside an AppLayout component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function AppRouteLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return <AppLayout>{children}</AppLayout>;\n}",
      "references": [
        "AppLayout",
        "children"
      ]
    },
    "file:web/src/components/cards/MemoryCard.tsx": {
      "id": "file:web/src/components/cards/MemoryCard.tsx",
      "type": "file",
      "name": "MemoryCard.tsx",
      "filePath": "web/src/components/cards/MemoryCard.tsx",
      "line": 1,
      "endLine": 258,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntitySummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/colors",
          "items": [
            {
              "name": "getEntityIcon",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getEntityTextClass",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/export",
          "items": [
            {
              "name": "exportMemoryAsMarkdown",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "exportMemoryAsText",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "MemoryCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MemoryCard",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/cards/MemoryCard.tsx:fn:MemoryCard:17",
        "file:web/src/components/cards/MemoryCard.tsx:fn:SalienceMeter:235"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/cards/MemoryCard.tsx:fn:MemoryCard:17": {
      "id": "file:web/src/components/cards/MemoryCard.tsx:fn:MemoryCard:17",
      "type": "function",
      "name": "MemoryCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/cards/MemoryCard.tsx",
      "line": 17,
      "endLine": 232,
      "parentFileId": "file:web/src/components/cards/MemoryCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  memory,\n  entities = [],\n  onDismiss,\n  compact = false,\n}",
          "type": "MemoryCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a flippable React memory card with export handlers and salience styling",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function MemoryCard({\n  memory,\n  entities = [],\n  onDismiss,\n  compact = false,\n}: MemoryCardProps) {\n  const [isFlipped, setIsFlipped] = useState(false);\n\n  // Export handlers\n  const handleExportMarkdown = useCallback(() => {\n    exportMemoryAsMarkdown(memory, entities);\n  }, [memory, entities]);\n\n  const handleExportText = useCallback(() => {\n    exportMemoryAsText(memory);\n  }, [memory]);\n\n  // Calculate glow intensity based on salience (1-10 scale)\n  const salienceLevel = Math.min(10, Math.max(1, Math.round(memory.salience_score)));\n  const glowClass = `salience-glow-${salienceLevel}`;\n\n  // Truncate content for front face\n  const maxLength = compact ? 80 : 150;\n  const truncatedContent =\n    memory.content.length > maxLength\n      ? memory.content.substring(0, maxLength) + '...'\n      : memory.content;\n\n  // Category badge styling\n  const categoryColors = {\n    high_salience: 'bg-accent-gold/20 text-accent-gold border-accent-gold/30',\n    relevant: 'bg-primary/20 text-primary border-primary/30',\n    recent: 'bg-accent-purple/20 text-accent-purple border-accent-purple/30',\n  };\n\n  const categoryLabels = {\n    high_salience: 'Important',\n    relevant: 'Relevant',\n    recent: 'Recent',\n  };\n\n  // Height expands when flipped to show full content\n  const cardHeight = isFlipped ? 'h-72' : (compact ? 'h-32' : 'h-48');\n\n  return (\n    <div\n      className={`\n        relative w-full perspective-1000\n        transition-all duration-500\n        ${cardHeight}\n      `}\n    >\n      <motion.div\n        className=\"relative w-full h-full\"\n        initial={false}\n        animate={{ rotateY: isFlipped ? 180 : 0 }}\n        transition={{ duration: 0.5, ease: 'easeInOut' }}\n        style={{ transformStyle: 'preserve-3d' }}\n      >\n        {/* Front Face */}\n        <div\n          className={`\n            absolute inset-0 w-full h-full\n            glass rounded-lg p-4 cursor-pointer\n            transition-all duration-300\n            hover:border-primary/50\n            ${glowClass}\n          `}\n          style={{ backfaceVisibility: 'hidden' }}\n          onClick={() => setIsFlipped(true)}\n        >\n          {/* Header */}\n          <div className=\"flex items-start justify-between gap-2 mb-2\">\n            {/* Category badge */}\n            <span\n              className={`\n                text-xs px-2 py-0.5 rounded-full border\n                ${categoryColors[memory.category]}\n              `}\n            >\n              {categoryLabels[memory.category]}\n            </span>\n\n            {/* Dismiss button */}\n            {onDismiss && (\n              <button\n                onClick={(e) => {\n                  e.stopPropagation();\n                  onDismiss();\n                }}\n                className=\"text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                \n              </button>\n            )}\n          </div>\n\n          {/* Content */}\n          <p className=\"text-sm text-foreground leading-relaxed mb-3\">\n            {truncatedContent}\n          </p>\n\n          {/* Footer */}\n          <div className=\"absolute bottom-4 left-4 right-4 flex items-center justify-between\">\n            {/* Timestamp */}\n            <span className=\"text-xs text-foreground-muted\">\n              {formatRelativeTime(memory.created_at)}\n            </span>\n\n            {/* Salience meter */}\n            <SalienceMeter score={memory.salience_score} />\n          </div>\n\n          {/* Flip hint */}\n          <div className=\"absolute bottom-4 right-4\">\n            <span className=\"text-xs text-foreground-muted opacity-50\">\n              Click to flip\n            </span>\n          </div>\n        </div>\n\n        {/* Back Face */}\n        <div\n          className={`\n            absolute inset-0 w-full h-full\n            glass rounded-lg p-4 overflow-y-auto\n            ${glowClass}\n          `}\n          style={{\n            backfaceVisibility: 'hidden',\n            transform: 'rotateY(180deg)',\n          }}\n        >\n          {/* Header */}\n          <div className=\"flex items-start justify-between gap-2 mb-3\">\n            <h4 className=\"text-sm font-medium text-primary\">Full Memory</h4>\n            <button\n              onClick={() => setIsFlipped(false)}\n              className=\"text-foreground-muted hover:text-foreground transition-colors\"\n            >\n              \n            </button>\n          </div>\n\n          {/* Full content */}\n          <p className=\"text-sm text-foreground leading-relaxed mb-3\">\n            {memory.content}\n          </p>\n\n          {/* Entities */}\n          {entities.length > 0 && (\n            <div className=\"mb-3\">\n              <h5 className=\"text-xs text-foreground-muted mb-1\">Entities</h5>\n              <div className=\"flex flex-wrap gap-1\">\n                {entities.slice(0, 5).map((entity) => (\n                  <span\n                    key={entity.id}\n                    className={`\n                      text-xs px-2 py-0.5 rounded-full\n                      bg-background-tertiary border border-glass-border\n                      ${getEntityTextClass(entity.type)}\n                    `}\n                  >\n                    {getEntityIcon(entity.type)} {entity.name}\n                  </span>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Scores */}\n          <div className=\"grid grid-cols-2 gap-2 mb-3 text-xs\">\n            <div className=\"text-foreground-muted\">\n              Salience: <span className=\"text-foreground\">{memory.salience_score.toFixed(1)}</span>\n            </div>\n            <div className=\"text-foreground-muted\">\n              Strength: <span className=\"text-foreground\">{(memory.current_strength * 100).toFixed(0)}%</span>\n            </div>\n            {memory.similarity !== undefined && (\n              <div className=\"text-foreground-muted\">\n                Similarity: <span className=\"text-foreground\">{(memory.similarity * 100).toFixed(0)}%</span>\n              </div>\n            )}\n            <div className=\"text-foreground-muted\">\n              Score: <span className=\"text-foreground\">{(memory.final_score * 100).toFixed(0)}%</span>\n            </div>\n          </div>\n\n          {/* Export buttons */}\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleExportMarkdown}\n              className=\"\n                text-xs px-3 py-1 rounded\n                bg-primary/20 text-primary border border-primary/30\n                hover:bg-primary/30 transition-colors\n              \"\n            >\n              Export .md\n            </button>\n            <button\n              onClick={handleExportText}\n              className=\"\n                text-xs px-3 py-1 rounded\n                bg-background-tertiary text-foreground-muted border border-glass-border\n                hover:text-foreground transition-colors\n              \"\n            >\n              Export .txt\n            </button>\n          </div>\n        </div>\n      </motion.div>\n    </div>\n  );\n}",
      "references": [
        "isFlipped",
        "setIsFlipped",
        "useState",
        "useCallback",
        "exportMemoryAsMarkdown",
        "memory",
        "entities",
        "exportMemoryAsText",
        "Math",
        "salienceLevel",
        "compact",
        "maxLength",
        "div",
        "className",
        "cardHeight",
        "motion",
        "initial",
        "animate",
        "transition",
        "style",
        "glowClass",
        "onClick",
        "span",
        "categoryColors",
        "categoryLabels",
        "onDismiss",
        "button",
        "e",
        "p",
        "truncatedContent",
        "formatRelativeTime",
        "SalienceMeter",
        "score",
        "h4",
        "h5",
        "key",
        "entity",
        "getEntityTextClass",
        "getEntityIcon",
        "handleExportMarkdown",
        "handleExportText"
      ]
    },
    "file:web/src/components/cards/MemoryCard.tsx:fn:SalienceMeter:235": {
      "id": "file:web/src/components/cards/MemoryCard.tsx:fn:SalienceMeter:235",
      "type": "function",
      "name": "SalienceMeter",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/cards/MemoryCard.tsx",
      "line": 235,
      "endLine": 255,
      "parentFileId": "file:web/src/components/cards/MemoryCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ score }",
          "type": "{ score: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated salience meter progress bar displaying a score.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SalienceMeter({ score }: { score: number }) {\n  const percentage = (score / 10) * 100;\n  const level = Math.min(10, Math.max(1, Math.round(score)));\n\n  return (\n    <div className=\"flex items-center gap-2\">\n      <div className=\"w-16 h-1.5 bg-background-tertiary rounded-full overflow-hidden\">\n        <motion.div\n          className=\"h-full rounded-full\"\n          initial={{ width: 0 }}\n          animate={{ width: `${percentage}%` }}\n          transition={{ duration: 0.5, ease: 'easeOut' }}\n          style={{\n            backgroundColor: `var(--salience-${level})`,\n          }}\n        />\n      </div>\n      <span className=\"text-xs text-foreground-muted\">{score.toFixed(1)}</span>\n    </div>\n  );\n}",
      "references": [
        "score",
        "Math",
        "div",
        "className",
        "motion",
        "initial",
        "animate",
        "percentage",
        "transition",
        "style",
        "level",
        "span"
      ]
    },
    "file:web/src/components/chat/ChatInputBar.tsx": {
      "id": "file:web/src/components/chat/ChatInputBar.tsx",
      "type": "file",
      "name": "ChatInputBar.tsx",
      "filePath": "web/src/components/chat/ChatInputBar.tsx",
      "line": 1,
      "endLine": 195,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "KeyboardEvent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./STTButton",
          "items": [
            {
              "name": "STTButton",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ChatInputBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/chat/ChatInputBar.tsx:fn:ChatInputBar:12"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/ChatInputBar.tsx:fn:ChatInputBar:12": {
      "id": "file:web/src/components/chat/ChatInputBar.tsx:fn:ChatInputBar:12",
      "type": "function",
      "name": "ChatInputBar",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/ChatInputBar.tsx",
      "line": 12,
      "endLine": 194,
      "parentFileId": "file:web/src/components/chat/ChatInputBar.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  onSend,\n  isLoading = false,\n  placeholder = 'Type a message...',\n}",
          "type": "ChatInputBarProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React chat input bar component with auto-resize, enter-to-send, and refocus after submit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ChatInputBar({\n  onSend,\n  isLoading = false,\n  placeholder = 'Type a message...',\n}: ChatInputBarProps) {\n  const [input, setInput] = useState('');\n  const textareaRef = useRef<HTMLTextAreaElement>(null);\n  const justSubmittedRef = useRef(false);\n\n  // Auto-resize textarea\n  useEffect(() => {\n    const textarea = textareaRef.current;\n    if (textarea) {\n      textarea.style.height = 'auto';\n      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;\n    }\n  }, [input]);\n\n  // Focus on mount\n  useEffect(() => {\n    textareaRef.current?.focus();\n  }, []);\n\n  // Refocus after submission - aggressive multi-attempt approach\n  useEffect(() => {\n    if (justSubmittedRef.current && input === '') {\n      // Multiple focus attempts to overcome any competing focus changes\n      const focusInput = () => textareaRef.current?.focus();\n\n      // Immediate attempt\n      focusInput();\n      // After microtask\n      queueMicrotask(focusInput);\n      // After paint\n      requestAnimationFrame(focusInput);\n      // After scroll animations (100ms covers most smooth scrolls)\n      setTimeout(focusInput, 100);\n      // Final fallback\n      setTimeout(focusInput, 250);\n      // Clear the flag after all attempts complete\n      setTimeout(() => {\n        justSubmittedRef.current = false;\n      }, 500);\n    }\n  }, [input]);\n\n  const handleSubmit = () => {\n    const trimmed = input.trim();\n    if (trimmed && !isLoading) {\n      justSubmittedRef.current = true;\n      onSend(trimmed);\n      setInput('');\n      // Reset height\n      if (textareaRef.current) {\n        textareaRef.current.style.height = 'auto';\n      }\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {\n    // Submit on Enter (without Shift) - but not while loading\n    if (e.key === 'Enter' && !e.shiftKey && !isLoading) {\n      e.preventDefault();\n      handleSubmit();\n    }\n  };\n\n  // Prevent focus loss after submission - refocus immediately on blur\n  const handleBlur = useCallback(() => {\n    if (justSubmittedRef.current) {\n      // Something stole focus right after submit - take it back\n      requestAnimationFrame(() => {\n        textareaRef.current?.focus();\n      });\n    }\n  }, []);\n\n  // Handle speech-to-text transcript\n  const handleSpeechTranscript = useCallback((text: string) => {\n    setInput((prev) => {\n      // Add space if there's existing text\n      const newText = prev ? `${prev} ${text}` : text;\n      return newText;\n    });\n    // Focus the textarea after speech input\n    textareaRef.current?.focus();\n  }, []);\n\n  const canSend = input.trim().length > 0 && !isLoading;\n\n  return (\n    <div className=\"border-t border-glass-border bg-background-secondary p-4\">\n      <div className=\"max-w-4xl mx-auto\">\n        <div className=\"flex items-end gap-3\">\n          {/* Speech-to-text button */}\n          <STTButton\n            onTranscript={handleSpeechTranscript}\n            disabled={isLoading}\n          />\n\n          {/* Text input */}\n          <div className=\"flex-1 relative\">\n            <textarea\n              ref={textareaRef}\n              value={input}\n              onChange={(e) => !isLoading && setInput(e.target.value)}\n              onKeyDown={handleKeyDown}\n              onBlur={handleBlur}\n              placeholder={placeholder}\n              aria-disabled={isLoading}\n              rows={1}\n              className={`\n                w-full px-4 py-3 rounded-xl resize-none\n                bg-background-tertiary border border-glass-border\n                text-foreground placeholder-foreground-muted\n                focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/50\n                transition-colors\n                ${isLoading ? 'opacity-50 cursor-not-allowed' : ''}\n              `}\n              style={{ maxHeight: '200px' }}\n            />\n          </div>\n\n          {/* Send button */}\n          <button\n            type=\"button\"\n            onClick={handleSubmit}\n            disabled={!canSend}\n            className={`\n              shrink-0 p-3 rounded-xl transition-all duration-200\n              ${canSend\n                ? 'bg-primary text-background hover:bg-primary-hover glow-primary'\n                : 'bg-background-tertiary text-foreground-muted border border-glass-border'\n              }\n              disabled:opacity-50 disabled:cursor-not-allowed\n            `}\n          >\n            {isLoading ? (\n              <svg\n                className=\"w-5 h-5 animate-spin\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n              >\n                <circle\n                  className=\"opacity-25\"\n                  cx=\"12\"\n                  cy=\"12\"\n                  r=\"10\"\n                  stroke=\"currentColor\"\n                  strokeWidth=\"4\"\n                />\n                <path\n                  className=\"opacity-75\"\n                  fill=\"currentColor\"\n                  d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n                />\n              </svg>\n            ) : (\n              <svg\n                className=\"w-5 h-5\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M12 19l9 2-9-18-9 18 9-2zm0 0v-8\"\n                />\n              </svg>\n            )}\n          </button>\n        </div>\n\n        {/* Helper text */}\n        <p className=\"text-xs text-foreground-muted mt-2 text-center\">\n          Press <kbd className=\"px-1.5 py-0.5 rounded bg-background-tertiary text-foreground-muted\">Enter</kbd> to send, <kbd className=\"px-1.5 py-0.5 rounded bg-background-tertiary text-foreground-muted\">Shift+Enter</kbd> for new line\n        </p>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "input",
        "setInput",
        "useState",
        "useRef",
        "useEffect",
        "textareaRef",
        "textarea",
        "Math",
        "justSubmittedRef",
        "focusInput",
        "queueMicrotask",
        "requestAnimationFrame",
        "setTimeout",
        "trimmed",
        "isLoading",
        "onSend",
        "e",
        "handleSubmit",
        "useCallback",
        "prev",
        "text",
        "newText",
        "div",
        "className",
        "STTButton",
        "onTranscript",
        "handleSpeechTranscript",
        "disabled",
        "ref",
        "value",
        "onChange",
        "onKeyDown",
        "handleKeyDown",
        "onBlur",
        "handleBlur",
        "placeholder",
        "aria-disabled",
        "rows",
        "style",
        "button",
        "onClick",
        "canSend",
        "svg",
        "fill",
        "viewBox",
        "circle",
        "cx",
        "cy",
        "r",
        "stroke",
        "strokeWidth",
        "path",
        "d",
        "strokeLinecap",
        "strokeLinejoin",
        "p",
        "kbd"
      ]
    },
    "file:web/src/components/chat/ChatWindow.tsx": {
      "id": "file:web/src/components/chat/ChatWindow.tsx",
      "type": "file",
      "name": "ChatWindow.tsx",
      "filePath": "web/src/components/chat/ChatWindow.tsx",
      "line": 1,
      "endLine": 42,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./MessageList",
          "items": [
            {
              "name": "MessageList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./ChatInputBar",
          "items": [
            {
              "name": "ChatInputBar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./ContextualMemoryOverlayStack",
          "items": [
            {
              "name": "ContextualMemoryOverlayStack",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useChatStore",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useIsLoadingContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ChatWindow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/chat/ChatWindow.tsx:fn:ChatWindow:9"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/ChatWindow.tsx:fn:ChatWindow:9": {
      "id": "file:web/src/components/chat/ChatWindow.tsx:fn:ChatWindow:9",
      "type": "function",
      "name": "ChatWindow",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/ChatWindow.tsx",
      "line": 9,
      "endLine": 41,
      "parentFileId": "file:web/src/components/chat/ChatWindow.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering chat window with messages, input, loading, and overlays",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function ChatWindow() {\n  const messages = useChatStore((state) => state.messages);\n  const isLoading = useChatStore((state) => state.isLoading);\n  const isLoadingContext = useIsLoadingContext();\n  const sendMessage = useChatStore((state) => state.sendMessage);\n\n  const handleSend = useCallback(\n    async (content: string) => {\n      await sendMessage(content);\n    },\n    [sendMessage]\n  );\n\n  return (\n    <div className=\"h-full flex flex-col relative\">\n      {/* Context loading indicator */}\n      {isLoadingContext && (\n        <div className=\"absolute top-2 left-1/2 -translate-x-1/2 z-10\">\n          <div className=\"glass px-3 py-1.5 rounded-full text-xs text-primary flex items-center gap-2\">\n            <span className=\"animate-pulse\"></span>\n            Recalling memories...\n          </div>\n        </div>\n      )}\n\n      <MessageList messages={messages} isLoading={isLoading} />\n      <ChatInputBar onSend={handleSend} isLoading={isLoading} />\n\n      {/* Memory context overlay */}\n      <ContextualMemoryOverlayStack />\n    </div>\n  );\n}",
      "references": [
        "useChatStore",
        "state",
        "useIsLoadingContext",
        "useCallback",
        "sendMessage",
        "content",
        "div",
        "className",
        "isLoadingContext",
        "span",
        "MessageList",
        "messages",
        "isLoading",
        "ChatInputBar",
        "onSend",
        "handleSend",
        "ContextualMemoryOverlayStack"
      ]
    },
    "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx": {
      "id": "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx",
      "type": "file",
      "name": "ContextualMemoryOverlayStack.tsx",
      "filePath": "web/src/components/chat/ContextualMemoryOverlayStack.tsx",
      "line": 1,
      "endLine": 125,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/cards/MemoryCard",
          "items": [
            {
              "name": "MemoryCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/layout/OverlayPortal",
          "items": [
            {
              "name": "OverlayPortal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores/overlayStore",
          "items": [
            {
              "name": "useOverlayCards",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOverlayVisible",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOverlayLoading",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useDismissCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useHideMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ContextualMemoryOverlayStack",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ContextualMemoryOverlayStack",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx:fn:ContextualMemoryOverlayStack:23"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx:fn:ContextualMemoryOverlayStack:23": {
      "id": "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx:fn:ContextualMemoryOverlayStack:23",
      "type": "function",
      "name": "ContextualMemoryOverlayStack",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/ContextualMemoryOverlayStack.tsx",
      "line": 23,
      "endLine": 122,
      "parentFileId": "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  position = 'right',\n  offset = 16,\n}",
          "type": "ContextualMemoryOverlayStackProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders overlay stack for chat memory cards with header, loading, and close button.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.594Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function ContextualMemoryOverlayStack({\n  position = 'right',\n  offset = 16,\n}: ContextualMemoryOverlayStackProps) {\n  const cards = useOverlayCards();\n  const isVisible = useOverlayVisible();\n  const isLoading = useOverlayLoading();\n  const dismissCard = useDismissCard();\n  const hideMemories = useHideMemories();\n\n  // Only render when visible (loading or has cards)\n  if (!isVisible && !isLoading) {\n    return null;\n  }\n\n  const positionStyles =\n    position === 'right'\n      ? { right: offset, left: 'auto' }\n      : { left: offset, right: 'auto' };\n\n  return (\n    <OverlayPortal>\n      <div\n        className=\"fixed top-20 bottom-4 w-80 pointer-events-auto flex flex-col\"\n        style={positionStyles}\n      >\n        {/* Header */}\n        <motion.div\n          initial={{ opacity: 0, y: -10 }}\n          animate={{ opacity: 1, y: 0 }}\n          className=\"flex items-center justify-between mb-3 px-1\"\n        >\n          <div className=\"flex items-center gap-2\">\n            <span className=\"text-sm font-medium text-primary\">\n               Related Memories\n            </span>\n            {!isLoading && (\n              <span className=\"text-xs text-foreground-muted bg-background-tertiary px-2 py-0.5 rounded-full\">\n                {cards.length}\n              </span>\n            )}\n          </div>\n\n          {/* Close button */}\n          <button\n            onClick={hideMemories}\n            className=\"p-1.5 text-foreground-muted hover:text-foreground transition-colors\"\n            title=\"Close\"\n          >\n            \n          </button>\n        </motion.div>\n\n        {/* Loading state */}\n        {isLoading && (\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            className=\"glass rounded-lg p-6 text-center\"\n          >\n            <div className=\"animate-pulse text-primary text-2xl mb-2\"></div>\n            <span className=\"text-sm text-foreground-muted\">Loading memories...</span>\n          </motion.div>\n        )}\n\n        {/* Cards stack */}\n        <AnimatePresence mode=\"popLayout\">\n          {isVisible && !isLoading && cards.length > 0 && (\n            <motion.div\n              initial={{ opacity: 0, height: 0 }}\n              animate={{ opacity: 1, height: 'auto' }}\n              exit={{ opacity: 0, height: 0 }}\n              className=\"flex-1 overflow-y-auto space-y-3 pr-1\"\n            >\n              {cards.map((card, index) => (\n                <motion.div\n                  key={card.id}\n                  initial={{ opacity: 0, x: 20, scale: 0.95 }}\n                  animate={{ opacity: 1, x: 0, scale: 1 }}\n                  exit={{ opacity: 0, x: 20, scale: 0.95 }}\n                  transition={{\n                    duration: 0.3,\n                    delay: index * 0.05,\n                  }}\n                >\n                  <MemoryCard\n                    memory={card.memory}\n                    entities={card.entities}\n                    onDismiss={() => dismissCard(card.id)}\n                    compact\n                  />\n                </motion.div>\n              ))}\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </OverlayPortal>\n  );\n}",
      "references": [
        "useOverlayCards",
        "useOverlayVisible",
        "useOverlayLoading",
        "useDismissCard",
        "useHideMemories",
        "isVisible",
        "isLoading",
        "position",
        "offset",
        "OverlayPortal",
        "div",
        "className",
        "style",
        "positionStyles",
        "motion",
        "initial",
        "animate",
        "span",
        "cards",
        "button",
        "onClick",
        "hideMemories",
        "title",
        "AnimatePresence",
        "mode",
        "exit",
        "key",
        "card",
        "transition",
        "index",
        "MemoryCard",
        "memory",
        "entities",
        "onDismiss",
        "dismissCard",
        "compact"
      ]
    },
    "file:web/src/components/chat/index.ts": {
      "id": "file:web/src/components/chat/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/chat/index.ts",
      "line": 1,
      "endLine": 6,
      "imports": [],
      "exports": [
        {
          "name": "ChatWindow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MessageList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MessageBubble",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "ChatInputBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "STTButton",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ChatWindow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ChatWindow"
        },
        {
          "name": "MessageList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./MessageList"
        },
        {
          "name": "MessageBubble",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./MessageBubble"
        },
        {
          "name": "ChatInputBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ChatInputBar"
        },
        {
          "name": "STTButton",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./STTButton"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/MessageBubble.tsx": {
      "id": "file:web/src/components/chat/MessageBubble.tsx",
      "type": "file",
      "name": "MessageBubble.tsx",
      "filePath": "web/src/components/chat/MessageBubble.tsx",
      "line": 1,
      "endLine": 166,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "memo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ChatMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/stores/overlayStore",
          "items": [
            {
              "name": "useShowMemoriesForMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOverlayLoading",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useActiveMessageId",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores/chatStore",
          "items": [
            {
              "name": "useChatStore",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "MessageBubble",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/components/chat/MessageBubble.tsx:fn:MemoryBadge:116",
        "file:web/src/components/chat/MessageBubble.tsx:fn:formatTime:162"
      ],
      "classes": [],
      "topLevelReferences": [
        "MessageBubble",
        "message",
        "isLatest",
        "badgeHovered",
        "setBadgeHovered",
        "state",
        "streamingMessageId",
        "activeMessageId",
        "overlayLoading",
        "showMemoriesForMessage",
        "isSystem",
        "initial",
        "animate",
        "className",
        "span",
        "isStreaming",
        "transition",
        "isUser",
        "div",
        "formatTime",
        "memoryCount",
        "MemoryBadge",
        "count",
        "isActive",
        "isLoading",
        "isLoadingThis",
        "isHovered",
        "onClick",
        "handleBadgeClick",
        "onHover"
      ]
    },
    "file:web/src/components/chat/MessageBubble.tsx:fn:MemoryBadge:116": {
      "id": "file:web/src/components/chat/MessageBubble.tsx:fn:MemoryBadge:116",
      "type": "function",
      "name": "MemoryBadge",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/MessageBubble.tsx",
      "line": 116,
      "endLine": 160,
      "parentFileId": "file:web/src/components/chat/MessageBubble.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  count,\n  isActive,\n  isLoading,\n  isHovered,\n  onClick,\n  onHover,\n}",
          "type": "MemoryBadgeProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated badge button for memory count with hover, active, and loading states.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function MemoryBadge({\n  count,\n  isActive,\n  isLoading,\n  isHovered,\n  onClick,\n  onHover,\n}: MemoryBadgeProps) {\n  return (\n    <motion.button\n      onClick={onClick}\n      onMouseEnter={() => onHover(true)}\n      onMouseLeave={() => onHover(false)}\n      disabled={isLoading}\n      className={`\n        inline-flex items-center gap-1.5 px-2 py-0.5 rounded-full\n        text-xs font-medium transition-all duration-200 cursor-pointer\n        ${isActive\n          ? 'bg-primary/30 text-primary border border-primary/50 glow-primary'\n          : 'bg-primary/10 text-primary/80 border border-primary/20 hover:bg-primary/20'\n        }\n        ${isLoading ? 'opacity-70 cursor-wait' : ''}\n      `}\n      whileHover={isLoading ? {} : { scale: 1.05 }}\n      whileTap={isLoading ? {} : { scale: 0.95 }}\n    >\n      <span className={`text-[10px] ${isLoading ? 'animate-pulse' : ''}`}>\n        {isLoading ? '' : ''}\n      </span>\n      <span>{count}</span>\n      <AnimatePresence>\n        {isHovered && !isLoading && (\n          <motion.span\n            initial={{ opacity: 0, width: 0 }}\n            animate={{ opacity: 1, width: 'auto' }}\n            exit={{ opacity: 0, width: 0 }}\n            className=\"overflow-hidden whitespace-nowrap\"\n          >\n            {count === 1 ? 'memory' : 'memories'}\n          </motion.span>\n        )}\n      </AnimatePresence>\n    </motion.button>\n  );\n}",
      "references": [
        "motion",
        "onClick",
        "onMouseEnter",
        "onHover",
        "onMouseLeave",
        "disabled",
        "isLoading",
        "className",
        "isActive",
        "whileHover",
        "whileTap",
        "span",
        "count",
        "AnimatePresence",
        "isHovered",
        "initial",
        "animate",
        "exit"
      ]
    },
    "file:web/src/components/chat/MessageBubble.tsx:fn:formatTime:162": {
      "id": "file:web/src/components/chat/MessageBubble.tsx:fn:formatTime:162",
      "type": "function",
      "name": "formatTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/MessageBubble.tsx",
      "line": 162,
      "endLine": 165,
      "parentFileId": "file:web/src/components/chat/MessageBubble.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "timestamp",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a timestamp string to 2-digit hour and minute time string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatTime(timestamp: string): string {\n  const date = new Date(timestamp);\n  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n}",
      "references": [
        "Date",
        "date"
      ]
    },
    "file:web/src/components/chat/MessageList.tsx": {
      "id": "file:web/src/components/chat/MessageList.tsx",
      "type": "file",
      "name": "MessageList.tsx",
      "filePath": "web/src/components/chat/MessageList.tsx",
      "line": 1,
      "endLine": 198,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TouchEvent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./MessageBubble",
          "items": [
            {
              "name": "MessageBubble",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/conversations",
          "items": [
            {
              "name": "fetchRecentConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores/chatStore",
          "items": [
            {
              "name": "useChatStore",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ChatMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "MessageList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/chat/MessageList.tsx:fn:MessageList:16"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/MessageList.tsx:fn:MessageList:16": {
      "id": "file:web/src/components/chat/MessageList.tsx:fn:MessageList:16",
      "type": "function",
      "name": "MessageList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/MessageList.tsx",
      "line": 16,
      "endLine": 197,
      "parentFileId": "file:web/src/components/chat/MessageList.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ messages, isLoading = false }",
          "type": "MessageListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for message list with auto-scroll and pull-to-refresh via API fetch and store update",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function MessageList({ messages, isLoading = false }: MessageListProps) {\n  const bottomRef = useRef<HTMLDivElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [pullDistance, setPullDistance] = useState(0);\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const touchStartY = useRef<number | null>(null);\n  const isPulling = useRef(false);\n\n  // Auto-scroll to bottom on new messages\n  useEffect(() => {\n    if (bottomRef.current) {\n      bottomRef.current.scrollIntoView({ behavior: 'smooth' });\n    }\n  }, [messages]);\n\n  // Refresh conversation from server\n  const handleRefresh = useCallback(async () => {\n    setIsRefreshing(true);\n    try {\n      const result = await fetchRecentConversation();\n      if (result) {\n        const chatMessages: ChatMessage[] = result.messages.map((m) => ({\n          id: m.id,\n          role: m.role,\n          content: m.content,\n          timestamp: m.created_at,\n          memoryIds: m.context_memory_ids,\n        }));\n        useChatStore.setState({\n          messages: chatMessages,\n          conversationId: result.conversation.client_id || result.conversation.id,\n          dbConversationId: result.conversation.id,\n        });\n      }\n    } catch (error) {\n      console.error('[MessageList] Refresh failed:', error);\n    } finally {\n      setIsRefreshing(false);\n      setPullDistance(0);\n    }\n  }, []);\n\n  // Touch handlers for pull-to-refresh\n  const handleTouchStart = useCallback((e: TouchEvent<HTMLDivElement>) => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Only enable pull-to-refresh when scrolled to top\n    if (container.scrollTop <= 0) {\n      touchStartY.current = e.touches[0].clientY;\n      isPulling.current = true;\n    }\n  }, []);\n\n  const handleTouchMove = useCallback((e: TouchEvent<HTMLDivElement>) => {\n    if (!isPulling.current || touchStartY.current === null) return;\n\n    const container = containerRef.current;\n    if (!container || container.scrollTop > 0) {\n      isPulling.current = false;\n      setPullDistance(0);\n      return;\n    }\n\n    const currentY = e.touches[0].clientY;\n    const distance = Math.max(0, currentY - touchStartY.current);\n\n    // Apply resistance (logarithmic) to make it feel natural\n    const resistedDistance = Math.min(distance * 0.5, 120);\n    setPullDistance(resistedDistance);\n  }, []);\n\n  const handleTouchEnd = useCallback(() => {\n    if (!isPulling.current) return;\n\n    isPulling.current = false;\n    touchStartY.current = null;\n\n    if (pullDistance >= PULL_THRESHOLD && !isRefreshing) {\n      handleRefresh();\n    } else {\n      setPullDistance(0);\n    }\n  }, [pullDistance, isRefreshing, handleRefresh]);\n\n  if (messages.length === 0 && !isLoading) {\n    return (\n      <div className=\"flex-1 flex flex-col items-center justify-center p-8 text-center\">\n        <div className=\"w-16 h-16 rounded-full bg-primary/10 border border-primary/30 flex items-center justify-center mb-4 glow-primary\">\n          <svg\n            className=\"w-8 h-8 text-primary\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z\"\n            />\n          </svg>\n        </div>\n        <h2 className=\"text-xl font-semibold text-foreground mb-2\">\n          Start a conversation\n        </h2>\n        <p className=\"text-foreground-muted max-w-sm\">\n          Ask me anything. I remember everything we discuss.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"flex-1 overflow-y-auto p-4 space-y-4 relative overscroll-y-contain\"\n      onTouchStart={handleTouchStart}\n      onTouchMove={handleTouchMove}\n      onTouchEnd={handleTouchEnd}\n    >\n      {/* Pull-to-refresh indicator */}\n      {(pullDistance > 0 || isRefreshing) && (\n        <div\n          className=\"absolute left-0 right-0 flex justify-center transition-transform duration-150\"\n          style={{\n            top: isRefreshing ? 8 : Math.min(pullDistance - 40, 20),\n            opacity: isRefreshing ? 1 : Math.min(pullDistance / PULL_THRESHOLD, 1),\n          }}\n        >\n          <div className=\"glass px-4 py-2 rounded-full flex items-center gap-2\">\n            {isRefreshing ? (\n              <>\n                <svg className=\"w-4 h-4 text-primary animate-spin\" viewBox=\"0 0 24 24\" fill=\"none\">\n                  <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n                  <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n                </svg>\n                <span className=\"text-xs text-primary\">Refreshing...</span>\n              </>\n            ) : pullDistance >= PULL_THRESHOLD ? (\n              <span className=\"text-xs text-primary\">Release to refresh</span>\n            ) : (\n              <span className=\"text-xs text-foreground-muted\">Pull to refresh</span>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Messages container with pull transform */}\n      <div\n        style={{\n          transform: pullDistance > 0 ? `translateY(${pullDistance}px)` : undefined,\n          transition: pullDistance === 0 ? 'transform 0.2s ease-out' : undefined,\n        }}\n      >\n        {messages.map((message, index) => (\n          <MessageBubble\n            key={message.id}\n            message={message}\n            isLatest={index === messages.length - 1}\n          />\n        ))}\n\n        {/* Typing indicator */}\n        {isLoading && (\n          <div className=\"flex justify-start mt-4\">\n            <div className=\"glass px-4 py-3 rounded-2xl rounded-bl-md\">\n              <div className=\"flex gap-1.5\">\n                <span className=\"w-2 h-2 bg-primary rounded-full animate-bounce\" style={{ animationDelay: '0ms' }} />\n                <span className=\"w-2 h-2 bg-primary rounded-full animate-bounce\" style={{ animationDelay: '150ms' }} />\n                <span className=\"w-2 h-2 bg-primary rounded-full animate-bounce\" style={{ animationDelay: '300ms' }} />\n              </div>\n            </div>\n          </div>\n        )}\n\n        {/* Scroll anchor */}\n        <div ref={bottomRef} />\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useRef",
        "pullDistance",
        "setPullDistance",
        "useState",
        "isRefreshing",
        "setIsRefreshing",
        "useEffect",
        "bottomRef",
        "messages",
        "useCallback",
        "fetchRecentConversation",
        "result",
        "m",
        "useChatStore",
        "chatMessages",
        "console",
        "error",
        "containerRef",
        "container",
        "touchStartY",
        "e",
        "isPulling",
        "Math",
        "currentY",
        "distance",
        "resistedDistance",
        "PULL_THRESHOLD",
        "handleRefresh",
        "isLoading",
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h2",
        "p",
        "ref",
        "onTouchStart",
        "handleTouchStart",
        "onTouchMove",
        "handleTouchMove",
        "onTouchEnd",
        "handleTouchEnd",
        "style",
        "circle",
        "cx",
        "cy",
        "r",
        "span",
        "MessageBubble",
        "key",
        "message",
        "isLatest",
        "index"
      ]
    },
    "file:web/src/components/chat/STTButton.tsx": {
      "id": "file:web/src/components/chat/STTButton.tsx",
      "type": "file",
      "name": "STTButton.tsx",
      "filePath": "web/src/components/chat/STTButton.tsx",
      "line": 1,
      "endLine": 172,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useSpeechRecognition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "STTButton",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/chat/STTButton.tsx:fn:STTButton:12",
        "file:web/src/components/chat/STTButton.tsx:fn:MicrophoneIcon:143",
        "file:web/src/components/chat/STTButton.tsx:fn:StopIcon:161"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/chat/STTButton.tsx:fn:STTButton:12": {
      "id": "file:web/src/components/chat/STTButton.tsx:fn:STTButton:12",
      "type": "function",
      "name": "STTButton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/STTButton.tsx",
      "line": 12,
      "endLine": 140,
      "parentFileId": "file:web/src/components/chat/STTButton.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onTranscript, disabled = false }",
          "type": "STTButtonProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for STT button that toggles speech recognition and sends transcripts to parent.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function STTButton({ onTranscript, disabled = false }: STTButtonProps) {\n  const {\n    isListening,\n    isSupported,\n    transcript,\n    interimTranscript,\n    error,\n    startListening,\n    stopListening,\n    resetTranscript,\n  } = useSpeechRecognition({\n    continuous: false,\n    interimResults: true,\n  });\n\n  // When we get a final transcript, send it to the parent\n  useEffect(() => {\n    if (transcript) {\n      onTranscript(transcript);\n      resetTranscript();\n    }\n  }, [transcript, onTranscript, resetTranscript]);\n\n  const handleClick = () => {\n    if (isListening) {\n      stopListening();\n    } else {\n      startListening();\n    }\n  };\n\n  // Not supported - show disabled state\n  if (!isSupported) {\n    return (\n      <button\n        type=\"button\"\n        className=\"shrink-0 p-3 rounded-xl bg-background-tertiary border border-glass-border text-foreground-muted opacity-50 cursor-not-allowed\"\n        disabled\n        title=\"Voice input not supported in this browser\"\n      >\n        <MicrophoneIcon className=\"w-5 h-5\" />\n      </button>\n    );\n  }\n\n  return (\n    <div className=\"relative\">\n      <motion.button\n        type=\"button\"\n        onClick={handleClick}\n        disabled={disabled}\n        className={`\n          shrink-0 p-3 rounded-xl transition-colors\n          ${isListening\n            ? 'bg-accent text-background border border-accent glow-accent'\n            : 'bg-background-tertiary border border-glass-border text-foreground-muted hover:text-foreground hover:border-primary/50'\n          }\n          disabled:opacity-50 disabled:cursor-not-allowed\n        `}\n        title={isListening ? 'Stop listening' : 'Voice input'}\n        whileTap={{ scale: 0.95 }}\n      >\n        <AnimatePresence mode=\"wait\">\n          {isListening ? (\n            <motion.div\n              key=\"listening\"\n              initial={{ scale: 0 }}\n              animate={{ scale: 1 }}\n              exit={{ scale: 0 }}\n              className=\"relative\"\n            >\n              {/* Pulsing ring animation */}\n              <motion.div\n                className=\"absolute inset-0 rounded-full bg-accent/30\"\n                animate={{\n                  scale: [1, 1.5, 1],\n                  opacity: [0.5, 0, 0.5],\n                }}\n                transition={{\n                  duration: 1.5,\n                  repeat: Infinity,\n                  ease: 'easeInOut',\n                }}\n              />\n              <StopIcon className=\"w-5 h-5 relative z-10\" />\n            </motion.div>\n          ) : (\n            <motion.div\n              key=\"idle\"\n              initial={{ scale: 0 }}\n              animate={{ scale: 1 }}\n              exit={{ scale: 0 }}\n            >\n              <MicrophoneIcon className=\"w-5 h-5\" />\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </motion.button>\n\n      {/* Interim transcript tooltip */}\n      <AnimatePresence>\n        {isListening && interimTranscript && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: 10 }}\n            className=\"absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 rounded-lg bg-background-tertiary border border-glass-border text-sm text-foreground-muted whitespace-nowrap max-w-xs truncate\"\n          >\n            {interimTranscript}\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Error tooltip */}\n      <AnimatePresence>\n        {error && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: 10 }}\n            className=\"absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-3 py-2 rounded-lg bg-error/20 border border-error/50 text-sm text-error whitespace-nowrap\"\n          >\n            {error}\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  );\n}",
      "references": [
        "isListening",
        "isSupported",
        "transcript",
        "interimTranscript",
        "error",
        "startListening",
        "stopListening",
        "resetTranscript",
        "useSpeechRecognition",
        "useEffect",
        "onTranscript",
        "button",
        "className",
        "disabled",
        "title",
        "MicrophoneIcon",
        "div",
        "motion",
        "onClick",
        "handleClick",
        "whileTap",
        "AnimatePresence",
        "mode",
        "key",
        "initial",
        "animate",
        "exit",
        "transition",
        "StopIcon"
      ]
    },
    "file:web/src/components/chat/STTButton.tsx:fn:MicrophoneIcon:143": {
      "id": "file:web/src/components/chat/STTButton.tsx:fn:MicrophoneIcon:143",
      "type": "function",
      "name": "MicrophoneIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/STTButton.tsx",
      "line": 143,
      "endLine": 159,
      "parentFileId": "file:web/src/components/chat/STTButton.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ className }",
          "type": "{ className?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an SVG microphone icon with customizable className.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function MicrophoneIcon({ className }: { className?: string }) {\n  return (\n    <svg\n      className={className}\n      fill=\"none\"\n      stroke=\"currentColor\"\n      viewBox=\"0 0 24 24\"\n    >\n      <path\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        strokeWidth={2}\n        d=\"M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z\"\n      />\n    </svg>\n  );\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/components/chat/STTButton.tsx:fn:StopIcon:161": {
      "id": "file:web/src/components/chat/STTButton.tsx:fn:StopIcon:161",
      "type": "function",
      "name": "StopIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/chat/STTButton.tsx",
      "line": 161,
      "endLine": 171,
      "parentFileId": "file:web/src/components/chat/STTButton.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ className }",
          "type": "{ className?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an SVG stop icon with optional className prop",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function StopIcon({ className }: { className?: string }) {\n  return (\n    <svg\n      className={className}\n      fill=\"currentColor\"\n      viewBox=\"0 0 24 24\"\n    >\n      <rect x=\"6\" y=\"6\" width=\"12\" height=\"12\" rx=\"2\" />\n    </svg>\n  );\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "viewBox",
        "rect",
        "x",
        "y",
        "width",
        "height",
        "rx"
      ]
    },
    "file:web/src/components/common/ExportModal.tsx": {
      "id": "file:web/src/components/common/ExportModal.tsx",
      "type": "file",
      "name": "ExportModal.tsx",
      "filePath": "web/src/components/common/ExportModal.tsx",
      "line": 1,
      "endLine": 185,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ExportModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExportFormat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        }
      ],
      "functions": [
        "file:web/src/components/common/ExportModal.tsx:fn:ExportModal:31"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/common/ExportModal.tsx:fn:ExportModal:31": {
      "id": "file:web/src/components/common/ExportModal.tsx:fn:ExportModal:31",
      "type": "function",
      "name": "ExportModal",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/common/ExportModal.tsx",
      "line": 31,
      "endLine": 184,
      "parentFileId": "file:web/src/components/common/ExportModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  isOpen,\n  onClose,\n  onExport,\n  title = 'Export',\n  formats = ['json', 'markdown', 'csv'],\n  defaultFormat = 'markdown',\n}",
          "type": "ExportModalProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React modal for selecting export format and triggering export via callback",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ExportModal({\n  isOpen,\n  onClose,\n  onExport,\n  title = 'Export',\n  formats = ['json', 'markdown', 'csv'],\n  defaultFormat = 'markdown',\n}: ExportModalProps) {\n  const [selectedFormat, setSelectedFormat] = useState<ExportFormat>(defaultFormat);\n  const [isExporting, setIsExporting] = useState(false);\n  const [success, setSuccess] = useState(false);\n\n  const handleExport = async () => {\n    setIsExporting(true);\n    setSuccess(false);\n    try {\n      await onExport(selectedFormat);\n      setSuccess(true);\n      setTimeout(() => {\n        onClose();\n        setSuccess(false);\n      }, 1000);\n    } catch (err) {\n      console.error('Export failed:', err);\n    } finally {\n      setIsExporting(false);\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Modal */}\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95 }}\n            animate={{ opacity: 1, scale: 1 }}\n            exit={{ opacity: 0, scale: 0.95 }}\n            transition={{ duration: 0.15 }}\n            className=\"fixed left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-sm z-50\"\n          >\n            <div className=\"glass rounded-xl border border-glass-border shadow-2xl overflow-hidden\">\n              {/* Header */}\n              <div className=\"flex items-center justify-between px-5 py-4 border-b border-glass-border\">\n                <h2 className=\"text-lg font-semibold text-foreground\">{title}</h2>\n                <button\n                  onClick={onClose}\n                  className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n                >\n                  <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                  </svg>\n                </button>\n              </div>\n\n              {/* Content */}\n              <div className=\"p-5 space-y-4\">\n                <p className=\"text-sm text-foreground-muted\">Select export format:</p>\n\n                <div className=\"space-y-2\">\n                  {formats.map((format) => (\n                    <button\n                      key={format}\n                      onClick={() => setSelectedFormat(format)}\n                      className={`\n                        w-full flex items-center gap-3 px-4 py-3 rounded-lg border transition-colors text-left\n                        ${\n                          selectedFormat === format\n                            ? 'border-primary bg-primary/10 text-foreground'\n                            : 'border-glass-border bg-background-secondary hover:border-foreground-muted text-foreground-muted'\n                        }\n                      `}\n                    >\n                      <span className=\"w-8 h-8 flex items-center justify-center bg-background-tertiary rounded-lg text-xs font-mono\">\n                        {formatIcons[format]}\n                      </span>\n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"font-medium text-sm uppercase\">{format}</div>\n                        <div className=\"text-xs text-foreground-muted truncate\">\n                          {formatDescriptions[format]}\n                        </div>\n                      </div>\n                      {selectedFormat === format && (\n                        <svg className=\"w-5 h-5 text-primary flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                        </svg>\n                      )}\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              {/* Footer */}\n              <div className=\"flex gap-3 px-5 py-4 border-t border-glass-border bg-background-secondary/50\">\n                <button\n                  onClick={onClose}\n                  className=\"flex-1 px-4 py-2.5 rounded-lg border border-glass-border hover:bg-background-tertiary transition-colors text-sm\"\n                >\n                  Cancel\n                </button>\n                <button\n                  onClick={handleExport}\n                  disabled={isExporting}\n                  className={`\n                    flex-1 px-4 py-2.5 rounded-lg font-medium text-sm transition-all flex items-center justify-center gap-2\n                    ${\n                      success\n                        ? 'bg-green-500 text-white'\n                        : 'bg-primary text-white hover:bg-primary-hover'\n                    }\n                    disabled:opacity-50 disabled:cursor-not-allowed\n                  `}\n                >\n                  {isExporting ? (\n                    <>\n                      <svg className=\"w-4 h-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n                        <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n                      </svg>\n                      Exporting...\n                    </>\n                  ) : success ? (\n                    <>\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                      </svg>\n                      Done!\n                    </>\n                  ) : (\n                    <>\n                      <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n                      </svg>\n                      Export\n                    </>\n                  )}\n                </button>\n              </div>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "selectedFormat",
        "setSelectedFormat",
        "useState",
        "defaultFormat",
        "isExporting",
        "setIsExporting",
        "success",
        "setSuccess",
        "onExport",
        "setTimeout",
        "onClose",
        "console",
        "err",
        "AnimatePresence",
        "isOpen",
        "motion",
        "initial",
        "animate",
        "exit",
        "className",
        "onClick",
        "transition",
        "div",
        "h2",
        "title",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "p",
        "formats",
        "key",
        "format",
        "span",
        "formatIcons",
        "formatDescriptions",
        "handleExport",
        "disabled",
        "circle",
        "cx",
        "cy",
        "r"
      ]
    },
    "file:web/src/components/common/index.ts": {
      "id": "file:web/src/components/common/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/common/index.ts",
      "line": 1,
      "endLine": 2,
      "imports": [],
      "exports": [
        {
          "name": "ExportModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExportFormat",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ExportModal"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/BeliefsPanel.tsx": {
      "id": "file:web/src/components/dashboard/BeliefsPanel.tsx",
      "type": "file",
      "name": "BeliefsPanel.tsx",
      "filePath": "web/src/components/dashboard/BeliefsPanel.tsx",
      "line": 1,
      "endLine": 211,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useBeliefs",
          "items": [
            {
              "name": "useBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatConfidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "BeliefsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BeliefsPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsPanel:71",
        "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefItem:125",
        "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsLoadingSkeleton:186"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsPanel:71": {
      "id": "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsPanel:71",
      "type": "function",
      "name": "BeliefsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/BeliefsPanel.tsx",
      "line": 71,
      "endLine": 117,
      "parentFileId": "file:web/src/components/dashboard/BeliefsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onBeliefClick, limit = 6 }",
          "type": "BeliefsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders active beliefs sorted by confidence with loading, error, and empty states",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function BeliefsPanel({ onBeliefClick, limit = 6 }: BeliefsPanelProps) {\n  const { data: beliefs, isLoading, error } = useBeliefs({\n    status: 'active',\n    limit,\n  });\n\n  if (isLoading) {\n    return <BeliefsLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load beliefs\n      </div>\n    );\n  }\n\n  if (!beliefs || beliefs.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-accent-gold/10 border border-accent-gold/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No beliefs detected yet. Keep chatting to build your belief profile.\n        </p>\n      </div>\n    );\n  }\n\n  // Sort by confidence (highest first)\n  const sortedBeliefs = [...beliefs].sort((a, b) => b.confidence - a.confidence);\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedBeliefs.map((belief, index) => (\n        <BeliefItem\n          key={belief.id}\n          belief={belief}\n          index={index}\n          onClick={() => onBeliefClick?.(belief)}\n        />\n      ))}\n    </div>\n  );\n}",
      "references": [
        "data",
        "beliefs",
        "isLoading",
        "error",
        "useBeliefs",
        "limit",
        "BeliefsLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "b",
        "a",
        "sortedBeliefs",
        "BeliefItem",
        "key",
        "belief",
        "index",
        "onClick",
        "onBeliefClick"
      ]
    },
    "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefItem:125": {
      "id": "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefItem:125",
      "type": "function",
      "name": "BeliefItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/BeliefsPanel.tsx",
      "line": 125,
      "endLine": 184,
      "parentFileId": "file:web/src/components/dashboard/BeliefsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ belief, index, onClick }",
          "type": "BeliefItemProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated clickable button displaying a belief item with category, confidence bar, statement, and meta.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function BeliefItem({ belief, index, onClick }: BeliefItemProps) {\n  const category = categoryMeta[belief.category] || categoryMeta.opinion;\n  const status = statusStyles[belief.status] || statusStyles.active;\n\n  // Confidence as visual bar width\n  const confidencePercent = Math.round(belief.confidence * 100);\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, x: -10 }}\n      animate={{ opacity: 1, x: 0 }}\n      transition={{ duration: 0.2, delay: index * 0.05 }}\n      onClick={onClick}\n      className={`\n        w-full text-left p-3 rounded-lg\n        bg-background-tertiary/50 border border-glass-border\n        hover:bg-background-tertiary hover:border-accent-gold/30\n        transition-all duration-200\n        group relative overflow-hidden\n      `}\n    >\n      {/* Confidence bar background */}\n      <div\n        className=\"absolute inset-0 bg-accent-gold/5 transition-all duration-300\"\n        style={{ width: `${confidencePercent}%` }}\n      />\n\n      {/* Content */}\n      <div className=\"relative z-10\">\n        {/* Header Row */}\n        <div className=\"flex items-center gap-2 mb-1.5\">\n          <span className={`\n            w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs\n            ${category.bgColor}\n          `}>\n            {category.icon}\n          </span>\n          <span className={`text-xs font-medium ${category.color}`}>\n            {category.label}\n          </span>\n          <span className={`text-xs ml-auto ${status.color}`}>\n            {formatConfidence(belief.confidence)}\n          </span>\n        </div>\n\n        {/* Statement */}\n        <p className=\"text-sm text-foreground leading-snug line-clamp-2 mb-1.5\">\n          {belief.statement}\n        </p>\n\n        {/* Meta Row */}\n        <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n          <span>{belief.evidence_count} evidence</span>\n          <span className=\"text-foreground-muted/50\"></span>\n          <span>{formatRelativeTime(belief.last_reinforced)}</span>\n        </div>\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "categoryMeta",
        "belief",
        "statusStyles",
        "Math",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "div",
        "style",
        "confidencePercent",
        "span",
        "category",
        "status",
        "formatConfidence",
        "p",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsLoadingSkeleton:186": {
      "id": "file:web/src/components/dashboard/BeliefsPanel.tsx:fn:BeliefsLoadingSkeleton:186",
      "type": "function",
      "name": "BeliefsLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/BeliefsPanel.tsx",
      "line": 186,
      "endLine": 208,
      "parentFileId": "file:web/src/components/dashboard/BeliefsPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading skeleton UI for a list of 4 beliefs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function BeliefsLoadingSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      {[1, 2, 3, 4].map((i) => (\n        <div\n          key={i}\n          className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-center gap-2 mb-2\">\n            <div className=\"w-5 h-5 rounded bg-background-tertiary flex-shrink-0\" />\n            <div className=\"h-3 w-16 bg-background-tertiary rounded\" />\n            <div className=\"h-3 w-12 bg-background-tertiary rounded ml-auto\" />\n          </div>\n          <div className=\"space-y-1.5\">\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-3/4\" />\n          </div>\n          <div className=\"h-2 bg-background-tertiary rounded w-1/3 mt-2\" />\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/BottomSheet.tsx": {
      "id": "file:web/src/components/dashboard/BottomSheet.tsx",
      "type": "file",
      "name": "BottomSheet.tsx",
      "filePath": "web/src/components/dashboard/BottomSheet.tsx",
      "line": 1,
      "endLine": 130,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useDragControls",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PanInfo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "BottomSheet",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BottomSheet",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/BottomSheet.tsx:fn:BottomSheet:15"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/BottomSheet.tsx:fn:BottomSheet:15": {
      "id": "file:web/src/components/dashboard/BottomSheet.tsx:fn:BottomSheet:15",
      "type": "function",
      "name": "BottomSheet",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/BottomSheet.tsx",
      "line": 15,
      "endLine": 127,
      "parentFileId": "file:web/src/components/dashboard/BottomSheet.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  isOpen,\n  onClose,\n  title,\n  icon,\n  accentColor = 'text-primary',\n  children,\n}",
          "type": "BottomSheetProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders draggable bottom sheet modal with backdrop, escape key, and drag-to-close.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function BottomSheet({\n  isOpen,\n  onClose,\n  title,\n  icon,\n  accentColor = 'text-primary',\n  children,\n}: BottomSheetProps) {\n  const dragControls = useDragControls();\n\n  // Close on escape key\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') onClose();\n  }, [onClose]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  // Handle drag end - close if dragged down enough\n  const handleDragEnd = (_: unknown, info: PanInfo) => {\n    if (info.offset.y > 100 || info.velocity.y > 500) {\n      onClose();\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Sheet - Different behavior for mobile vs desktop */}\n          <motion.div\n            initial={{ y: '100%' }}\n            animate={{ y: 0 }}\n            exit={{ y: '100%' }}\n            transition={{ type: 'spring', damping: 30, stiffness: 300 }}\n            drag=\"y\"\n            dragControls={dragControls}\n            dragConstraints={{ top: 0 }}\n            dragElastic={0.2}\n            onDragEnd={handleDragEnd}\n            className=\"\n              fixed z-50 bg-background-secondary\n\n              /* Mobile: bottom sheet */\n              inset-x-0 bottom-0\n              rounded-t-2xl\n              max-h-[85vh]\n\n              /* Desktop: centered modal */\n              md:inset-auto md:left-1/2 md:top-1/2\n              md:-translate-x-1/2 md:-translate-y-1/2\n              md:rounded-2xl md:max-w-2xl md:w-full\n              md:max-h-[70vh]\n\n              flex flex-col\n              border border-glass-border\n              shadow-2xl\n            \"\n          >\n            {/* Drag Handle (mobile) */}\n            <div\n              className=\"md:hidden flex justify-center py-3 cursor-grab active:cursor-grabbing\"\n              onPointerDown={(e) => dragControls.start(e)}\n            >\n              <div className=\"w-10 h-1 rounded-full bg-foreground-muted/30\" />\n            </div>\n\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-5 py-4 border-b border-glass-border\">\n              <div className=\"flex items-center gap-3\">\n                {icon && (\n                  <span className={`text-xl ${accentColor}`}>{icon}</span>\n                )}\n                <h2 className=\"text-lg font-semibold text-foreground\">{title}</h2>\n              </div>\n              <button\n                onClick={onClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Content - Scrollable */}\n            <div className=\"flex-1 overflow-y-auto p-5\">\n              {children}\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "useDragControls",
        "useCallback",
        "e",
        "onClose",
        "useEffect",
        "isOpen",
        "document",
        "handleKeyDown",
        "info",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "drag",
        "dragControls",
        "dragConstraints",
        "dragElastic",
        "onDragEnd",
        "handleDragEnd",
        "div",
        "onPointerDown",
        "icon",
        "span",
        "accentColor",
        "h2",
        "title",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "children"
      ]
    },
    "file:web/src/components/dashboard/DashboardPanel.tsx": {
      "id": "file:web/src/components/dashboard/DashboardPanel.tsx",
      "type": "file",
      "name": "DashboardPanel.tsx",
      "filePath": "web/src/components/dashboard/DashboardPanel.tsx",
      "line": 1,
      "endLine": 262,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DashboardPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "StatsCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PanelAccent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DashboardPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/DashboardPanel.tsx:fn:DashboardPanel:62",
        "file:web/src/components/dashboard/DashboardPanel.tsx:fn:LoadingSkeleton:150",
        "file:web/src/components/dashboard/DashboardPanel.tsx:fn:EmptyState:162",
        "file:web/src/components/dashboard/DashboardPanel.tsx:fn:StatsCard:200"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/DashboardPanel.tsx:fn:DashboardPanel:62": {
      "id": "file:web/src/components/dashboard/DashboardPanel.tsx:fn:DashboardPanel:62",
      "type": "function",
      "name": "DashboardPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DashboardPanel.tsx",
      "line": 62,
      "endLine": 147,
      "parentFileId": "file:web/src/components/dashboard/DashboardPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  title,\n  icon,\n  accent = 'primary',\n  className = '',\n  children,\n  isLoading = false,\n  isEmpty = false,\n  emptyMessage = 'No data available',\n  emptyIcon,\n  headerAction,\n  onHeaderClick,\n  expandable = false,\n}",
          "type": "DashboardPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a dashboard panel UI component with header, icon, and optional expandability",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function DashboardPanel({\n  title,\n  icon,\n  accent = 'primary',\n  className = '',\n  children,\n  isLoading = false,\n  isEmpty = false,\n  emptyMessage = 'No data available',\n  emptyIcon,\n  headerAction,\n  onHeaderClick,\n  expandable = false,\n}: DashboardPanelProps) {\n  const styles = accentStyles[accent];\n  const isClickable = expandable && onHeaderClick;\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.3 }}\n      className={`\n        glass rounded-xl overflow-hidden\n        flex flex-col\n        ${className}\n      `}\n    >\n      {/* Panel Header */}\n      <div\n        onClick={isClickable ? onHeaderClick : undefined}\n        className={`\n          px-5 py-4 border-b border-glass-border\n          flex items-center justify-between\n          ${isClickable ? 'cursor-pointer hover:bg-background-tertiary/50 transition-colors group' : ''}\n        `}\n      >\n        <div className=\"flex items-center gap-3\">\n          {icon && (\n            <div className={`\n              w-8 h-8 rounded-lg flex items-center justify-center\n              ${styles.bg} ${styles.border} border\n              ${isClickable ? 'group-hover:scale-105 transition-transform' : ''}\n            `}>\n              <span className={styles.text}>{icon}</span>\n            </div>\n          )}\n          <h3 className=\"font-semibold text-foreground\">{title}</h3>\n          {isClickable && (\n            <span className=\"text-xs text-foreground-muted opacity-0 group-hover:opacity-100 transition-opacity ml-1\">\n              tap to expand\n            </span>\n          )}\n        </div>\n        <div className=\"flex items-center gap-2\">\n          {headerAction && (\n            <div className=\"flex items-center\">\n              {headerAction}\n            </div>\n          )}\n          {isClickable && (\n            <svg\n              className=\"w-4 h-4 text-foreground-muted group-hover:text-foreground transition-colors\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4\" />\n            </svg>\n          )}\n        </div>\n      </div>\n\n      {/* Panel Content */}\n      <div className=\"flex-1 p-5 overflow-auto\">\n        {isLoading ? (\n          <LoadingSkeleton />\n        ) : isEmpty ? (\n          <EmptyState message={emptyMessage} icon={emptyIcon} accent={accent} />\n        ) : (\n          children\n        )}\n      </div>\n    </motion.div>\n  );\n}",
      "references": [
        "accentStyles",
        "accent",
        "expandable",
        "onHeaderClick",
        "motion",
        "initial",
        "animate",
        "transition",
        "className",
        "div",
        "onClick",
        "isClickable",
        "icon",
        "styles",
        "span",
        "h3",
        "title",
        "headerAction",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "isLoading",
        "LoadingSkeleton",
        "isEmpty",
        "EmptyState",
        "message",
        "emptyMessage",
        "emptyIcon",
        "children"
      ]
    },
    "file:web/src/components/dashboard/DashboardPanel.tsx:fn:LoadingSkeleton:150": {
      "id": "file:web/src/components/dashboard/DashboardPanel.tsx:fn:LoadingSkeleton:150",
      "type": "function",
      "name": "LoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DashboardPanel.tsx",
      "line": 150,
      "endLine": 159,
      "parentFileId": "file:web/src/components/dashboard/DashboardPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading skeleton with animated placeholder divs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function LoadingSkeleton() {\n  return (\n    <div className=\"space-y-4 animate-pulse\">\n      <div className=\"h-4 bg-background-tertiary rounded w-3/4\" />\n      <div className=\"h-4 bg-background-tertiary rounded w-1/2\" />\n      <div className=\"h-4 bg-background-tertiary rounded w-5/6\" />\n      <div className=\"h-4 bg-background-tertiary rounded w-2/3\" />\n    </div>\n  );\n}",
      "references": [
        "div",
        "className"
      ]
    },
    "file:web/src/components/dashboard/DashboardPanel.tsx:fn:EmptyState:162": {
      "id": "file:web/src/components/dashboard/DashboardPanel.tsx:fn:EmptyState:162",
      "type": "function",
      "name": "EmptyState",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DashboardPanel.tsx",
      "line": 162,
      "endLine": 186,
      "parentFileId": "file:web/src/components/dashboard/DashboardPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  message,\n  icon,\n  accent,\n}",
          "type": "{ message: string; icon?: React.ReactNode; accent: import(\"/home/ridgetop/projects/squire/web/src/components/dashboard/DashboardPanel\").PanelAccent; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an empty state UI panel with message, optional icon, and accent styling.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EmptyState({\n  message,\n  icon,\n  accent,\n}: {\n  message: string;\n  icon?: ReactNode;\n  accent: PanelAccent;\n}) {\n  const styles = accentStyles[accent];\n\n  return (\n    <div className=\"h-full flex flex-col items-center justify-center text-center py-8\">\n      {icon && (\n        <div className={`\n          w-12 h-12 rounded-full flex items-center justify-center mb-3\n          ${styles.bg} ${styles.border} border\n        `}>\n          <span className={`text-xl ${styles.text}`}>{icon}</span>\n        </div>\n      )}\n      <p className=\"text-foreground-muted text-sm\">{message}</p>\n    </div>\n  );\n}",
      "references": [
        "accentStyles",
        "accent",
        "div",
        "className",
        "icon",
        "styles",
        "span",
        "p",
        "message"
      ]
    },
    "file:web/src/components/dashboard/DashboardPanel.tsx:fn:StatsCard:200": {
      "id": "file:web/src/components/dashboard/DashboardPanel.tsx:fn:StatsCard:200",
      "type": "function",
      "name": "StatsCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DashboardPanel.tsx",
      "line": 200,
      "endLine": 259,
      "parentFileId": "file:web/src/components/dashboard/DashboardPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  label,\n  value,\n  icon,\n  accent = 'primary',\n  trend,\n}",
          "type": "StatsCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a styled stats card with label, value, optional icon and trend indicator.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function StatsCard({\n  label,\n  value,\n  icon,\n  accent = 'primary',\n  trend,\n}: StatsCardProps) {\n  const styles = accentStyles[accent];\n\n  const trendColors = {\n    up: 'text-success',\n    down: 'text-error',\n    neutral: 'text-foreground-muted',\n  };\n\n  const trendIcons = {\n    up: '',\n    down: '',\n    neutral: '',\n  };\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.2 }}\n      className={`\n        glass rounded-lg p-4\n        border ${styles.border}\n        hover:${styles.glow || ''}\n        transition-all duration-300\n      `}\n    >\n      <div className=\"flex items-start justify-between\">\n        <div>\n          <p className=\"text-foreground-muted text-xs uppercase tracking-wide mb-1\">\n            {label}\n          </p>\n          <p className={`text-2xl font-bold ${styles.text}`}>\n            {value}\n          </p>\n        </div>\n        {icon && (\n          <div className={`\n            w-10 h-10 rounded-lg flex items-center justify-center\n            ${styles.bg}\n          `}>\n            <span className={styles.text}>{icon}</span>\n          </div>\n        )}\n      </div>\n      {trend && (\n        <div className={`mt-2 text-xs ${trendColors[trend.direction]}`}>\n          {trendIcons[trend.direction]} {Math.abs(trend.value)}%\n          <span className=\"text-foreground-muted ml-1\">vs last week</span>\n        </div>\n      )}\n    </motion.div>\n  );\n}",
      "references": [
        "accentStyles",
        "accent",
        "motion",
        "initial",
        "animate",
        "transition",
        "className",
        "styles",
        "div",
        "p",
        "label",
        "value",
        "icon",
        "span",
        "trend",
        "trendColors",
        "trendIcons",
        "Math"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx",
      "type": "file",
      "name": "DetailModal.tsx",
      "filePath": "web/src/components/dashboard/DetailModal.tsx",
      "line": 1,
      "endLine": 405,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores/detailModalStore",
          "items": [
            {
              "name": "useDetailItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useDetailModalOpen",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCloseDetailModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DetailItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useEntityDetails",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityDetail",
              "alias": "EntityDetailType",
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatDateTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatSalience",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatConfidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "capitalize",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DetailModal",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailModal:24",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:getItemTitle:93",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailContent:104",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:MemoryDetail:116",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:BeliefDetail:147",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:PatternDetail:165",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:EntityDetail:195",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:InsightDetail:334",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:SummaryDetail:354",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:MetaItem:372",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:getEntityIcon:381",
        "file:web/src/components/dashboard/DetailModal.tsx:fn:getInsightIcon:393"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailModal:24": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailModal:24",
      "type": "function",
      "name": "DetailModal",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 24,
      "endLine": 91,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React modal component for item details with backdrop, animations, and escape key close.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function DetailModal() {\n  const item = useDetailItem();\n  const isOpen = useDetailModalOpen();\n  const close = useCloseDetailModal();\n\n  // Close on escape key\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') close();\n  }, [close]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  return (\n    <AnimatePresence>\n      {isOpen && item && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={close}\n          />\n\n          {/* Modal */}\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 20 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-4 md:inset-auto md:left-1/2 md:top-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:max-w-2xl md:w-full md:max-h-[80vh] z-50 glass rounded-xl overflow-hidden flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <h2 className=\"text-lg font-semibold text-foreground\">\n                {getItemTitle(item)}\n              </h2>\n              <button\n                onClick={close}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6\">\n              <DetailContent item={item} />\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "useDetailItem",
        "useDetailModalOpen",
        "useCloseDetailModal",
        "useCallback",
        "e",
        "close",
        "useEffect",
        "isOpen",
        "document",
        "handleKeyDown",
        "AnimatePresence",
        "item",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "h2",
        "getItemTitle",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "DetailContent"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:getItemTitle:93": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:getItemTitle:93",
      "type": "function",
      "name": "getItemTitle",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 93,
      "endLine": 102,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "item",
          "type": "DetailItem",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a title string based on the item's type.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getItemTitle(item: DetailItem): string {\n  switch (item.type) {\n    case 'memory': return 'Memory';\n    case 'belief': return 'Belief';\n    case 'pattern': return 'Pattern';\n    case 'entity': return item.data.name;\n    case 'insight': return 'Insight';\n    case 'summary': return `${capitalize(item.data.category)} Summary`;\n  }\n}",
      "references": [
        "capitalize"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailContent:104": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:DetailContent:104",
      "type": "function",
      "name": "DetailContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 104,
      "endLine": 113,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ item }",
          "type": "{ item: DetailItem; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders specific detail component based on item type via switch statement",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function DetailContent({ item }: { item: DetailItem }) {\n  switch (item.type) {\n    case 'memory': return <MemoryDetail memory={item.data} />;\n    case 'belief': return <BeliefDetail belief={item.data} />;\n    case 'pattern': return <PatternDetail pattern={item.data} />;\n    case 'entity': return <EntityDetail entity={item.data} />;\n    case 'insight': return <InsightDetail insight={item.data} />;\n    case 'summary': return <SummaryDetail summary={item.data} />;\n  }\n}",
      "references": [
        "item",
        "MemoryDetail",
        "memory",
        "BeliefDetail",
        "belief",
        "PatternDetail",
        "pattern",
        "EntityDetail",
        "entity",
        "InsightDetail",
        "insight",
        "SummaryDetail",
        "summary"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:MemoryDetail:116": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:MemoryDetail:116",
      "type": "function",
      "name": "MemoryDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 116,
      "endLine": 144,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ memory }",
          "type": "{ memory: Memory; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders detailed view of a memory with content, metadata, and entities.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function MemoryDetail({ memory }: { memory: Memory }) {\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"prose prose-invert max-w-none\">\n        <p className=\"text-foreground leading-relaxed whitespace-pre-wrap\">{memory.content}</p>\n      </div>\n\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Source\" value={capitalize(memory.source)} />\n        <MetaItem label=\"Salience\" value={formatSalience(memory.salience)} />\n        <MetaItem label=\"Created\" value={formatDateTime(memory.created_at)} />\n        <MetaItem label=\"Updated\" value={formatRelativeTime(memory.updated_at)} />\n      </div>\n\n      {memory.entities && memory.entities.length > 0 && (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <h4 className=\"text-sm font-medium text-foreground-muted mb-2\">Entities</h4>\n          <div className=\"flex flex-wrap gap-2\">\n            {memory.entities.map((e) => (\n              <span key={e.id} className=\"px-2 py-1 rounded-full bg-primary/10 text-primary text-xs\">\n                {e.name}\n              </span>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "p",
        "memory",
        "MetaItem",
        "label",
        "value",
        "capitalize",
        "formatSalience",
        "formatDateTime",
        "formatRelativeTime",
        "h4",
        "span",
        "key",
        "e"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:BeliefDetail:147": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:BeliefDetail:147",
      "type": "function",
      "name": "BeliefDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 147,
      "endLine": 162,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ belief }",
          "type": "{ belief: Belief; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a detail view of a belief with statement and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function BeliefDetail({ belief }: { belief: Belief }) {\n  return (\n    <div className=\"space-y-4\">\n      <p className=\"text-foreground text-lg leading-relaxed\">{belief.statement}</p>\n\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Category\" value={capitalize(belief.category)} />\n        <MetaItem label=\"Confidence\" value={formatConfidence(belief.confidence)} />\n        <MetaItem label=\"Status\" value={capitalize(belief.status)} />\n        <MetaItem label=\"Evidence\" value={`${belief.evidence_count} memories`} />\n        <MetaItem label=\"First Observed\" value={formatDateTime(belief.first_observed)} />\n        <MetaItem label=\"Last Reinforced\" value={formatRelativeTime(belief.last_reinforced)} />\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "p",
        "belief",
        "MetaItem",
        "label",
        "value",
        "capitalize",
        "formatConfidence",
        "formatDateTime",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:PatternDetail:165": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:PatternDetail:165",
      "type": "function",
      "name": "PatternDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 165,
      "endLine": 192,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ pattern }",
          "type": "{ pattern: Pattern; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders detail view for a pattern with description, metadata, and examples.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function PatternDetail({ pattern }: { pattern: Pattern }) {\n  return (\n    <div className=\"space-y-4\">\n      <p className=\"text-foreground text-lg leading-relaxed\">{pattern.description}</p>\n\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Type\" value={capitalize(pattern.type)} />\n        <MetaItem label=\"Confidence\" value={formatConfidence(pattern.confidence)} />\n        <MetaItem label=\"Frequency\" value={`${pattern.frequency} observed`} />\n        <MetaItem label=\"First Detected\" value={formatDateTime(pattern.first_detected)} />\n        <MetaItem label=\"Last Detected\" value={formatRelativeTime(pattern.last_detected)} />\n      </div>\n\n      {pattern.examples && pattern.examples.length > 0 && (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <h4 className=\"text-sm font-medium text-foreground-muted mb-2\">Examples</h4>\n          <ul className=\"space-y-2\">\n            {pattern.examples.map((example, i) => (\n              <li key={i} className=\"text-sm text-foreground bg-background-tertiary/50 rounded-lg p-3\">\n                {example}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "p",
        "pattern",
        "MetaItem",
        "label",
        "value",
        "capitalize",
        "formatConfidence",
        "formatDateTime",
        "formatRelativeTime",
        "h4",
        "ul",
        "li",
        "key",
        "i",
        "example"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:EntityDetail:195": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:EntityDetail:195",
      "type": "function",
      "name": "EntityDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 195,
      "endLine": 331,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ entity }",
          "type": "{ entity: Entity; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders UI for entity details using data from useEntityDetails hook",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.595Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function EntityDetail({ entity }: { entity: Entity }) {\n  const { data: enrichedEntity, isLoading, error } = useEntityDetails(entity.id);\n\n  // Entity type icons\n  const typeIcons: Record<string, string> = {\n    person: '',\n    organization: '',\n    location: '',\n    project: '',\n    concept: '',\n    event: '',\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Header with name, type, and relationship */}\n      <div className=\"flex items-center gap-3\">\n        <span className=\"text-3xl\">{getEntityIcon(entity.type)}</span>\n        <div className=\"flex-1\">\n          <h3 className=\"text-xl font-semibold text-foreground\">{entity.name}</h3>\n          <div className=\"flex items-center gap-2\">\n            <p className=\"text-sm text-foreground-muted\">{capitalize(entity.type)}</p>\n            {enrichedEntity?.primary_relationship && (\n              <span className=\"px-2 py-0.5 rounded-full bg-primary/20 text-primary text-xs font-medium\">\n                {enrichedEntity.primary_relationship}\n              </span>\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Stats */}\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Mentions\" value={`${entity.mention_count}`} />\n        <MetaItem label=\"First Seen\" value={formatDateTime(entity.first_seen)} />\n        <MetaItem label=\"Last Seen\" value={formatRelativeTime(entity.last_seen)} />\n        {enrichedEntity?.connected_entities && (\n          <MetaItem label=\"Connected To\" value={`${enrichedEntity.connected_entities.length} entities`} />\n        )}\n      </div>\n\n      {/* Aliases */}\n      {entity.aliases && entity.aliases.length > 0 && (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <h4 className=\"text-sm font-medium text-foreground-muted mb-2\">Also Known As</h4>\n          <div className=\"flex flex-wrap gap-2\">\n            {entity.aliases.map((alias, i) => (\n              <span key={i} className=\"px-2 py-1 rounded-full bg-background-tertiary text-foreground-muted text-xs\">\n                {alias}\n              </span>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Connected Entities */}\n      {isLoading ? (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <div className=\"animate-pulse space-y-2\">\n            <div className=\"h-4 w-32 bg-background-tertiary rounded\" />\n            <div className=\"flex gap-2\">\n              <div className=\"h-8 w-24 bg-background-tertiary rounded-lg\" />\n              <div className=\"h-8 w-20 bg-background-tertiary rounded-lg\" />\n              <div className=\"h-8 w-28 bg-background-tertiary rounded-lg\" />\n            </div>\n          </div>\n        </div>\n      ) : enrichedEntity?.connected_entities && enrichedEntity.connected_entities.length > 0 ? (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <h4 className=\"text-sm font-medium text-foreground-muted mb-2\">Connected Entities</h4>\n          <div className=\"flex flex-wrap gap-2\">\n            {enrichedEntity.connected_entities.map((connected) => (\n              <div\n                key={connected.id}\n                className=\"inline-flex items-center gap-1.5 px-2.5 py-1.5 rounded-lg bg-background-tertiary/50 border border-glass-border text-sm\"\n              >\n                <span>{typeIcons[connected.entity_type] || ''}</span>\n                <span className=\"text-foreground\">{connected.name}</span>\n                <span className=\"text-foreground-muted text-xs\">\n                  ({connected.shared_memory_count})\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      ) : null}\n\n      {/* Related Memories */}\n      {isLoading ? (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <div className=\"animate-pulse space-y-2\">\n            <div className=\"h-4 w-32 bg-background-tertiary rounded\" />\n            <div className=\"h-16 bg-background-tertiary rounded-lg\" />\n            <div className=\"h-16 bg-background-tertiary rounded-lg\" />\n          </div>\n        </div>\n      ) : enrichedEntity?.memories && enrichedEntity.memories.length > 0 ? (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <h4 className=\"text-sm font-medium text-foreground-muted mb-2\">\n            Related Memories ({enrichedEntity.memories.length})\n          </h4>\n          <div className=\"space-y-2 max-h-[200px] overflow-y-auto pr-2\">\n            {enrichedEntity.memories.slice(0, 5).map((memory) => (\n              <div\n                key={memory.id}\n                className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border\"\n              >\n                <p className=\"text-sm text-foreground line-clamp-2\">{memory.content}</p>\n                <div className=\"flex items-center gap-2 mt-1.5\">\n                  <span className=\"text-xs text-foreground-muted\">\n                    {formatRelativeTime(memory.created_at)}\n                  </span>\n                  {memory.relationship_type && (\n                    <span className=\"text-xs px-1.5 py-0.5 rounded bg-primary/10 text-primary\">\n                      {memory.relationship_type}\n                    </span>\n                  )}\n                </div>\n              </div>\n            ))}\n            {enrichedEntity.memories.length > 5 && (\n              <p className=\"text-xs text-foreground-muted text-center py-1\">\n                +{enrichedEntity.memories.length - 5} more memories\n              </p>\n            )}\n          </div>\n        </div>\n      ) : null}\n\n      {error && (\n        <div className=\"pt-4 border-t border-glass-border\">\n          <p className=\"text-sm text-error\">Failed to load entity details</p>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "data",
        "enrichedEntity",
        "isLoading",
        "error",
        "useEntityDetails",
        "entity",
        "div",
        "className",
        "span",
        "getEntityIcon",
        "h3",
        "p",
        "capitalize",
        "MetaItem",
        "label",
        "value",
        "formatDateTime",
        "formatRelativeTime",
        "h4",
        "key",
        "i",
        "alias",
        "connected",
        "typeIcons",
        "memory"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:InsightDetail:334": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:InsightDetail:334",
      "type": "function",
      "name": "InsightDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 334,
      "endLine": 351,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ insight }",
          "type": "{ insight: Insight; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders detail view of an insight with icon, content, and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function InsightDetail({ insight }: { insight: Insight }) {\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-start gap-3\">\n        <span className=\"text-2xl\">{getInsightIcon(insight.type)}</span>\n        <p className=\"text-foreground text-lg leading-relaxed\">{insight.content}</p>\n      </div>\n\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Type\" value={capitalize(insight.type)} />\n        <MetaItem label=\"Priority\" value={capitalize(insight.priority)} />\n        <MetaItem label=\"Status\" value={capitalize(insight.status)} />\n        <MetaItem label=\"Sources\" value={`${insight.source_memories?.length || 0} memories`} />\n        <MetaItem label=\"Created\" value={formatDateTime(insight.created_at)} />\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "span",
        "getInsightIcon",
        "insight",
        "p",
        "MetaItem",
        "label",
        "value",
        "capitalize",
        "formatDateTime"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:SummaryDetail:354": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:SummaryDetail:354",
      "type": "function",
      "name": "SummaryDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 354,
      "endLine": 369,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ summary }",
          "type": "{ summary: LivingSummary; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders summary content and metadata in a React component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SummaryDetail({ summary }: { summary: LivingSummary }) {\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"prose prose-invert max-w-none\">\n        <p className=\"text-foreground leading-relaxed whitespace-pre-wrap\">{summary.content}</p>\n      </div>\n\n      <div className=\"grid grid-cols-2 gap-4 pt-4 border-t border-glass-border\">\n        <MetaItem label=\"Category\" value={capitalize(summary.category)} />\n        <MetaItem label=\"Version\" value={`v${summary.version}`} />\n        <MetaItem label=\"Memories\" value={`${summary.memory_count} contributing`} />\n        <MetaItem label=\"Last Updated\" value={formatRelativeTime(summary.last_updated)} />\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "p",
        "summary",
        "MetaItem",
        "label",
        "value",
        "capitalize",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:MetaItem:372": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:MetaItem:372",
      "type": "function",
      "name": "MetaItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 372,
      "endLine": 379,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ label, value }",
          "type": "{ label: string; value: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a labeled metadata item with label and value.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function MetaItem({ label, value }: { label: string; value: string }) {\n  return (\n    <div>\n      <dt className=\"text-xs text-foreground-muted uppercase tracking-wide\">{label}</dt>\n      <dd className=\"text-sm text-foreground mt-0.5\">{value}</dd>\n    </div>\n  );\n}",
      "references": [
        "div",
        "dt",
        "className",
        "label",
        "dd",
        "value"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:getEntityIcon:381": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:getEntityIcon:381",
      "type": "function",
      "name": "getEntityIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 381,
      "endLine": 391,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji icon based on entity type, defaults to ''.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getEntityIcon(type: string): string {\n  const icons: Record<string, string> = {\n    person: '',\n    organization: '',\n    location: '',\n    project: '',\n    concept: '',\n    event: '',\n  };\n  return icons[type] || '';\n}",
      "references": [
        "icons"
      ]
    },
    "file:web/src/components/dashboard/DetailModal.tsx:fn:getInsightIcon:393": {
      "id": "file:web/src/components/dashboard/DetailModal.tsx:fn:getInsightIcon:393",
      "type": "function",
      "name": "getInsightIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/DetailModal.tsx",
      "line": 393,
      "endLine": 402,
      "parentFileId": "file:web/src/components/dashboard/DetailModal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an emoji icon for the given insight type, defaulting to ''.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getInsightIcon(type: string): string {\n  const icons: Record<string, string> = {\n    connection: '',\n    contradiction: '',\n    opportunity: '',\n    warning: '',\n    realization: '',\n  };\n  return icons[type] || '';\n}",
      "references": [
        "icons"
      ]
    },
    "file:web/src/components/dashboard/EntitiesPanel.tsx": {
      "id": "file:web/src/components/dashboard/EntitiesPanel.tsx",
      "type": "file",
      "name": "EntitiesPanel.tsx",
      "filePath": "web/src/components/dashboard/EntitiesPanel.tsx",
      "line": 1,
      "endLine": 208,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useEntities",
          "items": [
            {
              "name": "useTopEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "EntitiesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EntitiesPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesPanel:65",
        "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntityChip:140",
        "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesLoadingSkeleton:181"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesPanel:65": {
      "id": "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesPanel:65",
      "type": "function",
      "name": "EntitiesPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/EntitiesPanel.tsx",
      "line": 65,
      "endLine": 132,
      "parentFileId": "file:web/src/components/dashboard/EntitiesPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onEntityClick, limit = 15 }",
          "type": "EntitiesPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders dashboard panel for top entities with type counts, grid, loading, error, and empty states.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function EntitiesPanel({ onEntityClick, limit = 15 }: EntitiesPanelProps) {\n  const { data, isLoading, error } = useTopEntities(limit);\n\n  if (isLoading) {\n    return <EntitiesLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load entities\n      </div>\n    );\n  }\n\n  if (!data?.entities || data.entities.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-success/10 border border-success/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No entities tracked yet. People, places, and projects will appear as you chat.\n        </p>\n      </div>\n    );\n  }\n\n  // Group entities by type for the summary\n  const typeOrder: EntityType[] = ['person', 'project', 'organization', 'location', 'concept', 'event'];\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Type Summary Row */}\n      <div className=\"flex flex-wrap gap-2\">\n        {typeOrder.map((type) => {\n          const count = data.counts[type] || 0;\n          if (count === 0) return null;\n          const meta = typeMeta[type];\n          return (\n            <div\n              key={type}\n              className={`\n                inline-flex items-center gap-1.5 px-2 py-1 rounded-full text-xs\n                ${meta.bgColor} ${meta.borderColor} border\n              `}\n            >\n              <span>{meta.icon}</span>\n              <span className={meta.color}>{count} {meta.label}{count !== 1 ? 's' : ''}</span>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Entities Grid */}\n      <div className=\"flex flex-wrap gap-2\">\n        {data.entities.map((entity, index) => (\n          <EntityChip\n            key={entity.id}\n            entity={entity}\n            index={index}\n            onClick={() => onEntityClick?.(entity)}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "data",
        "isLoading",
        "error",
        "useTopEntities",
        "limit",
        "EntitiesLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "typeOrder",
        "count",
        "typeMeta",
        "key",
        "meta",
        "EntityChip",
        "entity",
        "index",
        "onClick",
        "onEntityClick"
      ]
    },
    "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntityChip:140": {
      "id": "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntityChip:140",
      "type": "function",
      "name": "EntityChip",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/EntitiesPanel.tsx",
      "line": 140,
      "endLine": 179,
      "parentFileId": "file:web/src/components/dashboard/EntitiesPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ entity, index, onClick }",
          "type": "EntityChipProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated clickable chip for entity with icon, name, and mention count badge",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EntityChip({ entity, index, onClick }: EntityChipProps) {\n  const meta = typeMeta[entity.type] || typeMeta.concept;\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, scale: 0.9 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.2, delay: index * 0.02 }}\n      onClick={onClick}\n      className={`\n        inline-flex items-center gap-2 px-3 py-2 rounded-lg\n        bg-background-tertiary/50 border border-glass-border\n        hover:bg-background-tertiary hover:${meta.borderColor}\n        transition-all duration-200\n        group\n      `}\n    >\n      {/* Type Icon */}\n      <span className={`\n        w-6 h-6 rounded flex-shrink-0 flex items-center justify-center text-sm\n        ${meta.bgColor}\n      `}>\n        {meta.icon}\n      </span>\n\n      {/* Name */}\n      <span className=\"text-sm text-foreground font-medium truncate max-w-[120px]\">\n        {entity.name}\n      </span>\n\n      {/* Mention Count Badge */}\n      <span className={`\n        text-xs px-1.5 py-0.5 rounded-full\n        ${meta.bgColor} ${meta.color}\n      `}>\n        {entity.mention_count}\n      </span>\n    </motion.button>\n  );\n}",
      "references": [
        "typeMeta",
        "entity",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "meta",
        "span"
      ]
    },
    "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesLoadingSkeleton:181": {
      "id": "file:web/src/components/dashboard/EntitiesPanel.tsx:fn:EntitiesLoadingSkeleton:181",
      "type": "function",
      "name": "EntitiesLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/EntitiesPanel.tsx",
      "line": 181,
      "endLine": 205,
      "parentFileId": "file:web/src/components/dashboard/EntitiesPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders loading skeleton UI for entities panel with pulsing divs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EntitiesLoadingSkeleton() {\n  return (\n    <div className=\"space-y-4\">\n      {/* Type summary skeleton */}\n      <div className=\"flex gap-2\">\n        {[1, 2, 3].map((i) => (\n          <div\n            key={i}\n            className=\"h-6 w-20 rounded-full bg-background-tertiary animate-pulse\"\n          />\n        ))}\n      </div>\n\n      {/* Entities grid skeleton */}\n      <div className=\"flex flex-wrap gap-2\">\n        {[1, 2, 3, 4, 5, 6, 7, 8].map((i) => (\n          <div\n            key={i}\n            className=\"h-10 w-32 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n          />\n        ))}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/ExpandedLists.tsx": {
      "id": "file:web/src/components/dashboard/ExpandedLists.tsx",
      "type": "file",
      "name": "ExpandedLists.tsx",
      "filePath": "web/src/components/dashboard/ExpandedLists.tsx",
      "line": 1,
      "endLine": 299,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useBeliefs",
          "items": [
            {
              "name": "useBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/usePatterns",
          "items": [
            {
              "name": "usePatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useInsights",
          "items": [
            {
              "name": "useInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatConfidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ExpandedBeliefsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExpandedPatternsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExpandedInsightsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedBeliefsList:33",
        "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedPatternsList:116",
        "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedInsightsList:203",
        "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedListSkeleton:276"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedBeliefsList:33": {
      "id": "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedBeliefsList:33",
      "type": "function",
      "name": "ExpandedBeliefsList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/ExpandedLists.tsx",
      "line": 33,
      "endLine": 93,
      "parentFileId": "file:web/src/components/dashboard/ExpandedLists.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onBeliefClick }",
          "type": "ExpandedBeliefsListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted list of active beliefs with loading/error/empty states and click handlers.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ExpandedBeliefsList({ onBeliefClick }: ExpandedBeliefsListProps) {\n  const { data: beliefs, isLoading, error } = useBeliefs({ status: 'active', limit: 50 });\n\n  if (isLoading) {\n    return <ExpandedListSkeleton />;\n  }\n\n  if (error) {\n    return <div className=\"text-error text-sm text-center py-8\">Failed to load beliefs</div>;\n  }\n\n  if (!beliefs || beliefs.length === 0) {\n    return (\n      <div className=\"text-center py-8 text-foreground-muted\">\n        No beliefs detected yet. Keep chatting to build your belief profile.\n      </div>\n    );\n  }\n\n  const sortedBeliefs = [...beliefs].sort((a, b) => b.confidence - a.confidence);\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedBeliefs.map((belief, index) => {\n        const category = beliefCategoryMeta[belief.category] || beliefCategoryMeta.opinion;\n        const confidencePercent = Math.round(belief.confidence * 100);\n\n        return (\n          <motion.button\n            key={belief.id}\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ duration: 0.2, delay: index * 0.02 }}\n            onClick={() => onBeliefClick?.(belief)}\n            className=\"w-full text-left p-3 rounded-lg bg-background-tertiary/50 border border-glass-border hover:bg-background-tertiary hover:border-accent-gold/30 transition-all duration-200 relative overflow-hidden\"\n          >\n            <div\n              className=\"absolute inset-0 bg-accent-gold/5 transition-all duration-300\"\n              style={{ width: `${confidencePercent}%` }}\n            />\n            <div className=\"relative z-10\">\n              <div className=\"flex items-center gap-2 mb-1.5\">\n                <span className={`w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs ${category.bgColor}`}>\n                  {category.icon}\n                </span>\n                <span className={`text-xs font-medium ${category.color}`}>{category.label}</span>\n                <span className=\"text-xs text-foreground-muted ml-auto\">{formatConfidence(belief.confidence)}</span>\n              </div>\n              <p className=\"text-sm text-foreground leading-snug mb-1.5\">{belief.statement}</p>\n              <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n                <span>{belief.evidence_count} evidence</span>\n                <span className=\"text-foreground-muted/50\"></span>\n                <span>{formatRelativeTime(belief.last_reinforced)}</span>\n              </div>\n            </div>\n          </motion.button>\n        );\n      })}\n    </div>\n  );\n}",
      "references": [
        "data",
        "beliefs",
        "isLoading",
        "error",
        "useBeliefs",
        "ExpandedListSkeleton",
        "div",
        "className",
        "b",
        "a",
        "sortedBeliefs",
        "beliefCategoryMeta",
        "belief",
        "Math",
        "motion",
        "key",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "onBeliefClick",
        "style",
        "confidencePercent",
        "span",
        "category",
        "formatConfidence",
        "p",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedPatternsList:116": {
      "id": "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedPatternsList:116",
      "type": "function",
      "name": "ExpandedPatternsList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/ExpandedLists.tsx",
      "line": 116,
      "endLine": 173,
      "parentFileId": "file:web/src/components/dashboard/ExpandedLists.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onPatternClick }",
          "type": "ExpandedPatternsListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted patterns list from usePatterns hook with click handlers",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ExpandedPatternsList({ onPatternClick }: ExpandedPatternsListProps) {\n  const { data: patterns, isLoading, error } = usePatterns({ limit: 50 });\n\n  if (isLoading) {\n    return <ExpandedListSkeleton />;\n  }\n\n  if (error) {\n    return <div className=\"text-error text-sm text-center py-8\">Failed to load patterns</div>;\n  }\n\n  if (!patterns || patterns.length === 0) {\n    return (\n      <div className=\"text-center py-8 text-foreground-muted\">\n        No patterns detected yet. Patterns emerge over time as you share more.\n      </div>\n    );\n  }\n\n  const sortedPatterns = [...patterns].sort((a, b) => {\n    if (b.frequency !== a.frequency) return b.frequency - a.frequency;\n    return b.confidence - a.confidence;\n  });\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedPatterns.map((pattern, index) => {\n        const type = patternTypeMeta[pattern.type] || patternTypeMeta.behavioral;\n        const frequencyLabel = pattern.frequency === 1 ? 'Once' : `${pattern.frequency} observed`;\n\n        return (\n          <motion.button\n            key={pattern.id}\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ duration: 0.2, delay: index * 0.02 }}\n            onClick={() => onPatternClick?.(pattern)}\n            className=\"w-full text-left p-3 rounded-lg bg-background-tertiary/50 border border-glass-border hover:bg-background-tertiary hover:border-accent-purple/30 transition-all duration-200\"\n          >\n            <div className=\"flex items-center gap-2 mb-1.5\">\n              <span className={`w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs ${type.bgColor}`}>\n                {type.icon}\n              </span>\n              <span className={`text-xs font-medium ${type.color}`}>{type.label}</span>\n              <span className=\"text-xs text-foreground-muted ml-auto\">{formatConfidence(pattern.confidence)}</span>\n            </div>\n            <p className=\"text-sm text-foreground leading-snug mb-1.5\">{pattern.description}</p>\n            <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n              <span>{frequencyLabel}</span>\n              <span className=\"text-foreground-muted/50\"></span>\n              <span>{formatRelativeTime(pattern.last_detected)}</span>\n            </div>\n          </motion.button>\n        );\n      })}\n    </div>\n  );\n}",
      "references": [
        "data",
        "patterns",
        "isLoading",
        "error",
        "usePatterns",
        "ExpandedListSkeleton",
        "div",
        "className",
        "b",
        "a",
        "sortedPatterns",
        "patternTypeMeta",
        "pattern",
        "motion",
        "key",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "onPatternClick",
        "span",
        "formatConfidence",
        "p",
        "frequencyLabel",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedInsightsList:203": {
      "id": "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedInsightsList:203",
      "type": "function",
      "name": "ExpandedInsightsList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/ExpandedLists.tsx",
      "line": 203,
      "endLine": 270,
      "parentFileId": "file:web/src/components/dashboard/ExpandedLists.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onInsightClick }",
          "type": "ExpandedInsightsListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted insights list with loading, error, and empty states using useInsights hook",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ExpandedInsightsList({ onInsightClick }: ExpandedInsightsListProps) {\n  const { data: insights, isLoading, error } = useInsights({ limit: 50 });\n\n  if (isLoading) {\n    return <ExpandedListSkeleton />;\n  }\n\n  if (error) {\n    return <div className=\"text-error text-sm text-center py-8\">Failed to load insights</div>;\n  }\n\n  if (!insights || insights.length === 0) {\n    return (\n      <div className=\"text-center py-8 text-foreground-muted\">\n        No insights yet. AI-generated realizations will appear as patterns emerge.\n      </div>\n    );\n  }\n\n  const priorityOrder = ['critical', 'high', 'medium', 'low'];\n  const sortedInsights = [...insights].sort((a, b) => {\n    const aPriority = priorityOrder.indexOf(a.priority);\n    const bPriority = priorityOrder.indexOf(b.priority);\n    if (aPriority !== bPriority) return aPriority - bPriority;\n    return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n  });\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedInsights.map((insight, index) => {\n        const type = insightTypeMeta[insight.type] || insightTypeMeta.realization;\n        const priority = priorityStyles[insight.priority] || priorityStyles.medium;\n        const isUrgent = insight.priority === 'critical' || insight.priority === 'high';\n\n        return (\n          <motion.button\n            key={insight.id}\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ duration: 0.2, delay: index * 0.02 }}\n            onClick={() => onInsightClick?.(insight)}\n            className={`w-full text-left p-3 rounded-lg bg-background-tertiary/50 border ${isUrgent ? 'border-warning/50' : 'border-glass-border'} hover:bg-background-tertiary hover:border-warning/30 transition-all duration-200`}\n          >\n            <div className=\"flex items-center gap-2 mb-1.5\">\n              <span className={`w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs ${type.bgColor}`}>\n                {type.icon}\n              </span>\n              <span className={`text-xs font-medium ${type.color}`}>{type.label}</span>\n              <span className={`text-xs ml-auto ${priority.color}`}>{priority.label}</span>\n            </div>\n            <p className=\"text-sm text-foreground leading-snug mb-1.5\">{insight.content}</p>\n            <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n              <span>{insight.source_memories?.length || 0} sources</span>\n              <span className=\"text-foreground-muted/50\"></span>\n              <span>{formatRelativeTime(insight.created_at)}</span>\n              {insight.status === 'new' && (\n                <>\n                  <span className=\"text-foreground-muted/50\"></span>\n                  <span className=\"text-primary\">New</span>\n                </>\n              )}\n            </div>\n          </motion.button>\n        );\n      })}\n    </div>\n  );\n}",
      "references": [
        "data",
        "insights",
        "isLoading",
        "error",
        "useInsights",
        "ExpandedListSkeleton",
        "div",
        "className",
        "priorityOrder",
        "a",
        "b",
        "aPriority",
        "bPriority",
        "Date",
        "sortedInsights",
        "insightTypeMeta",
        "insight",
        "priorityStyles",
        "motion",
        "key",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "onInsightClick",
        "isUrgent",
        "span",
        "priority",
        "p",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedListSkeleton:276": {
      "id": "file:web/src/components/dashboard/ExpandedLists.tsx:fn:ExpandedListSkeleton:276",
      "type": "function",
      "name": "ExpandedListSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/ExpandedLists.tsx",
      "line": 276,
      "endLine": 298,
      "parentFileId": "file:web/src/components/dashboard/ExpandedLists.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a skeleton loader UI for an expanded list with 6 animated placeholder items.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function ExpandedListSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      {[1, 2, 3, 4, 5, 6].map((i) => (\n        <div\n          key={i}\n          className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-center gap-2 mb-2\">\n            <div className=\"w-5 h-5 rounded bg-background-tertiary flex-shrink-0\" />\n            <div className=\"h-3 w-16 bg-background-tertiary rounded\" />\n            <div className=\"h-3 w-12 bg-background-tertiary rounded ml-auto\" />\n          </div>\n          <div className=\"space-y-1.5\">\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-3/4\" />\n          </div>\n          <div className=\"h-2 bg-background-tertiary rounded w-1/3 mt-2\" />\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/index.ts": {
      "id": "file:web/src/components/dashboard/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/dashboard/index.ts",
      "line": 1,
      "endLine": 14,
      "imports": [],
      "exports": [
        {
          "name": "DashboardPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "StatsCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PanelAccent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "LivingSummaryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "TodayPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BeliefsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PatternsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EntitiesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "InsightsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BottomSheet",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExpandedBeliefsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExpandedPatternsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ExpandedInsightsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DashboardPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DashboardPanel"
        },
        {
          "name": "StatsCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DashboardPanel"
        },
        {
          "name": "PanelAccent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./DashboardPanel"
        },
        {
          "name": "LivingSummaryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./LivingSummaryPanel"
        },
        {
          "name": "TodayPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TodayPanel"
        },
        {
          "name": "BeliefsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./BeliefsPanel"
        },
        {
          "name": "PatternsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./PatternsPanel"
        },
        {
          "name": "EntitiesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./EntitiesPanel"
        },
        {
          "name": "InsightsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./InsightsPanel"
        },
        {
          "name": "DetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DetailModal"
        },
        {
          "name": "BottomSheet",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./BottomSheet"
        },
        {
          "name": "ExpandedBeliefsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ExpandedLists"
        },
        {
          "name": "ExpandedPatternsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ExpandedLists"
        },
        {
          "name": "ExpandedInsightsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ExpandedLists"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/InsightsPanel.tsx": {
      "id": "file:web/src/components/dashboard/InsightsPanel.tsx",
      "type": "file",
      "name": "InsightsPanel.tsx",
      "filePath": "web/src/components/dashboard/InsightsPanel.tsx",
      "line": 1,
      "endLine": 202,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useInsights",
          "items": [
            {
              "name": "useNewInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "InsightsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "InsightsPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsPanel:60",
        "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightItem:119",
        "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsLoadingSkeleton:177"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsPanel:60": {
      "id": "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsPanel:60",
      "type": "function",
      "name": "InsightsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/InsightsPanel.tsx",
      "line": 60,
      "endLine": 111,
      "parentFileId": "file:web/src/components/dashboard/InsightsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onInsightClick, limit = 6 }",
          "type": "InsightsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted insights list with loading, error, and empty states; handles insight clicks",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function InsightsPanel({ onInsightClick, limit = 6 }: InsightsPanelProps) {\n  const { data: insights, isLoading, error } = useNewInsights(limit);\n\n  if (isLoading) {\n    return <InsightsLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load insights\n      </div>\n    );\n  }\n\n  if (!insights || insights.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-warning/10 border border-warning/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No new insights. AI-generated realizations will appear as patterns emerge.\n        </p>\n      </div>\n    );\n  }\n\n  // Sort by priority (critical first) then recency\n  const priorityOrder = ['critical', 'high', 'medium', 'low'];\n  const sortedInsights = [...insights].sort((a, b) => {\n    const aPriority = priorityOrder.indexOf(a.priority);\n    const bPriority = priorityOrder.indexOf(b.priority);\n    if (aPriority !== bPriority) {\n      return aPriority - bPriority;\n    }\n    return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n  });\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedInsights.map((insight, index) => (\n        <InsightItem\n          key={insight.id}\n          insight={insight}\n          index={index}\n          onClick={() => onInsightClick?.(insight)}\n        />\n      ))}\n    </div>\n  );\n}",
      "references": [
        "data",
        "insights",
        "isLoading",
        "error",
        "useNewInsights",
        "limit",
        "InsightsLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "priorityOrder",
        "a",
        "b",
        "aPriority",
        "bPriority",
        "Date",
        "sortedInsights",
        "InsightItem",
        "key",
        "insight",
        "index",
        "onClick",
        "onInsightClick"
      ]
    },
    "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightItem:119": {
      "id": "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightItem:119",
      "type": "function",
      "name": "InsightItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/InsightsPanel.tsx",
      "line": 119,
      "endLine": 175,
      "parentFileId": "file:web/src/components/dashboard/InsightsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ insight, index, onClick }",
          "type": "InsightItemProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated clickable insight item UI with type, priority, content, and metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function InsightItem({ insight, index, onClick }: InsightItemProps) {\n  const type = typeMeta[insight.type] || typeMeta.realization;\n  const priority = priorityStyles[insight.priority] || priorityStyles.medium;\n\n  const isUrgent = insight.priority === 'critical' || insight.priority === 'high';\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, x: -10 }}\n      animate={{ opacity: 1, x: 0 }}\n      transition={{ duration: 0.2, delay: index * 0.05 }}\n      onClick={onClick}\n      className={`\n        w-full text-left p-3 rounded-lg\n        bg-background-tertiary/50 border\n        ${isUrgent ? 'border-warning/50' : 'border-glass-border'}\n        hover:bg-background-tertiary hover:border-warning/30\n        transition-all duration-200\n        group\n      `}\n    >\n      {/* Header Row */}\n      <div className=\"flex items-center gap-2 mb-1.5\">\n        <span className={`\n          w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs\n          ${type.bgColor}\n        `}>\n          {type.icon}\n        </span>\n        <span className={`text-xs font-medium ${type.color}`}>\n          {type.label}\n        </span>\n        <span className={`text-xs ml-auto ${priority.color}`}>\n          {priority.label}\n        </span>\n      </div>\n\n      {/* Content */}\n      <p className=\"text-sm text-foreground leading-snug line-clamp-2 mb-1.5\">\n        {insight.content}\n      </p>\n\n      {/* Meta Row */}\n      <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n        <span>{insight.source_memories?.length || 0} sources</span>\n        <span className=\"text-foreground-muted/50\"></span>\n        <span>{formatRelativeTime(insight.created_at)}</span>\n        {insight.status === 'new' && (\n          <>\n            <span className=\"text-foreground-muted/50\"></span>\n            <span className=\"text-primary\">New</span>\n          </>\n        )}\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "typeMeta",
        "insight",
        "priorityStyles",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "isUrgent",
        "div",
        "span",
        "priority",
        "p",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsLoadingSkeleton:177": {
      "id": "file:web/src/components/dashboard/InsightsPanel.tsx:fn:InsightsLoadingSkeleton:177",
      "type": "function",
      "name": "InsightsLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/InsightsPanel.tsx",
      "line": 177,
      "endLine": 199,
      "parentFileId": "file:web/src/components/dashboard/InsightsPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading skeleton UI for insights panel with four animated placeholders.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function InsightsLoadingSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      {[1, 2, 3, 4].map((i) => (\n        <div\n          key={i}\n          className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-center gap-2 mb-2\">\n            <div className=\"w-5 h-5 rounded bg-background-tertiary flex-shrink-0\" />\n            <div className=\"h-3 w-16 bg-background-tertiary rounded\" />\n            <div className=\"h-3 w-12 bg-background-tertiary rounded ml-auto\" />\n          </div>\n          <div className=\"space-y-1.5\">\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-3/4\" />\n          </div>\n          <div className=\"h-2 bg-background-tertiary rounded w-1/3 mt-2\" />\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/LivingSummaryPanel.tsx": {
      "id": "file:web/src/components/dashboard/LivingSummaryPanel.tsx",
      "type": "file",
      "name": "LivingSummaryPanel.tsx",
      "filePath": "web/src/components/dashboard/LivingSummaryPanel.tsx",
      "line": 1,
      "endLine": 220,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useSummaries",
          "items": [
            {
              "name": "useSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SummaryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "LivingSummaryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "LivingSummaryPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:LivingSummaryPanel:82",
        "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryCard:144",
        "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryLoadingSkeleton:197"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:LivingSummaryPanel:82": {
      "id": "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:LivingSummaryPanel:82",
      "type": "function",
      "name": "LivingSummaryPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/LivingSummaryPanel.tsx",
      "line": 82,
      "endLine": 127,
      "parentFileId": "file:web/src/components/dashboard/LivingSummaryPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onSummaryClick }",
          "type": "LivingSummaryPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted summary cards with loading, error, and empty states from fetched data.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function LivingSummaryPanel({ onSummaryClick }: LivingSummaryPanelProps) {\n  const { data: summaries, isLoading, error } = useSummaries(true);\n\n  if (isLoading) {\n    return <SummaryLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load summaries\n      </div>\n    );\n  }\n\n  if (!summaries || summaries.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-primary/10 border border-primary/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No summaries yet. Start chatting to build your profile.\n        </p>\n      </div>\n    );\n  }\n\n  // Sort summaries by category order\n  const sortedSummaries = [...summaries].sort((a, b) => {\n    return categoryOrder.indexOf(a.category) - categoryOrder.indexOf(b.category);\n  });\n\n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n      {sortedSummaries.map((summary, index) => (\n        <SummaryCard\n          key={summary.id}\n          summary={summary}\n          index={index}\n          onClick={() => onSummaryClick?.(summary)}\n        />\n      ))}\n    </div>\n  );\n}",
      "references": [
        "data",
        "summaries",
        "isLoading",
        "error",
        "useSummaries",
        "SummaryLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "categoryOrder",
        "a",
        "b",
        "sortedSummaries",
        "SummaryCard",
        "key",
        "summary",
        "index",
        "onClick",
        "onSummaryClick"
      ]
    },
    "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryCard:144": {
      "id": "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryCard:144",
      "type": "function",
      "name": "SummaryCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/LivingSummaryPanel.tsx",
      "line": 144,
      "endLine": 195,
      "parentFileId": "file:web/src/components/dashboard/LivingSummaryPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ summary, index, onClick }",
          "type": "SummaryCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated clickable summary card with category info, truncated content, memories, and last updated time.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SummaryCard({ summary, index, onClick }: SummaryCardProps) {\n  const meta = categoryMeta[summary.category] || defaultMeta;\n\n  // Truncate content for preview\n  const maxLength = 120;\n  const truncatedContent = summary.content.length > maxLength\n    ? summary.content.substring(0, maxLength) + '...'\n    : summary.content;\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, y: 10 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ duration: 0.2, delay: index * 0.05 }}\n      onClick={onClick}\n      className={`\n        w-full text-left p-4 rounded-lg\n        bg-background-tertiary/50 border ${meta.borderColor}\n        hover:bg-background-tertiary hover:border-opacity-50\n        transition-all duration-200\n        group\n      `}\n    >\n      {/* Header */}\n      <div className=\"flex items-center gap-2 mb-2\">\n        <span className={`\n          w-7 h-7 rounded-md flex items-center justify-center text-sm\n          ${meta.bgColor}\n        `}>\n          {meta.icon}\n        </span>\n        <span className={`font-medium text-sm ${meta.color}`}>\n          {meta.label}\n        </span>\n        <span className=\"text-xs text-foreground-muted ml-auto\">\n          v{summary.version}\n        </span>\n      </div>\n\n      {/* Content Preview */}\n      <p className=\"text-sm text-foreground leading-relaxed line-clamp-2 mb-2\">\n        {truncatedContent}\n      </p>\n\n      {/* Footer */}\n      <div className=\"flex items-center justify-between text-xs text-foreground-muted\">\n        <span>{summary.memory_count} memories</span>\n        <span>{formatRelativeTime(summary.last_updated)}</span>\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "categoryMeta",
        "summary",
        "defaultMeta",
        "maxLength",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "meta",
        "div",
        "span",
        "p",
        "truncatedContent",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryLoadingSkeleton:197": {
      "id": "file:web/src/components/dashboard/LivingSummaryPanel.tsx:fn:SummaryLoadingSkeleton:197",
      "type": "function",
      "name": "SummaryLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/LivingSummaryPanel.tsx",
      "line": 197,
      "endLine": 217,
      "parentFileId": "file:web/src/components/dashboard/LivingSummaryPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a grid of 4 animated loading skeleton cards for a summary panel.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SummaryLoadingSkeleton() {\n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n      {[1, 2, 3, 4].map((i) => (\n        <div\n          key={i}\n          className=\"p-4 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-center gap-2 mb-3\">\n            <div className=\"w-7 h-7 rounded-md bg-background-tertiary\" />\n            <div className=\"h-4 w-20 bg-background-tertiary rounded\" />\n          </div>\n          <div className=\"space-y-2\">\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-3/4\" />\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/PatternsPanel.tsx": {
      "id": "file:web/src/components/dashboard/PatternsPanel.tsx",
      "type": "file",
      "name": "PatternsPanel.tsx",
      "filePath": "web/src/components/dashboard/PatternsPanel.tsx",
      "line": 1,
      "endLine": 186,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/usePatterns",
          "items": [
            {
              "name": "usePatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatConfidence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "PatternsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PatternsPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsPanel:52",
        "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternItem:108",
        "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsLoadingSkeleton:161"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsPanel:52": {
      "id": "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsPanel:52",
      "type": "function",
      "name": "PatternsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/PatternsPanel.tsx",
      "line": 52,
      "endLine": 100,
      "parentFileId": "file:web/src/components/dashboard/PatternsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onPatternClick, limit = 6 }",
          "type": "PatternsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sorted patterns list with loading, error, and empty states using usePatterns hook",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function PatternsPanel({ onPatternClick, limit = 6 }: PatternsPanelProps) {\n  const { data: patterns, isLoading, error } = usePatterns({ limit });\n\n  if (isLoading) {\n    return <PatternsLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load patterns\n      </div>\n    );\n  }\n\n  if (!patterns || patterns.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-accent-purple/10 border border-accent-purple/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No patterns detected yet. Patterns emerge over time as you share more.\n        </p>\n      </div>\n    );\n  }\n\n  // Sort by frequency (highest first), then confidence\n  const sortedPatterns = [...patterns].sort((a, b) => {\n    if (b.frequency !== a.frequency) {\n      return b.frequency - a.frequency;\n    }\n    return b.confidence - a.confidence;\n  });\n\n  return (\n    <div className=\"space-y-2\">\n      {sortedPatterns.map((pattern, index) => (\n        <PatternItem\n          key={pattern.id}\n          pattern={pattern}\n          index={index}\n          onClick={() => onPatternClick?.(pattern)}\n        />\n      ))}\n    </div>\n  );\n}",
      "references": [
        "data",
        "patterns",
        "isLoading",
        "error",
        "usePatterns",
        "limit",
        "PatternsLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "b",
        "a",
        "sortedPatterns",
        "PatternItem",
        "key",
        "pattern",
        "index",
        "onClick",
        "onPatternClick"
      ]
    },
    "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternItem:108": {
      "id": "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternItem:108",
      "type": "function",
      "name": "PatternItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/PatternsPanel.tsx",
      "line": 108,
      "endLine": 159,
      "parentFileId": "file:web/src/components/dashboard/PatternsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ pattern, index, onClick }",
          "type": "PatternItemProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated button displaying pattern details, type, confidence, frequency, and last detected time.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function PatternItem({ pattern, index, onClick }: PatternItemProps) {\n  const type = typeMeta[pattern.type] || typeMeta.behavioral;\n\n  // Format frequency display\n  const frequencyLabel = pattern.frequency === 1\n    ? 'Once'\n    : `${pattern.frequency} observed`;\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, x: -10 }}\n      animate={{ opacity: 1, x: 0 }}\n      transition={{ duration: 0.2, delay: index * 0.05 }}\n      onClick={onClick}\n      className={`\n        w-full text-left p-3 rounded-lg\n        bg-background-tertiary/50 border border-glass-border\n        hover:bg-background-tertiary hover:border-accent-purple/30\n        transition-all duration-200\n        group\n      `}\n    >\n      {/* Header Row */}\n      <div className=\"flex items-center gap-2 mb-1.5\">\n        <span className={`\n          w-5 h-5 rounded flex-shrink-0 flex items-center justify-center text-xs\n          ${type.bgColor}\n        `}>\n          {type.icon}\n        </span>\n        <span className={`text-xs font-medium ${type.color}`}>\n          {type.label}\n        </span>\n        <span className=\"text-xs text-foreground-muted ml-auto\">\n          {formatConfidence(pattern.confidence)}\n        </span>\n      </div>\n\n      {/* Description */}\n      <p className=\"text-sm text-foreground leading-snug line-clamp-2 mb-1.5\">\n        {pattern.description}\n      </p>\n\n      {/* Meta Row */}\n      <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n        <span>{frequencyLabel}</span>\n        <span className=\"text-foreground-muted/50\"></span>\n        <span>{formatRelativeTime(pattern.last_detected)}</span>\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "typeMeta",
        "pattern",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "div",
        "span",
        "formatConfidence",
        "p",
        "frequencyLabel",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsLoadingSkeleton:161": {
      "id": "file:web/src/components/dashboard/PatternsPanel.tsx:fn:PatternsLoadingSkeleton:161",
      "type": "function",
      "name": "PatternsLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/PatternsPanel.tsx",
      "line": 161,
      "endLine": 183,
      "parentFileId": "file:web/src/components/dashboard/PatternsPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading skeleton UI for a list of 4 patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.596Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function PatternsLoadingSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      {[1, 2, 3, 4].map((i) => (\n        <div\n          key={i}\n          className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-center gap-2 mb-2\">\n            <div className=\"w-5 h-5 rounded bg-background-tertiary flex-shrink-0\" />\n            <div className=\"h-3 w-16 bg-background-tertiary rounded\" />\n            <div className=\"h-3 w-12 bg-background-tertiary rounded ml-auto\" />\n          </div>\n          <div className=\"space-y-1.5\">\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-3/4\" />\n          </div>\n          <div className=\"h-2 bg-background-tertiary rounded w-1/3 mt-2\" />\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/dashboard/TodayPanel.tsx": {
      "id": "file:web/src/components/dashboard/TodayPanel.tsx",
      "type": "file",
      "name": "TodayPanel.tsx",
      "filePath": "web/src/components/dashboard/TodayPanel.tsx",
      "line": 1,
      "endLine": 179,
      "imports": [
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useMemories",
          "items": [
            {
              "name": "useRecentHighSalienceMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemorySource",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatSalience",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "TodayPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "TodayPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayPanel:46",
        "file:web/src/components/dashboard/TodayPanel.tsx:fn:MemoryItem:94",
        "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayLoadingSkeleton:156"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayPanel:46": {
      "id": "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayPanel:46",
      "type": "function",
      "name": "TodayPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/TodayPanel.tsx",
      "line": 46,
      "endLine": 86,
      "parentFileId": "file:web/src/components/dashboard/TodayPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onMemoryClick, limit = 6 }",
          "type": "TodayPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders recent high-salience memories panel with loading, error, or empty states.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function TodayPanel({ onMemoryClick, limit = 6 }: TodayPanelProps) {\n  const { data: memories, isLoading, error } = useRecentHighSalienceMemories(limit);\n\n  if (isLoading) {\n    return <TodayLoadingSkeleton />;\n  }\n\n  if (error) {\n    return (\n      <div className=\"flex items-center justify-center h-full text-error text-sm\">\n        Failed to load memories\n      </div>\n    );\n  }\n\n  if (!memories || memories.length === 0) {\n    return (\n      <div className=\"flex flex-col items-center justify-center h-full text-center py-8\">\n        <div className=\"w-12 h-12 rounded-full bg-accent-gold/10 border border-accent-gold/30 flex items-center justify-center mb-3\">\n          <span className=\"text-xl\"></span>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          No memories yet. Start a conversation to create memories.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-2\">\n      {memories.map((memory, index) => (\n        <MemoryItem\n          key={memory.id}\n          memory={memory}\n          index={index}\n          onClick={() => onMemoryClick?.(memory)}\n        />\n      ))}\n    </div>\n  );\n}",
      "references": [
        "data",
        "memories",
        "isLoading",
        "error",
        "useRecentHighSalienceMemories",
        "limit",
        "TodayLoadingSkeleton",
        "div",
        "className",
        "span",
        "p",
        "MemoryItem",
        "key",
        "memory",
        "index",
        "onClick",
        "onMemoryClick"
      ]
    },
    "file:web/src/components/dashboard/TodayPanel.tsx:fn:MemoryItem:94": {
      "id": "file:web/src/components/dashboard/TodayPanel.tsx:fn:MemoryItem:94",
      "type": "function",
      "name": "MemoryItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/TodayPanel.tsx",
      "line": 94,
      "endLine": 154,
      "parentFileId": "file:web/src/components/dashboard/TodayPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ memory, index, onClick }",
          "type": "MemoryItemProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a clickable preview card for a memory item with source icon, truncated content, and salience indicator.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function MemoryItem({ memory, index, onClick }: MemoryItemProps) {\n  const source = sourceMeta[memory.source] || sourceMeta.system;\n\n  // Truncate content for preview\n  const maxLength = 80;\n  const truncatedContent = memory.content.length > maxLength\n    ? memory.content.substring(0, maxLength) + '...'\n    : memory.content;\n\n  // Salience as visual indicator\n  const salienceLevel = Math.round(memory.salience * 10);\n  const isHighSalience = salienceLevel >= 7;\n\n  return (\n    <motion.button\n      initial={{ opacity: 0, x: -10 }}\n      animate={{ opacity: 1, x: 0 }}\n      transition={{ duration: 0.2, delay: index * 0.05 }}\n      onClick={onClick}\n      className={`\n        w-full text-left p-3 rounded-lg\n        bg-background-tertiary/50 border border-glass-border\n        hover:bg-background-tertiary hover:border-accent-gold/30\n        transition-all duration-200\n        group\n      `}\n    >\n      {/* Content Row */}\n      <div className=\"flex items-start gap-2\">\n        {/* Source Icon */}\n        <span className={`\n          w-6 h-6 rounded-md flex-shrink-0 flex items-center justify-center text-xs\n          ${source.bgColor}\n        `}>\n          {source.icon}\n        </span>\n\n        {/* Content */}\n        <div className=\"flex-1 min-w-0\">\n          <p className=\"text-sm text-foreground leading-snug line-clamp-2\">\n            {truncatedContent}\n          </p>\n\n          {/* Meta Row */}\n          <div className=\"flex items-center gap-2 mt-1.5 text-xs text-foreground-muted\">\n            <span>{formatRelativeTime(memory.created_at)}</span>\n            <span className=\"text-foreground-muted/50\"></span>\n            <span className={isHighSalience ? 'text-accent-gold' : ''}>\n              {formatSalience(memory.salience)}\n            </span>\n          </div>\n        </div>\n\n        {/* High Salience Indicator */}\n        {isHighSalience && (\n          <span className=\"w-2 h-2 rounded-full bg-accent-gold flex-shrink-0 mt-1.5\" />\n        )}\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "sourceMeta",
        "memory",
        "maxLength",
        "Math",
        "salienceLevel",
        "motion",
        "initial",
        "animate",
        "transition",
        "index",
        "onClick",
        "className",
        "div",
        "span",
        "source",
        "p",
        "truncatedContent",
        "formatRelativeTime",
        "isHighSalience",
        "formatSalience"
      ]
    },
    "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayLoadingSkeleton:156": {
      "id": "file:web/src/components/dashboard/TodayPanel.tsx:fn:TodayLoadingSkeleton:156",
      "type": "function",
      "name": "TodayLoadingSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/dashboard/TodayPanel.tsx",
      "line": 156,
      "endLine": 176,
      "parentFileId": "file:web/src/components/dashboard/TodayPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading skeleton UI with four animated placeholder cards.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function TodayLoadingSkeleton() {\n  return (\n    <div className=\"space-y-2\">\n      {[1, 2, 3, 4].map((i) => (\n        <div\n          key={i}\n          className=\"p-3 rounded-lg bg-background-tertiary/50 border border-glass-border animate-pulse\"\n        >\n          <div className=\"flex items-start gap-2\">\n            <div className=\"w-6 h-6 rounded-md bg-background-tertiary flex-shrink-0\" />\n            <div className=\"flex-1 space-y-2\">\n              <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n              <div className=\"h-3 bg-background-tertiary rounded w-2/3\" />\n              <div className=\"h-2 bg-background-tertiary rounded w-1/3 mt-1\" />\n            </div>\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i"
      ]
    },
    "file:web/src/components/documents/DocumentCard.tsx": {
      "id": "file:web/src/components/documents/DocumentCard.tsx",
      "type": "file",
      "name": "DocumentCard.tsx",
      "filePath": "web/src/components/documents/DocumentCard.tsx",
      "line": 1,
      "endLine": 191,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "StoredDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "getFileTypeLabel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatFileSize",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentCard",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/DocumentCard.tsx:fn:getTypeIcon:53",
        "file:web/src/components/documents/DocumentCard.tsx:fn:DocumentCard:64"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "text",
        "x",
        "y",
        "fontSize",
        "fontWeight"
      ]
    },
    "file:web/src/components/documents/DocumentCard.tsx:fn:getTypeIcon:53": {
      "id": "file:web/src/components/documents/DocumentCard.tsx:fn:getTypeIcon:53",
      "type": "function",
      "name": "getTypeIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentCard.tsx",
      "line": 53,
      "endLine": 62,
      "parentFileId": "file:web/src/components/documents/DocumentCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.ReactNode",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a ReactNode icon based on MIME type (image SVG or from typeIcons).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getTypeIcon(mimeType: string): ReactNode {\n  if (mimeType.startsWith('image/')) {\n    return (\n      <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n      </svg>\n    );\n  }\n  return typeIcons[mimeType] || typeIcons.default;\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "typeIcons"
      ]
    },
    "file:web/src/components/documents/DocumentCard.tsx:fn:DocumentCard:64": {
      "id": "file:web/src/components/documents/DocumentCard.tsx:fn:DocumentCard:64",
      "type": "function",
      "name": "DocumentCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentCard.tsx",
      "line": 64,
      "endLine": 188,
      "parentFileId": "file:web/src/components/documents/DocumentCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  document,\n  onClick,\n  onDelete,\n  isSelected = false,\n}",
          "type": "DocumentCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a clickable animated document card UI with icon, title, metadata, and status.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function DocumentCard({\n  document,\n  onClick,\n  onDelete,\n  isSelected = false,\n}: DocumentCardProps) {\n  const createdDate = new Date(document.created_at);\n  const formattedDate = createdDate.toLocaleDateString('en-US', {\n    month: 'short',\n    day: 'numeric',\n    year: 'numeric',\n  });\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 10 }}\n      animate={{ opacity: 1, y: 0 }}\n      exit={{ opacity: 0, y: -10 }}\n      whileHover={{ scale: 1.01 }}\n      onClick={onClick}\n      className={`\n        glass rounded-xl p-4 cursor-pointer transition-all\n        ${isSelected\n          ? 'ring-2 ring-primary border-primary/50'\n          : 'border border-glass-border hover:border-primary/30'\n        }\n      `}\n    >\n      <div className=\"flex items-start gap-4\">\n        {/* File Icon */}\n        <div className=\"flex-shrink-0 w-12 h-12 rounded-lg bg-background-tertiary flex items-center justify-center text-foreground-muted\">\n          {getTypeIcon(document.mime_type)}\n        </div>\n\n        {/* Content */}\n        <div className=\"flex-1 min-w-0\">\n          {/* Title */}\n          <h3 className=\"font-medium text-foreground truncate\" title={document.name}>\n            {document.name || document.filename}\n          </h3>\n\n          {/* Metadata Row */}\n          <div className=\"flex items-center gap-3 mt-1 text-sm text-foreground-muted\">\n            <span>{getFileTypeLabel(document.mime_type)}</span>\n            <span>&bull;</span>\n            <span>{formatFileSize(document.size_bytes)}</span>\n            <span>&bull;</span>\n            <span>{formattedDate}</span>\n          </div>\n\n          {/* Status & Chunk Info */}\n          <div className=\"flex items-center gap-2 mt-2\">\n            {/* Processing Status Badge */}\n            <span\n              className={`\n                inline-flex items-center px-2 py-0.5 rounded text-xs font-medium border\n                ${statusColors[document.processing_status] || statusColors.pending}\n              `}\n            >\n              {document.processing_status === 'completed' && (\n                <svg className=\"w-3 h-3 mr-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                </svg>\n              )}\n              {document.processing_status === 'processing' && (\n                <motion.div\n                  animate={{ rotate: 360 }}\n                  transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}\n                  className=\"w-3 h-3 mr-1 border border-current border-t-transparent rounded-full\"\n                />\n              )}\n              {document.processing_status === 'failed' && (\n                <svg className=\"w-3 h-3 mr-1\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              )}\n              {document.processing_status.charAt(0).toUpperCase() + document.processing_status.slice(1)}\n            </span>\n\n            {/* Chunk count if available */}\n            {document.chunk_count !== undefined && document.chunk_count > 0 && (\n              <span className=\"text-xs text-foreground-muted\">\n                {document.chunk_count} chunks\n              </span>\n            )}\n\n            {/* Embeddings indicator */}\n            {document.has_embeddings && (\n              <span className=\"text-xs text-primary\" title=\"Has embeddings\">\n                <svg className=\"w-3.5 h-3.5 inline\" fill=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path d=\"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z\"/>\n                </svg>\n              </span>\n            )}\n          </div>\n\n          {/* Description Preview */}\n          {document.description && (\n            <p className=\"mt-2 text-sm text-foreground-muted line-clamp-2\">\n              {document.description}\n            </p>\n          )}\n        </div>\n\n        {/* Actions */}\n        <div className=\"flex-shrink-0\">\n          {onDelete && (\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                onDelete();\n              }}\n              className=\"p-2 rounded-lg text-foreground-muted hover:text-red-400 hover:bg-red-500/10 transition-colors\"\n              title=\"Delete document\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n              </svg>\n            </button>\n          )}\n        </div>\n      </div>\n    </motion.div>\n  );\n}",
      "references": [
        "Date",
        "document",
        "createdDate",
        "motion",
        "initial",
        "animate",
        "exit",
        "whileHover",
        "onClick",
        "className",
        "isSelected",
        "div",
        "getTypeIcon",
        "h3",
        "title",
        "span",
        "getFileTypeLabel",
        "formatFileSize",
        "formattedDate",
        "statusColors",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "transition",
        "p",
        "onDelete",
        "button",
        "e"
      ]
    },
    "file:web/src/components/documents/DocumentDetail.tsx": {
      "id": "file:web/src/components/documents/DocumentDetail.tsx",
      "type": "file",
      "name": "DocumentDetail.tsx",
      "filePath": "web/src/components/documents/DocumentDetail.tsx",
      "line": 1,
      "endLine": 374,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "StoredDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "getDocumentChunks",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFileTypeLabel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatFileSize",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentDetail",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/DocumentDetail.tsx:fn:DocumentDetail:26"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/DocumentDetail.tsx:fn:DocumentDetail:26": {
      "id": "file:web/src/components/documents/DocumentDetail.tsx:fn:DocumentDetail:26",
      "type": "function",
      "name": "DocumentDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentDetail.tsx",
      "line": 26,
      "endLine": 371,
      "parentFileId": "file:web/src/components/documents/DocumentDetail.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  document,\n  isOpen,\n  onClose,\n  onReprocess,\n  onDelete,\n  onReviewFacts,\n}",
          "type": "DocumentDetailProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React modal component for document details, loads/paginates chunks, handles keyboard close.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function DocumentDetail({\n  document,\n  isOpen,\n  onClose,\n  onReprocess,\n  onDelete,\n  onReviewFacts,\n}: DocumentDetailProps) {\n  const [chunks, setChunks] = useState<DocumentChunk[]>([]);\n  const [isLoadingChunks, setIsLoadingChunks] = useState(false);\n  const [activeTab, setActiveTab] = useState<'overview' | 'chunks' | 'text'>('overview');\n  const [currentChunkPage, setCurrentChunkPage] = useState(0);\n  const chunksPerPage = 5;\n\n  // Load chunks when document changes\n  useEffect(() => {\n    if (document && isOpen) {\n      loadChunks();\n    }\n  }, [document?.id, isOpen]);\n\n  const loadChunks = async () => {\n    if (!document) return;\n\n    setIsLoadingChunks(true);\n    try {\n      const { chunks: loadedChunks } = await getDocumentChunks(document.id);\n      setChunks(loadedChunks);\n    } catch (err) {\n      console.error('Failed to load chunks:', err);\n      setChunks([]);\n    } finally {\n      setIsLoadingChunks(false);\n    }\n  };\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose();\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      window.document.addEventListener('keydown', handleKeyDown);\n      window.document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      window.document.removeEventListener('keydown', handleKeyDown);\n      window.document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!document) return null;\n\n  const createdDate = new Date(document.created_at);\n  const processedDate = document.processed_at ? new Date(document.processed_at) : null;\n  const status = statusLabels[document.processing_status] || statusLabels.pending;\n\n  // Paginated chunks\n  const totalChunkPages = Math.ceil(chunks.length / chunksPerPage);\n  const displayedChunks = chunks.slice(\n    currentChunkPage * chunksPerPage,\n    (currentChunkPage + 1) * chunksPerPage\n  );\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Panel */}\n          <motion.div\n            initial={{ opacity: 0, x: 300 }}\n            animate={{ opacity: 1, x: 0 }}\n            exit={{ opacity: 0, x: 300 }}\n            transition={{ duration: 0.2, ease: 'easeOut' }}\n            className=\"fixed top-0 right-0 bottom-0 w-full md:w-[500px] lg:w-[600px] z-50 glass border-l border-glass-border flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <div className=\"flex-1 min-w-0 mr-4\">\n                <h2 className=\"text-lg font-semibold text-foreground truncate\">\n                  {document.name || document.filename}\n                </h2>\n                <p className=\"text-sm text-foreground-muted mt-0.5\">\n                  {getFileTypeLabel(document.mime_type)} &bull; {formatFileSize(document.size_bytes)}\n                </p>\n              </div>\n              <button\n                onClick={onClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Tabs */}\n            <div className=\"flex border-b border-glass-border\">\n              {(['overview', 'chunks', 'text'] as const).map((tab) => (\n                <button\n                  key={tab}\n                  onClick={() => setActiveTab(tab)}\n                  className={`\n                    flex-1 px-4 py-3 text-sm font-medium transition-colors\n                    ${activeTab === tab\n                      ? 'text-primary border-b-2 border-primary'\n                      : 'text-foreground-muted hover:text-foreground'\n                    }\n                  `}\n                >\n                  {tab.charAt(0).toUpperCase() + tab.slice(1)}\n                </button>\n              ))}\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6\">\n              {/* Overview Tab */}\n              {activeTab === 'overview' && (\n                <div className=\"space-y-6\">\n                  {/* Status Card */}\n                  <div className=\"p-4 rounded-lg bg-background-tertiary\">\n                    <h3 className=\"text-sm font-medium text-foreground-muted mb-3\">Processing Status</h3>\n                    <div className=\"flex items-center gap-3\">\n                      <span className={`text-lg font-semibold ${status.color}`}>\n                        {status.label}\n                      </span>\n                      {document.processing_status === 'completed' && (\n                        <svg className=\"w-5 h-5 text-green-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                        </svg>\n                      )}\n                    </div>\n                    {document.processing_error && (\n                      <p className=\"mt-2 text-sm text-red-400\">{document.processing_error}</p>\n                    )}\n                  </div>\n\n                  {/* Metadata */}\n                  <div className=\"space-y-3\">\n                    <h3 className=\"text-sm font-medium text-foreground-muted\">Details</h3>\n                    <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                      <div>\n                        <p className=\"text-foreground-muted\">File Type</p>\n                        <p className=\"text-foreground\">{getFileTypeLabel(document.mime_type)}</p>\n                      </div>\n                      <div>\n                        <p className=\"text-foreground-muted\">Size</p>\n                        <p className=\"text-foreground\">{formatFileSize(document.size_bytes)}</p>\n                      </div>\n                      <div>\n                        <p className=\"text-foreground-muted\">Uploaded</p>\n                        <p className=\"text-foreground\">\n                          {createdDate.toLocaleDateString('en-US', {\n                            month: 'short',\n                            day: 'numeric',\n                            year: 'numeric',\n                            hour: '2-digit',\n                            minute: '2-digit',\n                          })}\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-foreground-muted\">Processed</p>\n                        <p className=\"text-foreground\">\n                          {processedDate\n                            ? processedDate.toLocaleDateString('en-US', {\n                                month: 'short',\n                                day: 'numeric',\n                                year: 'numeric',\n                                hour: '2-digit',\n                                minute: '2-digit',\n                              })\n                            : 'Not yet'\n                          }\n                        </p>\n                      </div>\n                      <div>\n                        <p className=\"text-foreground-muted\">Chunks</p>\n                        <p className=\"text-foreground\">{chunks.length}</p>\n                      </div>\n                      <div>\n                        <p className=\"text-foreground-muted\">Source</p>\n                        <p className=\"text-foreground capitalize\">{document.source}</p>\n                      </div>\n                    </div>\n                  </div>\n\n                  {/* Description */}\n                  {document.description && (\n                    <div className=\"space-y-2\">\n                      <h3 className=\"text-sm font-medium text-foreground-muted\">Description</h3>\n                      <p className=\"text-sm text-foreground\">{document.description}</p>\n                    </div>\n                  )}\n                </div>\n              )}\n\n              {/* Chunks Tab */}\n              {activeTab === 'chunks' && (\n                <div className=\"space-y-4\">\n                  {isLoadingChunks ? (\n                    <div className=\"space-y-3\">\n                      {[...Array(3)].map((_, i) => (\n                        <div key={i} className=\"p-4 rounded-lg bg-background-tertiary animate-pulse\">\n                          <div className=\"h-4 bg-background rounded w-1/4 mb-2\" />\n                          <div className=\"h-3 bg-background rounded w-full mb-1\" />\n                          <div className=\"h-3 bg-background rounded w-3/4\" />\n                        </div>\n                      ))}\n                    </div>\n                  ) : chunks.length === 0 ? (\n                    <div className=\"text-center py-8\">\n                      <p className=\"text-foreground-muted\">No chunks available</p>\n                      <p className=\"text-sm text-foreground-muted mt-1\">\n                        Document may not be processed yet\n                      </p>\n                    </div>\n                  ) : (\n                    <>\n                      {displayedChunks.map((chunk, index) => (\n                        <motion.div\n                          key={chunk.id}\n                          initial={{ opacity: 0, y: 10 }}\n                          animate={{ opacity: 1, y: 0 }}\n                          transition={{ delay: index * 0.05 }}\n                          className=\"p-4 rounded-lg bg-background-tertiary\"\n                        >\n                          <div className=\"flex items-center justify-between mb-2\">\n                            <span className=\"text-xs font-medium text-primary\">\n                              Chunk {chunk.chunkIndex + 1}\n                            </span>\n                            <span className=\"text-xs text-foreground-muted\">\n                              {chunk.tokenCount} tokens\n                            </span>\n                          </div>\n                          <p className=\"text-sm text-foreground line-clamp-4\">\n                            {chunk.content}\n                          </p>\n                          {chunk.pageNumber && (\n                            <p className=\"mt-2 text-xs text-foreground-muted\">\n                              Page {chunk.pageNumber}\n                            </p>\n                          )}\n                        </motion.div>\n                      ))}\n\n                      {/* Pagination */}\n                      {totalChunkPages > 1 && (\n                        <div className=\"flex items-center justify-between pt-4\">\n                          <button\n                            onClick={() => setCurrentChunkPage((p) => Math.max(0, p - 1))}\n                            disabled={currentChunkPage === 0}\n                            className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground disabled:opacity-50 disabled:cursor-not-allowed\"\n                          >\n                            Previous\n                          </button>\n                          <span className=\"text-sm text-foreground-muted\">\n                            Page {currentChunkPage + 1} of {totalChunkPages}\n                          </span>\n                          <button\n                            onClick={() => setCurrentChunkPage((p) => Math.min(totalChunkPages - 1, p + 1))}\n                            disabled={currentChunkPage >= totalChunkPages - 1}\n                            className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground disabled:opacity-50 disabled:cursor-not-allowed\"\n                          >\n                            Next\n                          </button>\n                        </div>\n                      )}\n                    </>\n                  )}\n                </div>\n              )}\n\n              {/* Text Tab */}\n              {activeTab === 'text' && (\n                <div className=\"space-y-4\">\n                  {document.extracted_text ? (\n                    <div className=\"p-4 rounded-lg bg-background-tertiary max-h-[60vh] overflow-auto\">\n                      <pre className=\"text-sm text-foreground whitespace-pre-wrap font-mono\">\n                        {document.extracted_text}\n                      </pre>\n                    </div>\n                  ) : (\n                    <div className=\"text-center py-8\">\n                      <p className=\"text-foreground-muted\">No extracted text available</p>\n                    </div>\n                  )}\n                </div>\n              )}\n            </div>\n\n            {/* Footer Actions */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-t border-glass-border\">\n              <div className=\"flex items-center gap-2\">\n                {onReprocess && (\n                  <button\n                    onClick={onReprocess}\n                    className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n                  >\n                    Reprocess\n                  </button>\n                )}\n                {onReviewFacts && document?.processing_status === 'completed' && (\n                  <button\n                    onClick={onReviewFacts}\n                    className=\"px-3 py-1.5 text-sm rounded-lg bg-primary/10 text-primary hover:bg-primary/20 transition-colors\"\n                  >\n                    Review Facts\n                  </button>\n                )}\n                {onDelete && (\n                  <button\n                    onClick={onDelete}\n                    className=\"px-3 py-1.5 text-sm rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-colors\"\n                  >\n                    Delete\n                  </button>\n                )}\n              </div>\n              <button\n                onClick={onClose}\n                className=\"px-4 py-2 rounded-lg text-sm bg-primary text-white hover:bg-primary/90 transition-colors\"\n              >\n                Close\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "chunks",
        "setChunks",
        "useState",
        "isLoadingChunks",
        "setIsLoadingChunks",
        "activeTab",
        "setActiveTab",
        "currentChunkPage",
        "setCurrentChunkPage",
        "useEffect",
        "document",
        "isOpen",
        "loadChunks",
        "loadedChunks",
        "getDocumentChunks",
        "console",
        "err",
        "useCallback",
        "e",
        "onClose",
        "window",
        "handleKeyDown",
        "Date",
        "statusLabels",
        "Math",
        "chunksPerPage",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "h2",
        "p",
        "getFileTypeLabel",
        "formatFileSize",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "key",
        "tab",
        "h3",
        "span",
        "status",
        "createdDate",
        "processedDate",
        "Array",
        "i",
        "displayedChunks",
        "chunk",
        "index",
        "totalChunkPages",
        "disabled",
        "pre",
        "onReprocess",
        "onReviewFacts",
        "onDelete"
      ]
    },
    "file:web/src/components/documents/DocumentList.tsx": {
      "id": "file:web/src/components/documents/DocumentList.tsx",
      "type": "file",
      "name": "DocumentList.tsx",
      "filePath": "web/src/components/documents/DocumentList.tsx",
      "line": 1,
      "endLine": 148,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "StoredDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./DocumentCard",
          "items": [
            {
              "name": "DocumentCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentList",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/DocumentList.tsx:fn:DocumentList:17"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/DocumentList.tsx:fn:DocumentList:17": {
      "id": "file:web/src/components/documents/DocumentList.tsx:fn:DocumentList:17",
      "type": "function",
      "name": "DocumentList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentList.tsx",
      "line": 17,
      "endLine": 145,
      "parentFileId": "file:web/src/components/documents/DocumentList.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  documents,\n  isLoading,\n  onSelect,\n  onDelete,\n  selectedId,\n  viewMode = 'list',\n}",
          "type": "DocumentListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering sortable document list/grid with loading/empty states",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function DocumentList({\n  documents,\n  isLoading,\n  onSelect,\n  onDelete,\n  selectedId,\n  viewMode = 'list',\n}: DocumentListProps) {\n  const [sortBy, setSortBy] = useState<'date' | 'name' | 'size'>('date');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');\n\n  // Sort documents\n  const sortedDocuments = [...documents].sort((a, b) => {\n    let comparison = 0;\n\n    switch (sortBy) {\n      case 'date':\n        comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();\n        break;\n      case 'name':\n        comparison = (a.name || a.filename).localeCompare(b.name || b.filename);\n        break;\n      case 'size':\n        comparison = a.size_bytes - b.size_bytes;\n        break;\n    }\n\n    return sortOrder === 'desc' ? -comparison : comparison;\n  });\n\n  // Loading skeleton\n  if (isLoading) {\n    return (\n      <div className={viewMode === 'grid' ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4' : 'space-y-3'}>\n        {[...Array(6)].map((_, i) => (\n          <div\n            key={i}\n            className=\"glass rounded-xl p-4 animate-pulse\"\n          >\n            <div className=\"flex items-start gap-4\">\n              <div className=\"w-12 h-12 rounded-lg bg-background-tertiary\" />\n              <div className=\"flex-1 space-y-2\">\n                <div className=\"h-4 bg-background-tertiary rounded w-3/4\" />\n                <div className=\"h-3 bg-background-tertiary rounded w-1/2\" />\n                <div className=\"h-3 bg-background-tertiary rounded w-1/4\" />\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n    );\n  }\n\n  // Empty state\n  if (documents.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"w-16 h-16 mx-auto mb-4 rounded-xl bg-background-tertiary flex items-center justify-center\">\n          <svg className=\"w-8 h-8 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n          </svg>\n        </div>\n        <h3 className=\"text-lg font-medium text-foreground mb-1\">No documents yet</h3>\n        <p className=\"text-foreground-muted\">Upload your first document to get started</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Sort Controls */}\n      <div className=\"flex items-center justify-between\">\n        <p className=\"text-sm text-foreground-muted\">\n          {documents.length} document{documents.length !== 1 ? 's' : ''}\n        </p>\n\n        <div className=\"flex items-center gap-2\">\n          <select\n            value={sortBy}\n            onChange={(e) => setSortBy(e.target.value as 'date' | 'name' | 'size')}\n            className=\"text-sm px-2 py-1 rounded-lg bg-background-tertiary border border-glass-border text-foreground focus:outline-none focus:border-primary/50\"\n          >\n            <option value=\"date\">Date</option>\n            <option value=\"name\">Name</option>\n            <option value=\"size\">Size</option>\n          </select>\n\n          <button\n            onClick={() => setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')}\n            className=\"p-1.5 rounded-lg bg-background-tertiary border border-glass-border text-foreground-muted hover:text-foreground transition-colors\"\n            title={sortOrder === 'asc' ? 'Sort descending' : 'Sort ascending'}\n          >\n            {sortOrder === 'asc' ? (\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 4h13M3 8h9m-9 4h6m4 0l4-4m0 0l4 4m-4-4v12\" />\n              </svg>\n            ) : (\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M3 4h13M3 8h9m-9 4h9m5-4v12m0 0l-4-4m4 4l4-4\" />\n              </svg>\n            )}\n          </button>\n        </div>\n      </div>\n\n      {/* Document List */}\n      <motion.div\n        layout\n        className={\n          viewMode === 'grid'\n            ? 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4'\n            : 'space-y-3'\n        }\n      >\n        <AnimatePresence mode=\"popLayout\">\n          {sortedDocuments.map((doc) => (\n            <DocumentCard\n              key={doc.id}\n              document={doc}\n              onClick={() => onSelect?.(doc)}\n              onDelete={onDelete ? () => onDelete(doc) : undefined}\n              isSelected={selectedId === doc.id}\n            />\n          ))}\n        </AnimatePresence>\n      </motion.div>\n    </div>\n  );\n}",
      "references": [
        "sortBy",
        "setSortBy",
        "useState",
        "sortOrder",
        "setSortOrder",
        "documents",
        "comparison",
        "Date",
        "a",
        "b",
        "isLoading",
        "div",
        "className",
        "viewMode",
        "Array",
        "key",
        "i",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h3",
        "p",
        "select",
        "value",
        "onChange",
        "e",
        "option",
        "button",
        "onClick",
        "title",
        "motion",
        "layout",
        "AnimatePresence",
        "mode",
        "sortedDocuments",
        "DocumentCard",
        "doc",
        "document",
        "onSelect",
        "onDelete",
        "isSelected",
        "selectedId"
      ]
    },
    "file:web/src/components/documents/DocumentSearch.tsx": {
      "id": "file:web/src/components/documents/DocumentSearch.tsx",
      "type": "file",
      "name": "DocumentSearch.tsx",
      "filePath": "web/src/components/documents/DocumentSearch.tsx",
      "line": 1,
      "endLine": 267,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "DocumentSearchResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "searchDocuments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentSearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentSearch",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/DocumentSearch.tsx:fn:DocumentSearch:12"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/DocumentSearch.tsx:fn:DocumentSearch:12": {
      "id": "file:web/src/components/documents/DocumentSearch.tsx:fn:DocumentSearch:12",
      "type": "function",
      "name": "DocumentSearch",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentSearch.tsx",
      "line": 12,
      "endLine": 264,
      "parentFileId": "file:web/src/components/documents/DocumentSearch.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onResultClick }",
          "type": "DocumentSearchProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for debounced document search displaying results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function DocumentSearch({ onResultClick }: DocumentSearchProps) {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState<DocumentSearchResult[]>([]);\n  const [isSearching, setIsSearching] = useState(false);\n  const [hasSearched, setHasSearched] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const searchTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const performSearch = useCallback(async (searchQuery: string) => {\n    if (!searchQuery.trim()) {\n      setResults([]);\n      setHasSearched(false);\n      return;\n    }\n\n    setIsSearching(true);\n    setError(null);\n\n    try {\n      const { results: searchResults } = await searchDocuments(searchQuery, {\n        limit: 20,\n        threshold: 0.3,\n      });\n      setResults(searchResults);\n      setHasSearched(true);\n    } catch (err) {\n      console.error('Search failed:', err);\n      setError('Search failed. Please try again.');\n      setResults([]);\n    } finally {\n      setIsSearching(false);\n    }\n  }, []);\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setQuery(value);\n\n    // Debounce search\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n\n    searchTimeoutRef.current = setTimeout(() => {\n      performSearch(value);\n    }, 300);\n  };\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (searchTimeoutRef.current) {\n      clearTimeout(searchTimeoutRef.current);\n    }\n    performSearch(query);\n  };\n\n  const clearSearch = () => {\n    setQuery('');\n    setResults([]);\n    setHasSearched(false);\n    setError(null);\n  };\n\n  const getRelevanceColor = (similarity: number): string => {\n    if (similarity >= 0.8) return 'bg-green-500';\n    if (similarity >= 0.6) return 'bg-emerald-500';\n    if (similarity >= 0.4) return 'bg-yellow-500';\n    return 'bg-orange-500';\n  };\n\n  const getRelevanceLabel = (similarity: number): string => {\n    if (similarity >= 0.8) return 'Excellent';\n    if (similarity >= 0.6) return 'Good';\n    if (similarity >= 0.4) return 'Fair';\n    return 'Partial';\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Search Input */}\n      <form onSubmit={handleSubmit} className=\"relative\">\n        <div className=\"relative\">\n          <svg\n            className=\"absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-foreground-muted\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\"\n            />\n          </svg>\n\n          <input\n            type=\"text\"\n            value={query}\n            onChange={handleInputChange}\n            placeholder=\"Search documents...\"\n            className=\"\n              w-full pl-10 pr-10 py-3 rounded-xl\n              bg-background-tertiary border border-glass-border\n              text-foreground placeholder:text-foreground-muted\n              focus:outline-none focus:border-primary/50 focus:ring-1 focus:ring-primary/30\n              transition-all\n            \"\n          />\n\n          {query && (\n            <button\n              type=\"button\"\n              onClick={clearSearch}\n              className=\"absolute right-3 top-1/2 -translate-y-1/2 p-1 rounded hover:bg-background transition-colors\"\n            >\n              <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          )}\n        </div>\n\n        {/* Loading indicator */}\n        {isSearching && (\n          <div className=\"absolute right-12 top-1/2 -translate-y-1/2\">\n            <motion.div\n              animate={{ rotate: 360 }}\n              transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}\n              className=\"w-4 h-4 border-2 border-primary border-t-transparent rounded-full\"\n            />\n          </div>\n        )}\n      </form>\n\n      {/* Error Message */}\n      {error && (\n        <div className=\"p-3 rounded-lg bg-red-500/10 border border-red-500/20 text-red-400 text-sm\">\n          {error}\n        </div>\n      )}\n\n      {/* Results */}\n      <AnimatePresence mode=\"wait\">\n        {hasSearched && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -10 }}\n            className=\"space-y-3\"\n          >\n            {/* Results count */}\n            <p className=\"text-sm text-foreground-muted\">\n              {results.length} result{results.length !== 1 ? 's' : ''} found\n            </p>\n\n            {/* Result list */}\n            {results.length === 0 ? (\n              <div className=\"text-center py-8\">\n                <svg\n                  className=\"w-12 h-12 mx-auto text-foreground-muted mb-3\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={1.5}\n                    d=\"M9.172 16.172a4 4 0 015.656 0M9 10h.01M15 10h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n                  />\n                </svg>\n                <p className=\"text-foreground-muted\">No matching documents found</p>\n                <p className=\"text-sm text-foreground-muted mt-1\">Try different keywords</p>\n              </div>\n            ) : (\n              <div className=\"space-y-2\">\n                {results.map((result, index) => (\n                  <motion.div\n                    key={result.chunkId}\n                    initial={{ opacity: 0, x: -10 }}\n                    animate={{ opacity: 1, x: 0 }}\n                    transition={{ delay: index * 0.05 }}\n                    onClick={() => onResultClick?.(result)}\n                    className=\"p-4 rounded-lg bg-background-tertiary border border-glass-border hover:border-primary/30 cursor-pointer transition-all group\"\n                  >\n                    {/* Header */}\n                    <div className=\"flex items-start justify-between gap-3 mb-2\">\n                      <div className=\"flex-1 min-w-0\">\n                        {result.sectionTitle && (\n                          <p className=\"text-sm font-medium text-primary truncate\">\n                            {result.sectionTitle}\n                          </p>\n                        )}\n                        {result.pageNumber && (\n                          <p className=\"text-xs text-foreground-muted\">\n                            Page {result.pageNumber}\n                          </p>\n                        )}\n                      </div>\n\n                      {/* Relevance indicator */}\n                      <div className=\"flex items-center gap-2\">\n                        <div\n                          className={`w-2 h-2 rounded-full ${getRelevanceColor(result.similarity)}`}\n                          title={`${(result.similarity * 100).toFixed(0)}% match`}\n                        />\n                        <span className=\"text-xs text-foreground-muted\">\n                          {getRelevanceLabel(result.similarity)}\n                        </span>\n                      </div>\n                    </div>\n\n                    {/* Content preview */}\n                    <p className=\"text-sm text-foreground line-clamp-3 group-hover:line-clamp-none transition-all\">\n                      {result.content}\n                    </p>\n\n                    {/* Footer */}\n                    <div className=\"flex items-center gap-2 mt-2 text-xs text-foreground-muted\">\n                      <span>{(result.similarity * 100).toFixed(0)}% match</span>\n                    </div>\n                  </motion.div>\n                ))}\n              </div>\n            )}\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Hint when empty */}\n      {!hasSearched && !query && (\n        <div className=\"text-center py-8 text-foreground-muted\">\n          <svg\n            className=\"w-10 h-10 mx-auto mb-3 opacity-50\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={1.5}\n              d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\"\n            />\n          </svg>\n          <p className=\"text-sm\">Search across all your documents</p>\n          <p className=\"text-xs mt-1\">Uses AI-powered semantic search</p>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "query",
        "setQuery",
        "useState",
        "results",
        "setResults",
        "isSearching",
        "setIsSearching",
        "hasSearched",
        "setHasSearched",
        "error",
        "setError",
        "useRef",
        "useCallback",
        "searchQuery",
        "searchResults",
        "searchDocuments",
        "console",
        "err",
        "e",
        "value",
        "searchTimeoutRef",
        "clearTimeout",
        "setTimeout",
        "performSearch",
        "similarity",
        "div",
        "className",
        "form",
        "onSubmit",
        "handleSubmit",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "input",
        "onChange",
        "handleInputChange",
        "placeholder",
        "button",
        "onClick",
        "clearSearch",
        "motion",
        "animate",
        "transition",
        "AnimatePresence",
        "mode",
        "initial",
        "exit",
        "p",
        "key",
        "result",
        "index",
        "onResultClick",
        "getRelevanceColor",
        "title",
        "span",
        "getRelevanceLabel"
      ]
    },
    "file:web/src/components/documents/DocumentUpload.tsx": {
      "id": "file:web/src/components/documents/DocumentUpload.tsx",
      "type": "file",
      "name": "DocumentUpload.tsx",
      "filePath": "web/src/components/documents/DocumentUpload.tsx",
      "line": 1,
      "endLine": 415,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentProcessingStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "extractDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "chunkDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateChunkEmbeddings",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SUPPORTED_EXTENSIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getFileTypeLabel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatFileSize",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentUpload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentUpload",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/DocumentUpload.tsx:fn:DocumentUpload:43"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/DocumentUpload.tsx:fn:DocumentUpload:43": {
      "id": "file:web/src/components/documents/DocumentUpload.tsx:fn:DocumentUpload:43",
      "type": "function",
      "name": "DocumentUpload",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/DocumentUpload.tsx",
      "line": 43,
      "endLine": 412,
      "parentFileId": "file:web/src/components/documents/DocumentUpload.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  isOpen,\n  onClose,\n  onSuccess,\n  ephemeralMode = false,\n}",
          "type": "DocumentUploadProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for document upload with drag-drop, validation, and image preview.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function DocumentUpload({\n  isOpen,\n  onClose,\n  onSuccess,\n  ephemeralMode = false,\n}: DocumentUploadProps) {\n  const [selectedFile, setSelectedFile] = useState<FileWithPreview | null>(null);\n  const [isDragOver, setIsDragOver] = useState(false);\n  const [status, setStatus] = useState<DocumentProcessingStatus>('pending');\n  const [error, setError] = useState<string | null>(null);\n  const [progress, setProgress] = useState<string>('');\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const resetState = useCallback(() => {\n    setSelectedFile(null);\n    setStatus('pending');\n    setError(null);\n    setProgress('');\n  }, []);\n\n  const handleClose = useCallback(() => {\n    resetState();\n    onClose();\n  }, [onClose, resetState]);\n\n  const validateFile = (file: File): boolean => {\n    const extension = '.' + file.name.split('.').pop()?.toLowerCase();\n    if (!SUPPORTED_EXTENSIONS.includes(extension)) {\n      setError(`Unsupported file type. Supported: ${SUPPORTED_EXTENSIONS.join(', ')}`);\n      return false;\n    }\n    if (file.size > 50 * 1024 * 1024) {\n      setError('File size must be less than 50MB');\n      return false;\n    }\n    return true;\n  };\n\n  const handleFileSelect = useCallback((file: File) => {\n    setError(null);\n    if (!validateFile(file)) return;\n\n    const preview = file.type.startsWith('image/')\n      ? URL.createObjectURL(file)\n      : undefined;\n\n    setSelectedFile({ file, preview });\n  }, []);\n\n  const handleDrop = useCallback(\n    (e: React.DragEvent) => {\n      e.preventDefault();\n      setIsDragOver(false);\n\n      const file = e.dataTransfer.files[0];\n      if (file) handleFileSelect(file);\n    },\n    [handleFileSelect]\n  );\n\n  const handleDragOver = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(true);\n  }, []);\n\n  const handleDragLeave = useCallback((e: React.DragEvent) => {\n    e.preventDefault();\n    setIsDragOver(false);\n  }, []);\n\n  const handleInputChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const file = e.target.files?.[0];\n      if (file) handleFileSelect(file);\n    },\n    [handleFileSelect]\n  );\n\n  const handleUpload = async () => {\n    if (!selectedFile) return;\n\n    setError(null);\n    setStatus('extracting');\n    setProgress('Extracting text from document...');\n\n    try {\n      // Step 1: Extract text\n      const { objectId, extraction } = await extractDocument(selectedFile.file);\n\n      if (ephemeralMode) {\n        // Skip chunking/embedding for ephemeral mode\n        setStatus('completed');\n        setProgress('Extraction complete!');\n        onSuccess?.({\n          objectId,\n          filename: selectedFile.file.name,\n          extraction,\n        });\n        setTimeout(handleClose, 1500);\n        return;\n      }\n\n      // Step 2: Create chunks\n      setStatus('chunking');\n      setProgress('Creating document chunks...');\n      const { chunks } = await chunkDocument(objectId, {\n        strategy: 'hybrid',\n        maxTokens: 512,\n        overlapTokens: 50,\n      });\n\n      // Step 3: Generate embeddings\n      setStatus('embedding');\n      setProgress('Generating embeddings...');\n      const { embedded } = await generateChunkEmbeddings(objectId);\n\n      // Done!\n      setStatus('completed');\n      setProgress('Document processed successfully!');\n\n      onSuccess?.({\n        objectId,\n        filename: selectedFile.file.name,\n        extraction,\n        chunksCreated: chunks.length,\n        embeddingsGenerated: embedded,\n      });\n\n      setTimeout(handleClose, 1500);\n    } catch (err) {\n      setStatus('failed');\n      setError(err instanceof Error ? err.message : 'Upload failed');\n      setProgress('');\n    }\n  };\n\n  const getStatusIcon = () => {\n    switch (status) {\n      case 'extracting':\n      case 'chunking':\n      case 'embedding':\n        return (\n          <motion.div\n            animate={{ rotate: 360 }}\n            transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}\n            className=\"w-5 h-5 border-2 border-primary border-t-transparent rounded-full\"\n          />\n        );\n      case 'completed':\n        return (\n          <svg className=\"w-5 h-5 text-green-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n          </svg>\n        );\n      case 'failed':\n        return (\n          <svg className=\"w-5 h-5 text-red-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n          </svg>\n        );\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={handleClose}\n          />\n\n          {/* Modal */}\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 20 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed top-[calc(env(safe-area-inset-top)+1.5rem)] right-[calc(env(safe-area-inset-right)+1.5rem)] bottom-[calc(env(safe-area-inset-bottom)+1.5rem)] left-[calc(env(safe-area-inset-left)+1.5rem)] md:inset-auto md:left-1/2 md:top-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:max-w-xl md:w-full md:max-h-[85vh] z-50 glass rounded-xl overflow-hidden flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <h2 className=\"text-lg font-semibold text-foreground\">\n                {ephemeralMode ? 'Process Document' : 'Upload Document'}\n              </h2>\n              <button\n                onClick={handleClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6 space-y-4\">\n              {/* Drop Zone */}\n              <div\n                onDrop={handleDrop}\n                onDragOver={handleDragOver}\n                onDragLeave={handleDragLeave}\n                onClick={() => fileInputRef.current?.click()}\n                className={`\n                  relative border-2 border-dashed rounded-xl p-8 text-center cursor-pointer\n                  transition-all duration-200\n                  ${isDragOver\n                    ? 'border-primary bg-primary/10'\n                    : 'border-glass-border hover:border-primary/50 hover:bg-background-tertiary'\n                  }\n                  ${selectedFile ? 'bg-background-tertiary' : ''}\n                `}\n              >\n                <input\n                  ref={fileInputRef}\n                  type=\"file\"\n                  accept={SUPPORTED_EXTENSIONS.join(',')}\n                  onChange={handleInputChange}\n                  className=\"hidden\"\n                />\n\n                {selectedFile ? (\n                  <div className=\"space-y-3\">\n                    {/* File Preview */}\n                    {selectedFile.preview ? (\n                      <div className=\"w-20 h-20 mx-auto rounded-lg overflow-hidden bg-background\">\n                        <img\n                          src={selectedFile.preview}\n                          alt=\"Preview\"\n                          className=\"w-full h-full object-cover\"\n                        />\n                      </div>\n                    ) : (\n                      <div className=\"w-20 h-20 mx-auto rounded-lg bg-background flex items-center justify-center\">\n                        <svg className=\"w-10 h-10 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n                        </svg>\n                      </div>\n                    )}\n\n                    {/* File Info */}\n                    <div>\n                      <p className=\"font-medium text-foreground truncate max-w-xs mx-auto\">\n                        {selectedFile.file.name}\n                      </p>\n                      <p className=\"text-sm text-foreground-muted\">\n                        {getFileTypeLabel(selectedFile.file.type)} &bull; {formatFileSize(selectedFile.file.size)}\n                      </p>\n                    </div>\n\n                    {/* Change File Button */}\n                    <button\n                      type=\"button\"\n                      onClick={(e) => {\n                        e.stopPropagation();\n                        resetState();\n                      }}\n                      className=\"text-sm text-primary hover:text-primary/80 transition-colors\"\n                    >\n                      Choose different file\n                    </button>\n                  </div>\n                ) : (\n                  <div className=\"space-y-3\">\n                    <div className=\"w-16 h-16 mx-auto rounded-xl bg-background flex items-center justify-center\">\n                      <svg className=\"w-8 h-8 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n                      </svg>\n                    </div>\n                    <div>\n                      <p className=\"text-foreground font-medium\">\n                        Drop file here or click to browse\n                      </p>\n                      <p className=\"text-sm text-foreground-muted mt-1\">\n                        PDF, Word, Text, Markdown, CSV, or Images (max 50MB)\n                      </p>\n                    </div>\n                  </div>\n                )}\n              </div>\n\n              {/* Processing Status */}\n              {status !== 'pending' && (\n                <motion.div\n                  initial={{ opacity: 0, y: 10 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  className=\"space-y-3\"\n                >\n                  {/* Progress Steps */}\n                  {!ephemeralMode && (\n                    <div className=\"flex items-center justify-between gap-2\">\n                      {processingSteps.map((step, index) => {\n                        const stepIndex = processingSteps.findIndex((s) => s.key === status);\n                        const isActive = step.key === status;\n                        const isCompleted = index < stepIndex || status === 'completed';\n\n                        return (\n                          <div\n                            key={step.key}\n                            className={`\n                              flex-1 h-1 rounded-full transition-colors\n                              ${isCompleted ? 'bg-green-500' : isActive ? 'bg-primary' : 'bg-background-tertiary'}\n                            `}\n                          />\n                        );\n                      })}\n                    </div>\n                  )}\n\n                  {/* Status Message */}\n                  <div className=\"flex items-center gap-3 px-4 py-3 rounded-lg bg-background-tertiary\">\n                    {getStatusIcon()}\n                    <span className=\"text-sm text-foreground\">{progress}</span>\n                  </div>\n                </motion.div>\n              )}\n\n              {/* Error Message */}\n              {error && (\n                <motion.div\n                  initial={{ opacity: 0, y: 10 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  className=\"px-4 py-3 rounded-lg bg-red-500/10 border border-red-500/20 text-red-400 text-sm\"\n                >\n                  {error}\n                </motion.div>\n              )}\n\n              {/* Info Text */}\n              {!ephemeralMode && status === 'pending' && (\n                <p className=\"text-xs text-foreground-muted text-center\">\n                  Documents will be stored, chunked, and indexed for semantic search\n                </p>\n              )}\n            </div>\n\n            {/* Footer */}\n            <div className=\"flex items-center justify-end gap-3 px-6 py-4 border-t border-glass-border\">\n              <button\n                onClick={handleClose}\n                className=\"px-4 py-2 rounded-lg text-sm text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={handleUpload}\n                disabled={!selectedFile || status !== 'pending'}\n                className=\"\n                  px-4 py-2 rounded-lg text-sm\n                  bg-primary text-white\n                  hover:bg-primary/90 transition-colors\n                  disabled:opacity-50 disabled:cursor-not-allowed\n                \"\n              >\n                {ephemeralMode ? 'Process' : 'Upload & Process'}\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "selectedFile",
        "setSelectedFile",
        "useState",
        "isDragOver",
        "setIsDragOver",
        "status",
        "setStatus",
        "error",
        "setError",
        "progress",
        "setProgress",
        "useRef",
        "useCallback",
        "resetState",
        "onClose",
        "file",
        "SUPPORTED_EXTENSIONS",
        "extension",
        "validateFile",
        "URL",
        "preview",
        "e",
        "handleFileSelect",
        "objectId",
        "extraction",
        "extractDocument",
        "ephemeralMode",
        "onSuccess",
        "setTimeout",
        "handleClose",
        "chunks",
        "chunkDocument",
        "embedded",
        "generateChunkEmbeddings",
        "err",
        "Error",
        "motion",
        "animate",
        "transition",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "AnimatePresence",
        "isOpen",
        "initial",
        "exit",
        "onClick",
        "div",
        "h2",
        "button",
        "onDrop",
        "handleDrop",
        "onDragOver",
        "handleDragOver",
        "onDragLeave",
        "handleDragLeave",
        "fileInputRef",
        "input",
        "ref",
        "accept",
        "onChange",
        "handleInputChange",
        "img",
        "src",
        "alt",
        "p",
        "getFileTypeLabel",
        "formatFileSize",
        "processingSteps",
        "s",
        "step",
        "index",
        "stepIndex",
        "key",
        "isCompleted",
        "isActive",
        "getStatusIcon",
        "span",
        "handleUpload",
        "disabled"
      ]
    },
    "file:web/src/components/documents/FactReviewCard.tsx": {
      "id": "file:web/src/components/documents/FactReviewCard.tsx",
      "type": "file",
      "name": "FactReviewCard.tsx",
      "filePath": "web/src/components/documents/FactReviewCard.tsx",
      "line": 1,
      "endLine": 270,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "FactTypeLabels",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactStatusColors",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "FactReviewCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FactReviewCard",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/FactReviewCard.tsx:fn:FactReviewCard:29"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/FactReviewCard.tsx:fn:FactReviewCard:29": {
      "id": "file:web/src/components/documents/FactReviewCard.tsx:fn:FactReviewCard:29",
      "type": "function",
      "name": "FactReviewCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/FactReviewCard.tsx",
      "line": 29,
      "endLine": 267,
      "parentFileId": "file:web/src/components/documents/FactReviewCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  fact,\n  isSelected,\n  onSelect,\n  onApprove,\n  onReject,\n  onEdit,\n  disabled,\n}",
          "type": "FactReviewCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering a selectable, editable fact review card with confidence colors",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function FactReviewCard({\n  fact,\n  isSelected,\n  onSelect,\n  onApprove,\n  onReject,\n  onEdit,\n  disabled,\n}: FactReviewCardProps) {\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [isEditing, setIsEditing] = useState(false);\n  const [editedContent, setEditedContent] = useState(fact.content);\n\n  const confidenceColor =\n    fact.confidence >= 0.8\n      ? 'bg-green-500/20 text-green-400'\n      : fact.confidence >= 0.6\n        ? 'bg-yellow-500/20 text-yellow-400'\n        : 'bg-red-500/20 text-red-400';\n\n  const handleSaveEdit = () => {\n    if (onEdit && editedContent !== fact.content) {\n      onEdit(editedContent);\n    }\n    setIsEditing(false);\n  };\n\n  const handleCancelEdit = () => {\n    setEditedContent(fact.content);\n    setIsEditing(false);\n  };\n\n  return (\n    <motion.div\n      layout\n      initial={{ opacity: 0, y: 10 }}\n      animate={{ opacity: 1, y: 0 }}\n      exit={{ opacity: 0, y: -10 }}\n      className={`\n        relative p-4 rounded-lg border transition-all\n        ${isSelected\n          ? 'border-primary bg-primary/5'\n          : 'border-glass-border bg-background-tertiary hover:border-primary/50'\n        }\n        ${disabled ? 'opacity-50 pointer-events-none' : ''}\n      `}\n    >\n      {/* Selection checkbox */}\n      {onSelect && (\n        <div className=\"absolute top-4 left-4\">\n          <input\n            type=\"checkbox\"\n            checked={isSelected}\n            onChange={(e) => onSelect(e.target.checked)}\n            className=\"w-4 h-4 rounded border-glass-border bg-background text-primary focus:ring-primary focus:ring-offset-0\"\n          />\n        </div>\n      )}\n\n      <div className={onSelect ? 'pl-8' : ''}>\n        {/* Header */}\n        <div className=\"flex items-start justify-between gap-3 mb-3\">\n          <div className=\"flex items-center gap-2\">\n            {/* Type icon */}\n            <div className=\"w-8 h-8 rounded-lg bg-primary/10 flex items-center justify-center flex-shrink-0\">\n              <svg className=\"w-4 h-4 text-primary\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d={typeIcons[fact.factType] || typeIcons.statement} />\n              </svg>\n            </div>\n            <div>\n              <span className=\"text-xs font-medium text-primary\">\n                {FactTypeLabels[fact.factType]}\n              </span>\n              <div className=\"flex items-center gap-2 mt-0.5\">\n                <span className={`text-xs px-1.5 py-0.5 rounded ${confidenceColor}`}>\n                  {Math.round(fact.confidence * 100)}%\n                </span>\n                {fact.status !== 'pending' && (\n                  <span className={`text-xs ${FactStatusColors[fact.status]}`}>\n                    {fact.status.replace('_', ' ')}\n                  </span>\n                )}\n              </div>\n            </div>\n          </div>\n\n          {/* Expand/Collapse */}\n          <button\n            onClick={() => setIsExpanded(!isExpanded)}\n            className=\"p-1.5 rounded-lg hover:bg-background transition-colors\"\n          >\n            <svg\n              className={`w-4 h-4 text-foreground-muted transition-transform ${isExpanded ? 'rotate-180' : ''}`}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n            </svg>\n          </button>\n        </div>\n\n        {/* Content */}\n        {isEditing ? (\n          <div className=\"mb-3\">\n            <textarea\n              value={editedContent}\n              onChange={(e) => setEditedContent(e.target.value)}\n              className=\"w-full px-3 py-2 rounded-lg bg-background border border-glass-border text-sm text-foreground resize-none focus:outline-none focus:border-primary\"\n              rows={3}\n              autoFocus\n            />\n            <div className=\"flex justify-end gap-2 mt-2\">\n              <button\n                onClick={handleCancelEdit}\n                className=\"px-3 py-1 text-xs rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={handleSaveEdit}\n                className=\"px-3 py-1 text-xs rounded-lg bg-primary text-white hover:bg-primary/90\"\n              >\n                Save\n              </button>\n            </div>\n          </div>\n        ) : (\n          <p className=\"text-sm text-foreground mb-3\">{fact.content}</p>\n        )}\n\n        {/* Expanded details */}\n        {isExpanded && !isEditing && (\n          <motion.div\n            initial={{ opacity: 0, height: 0 }}\n            animate={{ opacity: 1, height: 'auto' }}\n            exit={{ opacity: 0, height: 0 }}\n            className=\"space-y-3 pt-3 border-t border-glass-border\"\n          >\n            {/* Raw text */}\n            <div>\n              <p className=\"text-xs font-medium text-foreground-muted mb-1\">Source Text</p>\n              <p className=\"text-xs text-foreground-muted bg-background rounded-lg p-2 line-clamp-3\">\n                \"{fact.rawText}\"\n              </p>\n            </div>\n\n            {/* Entities */}\n            {fact.entities.length > 0 && (\n              <div>\n                <p className=\"text-xs font-medium text-foreground-muted mb-1\">Entities</p>\n                <div className=\"flex flex-wrap gap-1\">\n                  {fact.entities.map((entity, i) => (\n                    <span\n                      key={i}\n                      className=\"inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs bg-blue-500/10 text-blue-400\"\n                    >\n                      <span className=\"capitalize\">{entity.type}:</span>\n                      <span className=\"font-medium\">{entity.name}</span>\n                      {entity.role && <span className=\"text-blue-300\">({entity.role})</span>}\n                    </span>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Dates */}\n            {fact.dates.length > 0 && (\n              <div>\n                <p className=\"text-xs font-medium text-foreground-muted mb-1\">Dates</p>\n                <div className=\"flex flex-wrap gap-1\">\n                  {fact.dates.map((date, i) => (\n                    <span\n                      key={i}\n                      className=\"inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs bg-purple-500/10 text-purple-400\"\n                    >\n                      <span>{date.date}</span>\n                      <span className=\"text-purple-300\">({date.type.replace('_', ' ')})</span>\n                    </span>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Relationships */}\n            {fact.relationships.length > 0 && (\n              <div>\n                <p className=\"text-xs font-medium text-foreground-muted mb-1\">Relationships</p>\n                <div className=\"space-y-1\">\n                  {fact.relationships.map((rel, i) => (\n                    <p key={i} className=\"text-xs text-foreground-muted\">\n                      <span className=\"text-foreground\">{rel.subject}</span>\n                      <span className=\"mx-1 text-primary\">{rel.predicate.replace(/_/g, ' ')}</span>\n                      <span className=\"text-foreground\">{rel.object}</span>\n                    </p>\n                  ))}\n                </div>\n              </div>\n            )}\n\n            {/* Source info */}\n            {(fact.sourcePage || fact.sourceSection) && (\n              <div className=\"flex gap-4 text-xs text-foreground-muted\">\n                {fact.sourcePage && <span>Page {fact.sourcePage}</span>}\n                {fact.sourceSection && <span>Section: {fact.sourceSection}</span>}\n              </div>\n            )}\n          </motion.div>\n        )}\n\n        {/* Actions */}\n        {fact.status === 'pending' && !isEditing && (\n          <div className=\"flex items-center justify-between pt-3 border-t border-glass-border mt-3\">\n            <button\n              onClick={() => setIsEditing(true)}\n              className=\"px-3 py-1.5 text-xs rounded-lg text-foreground-muted hover:text-foreground hover:bg-background transition-colors\"\n            >\n              Edit\n            </button>\n            <div className=\"flex gap-2\">\n              <button\n                onClick={onReject}\n                className=\"px-3 py-1.5 text-xs rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500/20 transition-colors\"\n              >\n                Reject\n              </button>\n              <button\n                onClick={onApprove}\n                className=\"px-3 py-1.5 text-xs rounded-lg bg-green-500/10 text-green-400 hover:bg-green-500/20 transition-colors\"\n              >\n                Approve\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </motion.div>\n  );\n}",
      "references": [
        "isExpanded",
        "setIsExpanded",
        "useState",
        "isEditing",
        "setIsEditing",
        "editedContent",
        "setEditedContent",
        "fact",
        "onEdit",
        "motion",
        "layout",
        "initial",
        "animate",
        "exit",
        "className",
        "isSelected",
        "disabled",
        "onSelect",
        "div",
        "input",
        "checked",
        "onChange",
        "e",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "typeIcons",
        "span",
        "FactTypeLabels",
        "confidenceColor",
        "Math",
        "FactStatusColors",
        "button",
        "onClick",
        "textarea",
        "value",
        "rows",
        "autoFocus",
        "handleCancelEdit",
        "handleSaveEdit",
        "p",
        "key",
        "i",
        "entity",
        "date",
        "rel",
        "onReject",
        "onApprove"
      ]
    },
    "file:web/src/components/documents/FactReviewList.tsx": {
      "id": "file:web/src/components/documents/FactReviewList.tsx",
      "type": "file",
      "name": "FactReviewList.tsx",
      "filePath": "web/src/components/documents/FactReviewList.tsx",
      "line": 1,
      "endLine": 293,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "FactTypeLabels",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./FactReviewCard",
          "items": [
            {
              "name": "FactReviewCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "FactReviewList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FactReviewList",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/FactReviewList.tsx:fn:FactReviewList:22"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/FactReviewList.tsx:fn:FactReviewList:22": {
      "id": "file:web/src/components/documents/FactReviewList.tsx:fn:FactReviewList:22",
      "type": "function",
      "name": "FactReviewList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/FactReviewList.tsx",
      "line": 22,
      "endLine": 290,
      "parentFileId": "file:web/src/components/documents/FactReviewList.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  facts,\n  isLoading,\n  onApprove,\n  onReject,\n  onEdit,\n  onBulkApprove,\n  onBulkReject,\n}",
          "type": "FactReviewListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for displaying, filtering, sorting, selecting, and bulk approving/rejecting facts.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function FactReviewList({\n  facts,\n  isLoading,\n  onApprove,\n  onReject,\n  onEdit,\n  onBulkApprove,\n  onBulkReject,\n}: FactReviewListProps) {\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [sortBy, setSortBy] = useState<SortOption>('confidence-desc');\n  const [filterType, setFilterType] = useState<FilterType>('all');\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  // Filter and sort facts\n  const processedFacts = useMemo(() => {\n    let result = [...facts];\n\n    // Filter by type\n    if (filterType !== 'all') {\n      result = result.filter((f) => f.factType === filterType);\n    }\n\n    // Sort\n    switch (sortBy) {\n      case 'confidence-desc':\n        result.sort((a, b) => b.confidence - a.confidence);\n        break;\n      case 'confidence-asc':\n        result.sort((a, b) => a.confidence - b.confidence);\n        break;\n      case 'type':\n        result.sort((a, b) => a.factType.localeCompare(b.factType));\n        break;\n      case 'date':\n        result.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n        break;\n    }\n\n    return result;\n  }, [facts, sortBy, filterType]);\n\n  // Get unique fact types for filter\n  const availableTypes = useMemo(() => {\n    const types = new Set(facts.map((f) => f.factType));\n    return Array.from(types).sort();\n  }, [facts]);\n\n  // Selection handlers\n  const handleSelectAll = () => {\n    if (selectedIds.size === processedFacts.length) {\n      setSelectedIds(new Set());\n    } else {\n      setSelectedIds(new Set(processedFacts.map((f) => f.id)));\n    }\n  };\n\n  const handleSelect = (factId: string, selected: boolean) => {\n    const newSelected = new Set(selectedIds);\n    if (selected) {\n      newSelected.add(factId);\n    } else {\n      newSelected.delete(factId);\n    }\n    setSelectedIds(newSelected);\n  };\n\n  // Bulk action handlers\n  const handleBulkApprove = async () => {\n    if (selectedIds.size === 0) return;\n    setIsProcessing(true);\n    try {\n      await onBulkApprove(Array.from(selectedIds));\n      setSelectedIds(new Set());\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleBulkReject = async () => {\n    if (selectedIds.size === 0) return;\n    setIsProcessing(true);\n    try {\n      await onBulkReject(Array.from(selectedIds));\n      setSelectedIds(new Set());\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Individual action handlers\n  const handleApprove = async (factId: string) => {\n    setIsProcessing(true);\n    try {\n      await onApprove(factId);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleReject = async (factId: string) => {\n    setIsProcessing(true);\n    try {\n      await onReject(factId);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleEdit = async (factId: string, content: string) => {\n    setIsProcessing(true);\n    try {\n      await onEdit(factId, content);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Pending facts count\n  const pendingCount = facts.filter((f) => f.status === 'pending').length;\n\n  if (isLoading) {\n    return (\n      <div className=\"space-y-3\">\n        {[...Array(3)].map((_, i) => (\n          <div key={i} className=\"p-4 rounded-lg bg-background-tertiary animate-pulse\">\n            <div className=\"h-4 bg-background rounded w-1/4 mb-3\" />\n            <div className=\"h-3 bg-background rounded w-full mb-2\" />\n            <div className=\"h-3 bg-background rounded w-3/4\" />\n          </div>\n        ))}\n      </div>\n    );\n  }\n\n  if (facts.length === 0) {\n    return (\n      <div className=\"text-center py-12\">\n        <div className=\"w-16 h-16 mx-auto mb-4 rounded-full bg-background-tertiary flex items-center justify-center\">\n          <svg className=\"w-8 h-8 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z\" />\n          </svg>\n        </div>\n        <p className=\"text-foreground-muted\">No facts extracted yet</p>\n        <p className=\"text-sm text-foreground-muted mt-1\">\n          Extract facts from document chunks to review them here\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Header with controls */}\n      <div className=\"flex flex-col sm:flex-row sm:items-center justify-between gap-3\">\n        <div className=\"flex items-center gap-3\">\n          <span className=\"text-sm text-foreground-muted\">\n            {pendingCount} pending &bull; {facts.length} total\n          </span>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          {/* Type filter */}\n          <select\n            value={filterType}\n            onChange={(e) => setFilterType(e.target.value as FilterType)}\n            className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary border border-glass-border text-foreground focus:outline-none focus:border-primary\"\n          >\n            <option value=\"all\">All Types</option>\n            {availableTypes.map((type) => (\n              <option key={type} value={type}>\n                {FactTypeLabels[type]}\n              </option>\n            ))}\n          </select>\n\n          {/* Sort */}\n          <select\n            value={sortBy}\n            onChange={(e) => setSortBy(e.target.value as SortOption)}\n            className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary border border-glass-border text-foreground focus:outline-none focus:border-primary\"\n          >\n            <option value=\"confidence-desc\">Highest Confidence</option>\n            <option value=\"confidence-asc\">Lowest Confidence</option>\n            <option value=\"type\">By Type</option>\n            <option value=\"date\">Most Recent</option>\n          </select>\n        </div>\n      </div>\n\n      {/* Bulk actions bar */}\n      {selectedIds.size > 0 && (\n        <div className=\"flex items-center justify-between px-4 py-3 rounded-lg bg-primary/10 border border-primary/20\">\n          <div className=\"flex items-center gap-3\">\n            <input\n              type=\"checkbox\"\n              checked={selectedIds.size === processedFacts.length}\n              onChange={handleSelectAll}\n              className=\"w-4 h-4 rounded border-glass-border bg-background text-primary focus:ring-primary\"\n            />\n            <span className=\"text-sm text-foreground\">\n              {selectedIds.size} selected\n            </span>\n          </div>\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleBulkReject}\n              disabled={isProcessing}\n              className=\"px-3 py-1.5 text-xs rounded-lg bg-red-500/10 text-red-400 hover:bg-red-500/20 disabled:opacity-50 transition-colors\"\n            >\n              Reject All\n            </button>\n            <button\n              onClick={handleBulkApprove}\n              disabled={isProcessing}\n              className=\"px-3 py-1.5 text-xs rounded-lg bg-green-500/10 text-green-400 hover:bg-green-500/20 disabled:opacity-50 transition-colors\"\n            >\n              Approve All\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Select all toggle (when nothing selected) */}\n      {selectedIds.size === 0 && processedFacts.length > 0 && (\n        <div className=\"flex items-center gap-2 px-4\">\n          <input\n            type=\"checkbox\"\n            checked={false}\n            onChange={handleSelectAll}\n            className=\"w-4 h-4 rounded border-glass-border bg-background text-primary focus:ring-primary\"\n          />\n          <span className=\"text-xs text-foreground-muted\">Select all</span>\n        </div>\n      )}\n\n      {/* Facts list */}\n      <div className=\"space-y-3\">\n        <AnimatePresence mode=\"popLayout\">\n          {processedFacts.map((fact) => (\n            <FactReviewCard\n              key={fact.id}\n              fact={fact}\n              isSelected={selectedIds.has(fact.id)}\n              onSelect={(selected) => handleSelect(fact.id, selected)}\n              onApprove={() => handleApprove(fact.id)}\n              onReject={() => handleReject(fact.id)}\n              onEdit={(content) => handleEdit(fact.id, content)}\n              disabled={isProcessing}\n            />\n          ))}\n        </AnimatePresence>\n      </div>\n\n      {/* Empty state for filtered results */}\n      {processedFacts.length === 0 && facts.length > 0 && (\n        <div className=\"text-center py-8\">\n          <p className=\"text-foreground-muted\">No facts match the current filter</p>\n          <button\n            onClick={() => setFilterType('all')}\n            className=\"mt-2 text-sm text-primary hover:underline\"\n          >\n            Clear filter\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "selectedIds",
        "setSelectedIds",
        "useState",
        "Set",
        "sortBy",
        "setSortBy",
        "filterType",
        "setFilterType",
        "isProcessing",
        "setIsProcessing",
        "useMemo",
        "facts",
        "result",
        "f",
        "b",
        "a",
        "Date",
        "Array",
        "types",
        "processedFacts",
        "selected",
        "newSelected",
        "factId",
        "onBulkApprove",
        "onBulkReject",
        "onApprove",
        "onReject",
        "onEdit",
        "content",
        "isLoading",
        "div",
        "className",
        "key",
        "i",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "p",
        "span",
        "pendingCount",
        "select",
        "value",
        "onChange",
        "e",
        "option",
        "availableTypes",
        "FactTypeLabels",
        "input",
        "checked",
        "handleSelectAll",
        "button",
        "onClick",
        "handleBulkReject",
        "disabled",
        "handleBulkApprove",
        "AnimatePresence",
        "mode",
        "FactReviewCard",
        "fact",
        "isSelected",
        "onSelect",
        "handleSelect",
        "handleApprove",
        "handleReject",
        "handleEdit"
      ]
    },
    "file:web/src/components/documents/FactReviewPanel.tsx": {
      "id": "file:web/src/components/documents/FactReviewPanel.tsx",
      "type": "file",
      "name": "FactReviewPanel.tsx",
      "filePath": "web/src/components/documents/FactReviewPanel.tsx",
      "line": 1,
      "endLine": 326,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "StoredDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "getDocumentFacts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getDocumentFactStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "extractDocumentFacts",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateFactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateFactContent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "bulkUpdateFactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./FactReviewList",
          "items": [
            {
              "name": "FactReviewList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "FactReviewPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FactReviewPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/documents/FactReviewPanel.tsx:fn:FactReviewPanel:23"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/documents/FactReviewPanel.tsx:fn:FactReviewPanel:23": {
      "id": "file:web/src/components/documents/FactReviewPanel.tsx:fn:FactReviewPanel:23",
      "type": "function",
      "name": "FactReviewPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/documents/FactReviewPanel.tsx",
      "line": 23,
      "endLine": 323,
      "parentFileId": "file:web/src/components/documents/FactReviewPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ document, isOpen, onClose }",
          "type": "FactReviewPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for loading, reviewing, and extracting facts from a document",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function FactReviewPanel({ document, isOpen, onClose }: FactReviewPanelProps) {\n  const [facts, setFacts] = useState<ExtractedFact[]>([]);\n  const [stats, setStats] = useState<FactExtractionStats | null>(null);\n  const [hasBeenExtracted, setHasBeenExtracted] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isExtracting, setIsExtracting] = useState(false);\n  const [extractionResult, setExtractionResult] = useState<{\n    success: boolean;\n    factsExtracted: number;\n    message?: string;\n  } | null>(null);\n  const [activeTab, setActiveTab] = useState<'pending' | 'all' | 'approved'>('pending');\n\n  // Load facts when document changes\n  useEffect(() => {\n    if (document && isOpen) {\n      loadFactsAndStats();\n    }\n  }, [document?.id, isOpen]);\n\n  const loadFactsAndStats = async () => {\n    if (!document) return;\n\n    setIsLoading(true);\n    try {\n      // Load stats first to check if extraction has been done\n      const statsResult = await getDocumentFactStats(document.id);\n      setHasBeenExtracted(statsResult.hasBeenExtracted);\n      setStats(statsResult.stats);\n\n      // Load facts based on active tab\n      const statusFilter =\n        activeTab === 'pending'\n          ? 'pending'\n          : activeTab === 'approved'\n            ? ['approved', 'auto_approved']\n            : undefined;\n\n      const factsResult = await getDocumentFacts(document.id, {\n        status: statusFilter as any,\n      });\n      setFacts(factsResult.facts);\n    } catch (err) {\n      console.error('Failed to load facts:', err);\n      setFacts([]);\n      setStats(null);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Reload facts when tab changes\n  useEffect(() => {\n    if (document && isOpen && hasBeenExtracted) {\n      loadFactsAndStats();\n    }\n  }, [activeTab]);\n\n  const handleExtract = async () => {\n    if (!document) return;\n\n    setIsExtracting(true);\n    setExtractionResult(null);\n    try {\n      const result = await extractDocumentFacts(document.id);\n      setExtractionResult({\n        success: result.success,\n        factsExtracted: result.factsExtracted,\n        message: result.success\n          ? `Extracted ${result.factsExtracted} facts from ${result.chunksProcessed} chunks`\n          : 'Extraction failed',\n      });\n      // Reload facts after extraction\n      await loadFactsAndStats();\n    } catch (err) {\n      setExtractionResult({\n        success: false,\n        factsExtracted: 0,\n        message: err instanceof Error ? err.message : 'Extraction failed',\n      });\n    } finally {\n      setIsExtracting(false);\n    }\n  };\n\n  const handleApprove = async (factId: string) => {\n    await updateFactStatus(factId, 'approved');\n    await loadFactsAndStats();\n  };\n\n  const handleReject = async (factId: string) => {\n    await updateFactStatus(factId, 'rejected');\n    await loadFactsAndStats();\n  };\n\n  const handleEdit = async (factId: string, content: string) => {\n    await updateFactContent(factId, content);\n    await loadFactsAndStats();\n  };\n\n  const handleBulkApprove = async (factIds: string[]) => {\n    await bulkUpdateFactStatus(factIds, 'approved');\n    await loadFactsAndStats();\n  };\n\n  const handleBulkReject = async (factIds: string[]) => {\n    await bulkUpdateFactStatus(factIds, 'rejected');\n    await loadFactsAndStats();\n  };\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === 'Escape') onClose();\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      window.document.addEventListener('keydown', handleKeyDown);\n      window.document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      window.document.removeEventListener('keydown', handleKeyDown);\n      window.document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!document) return null;\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Panel */}\n          <motion.div\n            initial={{ opacity: 0, x: 300 }}\n            animate={{ opacity: 1, x: 0 }}\n            exit={{ opacity: 0, x: 300 }}\n            transition={{ duration: 0.2, ease: 'easeOut' }}\n            className=\"fixed top-0 right-0 bottom-0 w-full md:w-[600px] lg:w-[700px] z-50 glass border-l border-glass-border flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <div className=\"flex-1 min-w-0 mr-4\">\n                <h2 className=\"text-lg font-semibold text-foreground\">Fact Review</h2>\n                <p className=\"text-sm text-foreground-muted mt-0.5 truncate\">\n                  {document.name || document.filename}\n                </p>\n              </div>\n              <button\n                onClick={onClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Stats bar */}\n            {stats && hasBeenExtracted && (\n              <div className=\"px-6 py-3 border-b border-glass-border bg-background-tertiary/50\">\n                <div className=\"flex items-center justify-between text-sm\">\n                  <div className=\"flex gap-4\">\n                    <span className=\"text-yellow-400\">\n                      {stats.byStatus.pending ?? 0} pending\n                    </span>\n                    <span className=\"text-green-400\">\n                      {(stats.byStatus.approved ?? 0) + (stats.byStatus.auto_approved ?? 0)} approved\n                    </span>\n                    <span className=\"text-red-400\">\n                      {stats.byStatus.rejected ?? 0} rejected\n                    </span>\n                  </div>\n                  <span className=\"text-foreground-muted\">\n                    {stats.total} total facts\n                  </span>\n                </div>\n              </div>\n            )}\n\n            {/* Tabs */}\n            {hasBeenExtracted && (\n              <div className=\"flex border-b border-glass-border\">\n                {(['pending', 'all', 'approved'] as const).map((tab) => (\n                  <button\n                    key={tab}\n                    onClick={() => setActiveTab(tab)}\n                    className={`\n                      flex-1 px-4 py-3 text-sm font-medium transition-colors\n                      ${activeTab === tab\n                        ? 'text-primary border-b-2 border-primary'\n                        : 'text-foreground-muted hover:text-foreground'\n                      }\n                    `}\n                  >\n                    {tab === 'pending' ? 'Pending Review' : tab === 'all' ? 'All Facts' : 'Approved'}\n                  </button>\n                ))}\n              </div>\n            )}\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6\">\n              {!hasBeenExtracted ? (\n                // Not yet extracted - show extraction UI\n                <div className=\"text-center py-12\">\n                  <div className=\"w-20 h-20 mx-auto mb-6 rounded-full bg-primary/10 flex items-center justify-center\">\n                    <svg className=\"w-10 h-10 text-primary\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z\" />\n                    </svg>\n                  </div>\n                  <h3 className=\"text-lg font-semibold text-foreground mb-2\">\n                    Extract Facts from Document\n                  </h3>\n                  <p className=\"text-sm text-foreground-muted mb-6 max-w-md mx-auto\">\n                    Use AI to extract facts, entities, dates, and relationships from this document.\n                    You'll be able to review and approve them before they become memories.\n                  </p>\n\n                  {extractionResult && (\n                    <div\n                      className={`mb-6 px-4 py-3 rounded-lg text-sm ${\n                        extractionResult.success\n                          ? 'bg-green-500/10 text-green-400'\n                          : 'bg-red-500/10 text-red-400'\n                      }`}\n                    >\n                      {extractionResult.message}\n                    </div>\n                  )}\n\n                  <button\n                    onClick={handleExtract}\n                    disabled={isExtracting}\n                    className=\"px-6 py-3 rounded-lg bg-primary text-white font-medium hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\n                  >\n                    {isExtracting ? (\n                      <span className=\"flex items-center gap-2\">\n                        <svg className=\"w-4 h-4 animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n                          <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n                          <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n                        </svg>\n                        Extracting...\n                      </span>\n                    ) : (\n                      'Extract Facts'\n                    )}\n                  </button>\n                </div>\n              ) : (\n                // Facts list\n                <FactReviewList\n                  facts={facts}\n                  isLoading={isLoading}\n                  onApprove={handleApprove}\n                  onReject={handleReject}\n                  onEdit={handleEdit}\n                  onBulkApprove={handleBulkApprove}\n                  onBulkReject={handleBulkReject}\n                />\n              )}\n            </div>\n\n            {/* Footer */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-t border-glass-border\">\n              <div>\n                {hasBeenExtracted && (\n                  <button\n                    onClick={handleExtract}\n                    disabled={isExtracting}\n                    className=\"px-3 py-1.5 text-sm rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n                  >\n                    {isExtracting ? 'Re-extracting...' : 'Re-extract Facts'}\n                  </button>\n                )}\n              </div>\n              <button\n                onClick={onClose}\n                className=\"px-4 py-2 rounded-lg text-sm bg-primary text-white hover:bg-primary/90 transition-colors\"\n              >\n                Close\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "facts",
        "setFacts",
        "useState",
        "stats",
        "setStats",
        "hasBeenExtracted",
        "setHasBeenExtracted",
        "isLoading",
        "setIsLoading",
        "isExtracting",
        "setIsExtracting",
        "extractionResult",
        "setExtractionResult",
        "activeTab",
        "setActiveTab",
        "useEffect",
        "document",
        "isOpen",
        "loadFactsAndStats",
        "getDocumentFactStats",
        "statsResult",
        "getDocumentFacts",
        "statusFilter",
        "factsResult",
        "console",
        "err",
        "extractDocumentFacts",
        "result",
        "Error",
        "updateFactStatus",
        "factId",
        "updateFactContent",
        "content",
        "bulkUpdateFactStatus",
        "factIds",
        "useCallback",
        "e",
        "onClose",
        "window",
        "handleKeyDown",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "h2",
        "p",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "span",
        "key",
        "tab",
        "h3",
        "handleExtract",
        "disabled",
        "circle",
        "cx",
        "cy",
        "r",
        "FactReviewList",
        "onApprove",
        "handleApprove",
        "onReject",
        "handleReject",
        "onEdit",
        "handleEdit",
        "onBulkApprove",
        "handleBulkApprove",
        "onBulkReject",
        "handleBulkReject"
      ]
    },
    "file:web/src/components/documents/index.ts": {
      "id": "file:web/src/components/documents/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/documents/index.ts",
      "line": 1,
      "endLine": 11,
      "imports": [],
      "exports": [
        {
          "name": "DocumentUpload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentSearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DocumentUpload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DocumentUpload"
        },
        {
          "name": "DocumentCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DocumentCard"
        },
        {
          "name": "DocumentList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DocumentList"
        },
        {
          "name": "DocumentDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DocumentDetail"
        },
        {
          "name": "DocumentSearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DocumentSearch"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/graph/GraphContextMenu.tsx": {
      "id": "file:web/src/components/graph/GraphContextMenu.tsx",
      "type": "file",
      "name": "GraphContextMenu.tsx",
      "filePath": "web/src/components/graph/GraphContextMenu.tsx",
      "line": 1,
      "endLine": 186,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "ForceGraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "GraphContextMenu",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphContextMenuProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphContextMenu",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/graph/GraphContextMenu.tsx:fn:GraphContextMenu:63"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/components/graph/GraphContextMenu.tsx:fn:GraphContextMenu:63": {
      "id": "file:web/src/components/graph/GraphContextMenu.tsx:fn:GraphContextMenu:63",
      "type": "function",
      "name": "GraphContextMenu",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/graph/GraphContextMenu.tsx",
      "line": 63,
      "endLine": 183,
      "parentFileId": "file:web/src/components/graph/GraphContextMenu.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  node,\n  position,\n  onClose,\n  onFocus,\n  onViewDetails,\n  onFindRelated,\n  onCopy,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/graph/GraphContextMenu\").GraphContextMenuProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React context menu for graph nodes with focus, view details, find related, copy options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function GraphContextMenu({\n  node,\n  position,\n  onClose,\n  onFocus,\n  onViewDetails,\n  onFindRelated,\n  onCopy,\n}: GraphContextMenuProps) {\n  const menuRef = useRef<HTMLDivElement>(null);\n\n  // Close on click outside\n  useEffect(() => {\n    const handleClickOutside = (e: MouseEvent) => {\n      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {\n        onClose();\n      }\n    };\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onClose();\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    document.addEventListener('keydown', handleKeyDown);\n    return () => {\n      document.removeEventListener('mousedown', handleClickOutside);\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [onClose]);\n\n  // Adjust position to stay within viewport\n  const adjustedPosition = {\n    x: Math.min(position.x, window.innerWidth - 200),\n    y: Math.min(position.y, window.innerHeight - 200),\n  };\n\n  const handleFocus = () => {\n    onFocus?.(node);\n    onClose();\n  };\n\n  const handleViewDetails = () => {\n    onViewDetails?.(node);\n    onClose();\n  };\n\n  const handleFindRelated = () => {\n    onFindRelated?.(node);\n    onClose();\n  };\n\n  const handleCopy = async () => {\n    const info = `${node.type}: ${node.label}`;\n    try {\n      await navigator.clipboard.writeText(info);\n      onCopy?.(node);\n    } catch {\n      // Fallback for older browsers\n      console.warn('Failed to copy to clipboard');\n    }\n    onClose();\n  };\n\n  return (\n    <div\n      ref={menuRef}\n      className=\"fixed z-50 bg-surface-raised border border-border rounded-lg shadow-xl py-1 min-w-[160px]\"\n      style={{ left: adjustedPosition.x, top: adjustedPosition.y }}\n    >\n      {/* Header */}\n      <div className=\"px-3 py-2 border-b border-border\">\n        <div className=\"text-sm font-medium text-foreground truncate\">{node.label}</div>\n        <div className=\"text-xs text-foreground-muted capitalize\">{node.type}</div>\n      </div>\n\n      {/* Actions */}\n      <div className=\"py-1\">\n        {onFocus && (\n          <button\n            onClick={handleFocus}\n            className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-foreground-muted hover:text-foreground hover:bg-surface-sunken transition-colors\"\n          >\n            {icons.focus}\n            <span>Focus on node</span>\n          </button>\n        )}\n\n        {onViewDetails && (\n          <button\n            onClick={handleViewDetails}\n            className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-foreground-muted hover:text-foreground hover:bg-surface-sunken transition-colors\"\n          >\n            {icons.details}\n            <span>View details</span>\n          </button>\n        )}\n\n        {onFindRelated && (\n          <button\n            onClick={handleFindRelated}\n            className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-foreground-muted hover:text-foreground hover:bg-surface-sunken transition-colors\"\n          >\n            {icons.related}\n            <span>Find related</span>\n          </button>\n        )}\n\n        <button\n          onClick={handleCopy}\n          className=\"w-full flex items-center gap-2 px-3 py-2 text-sm text-foreground-muted hover:text-foreground hover:bg-surface-sunken transition-colors\"\n        >\n          {icons.copy}\n          <span>Copy info</span>\n        </button>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useRef",
        "useEffect",
        "menuRef",
        "e",
        "onClose",
        "document",
        "handleClickOutside",
        "handleKeyDown",
        "Math",
        "position",
        "window",
        "onFocus",
        "node",
        "onViewDetails",
        "onFindRelated",
        "navigator",
        "info",
        "onCopy",
        "console",
        "div",
        "ref",
        "className",
        "style",
        "adjustedPosition",
        "button",
        "onClick",
        "handleFocus",
        "icons",
        "span",
        "handleViewDetails",
        "handleFindRelated",
        "handleCopy"
      ]
    },
    "file:web/src/components/graph/GraphControls.tsx": {
      "id": "file:web/src/components/graph/GraphControls.tsx",
      "type": "file",
      "name": "GraphControls.tsx",
      "filePath": "web/src/components/graph/GraphControls.tsx",
      "line": 1,
      "endLine": 394,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "GraphControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphDisplayOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphControlsProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_GRAPH_FILTERS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DEFAULT_DISPLAY_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "GraphControls",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/graph/GraphControls.tsx:fn:GraphControls:102"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "ENTITY_TYPES",
        "t",
        "EDGE_TYPES"
      ]
    },
    "file:web/src/components/graph/GraphControls.tsx:fn:GraphControls:102": {
      "id": "file:web/src/components/graph/GraphControls.tsx:fn:GraphControls:102",
      "type": "function",
      "name": "GraphControls",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/graph/GraphControls.tsx",
      "line": 102,
      "endLine": 373,
      "parentFileId": "file:web/src/components/graph/GraphControls.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  filters,\n  displayOptions,\n  onFiltersChange,\n  onDisplayOptionsChange,\n  collapsed = false,\n  onToggleCollapsed,\n  className = '',\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/graph/GraphControls\").GraphControlsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders UI controls for toggling graph entity/edge types and display options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function GraphControls({\n  filters,\n  displayOptions,\n  onFiltersChange,\n  onDisplayOptionsChange,\n  collapsed = false,\n  onToggleCollapsed,\n  className = '',\n}: GraphControlsProps) {\n  const [expandedSection, setExpandedSection] = useState<'filters' | 'display' | null>('filters');\n\n  // Toggle entity type\n  const toggleEntityType = useCallback(\n    (type: string) => {\n      const newTypes = filters.entityTypes.includes(type)\n        ? filters.entityTypes.filter((t) => t !== type)\n        : [...filters.entityTypes, type];\n      onFiltersChange({ ...filters, entityTypes: newTypes });\n    },\n    [filters, onFiltersChange]\n  );\n\n  // Toggle edge type\n  const toggleEdgeType = useCallback(\n    (type: string) => {\n      const newTypes = displayOptions.visibleEdgeTypes.includes(type)\n        ? displayOptions.visibleEdgeTypes.filter((t) => t !== type)\n        : [...displayOptions.visibleEdgeTypes, type];\n      onDisplayOptionsChange({ ...displayOptions, visibleEdgeTypes: newTypes });\n    },\n    [displayOptions, onDisplayOptionsChange]\n  );\n\n  // Toggle all entity types\n  const toggleAllEntityTypes = useCallback(() => {\n    const allSelected = filters.entityTypes.length === ENTITY_TYPES.length;\n    onFiltersChange({\n      ...filters,\n      entityTypes: allSelected ? [] : ENTITY_TYPES.map((t) => t.value),\n    });\n  }, [filters, onFiltersChange]);\n\n  // Toggle all edge types\n  const toggleAllEdgeTypes = useCallback(() => {\n    const allSelected = displayOptions.visibleEdgeTypes.length === EDGE_TYPES.length;\n    onDisplayOptionsChange({\n      ...displayOptions,\n      visibleEdgeTypes: allSelected ? [] : EDGE_TYPES.map((t) => t.value),\n    });\n  }, [displayOptions, onDisplayOptionsChange]);\n\n  if (collapsed) {\n    return (\n      <div className={`p-2 ${className}`}>\n        <button\n          onClick={onToggleCollapsed}\n          className=\"flex items-center gap-2 px-3 py-2 rounded-lg bg-surface-raised border border-border hover:bg-surface-sunken transition-colors w-full\"\n        >\n          {icons.filter}\n          <span className=\"text-sm text-foreground\">Controls</span>\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`flex flex-col gap-4 p-4 ${className}`}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"text-sm font-medium text-foreground\">Graph Controls</h3>\n        {onToggleCollapsed && (\n          <button\n            onClick={onToggleCollapsed}\n            className=\"p-1 rounded hover:bg-surface-sunken transition-colors\"\n          >\n            {icons.chevronUp}\n          </button>\n        )}\n      </div>\n\n      {/* Filters Section */}\n      <div className=\"space-y-3\">\n        <button\n          onClick={() => setExpandedSection(expandedSection === 'filters' ? null : 'filters')}\n          className=\"flex items-center justify-between w-full text-left\"\n        >\n          <div className=\"flex items-center gap-2 text-sm font-medium text-foreground-muted\">\n            {icons.filter}\n            <span>Filters</span>\n          </div>\n          {expandedSection === 'filters' ? icons.chevronUp : icons.chevronDown}\n        </button>\n\n        {expandedSection === 'filters' && (\n          <div className=\"space-y-4 pl-6\">\n            {/* Entity Types */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-xs text-foreground-muted\">Entity Types</span>\n                <button\n                  onClick={toggleAllEntityTypes}\n                  className=\"text-xs text-primary hover:text-primary-hover transition-colors\"\n                >\n                  {filters.entityTypes.length === ENTITY_TYPES.length ? 'None' : 'All'}\n                </button>\n              </div>\n              <div className=\"grid grid-cols-2 gap-1.5\">\n                {ENTITY_TYPES.map((type) => (\n                  <label\n                    key={type.value}\n                    className=\"flex items-center gap-2 cursor-pointer group\"\n                  >\n                    <input\n                      type=\"checkbox\"\n                      checked={filters.entityTypes.includes(type.value)}\n                      onChange={() => toggleEntityType(type.value)}\n                      className=\"w-3.5 h-3.5 rounded border-border bg-surface-sunken text-primary focus:ring-1 focus:ring-primary\"\n                    />\n                    <span\n                      className=\"w-2 h-2 rounded-full flex-none\"\n                      style={{ backgroundColor: type.color }}\n                    />\n                    <span className=\"text-xs text-foreground-muted group-hover:text-foreground transition-colors\">\n                      {type.label}\n                    </span>\n                  </label>\n                ))}\n              </div>\n            </div>\n\n            {/* Salience Threshold */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-xs text-foreground-muted\">Min Salience</span>\n                <span className=\"text-xs text-foreground tabular-nums\">\n                  {(filters.minSalience * 100).toFixed(0)}%\n                </span>\n              </div>\n              <input\n                type=\"range\"\n                min=\"0\"\n                max=\"100\"\n                value={filters.minSalience * 100}\n                onChange={(e) =>\n                  onFiltersChange({ ...filters, minSalience: parseInt(e.target.value) / 100 })\n                }\n                className=\"w-full h-1.5 rounded-lg appearance-none bg-surface-sunken accent-primary cursor-pointer\"\n              />\n            </div>\n\n            {/* Entity Limit */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-xs text-foreground-muted\">Entity Limit</span>\n                <span className=\"text-xs text-foreground tabular-nums\">{filters.entityLimit}</span>\n              </div>\n              <input\n                type=\"range\"\n                min=\"5\"\n                max=\"50\"\n                step=\"5\"\n                value={filters.entityLimit}\n                onChange={(e) =>\n                  onFiltersChange({ ...filters, entityLimit: parseInt(e.target.value) })\n                }\n                className=\"w-full h-1.5 rounded-lg appearance-none bg-surface-sunken accent-primary cursor-pointer\"\n              />\n            </div>\n\n            {/* Memory Limit */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-xs text-foreground-muted\">Memory Limit</span>\n                <span className=\"text-xs text-foreground tabular-nums\">{filters.memoryLimit}</span>\n              </div>\n              <input\n                type=\"range\"\n                min=\"10\"\n                max=\"100\"\n                step=\"10\"\n                value={filters.memoryLimit}\n                onChange={(e) =>\n                  onFiltersChange({ ...filters, memoryLimit: parseInt(e.target.value) })\n                }\n                className=\"w-full h-1.5 rounded-lg appearance-none bg-surface-sunken accent-primary cursor-pointer\"\n              />\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Display Options Section */}\n      <div className=\"space-y-3\">\n        <button\n          onClick={() => setExpandedSection(expandedSection === 'display' ? null : 'display')}\n          className=\"flex items-center justify-between w-full text-left\"\n        >\n          <div className=\"flex items-center gap-2 text-sm font-medium text-foreground-muted\">\n            {icons.display}\n            <span>Display</span>\n          </div>\n          {expandedSection === 'display' ? icons.chevronUp : icons.chevronDown}\n        </button>\n\n        {expandedSection === 'display' && (\n          <div className=\"space-y-4 pl-6\">\n            {/* Toggle Options */}\n            <div className=\"space-y-2\">\n              <label className=\"flex items-center justify-between cursor-pointer\">\n                <span className=\"text-xs text-foreground-muted\">Show Particles</span>\n                <input\n                  type=\"checkbox\"\n                  checked={displayOptions.showParticles}\n                  onChange={(e) =>\n                    onDisplayOptionsChange({ ...displayOptions, showParticles: e.target.checked })\n                  }\n                  className=\"w-3.5 h-3.5 rounded border-border bg-surface-sunken text-primary focus:ring-1 focus:ring-primary\"\n                />\n              </label>\n              <label className=\"flex items-center justify-between cursor-pointer\">\n                <span className=\"text-xs text-foreground-muted\">Show Labels</span>\n                <input\n                  type=\"checkbox\"\n                  checked={displayOptions.showLabels}\n                  onChange={(e) =>\n                    onDisplayOptionsChange({ ...displayOptions, showLabels: e.target.checked })\n                  }\n                  className=\"w-3.5 h-3.5 rounded border-border bg-surface-sunken text-primary focus:ring-1 focus:ring-primary\"\n                />\n              </label>\n            </div>\n\n            {/* Edge Types */}\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <span className=\"text-xs text-foreground-muted\">Edge Types</span>\n                <button\n                  onClick={toggleAllEdgeTypes}\n                  className=\"text-xs text-primary hover:text-primary-hover transition-colors\"\n                >\n                  {displayOptions.visibleEdgeTypes.length === EDGE_TYPES.length ? 'None' : 'All'}\n                </button>\n              </div>\n              <div className=\"space-y-1.5\">\n                {EDGE_TYPES.map((type) => (\n                  <label\n                    key={type.value}\n                    className=\"flex items-center gap-2 cursor-pointer group\"\n                  >\n                    <input\n                      type=\"checkbox\"\n                      checked={displayOptions.visibleEdgeTypes.includes(type.value)}\n                      onChange={() => toggleEdgeType(type.value)}\n                      className=\"w-3.5 h-3.5 rounded border-border bg-surface-sunken text-primary focus:ring-1 focus:ring-primary\"\n                    />\n                    <span\n                      className=\"w-4 h-0.5 flex-none rounded\"\n                      style={{ backgroundColor: type.color }}\n                    />\n                    <span className=\"text-xs text-foreground-muted group-hover:text-foreground transition-colors\">\n                      {type.label}\n                    </span>\n                  </label>\n                ))}\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "expandedSection",
        "setExpandedSection",
        "useState",
        "useCallback",
        "filters",
        "t",
        "onFiltersChange",
        "newTypes",
        "displayOptions",
        "onDisplayOptionsChange",
        "ENTITY_TYPES",
        "allSelected",
        "EDGE_TYPES",
        "collapsed",
        "div",
        "className",
        "button",
        "onClick",
        "onToggleCollapsed",
        "icons",
        "span",
        "h3",
        "toggleAllEntityTypes",
        "label",
        "key",
        "input",
        "checked",
        "onChange",
        "toggleEntityType",
        "style",
        "min",
        "max",
        "value",
        "parseInt",
        "e",
        "step",
        "toggleAllEdgeTypes",
        "toggleEdgeType"
      ]
    },
    "file:web/src/components/graph/index.ts": {
      "id": "file:web/src/components/graph/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/graph/index.ts",
      "line": 1,
      "endLine": 15,
      "imports": [],
      "exports": [
        {
          "name": "GraphControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphControlsProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphDisplayOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DEFAULT_GRAPH_FILTERS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DEFAULT_DISPLAY_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "GraphContextMenu",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphContextMenuProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SelectionDetailsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SelectionDetailsPanelProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "GraphControlsProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "GraphFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "GraphDisplayOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "DEFAULT_GRAPH_FILTERS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "DEFAULT_DISPLAY_OPTIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphControls"
        },
        {
          "name": "GraphContextMenu",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphContextMenu"
        },
        {
          "name": "GraphContextMenuProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GraphContextMenu"
        },
        {
          "name": "SelectionDetailsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./SelectionDetailsPanel"
        },
        {
          "name": "SelectionDetailsPanelProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./SelectionDetailsPanel"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/graph/SelectionDetailsPanel.tsx": {
      "id": "file:web/src/components/graph/SelectionDetailsPanel.tsx",
      "type": "file",
      "name": "SelectionDetailsPanel.tsx",
      "filePath": "web/src/components/graph/SelectionDetailsPanel.tsx",
      "line": 1,
      "endLine": 448,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "ForceGraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphLink",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEntityNeighbors",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "SelectionDetailsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SelectionDetailsPanelProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SelectionDetailsPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:EntityDetails:77",
        "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:MemoryDetails:224",
        "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:SelectionDetailsPanel:383"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:EntityDetails:77": {
      "id": "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:EntityDetails:77",
      "type": "function",
      "name": "EntityDetails",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/graph/SelectionDetailsPanel.tsx",
      "line": 77,
      "endLine": 218,
      "parentFileId": "file:web/src/components/graph/SelectionDetailsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  entityId,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n}",
          "type": "{ entityId: string; graphData: { nodes: ForceGraphNode[]; links: ForceGraphLink[]; }; onEntityClick?: (id: string) => void; onMemoryClick?: (id: string) => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering entity details, connected memories from graph, with loading/not found states",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function EntityDetails({\n  entityId,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n}: {\n  entityId: string;\n  graphData: { nodes: ForceGraphNode[]; links: ForceGraphLink[] } | null;\n  onEntityClick?: (id: string) => void;\n  onMemoryClick?: (id: string) => void;\n}) {\n  const { data: entity, isLoading } = useEntity(entityId);\n  const { data: neighbors } = useEntityNeighbors(entityId, { limit: 5 });\n\n  // Find connected memories from graph\n  const connectedMemories = useMemo(() => {\n    if (!graphData) return [];\n    const memoryIds = new Set<string>();\n\n    graphData.links.forEach((link) => {\n      const source = typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n      const target = typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n\n      if (source === entityId) {\n        const targetNode = graphData.nodes.find((n) => n.id === target);\n        if (targetNode?.type === 'memory') memoryIds.add(target);\n      }\n      if (target === entityId) {\n        const sourceNode = graphData.nodes.find((n) => n.id === source);\n        if (sourceNode?.type === 'memory') memoryIds.add(source);\n      }\n    });\n\n    return graphData.nodes.filter((n) => memoryIds.has(n.id));\n  }, [graphData, entityId]);\n\n  if (isLoading) {\n    return (\n      <div className=\"p-4 space-y-3\">\n        <div className=\"h-4 w-3/4 bg-surface-sunken rounded animate-pulse\" />\n        <div className=\"h-3 w-1/2 bg-surface-sunken rounded animate-pulse\" />\n        <div className=\"h-20 bg-surface-sunken rounded animate-pulse\" />\n      </div>\n    );\n  }\n\n  if (!entity) {\n    return (\n      <div className=\"p-4 text-sm text-foreground-muted\">\n        Entity not found\n      </div>\n    );\n  }\n\n  const entityType = entity.type || 'unknown';\n  const typeColor = ENTITY_TYPE_COLORS[entityType] || '#64748b';\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Header */}\n      <div className=\"flex items-start gap-3\">\n        <div\n          className=\"w-10 h-10 rounded-lg flex items-center justify-center flex-none\"\n          style={{ backgroundColor: `${typeColor}20`, borderColor: `${typeColor}40`, borderWidth: 1 }}\n        >\n          <span style={{ color: typeColor }}>{icons.entity}</span>\n        </div>\n        <div className=\"min-w-0 flex-1\">\n          <h3 className=\"text-sm font-medium text-foreground truncate\">{entity.name}</h3>\n          <p className=\"text-xs text-foreground-muted capitalize\">{entityType}</p>\n        </div>\n      </div>\n\n      {/* Stats */}\n      <div className=\"grid grid-cols-2 gap-2 text-xs\">\n        <div className=\"px-2 py-1.5 rounded bg-surface-sunken\">\n          <span className=\"text-foreground-muted\">Mentions</span>\n          <span className=\"float-right text-foreground font-medium\">{entity.mention_count || 0}</span>\n        </div>\n        <div className=\"px-2 py-1.5 rounded bg-surface-sunken\">\n          <span className=\"text-foreground-muted\">Related</span>\n          <span className=\"float-right text-foreground font-medium\">{neighbors?.neighborCount || 0}</span>\n        </div>\n      </div>\n\n      {/* Connected Memories */}\n      {connectedMemories.length > 0 && (\n        <div className=\"space-y-2\">\n          <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n            Connected Memories ({connectedMemories.length})\n          </h4>\n          <div className=\"space-y-1\">\n            {connectedMemories.slice(0, 5).map((memory) => (\n              <button\n                key={memory.id}\n                onClick={() => onMemoryClick?.(memory.id)}\n                className=\"w-full text-left px-2 py-1.5 rounded text-xs bg-surface-sunken hover:bg-border transition-colors flex items-center gap-2 group\"\n              >\n                <span className=\"w-1.5 h-1.5 rounded-full bg-blue-400 flex-none\" />\n                <span className=\"truncate flex-1 text-foreground-muted group-hover:text-foreground\">\n                  {memory.label}\n                </span>\n                <span className=\"text-foreground-muted opacity-0 group-hover:opacity-100 transition-opacity\">\n                  {icons.chevronRight}\n                </span>\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Related Entities */}\n      {neighbors && neighbors.neighbors.length > 0 && (\n        <div className=\"space-y-2\">\n          <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n            Related Entities ({neighbors.neighborCount})\n          </h4>\n          <div className=\"space-y-1\">\n            {neighbors.neighbors.slice(0, 5).map((neighbor) => (\n              <button\n                key={neighbor.id}\n                onClick={() => onEntityClick?.(neighbor.id)}\n                className=\"w-full text-left px-2 py-1.5 rounded text-xs bg-surface-sunken hover:bg-border transition-colors flex items-center gap-2 group\"\n              >\n                <span\n                  className=\"w-1.5 h-1.5 rounded-full flex-none\"\n                  style={{ backgroundColor: ENTITY_TYPE_COLORS[neighbor.type] || '#64748b' }}\n                />\n                <span className=\"truncate flex-1 text-foreground-muted group-hover:text-foreground\">\n                  {neighbor.name}\n                </span>\n                <span className=\"text-[10px] text-foreground-muted\">\n                  {neighbor.sharedMemoryCount} shared\n                </span>\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "data",
        "entity",
        "isLoading",
        "useEntity",
        "entityId",
        "neighbors",
        "useEntityNeighbors",
        "useMemo",
        "graphData",
        "Set",
        "link",
        "source",
        "n",
        "target",
        "targetNode",
        "memoryIds",
        "sourceNode",
        "div",
        "className",
        "ENTITY_TYPE_COLORS",
        "entityType",
        "style",
        "typeColor",
        "span",
        "icons",
        "h3",
        "p",
        "connectedMemories",
        "h4",
        "button",
        "key",
        "memory",
        "onClick",
        "onMemoryClick",
        "neighbor",
        "onEntityClick"
      ]
    },
    "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:MemoryDetails:224": {
      "id": "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:MemoryDetails:224",
      "type": "function",
      "name": "MemoryDetails",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/graph/SelectionDetailsPanel.tsx",
      "line": 224,
      "endLine": 377,
      "parentFileId": "file:web/src/components/graph/SelectionDetailsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  memoryId,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n}",
          "type": "{ memoryId: string; graphData: { nodes: ForceGraphNode[]; links: ForceGraphLink[]; }; onEntityClick?: (id: string) => void; onMemoryClick?: (id: string) => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders memory details panel with loading state, connected entities, and similar memories from graph data",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function MemoryDetails({\n  memoryId,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n}: {\n  memoryId: string;\n  graphData: { nodes: ForceGraphNode[]; links: ForceGraphLink[] } | null;\n  onEntityClick?: (id: string) => void;\n  onMemoryClick?: (id: string) => void;\n}) {\n  const { data: memory, isLoading } = useMemory(memoryId);\n\n  // Find connected entities and similar memories from graph\n  const { connectedEntities, similarMemories } = useMemo(() => {\n    if (!graphData) return { connectedEntities: [], similarMemories: [] };\n\n    // Use Maps to dedupe by id (same node can be connected via multiple links)\n    const entitiesMap = new Map<string, ForceGraphNode>();\n    const memoriesMap = new Map<string, ForceGraphNode>();\n\n    graphData.links.forEach((link) => {\n      const source = typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n      const target = typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n\n      if (source === memoryId || target === memoryId) {\n        const otherId = source === memoryId ? target : source;\n        const otherNode = graphData.nodes.find((n) => n.id === otherId);\n\n        if (otherNode?.type === 'entity' && !entitiesMap.has(otherNode.id)) {\n          entitiesMap.set(otherNode.id, otherNode);\n        } else if (otherNode?.type === 'memory' && link.type === 'SIMILAR' && !memoriesMap.has(otherNode.id)) {\n          memoriesMap.set(otherNode.id, otherNode);\n        }\n      }\n    });\n\n    return {\n      connectedEntities: Array.from(entitiesMap.values()),\n      similarMemories: Array.from(memoriesMap.values())\n    };\n  }, [graphData, memoryId]);\n\n  if (isLoading) {\n    return (\n      <div className=\"p-4 space-y-3\">\n        <div className=\"h-4 w-3/4 bg-surface-sunken rounded animate-pulse\" />\n        <div className=\"h-3 w-1/2 bg-surface-sunken rounded animate-pulse\" />\n        <div className=\"h-32 bg-surface-sunken rounded animate-pulse\" />\n      </div>\n    );\n  }\n\n  if (!memory) {\n    return (\n      <div className=\"p-4 text-sm text-foreground-muted\">\n        Memory not found\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Header */}\n      <div className=\"flex items-start gap-3\">\n        <div className=\"w-10 h-10 rounded-lg flex items-center justify-center flex-none bg-blue-500/10 border border-blue-500/30\">\n          <span className=\"text-blue-400\">{icons.memory}</span>\n        </div>\n        <div className=\"min-w-0 flex-1\">\n          <h3 className=\"text-sm font-medium text-foreground line-clamp-2\">\n            {memory.content?.slice(0, 100)}...\n          </h3>\n          <p className=\"text-xs text-foreground-muted mt-0.5\">\n            {new Date(memory.created_at).toLocaleDateString()}\n          </p>\n        </div>\n      </div>\n\n      {/* Salience */}\n      <div className=\"space-y-1.5\">\n        <div className=\"flex items-center justify-between text-xs\">\n          <span className=\"text-foreground-muted\">Salience</span>\n          <span className=\"text-foreground font-medium\">\n            {Math.round((memory.salience || 0) * 100)}%\n          </span>\n        </div>\n        <div className=\"h-1.5 bg-surface-sunken rounded-full overflow-hidden\">\n          <div\n            className=\"h-full bg-gradient-to-r from-blue-500 to-cyan-400 rounded-full\"\n            style={{ width: `${(memory.salience || 0) * 100}%` }}\n          />\n        </div>\n      </div>\n\n      {/* Content Preview */}\n      <div className=\"space-y-2\">\n        <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n          Content\n        </h4>\n        <div className=\"text-xs text-foreground-muted bg-surface-sunken rounded p-2 max-h-24 overflow-y-auto\">\n          {memory.content}\n        </div>\n      </div>\n\n      {/* Connected Entities */}\n      {connectedEntities.length > 0 && (\n        <div className=\"space-y-2\">\n          <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n            Entities ({connectedEntities.length})\n          </h4>\n          <div className=\"flex flex-wrap gap-1\">\n            {connectedEntities.slice(0, 8).map((entity) => {\n              const entityType = (entity.attributes?.type as string) || 'unknown';\n              const color = ENTITY_TYPE_COLORS[entityType] || '#64748b';\n              return (\n                <button\n                  key={entity.id}\n                  onClick={() => onEntityClick?.(entity.id)}\n                  className=\"px-2 py-1 rounded text-xs hover:opacity-80 transition-opacity\"\n                  style={{ backgroundColor: `${color}20`, color }}\n                >\n                  {entity.label}\n                </button>\n              );\n            })}\n          </div>\n        </div>\n      )}\n\n      {/* Similar Memories */}\n      {similarMemories.length > 0 && (\n        <div className=\"space-y-2\">\n          <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n            Similar Memories ({similarMemories.length})\n          </h4>\n          <div className=\"space-y-1\">\n            {similarMemories.slice(0, 3).map((mem) => (\n              <button\n                key={mem.id}\n                onClick={() => onMemoryClick?.(mem.id)}\n                className=\"w-full text-left px-2 py-1.5 rounded text-xs bg-surface-sunken hover:bg-border transition-colors flex items-center gap-2 group\"\n              >\n                <span className=\"w-1.5 h-1.5 rounded-full bg-blue-400 flex-none\" />\n                <span className=\"truncate flex-1 text-foreground-muted group-hover:text-foreground\">\n                  {mem.label}\n                </span>\n              </button>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "data",
        "memory",
        "isLoading",
        "useMemory",
        "memoryId",
        "connectedEntities",
        "similarMemories",
        "useMemo",
        "graphData",
        "Map",
        "link",
        "source",
        "target",
        "n",
        "otherId",
        "otherNode",
        "entitiesMap",
        "memoriesMap",
        "Array",
        "div",
        "className",
        "span",
        "icons",
        "h3",
        "p",
        "Date",
        "Math",
        "style",
        "h4",
        "entity",
        "ENTITY_TYPE_COLORS",
        "entityType",
        "button",
        "key",
        "onClick",
        "onEntityClick",
        "color",
        "mem",
        "onMemoryClick"
      ]
    },
    "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:SelectionDetailsPanel:383": {
      "id": "file:web/src/components/graph/SelectionDetailsPanel.tsx:fn:SelectionDetailsPanel:383",
      "type": "function",
      "name": "SelectionDetailsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/graph/SelectionDetailsPanel.tsx",
      "line": 383,
      "endLine": 445,
      "parentFileId": "file:web/src/components/graph/SelectionDetailsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  selectedNode,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n  onClearSelection,\n  className = '',\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/graph/SelectionDetailsPanel\").SelectionDetailsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders UI panel for selected graph node details or placeholder.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function SelectionDetailsPanel({\n  selectedNode,\n  graphData,\n  onEntityClick,\n  onMemoryClick,\n  onClearSelection,\n  className = '',\n}: SelectionDetailsPanelProps) {\n  if (!selectedNode) {\n    return (\n      <div className={`flex flex-col items-center justify-center text-center p-6 ${className}`}>\n        <div className=\"w-12 h-12 rounded-full bg-surface-sunken flex items-center justify-center mb-3\">\n          <span className=\"text-foreground-muted\">{icons.link}</span>\n        </div>\n        <p className=\"text-sm text-foreground-muted\">\n          Click a node to view details\n        </p>\n        <p className=\"text-xs text-foreground-muted mt-1\">\n          Double-click to zoom in\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between px-4 py-3 border-b border-border\">\n        <h3 className=\"text-sm font-medium text-foreground\">\n          {selectedNode.type === 'entity' ? 'Entity' : 'Memory'} Details\n        </h3>\n        {onClearSelection && (\n          <button\n            onClick={onClearSelection}\n            className=\"p-1 rounded hover:bg-surface-sunken transition-colors text-foreground-muted hover:text-foreground\"\n            title=\"Close\"\n          >\n            {icons.close}\n          </button>\n        )}\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        {selectedNode.type === 'entity' ? (\n          <EntityDetails\n            entityId={selectedNode.id}\n            graphData={graphData}\n            onEntityClick={onEntityClick}\n            onMemoryClick={onMemoryClick}\n          />\n        ) : (\n          <MemoryDetails\n            memoryId={selectedNode.id}\n            graphData={graphData}\n            onEntityClick={onEntityClick}\n            onMemoryClick={onMemoryClick}\n          />\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "selectedNode",
        "div",
        "className",
        "span",
        "icons",
        "p",
        "h3",
        "onClearSelection",
        "button",
        "onClick",
        "title",
        "EntityDetails",
        "entityId",
        "graphData",
        "onEntityClick",
        "onMemoryClick",
        "MemoryDetails",
        "memoryId"
      ]
    },
    "file:web/src/components/layout/AppLayout.tsx": {
      "id": "file:web/src/components/layout/AppLayout.tsx",
      "type": "file",
      "name": "AppLayout.tsx",
      "filePath": "web/src/components/layout/AppLayout.tsx",
      "line": 1,
      "endLine": 218,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./HeaderBar",
          "items": [
            {
              "name": "HeaderBar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./SideNav",
          "items": [
            {
              "name": "SideNav",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/shared/Toast",
          "items": [
            {
              "name": "ToastProvider",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useToast",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useWebSocket",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useNavigationGuard",
          "items": [
            {
              "name": "useChatNavigationGuard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "AppLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/layout/AppLayout.tsx:fn:SocketToastListener:15",
        "file:web/src/components/layout/AppLayout.tsx:fn:NavigationGuardProvider:38",
        "file:web/src/components/layout/AppLayout.tsx:fn:MessageRecoveryProvider:45",
        "file:web/src/components/layout/AppLayout.tsx:fn:AppLayout:158"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/layout/AppLayout.tsx:fn:SocketToastListener:15": {
      "id": "file:web/src/components/layout/AppLayout.tsx:fn:SocketToastListener:15",
      "type": "function",
      "name": "SocketToastListener",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/AppLayout.tsx",
      "line": 15,
      "endLine": 35,
      "parentFileId": "file:web/src/components/layout/AppLayout.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Sets up WebSocket listeners to show toasts for new commitments and reminders.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function SocketToastListener() {\n  const { showToast } = useToast();\n  const { onCommitmentCreated, onReminderCreated } = useWebSocket();\n\n  useEffect(() => {\n    const unsubCommitment = onCommitmentCreated((data) => {\n      showToast(`Scheduled: ${data.title}`, 'success', 6000);\n    });\n\n    const unsubReminder = onReminderCreated((data) => {\n      showToast(`Reminder set: ${data.title}`, 'info', 6000);\n    });\n\n    return () => {\n      unsubCommitment();\n      unsubReminder();\n    };\n  }, [onCommitmentCreated, onReminderCreated, showToast]);\n\n  return null;\n}",
      "references": [
        "showToast",
        "useToast",
        "onCommitmentCreated",
        "onReminderCreated",
        "useWebSocket",
        "useEffect",
        "data",
        "unsubCommitment",
        "unsubReminder"
      ]
    },
    "file:web/src/components/layout/AppLayout.tsx:fn:NavigationGuardProvider:38": {
      "id": "file:web/src/components/layout/AppLayout.tsx:fn:NavigationGuardProvider:38",
      "type": "function",
      "name": "NavigationGuardProvider",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/AppLayout.tsx",
      "line": 38,
      "endLine": 42,
      "parentFileId": "file:web/src/components/layout/AppLayout.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Activates chat navigation guard via hook and renders nothing.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function NavigationGuardProvider() {\n  // Activate the chat navigation guard for the entire app\n  useChatNavigationGuard();\n  return null;\n}",
      "references": [
        "useChatNavigationGuard"
      ]
    },
    "file:web/src/components/layout/AppLayout.tsx:fn:MessageRecoveryProvider:45": {
      "id": "file:web/src/components/layout/AppLayout.tsx:fn:MessageRecoveryProvider:45",
      "type": "function",
      "name": "MessageRecoveryProvider",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/AppLayout.tsx",
      "line": 45,
      "endLine": 156,
      "parentFileId": "file:web/src/components/layout/AppLayout.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component recovers unsent chat messages from store, shows banner with copy/dismiss.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function MessageRecoveryProvider() {\n  const { showToast } = useToast();\n  const [recoveredMessages, setRecoveredMessages] = useState<Array<{ id: string; content: string }>>([]);\n  const [showRecoveryBanner, setShowRecoveryBanner] = useState(false);\n\n  useEffect(() => {\n    // Check for orphaned messages on mount (client-side only)\n    const checkOrphanedMessages = async () => {\n      const { useChatStore } = await import('@/lib/stores/chatStore');\n      const orphaned = useChatStore.getState().recoverOrphanedMessages();\n\n      if (orphaned.length > 0) {\n        setRecoveredMessages(orphaned.map((m) => ({ id: m.id, content: m.content })));\n        setShowRecoveryBanner(true);\n        showToast(\n          `Found ${orphaned.length} unsent message(s) from your last session`,\n          'info',\n          10000\n        );\n      }\n    };\n\n    // Small delay to ensure client hydration\n    const timeout = setTimeout(checkOrphanedMessages, 500);\n    return () => clearTimeout(timeout);\n  }, [showToast]);\n\n  const handleDismiss = async () => {\n    const { useChatStore } = await import('@/lib/stores/chatStore');\n    useChatStore.getState().clearPendingBackup();\n    setShowRecoveryBanner(false);\n    setRecoveredMessages([]);\n  };\n\n  const handleCopy = (content: string) => {\n    navigator.clipboard.writeText(content);\n    showToast('Message copied to clipboard', 'success', 3000);\n  };\n\n  if (!showRecoveryBanner || recoveredMessages.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-50 max-w-md animate-fade-in\">\n      <div className=\"bg-yellow-500/10 border border-yellow-500/30 rounded-xl p-4 shadow-lg backdrop-blur-sm\">\n        <div className=\"flex items-start gap-3\">\n          <div className=\"shrink-0 w-8 h-8 rounded-full bg-yellow-500/20 flex items-center justify-center\">\n            <svg\n              className=\"w-4 h-4 text-yellow-400\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n              />\n            </svg>\n          </div>\n          <div className=\"flex-1 min-w-0\">\n            <h3 className=\"font-medium text-yellow-400 text-sm\">\n              Recovered Message{recoveredMessages.length > 1 ? 's' : ''}\n            </h3>\n            <p className=\"text-foreground-muted text-xs mt-1\">\n              {recoveredMessages.length === 1\n                ? 'A message was not saved before you left.'\n                : `${recoveredMessages.length} messages were not saved before you left.`}\n            </p>\n            <div className=\"mt-3 space-y-2 max-h-32 overflow-y-auto\">\n              {recoveredMessages.map((msg) => (\n                <div\n                  key={msg.id}\n                  className=\"bg-background-secondary/50 rounded-lg p-2 text-xs text-foreground-muted\"\n                >\n                  <p className=\"line-clamp-2\">{msg.content}</p>\n                  <button\n                    onClick={() => handleCopy(msg.content)}\n                    className=\"mt-1 text-primary hover:text-primary-hover text-xs underline\"\n                  >\n                    Copy to clipboard\n                  </button>\n                </div>\n              ))}\n            </div>\n            <button\n              onClick={handleDismiss}\n              className=\"mt-3 text-xs text-foreground-muted hover:text-foreground underline\"\n            >\n              Dismiss\n            </button>\n          </div>\n          <button\n            onClick={handleDismiss}\n            className=\"shrink-0 text-foreground-muted hover:text-foreground\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M6 18L18 6M6 6l12 12\"\n              />\n            </svg>\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "showToast",
        "useToast",
        "recoveredMessages",
        "setRecoveredMessages",
        "useState",
        "showRecoveryBanner",
        "setShowRecoveryBanner",
        "useEffect",
        "useChatStore",
        "orphaned",
        "m",
        "setTimeout",
        "checkOrphanedMessages",
        "clearTimeout",
        "timeout",
        "navigator",
        "content",
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h3",
        "p",
        "key",
        "msg",
        "button",
        "onClick",
        "handleCopy",
        "handleDismiss"
      ]
    },
    "file:web/src/components/layout/AppLayout.tsx:fn:AppLayout:158": {
      "id": "file:web/src/components/layout/AppLayout.tsx:fn:AppLayout:158",
      "type": "function",
      "name": "AppLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/AppLayout.tsx",
      "line": 158,
      "endLine": 217,
      "parentFileId": "file:web/src/components/layout/AppLayout.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ children }",
          "type": "AppLayoutProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for app layout with side nav, header, and mobile nav state management.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function AppLayout({ children }: AppLayoutProps) {\n  const [isSideNavOpen, setIsSideNavOpen] = useState(false);\n  const [isSideNavCollapsed, setIsSideNavCollapsed] = useState(false);\n\n  // Close mobile nav on resize to desktop\n  useEffect(() => {\n    const handleResize = () => {\n      if (window.innerWidth >= 1024) {\n        setIsSideNavOpen(false);\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Prevent body scroll when mobile nav is open\n  useEffect(() => {\n    if (isSideNavOpen) {\n      document.body.style.overflow = 'hidden';\n    } else {\n      document.body.style.overflow = '';\n    }\n\n    return () => {\n      document.body.style.overflow = '';\n    };\n  }, [isSideNavOpen]);\n\n  return (\n    <ToastProvider>\n      <SocketToastListener />\n      <NavigationGuardProvider />\n      <MessageRecoveryProvider />\n      <div className=\"h-screen flex flex-col bg-background overflow-hidden pt-[env(safe-area-inset-top)] pb-[env(safe-area-inset-bottom)]\">\n        {/* Header */}\n        <HeaderBar\n          onMenuToggle={() => setIsSideNavOpen(!isSideNavOpen)}\n          isSideNavOpen={isSideNavOpen}\n        />\n\n        {/* Main content area with sidebar */}\n        <div className=\"flex-1 flex overflow-hidden\">\n          {/* Sidebar */}\n          <SideNav\n            isOpen={isSideNavOpen}\n            onClose={() => setIsSideNavOpen(false)}\n            isCollapsed={isSideNavCollapsed}\n            onToggleCollapse={() => setIsSideNavCollapsed(!isSideNavCollapsed)}\n          />\n\n          {/* Page content */}\n          <main className=\"flex-1 overflow-auto\">\n            {children}\n          </main>\n        </div>\n      </div>\n    </ToastProvider>\n  );\n}",
      "references": [
        "isSideNavOpen",
        "setIsSideNavOpen",
        "useState",
        "isSideNavCollapsed",
        "setIsSideNavCollapsed",
        "useEffect",
        "window",
        "handleResize",
        "document",
        "ToastProvider",
        "SocketToastListener",
        "NavigationGuardProvider",
        "MessageRecoveryProvider",
        "div",
        "className",
        "HeaderBar",
        "onMenuToggle",
        "SideNav",
        "isOpen",
        "onClose",
        "isCollapsed",
        "onToggleCollapse",
        "main",
        "children"
      ]
    },
    "file:web/src/components/layout/HeaderBar.tsx": {
      "id": "file:web/src/components/layout/HeaderBar.tsx",
      "type": "file",
      "name": "HeaderBar.tsx",
      "filePath": "web/src/components/layout/HeaderBar.tsx",
      "line": 1,
      "endLine": 109,
      "imports": [
        {
          "source": "@/lib/hooks/useWebSocket",
          "items": [
            {
              "name": "useWebSocket",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "HeaderBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/layout/HeaderBar.tsx:fn:HeaderBar:10"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/layout/HeaderBar.tsx:fn:HeaderBar:10": {
      "id": "file:web/src/components/layout/HeaderBar.tsx:fn:HeaderBar:10",
      "type": "function",
      "name": "HeaderBar",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/HeaderBar.tsx",
      "line": 10,
      "endLine": 108,
      "parentFileId": "file:web/src/components/layout/HeaderBar.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onMenuToggle, isSideNavOpen }",
          "type": "HeaderBarProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders header bar with mobile menu toggle, logo, and WebSocket status.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function HeaderBar({ onMenuToggle, isSideNavOpen }: HeaderBarProps) {\n  // Real WebSocket connection status (P6-T6)\n  const { isConnected, latency } = useWebSocket();\n\n  return (\n    <header className=\"h-14 bg-background-secondary border-b border-glass-border flex items-center justify-between px-4 shrink-0\">\n      {/* Left: Menu button (mobile) + Logo */}\n      <div className=\"flex items-center gap-3\">\n        {/* Mobile menu toggle */}\n        <button\n          onClick={onMenuToggle}\n          className=\"lg:hidden p-2 rounded-md hover:bg-background-tertiary transition-colors\"\n          aria-label={isSideNavOpen ? 'Close menu' : 'Open menu'}\n        >\n          <svg\n            className=\"w-5 h-5 text-foreground\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            {isSideNavOpen ? (\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M6 18L18 6M6 6l12 12\"\n              />\n            ) : (\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M4 6h16M4 12h16M4 18h16\"\n              />\n            )}\n          </svg>\n        </button>\n\n        {/* Logo */}\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-xl font-bold text-primary glow-text-primary\">\n            Squire\n          </span>\n        </div>\n      </div>\n\n      {/* Center: Reserved for breadcrumb/title */}\n      <div className=\"hidden md:flex items-center\">\n        {/* Will be populated by page context later */}\n      </div>\n\n      {/* Right: Status + Profile */}\n      <div className=\"flex items-center gap-4\">\n        {/* WebSocket connection status (P6-T6) */}\n        <div\n          className={`flex items-center gap-2 px-2 py-1 rounded-md ${\n            isConnected ? '' : 'bg-error/20 border border-error/50'\n          }`}\n        >\n          <div\n            className={`w-2 h-2 rounded-full ${\n              isConnected\n                ? 'bg-success animate-pulse'\n                : 'bg-error animate-pulse'\n            }`}\n            title={isConnected ? `Connected${latency ? ` (${latency}ms)` : ''}` : 'Disconnected - messages may not be saved'}\n          />\n          <span className={`text-xs ${isConnected ? 'hidden sm:inline text-foreground-muted' : 'text-error font-medium'}`}>\n            {isConnected ? (\n              <>Live{latency ? <span className=\"text-foreground-subtle ml-1\">({latency}ms)</span> : ''}</>\n            ) : (\n              'Offline - Refresh'\n            )}\n          </span>\n        </div>\n\n        {/* Profile placeholder */}\n        <button\n          className=\"w-8 h-8 rounded-full bg-background-tertiary border border-glass-border flex items-center justify-center hover:border-primary transition-colors\"\n          aria-label=\"Profile\"\n        >\n          <svg\n            className=\"w-4 h-4 text-foreground-muted\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path\n              strokeLinecap=\"round\"\n              strokeLinejoin=\"round\"\n              strokeWidth={2}\n              d=\"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\"\n            />\n          </svg>\n        </button>\n      </div>\n    </header>\n  );\n}",
      "references": [
        "isConnected",
        "latency",
        "useWebSocket",
        "header",
        "className",
        "div",
        "button",
        "onClick",
        "onMenuToggle",
        "aria-label",
        "isSideNavOpen",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "span",
        "title"
      ]
    },
    "file:web/src/components/layout/index.ts": {
      "id": "file:web/src/components/layout/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/layout/index.ts",
      "line": 1,
      "endLine": 4,
      "imports": [],
      "exports": [
        {
          "name": "AppLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "HeaderBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SideNav",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "AppLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./AppLayout"
        },
        {
          "name": "HeaderBar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./HeaderBar"
        },
        {
          "name": "SideNav",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./SideNav"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/layout/OverlayPortal.tsx": {
      "id": "file:web/src/components/layout/OverlayPortal.tsx",
      "type": "file",
      "name": "OverlayPortal.tsx",
      "filePath": "web/src/components/layout/OverlayPortal.tsx",
      "line": 1,
      "endLine": 48,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "react-dom",
          "items": [
            {
              "name": "createPortal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "OverlayPortal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "OverlayPortal",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/layout/OverlayPortal.tsx:fn:OverlayPortal:15"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/layout/OverlayPortal.tsx:fn:OverlayPortal:15": {
      "id": "file:web/src/components/layout/OverlayPortal.tsx:fn:OverlayPortal:15",
      "type": "function",
      "name": "OverlayPortal",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/OverlayPortal.tsx",
      "line": 15,
      "endLine": 45,
      "parentFileId": "file:web/src/components/layout/OverlayPortal.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  children,\n  containerId = 'overlay-root',\n}",
          "type": "OverlayPortalProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.ReactPortal",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates/finds fixed overlay container and portals children into it",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function OverlayPortal({\n  children,\n  containerId = 'overlay-root',\n}: OverlayPortalProps) {\n  const [mounted, setMounted] = useState(false);\n  const [container, setContainer] = useState<HTMLElement | null>(null);\n\n  useEffect(() => {\n    setMounted(true);\n\n    // Get or create container\n    let element = document.getElementById(containerId);\n    if (!element) {\n      element = document.createElement('div');\n      element.id = containerId;\n      element.className = 'fixed inset-0 pointer-events-none z-50';\n      document.body.appendChild(element);\n    }\n    setContainer(element);\n\n    return () => {\n      // Don't remove the container on unmount as other portals might use it\n    };\n  }, [containerId]);\n\n  if (!mounted || !container) {\n    return null;\n  }\n\n  return createPortal(children, container);\n}",
      "references": [
        "mounted",
        "setMounted",
        "useState",
        "container",
        "setContainer",
        "useEffect",
        "document",
        "containerId",
        "element",
        "createPortal",
        "children"
      ]
    },
    "file:web/src/components/layout/SideNav.tsx": {
      "id": "file:web/src/components/layout/SideNav.tsx",
      "type": "file",
      "name": "SideNav.tsx",
      "filePath": "web/src/components/layout/SideNav.tsx",
      "line": 1,
      "endLine": 305,
      "imports": [
        {
          "source": "next/link",
          "items": [
            {
              "name": "Link",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/navigation",
          "items": [
            {
              "name": "usePathname",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "SideNav",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/layout/SideNav.tsx:fn:SideNav:202"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/components/layout/SideNav.tsx:fn:SideNav:202": {
      "id": "file:web/src/components/layout/SideNav.tsx:fn:SideNav:202",
      "type": "function",
      "name": "SideNav",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/layout/SideNav.tsx",
      "line": 202,
      "endLine": 304,
      "parentFileId": "file:web/src/components/layout/SideNav.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ isOpen, onClose, isCollapsed, onToggleCollapse }",
          "type": "SideNavProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a responsive sidebar navigation with mobile overlay, collapse toggle, and active link highlighting.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function SideNav({ isOpen, onClose, isCollapsed, onToggleCollapse }: SideNavProps) {\n  const pathname = usePathname();\n\n  return (\n    <>\n      {/* Mobile overlay */}\n      {isOpen && (\n        <div\n          className=\"fixed inset-0 bg-black/50 z-40 lg:hidden\"\n          onClick={onClose}\n          aria-hidden=\"true\"\n        />\n      )}\n\n      {/* Sidebar */}\n      <aside\n        className={`\n          fixed lg:static inset-y-0 left-0 z-50\n          flex flex-col\n          bg-background-secondary border-r border-glass-border\n          transition-all duration-300 ease-in-out\n          pt-[env(safe-area-inset-top)] pb-[env(safe-area-inset-bottom)]\n          ${isOpen ? 'translate-x-0' : '-translate-x-full lg:translate-x-0'}\n          ${isCollapsed ? 'w-16' : 'w-56'}\n        `}\n      >\n        {/* Collapse toggle (desktop only) */}\n        <div className=\"hidden lg:flex justify-end p-2 border-b border-glass-border\">\n          <button\n            onClick={onToggleCollapse}\n            className=\"p-1.5 rounded-md hover:bg-background-tertiary transition-colors\"\n            aria-label={isCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}\n          >\n            <svg\n              className={`w-4 h-4 text-foreground-muted transition-transform ${\n                isCollapsed ? 'rotate-180' : ''\n              }`}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M11 19l-7-7 7-7m8 14l-7-7 7-7\"\n              />\n            </svg>\n          </button>\n        </div>\n\n        {/* Navigation items */}\n        <nav className=\"flex-1 py-4 overflow-y-auto\">\n          <ul className=\"space-y-1 px-2\">\n            {navItems.map((item) => {\n              const isActive = pathname === item.href || pathname.startsWith(item.href + '/');\n\n              return (\n                <li key={item.href}>\n                  <Link\n                    href={item.href}\n                    onClick={() => {\n                      // Close mobile nav on navigation\n                      if (window.innerWidth < 1024) {\n                        onClose();\n                      }\n                    }}\n                    className={`\n                      flex items-center gap-3 px-3 py-2.5 rounded-lg\n                      transition-all duration-200\n                      ${isActive\n                        ? 'bg-primary/10 text-primary border border-primary/30 glow-primary'\n                        : 'text-foreground-muted hover:text-foreground hover:bg-background-tertiary border border-transparent'\n                      }\n                      ${isCollapsed ? 'justify-center' : ''}\n                    `}\n                    title={isCollapsed ? item.label : undefined}\n                  >\n                    <span className={isActive ? 'text-primary' : ''}>\n                      {item.icon}\n                    </span>\n                    {!isCollapsed && (\n                      <span className=\"font-medium text-sm\">{item.label}</span>\n                    )}\n                  </Link>\n                </li>\n              );\n            })}\n          </ul>\n        </nav>\n\n        {/* Bottom section - version/info */}\n        <div className={`p-4 border-t border-glass-border ${isCollapsed ? 'text-center' : ''}`}>\n          {!isCollapsed && (\n            <p className=\"text-xs text-foreground-muted\">\n              Squire v0.1.0\n            </p>\n          )}\n        </div>\n      </aside>\n    </>\n  );\n}",
      "references": [
        "usePathname",
        "isOpen",
        "div",
        "className",
        "onClick",
        "onClose",
        "aria-hidden",
        "aside",
        "isCollapsed",
        "button",
        "onToggleCollapse",
        "aria-label",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "nav",
        "ul",
        "navItems",
        "pathname",
        "item",
        "li",
        "key",
        "Link",
        "href",
        "window",
        "isActive",
        "title",
        "span",
        "p"
      ]
    },
    "file:web/src/components/lists/ActiveListsPanel.tsx": {
      "id": "file:web/src/components/lists/ActiveListsPanel.tsx",
      "type": "file",
      "name": "ActiveListsPanel.tsx",
      "filePath": "web/src/components/lists/ActiveListsPanel.tsx",
      "line": 1,
      "endLine": 100,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/link",
          "items": [
            {
              "name": "Link",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/lists",
          "items": [
            {
              "name": "fetchLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./ListCard",
          "items": [
            {
              "name": "ListCardCompact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ActiveListsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ActiveListsPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ActiveListsPanel.tsx:fn:ActiveListsPanel:14"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ActiveListsPanel.tsx:fn:ActiveListsPanel:14": {
      "id": "file:web/src/components/lists/ActiveListsPanel.tsx:fn:ActiveListsPanel:14",
      "type": "function",
      "name": "ActiveListsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ActiveListsPanel.tsx",
      "line": 14,
      "endLine": 97,
      "parentFileId": "file:web/src/components/lists/ActiveListsPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ limit = 4 }",
          "type": "ActiveListsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component fetching and rendering active checklists with loading state",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ActiveListsPanel({ limit = 4 }: ActiveListsPanelProps) {\n  const [lists, setLists] = useState<List[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  useEffect(() => {\n    async function loadLists() {\n      try {\n        const data = await fetchLists({\n          list_type: 'checklist',\n          limit: limit + 2,\n        });\n        const activeLists = data\n          .filter((l) => {\n            const itemCount = l.item_count ?? 0;\n            const completedCount = l.completed_count ?? 0;\n            return itemCount > 0 && completedCount < itemCount;\n          })\n          .slice(0, limit);\n        setLists(activeLists);\n      } catch (error) {\n        console.error('Failed to load active lists:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    }\n    loadLists();\n  }, [limit]);\n\n  if (isLoading) {\n    return (\n      <div className=\"glass rounded-xl p-4\">\n        <div className=\"flex items-center justify-between mb-4\">\n          <h3 className=\"font-semibold text-foreground\">Active Lists</h3>\n        </div>\n        <div className=\"space-y-2\">\n          {[...Array(3)].map((_, i) => (\n            <div key={i} className=\"animate-pulse h-16 bg-background-tertiary rounded-lg\" />\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 10 }}\n      animate={{ opacity: 1, y: 0 }}\n      className=\"glass rounded-xl p-4\"\n    >\n      <div className=\"flex items-center justify-between mb-4\">\n        <h3 className=\"font-semibold text-foreground flex items-center gap-2\">\n          <span></span>\n          Active Lists\n        </h3>\n        <Link\n          href=\"/app/lists\"\n          className=\"text-xs text-primary hover:text-primary/80 transition-colors\"\n        >\n          View all \n        </Link>\n      </div>\n\n      {lists.length === 0 ? (\n        <div className=\"text-center py-6\">\n          <p className=\"text-sm text-foreground-muted\">No active checklists</p>\n          <Link\n            href=\"/app/lists\"\n            className=\"text-sm text-primary hover:underline mt-1 inline-block\"\n          >\n            Create a list\n          </Link>\n        </div>\n      ) : (\n        <div className=\"space-y-2\">\n          {lists.map((list) => (\n            <Link key={list.id} href={`/app/lists?open=${list.id}`}>\n              <ListCardCompact list={list} />\n            </Link>\n          ))}\n        </div>\n      )}\n    </motion.div>\n  );\n}",
      "references": [
        "lists",
        "setLists",
        "useState",
        "isLoading",
        "setIsLoading",
        "useEffect",
        "fetchLists",
        "limit",
        "data",
        "l",
        "itemCount",
        "completedCount",
        "activeLists",
        "console",
        "error",
        "loadLists",
        "div",
        "className",
        "h3",
        "Array",
        "key",
        "i",
        "motion",
        "initial",
        "animate",
        "span",
        "Link",
        "href",
        "p",
        "list",
        "ListCardCompact"
      ]
    },
    "file:web/src/components/lists/index.ts": {
      "id": "file:web/src/components/lists/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/lists/index.ts",
      "line": 1,
      "endLine": 8,
      "imports": [],
      "exports": [
        {
          "name": "ListCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListCardCompact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListItemRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListDetailView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ActiveListsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListCard"
        },
        {
          "name": "ListCardCompact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListCard"
        },
        {
          "name": "ListItemRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListItemRow"
        },
        {
          "name": "ListView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListView"
        },
        {
          "name": "ListEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListEditor"
        },
        {
          "name": "ListsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListsList"
        },
        {
          "name": "ListDetailView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ListDetailView"
        },
        {
          "name": "ActiveListsPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./ActiveListsPanel"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListCard.tsx": {
      "id": "file:web/src/components/lists/ListCard.tsx",
      "type": "file",
      "name": "ListCard.tsx",
      "filePath": "web/src/components/lists/ListCard.tsx",
      "line": 1,
      "endLine": 240,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListCardCompact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListCard",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListCard.tsx:fn:ListCard:29",
        "file:web/src/components/lists/ListCard.tsx:fn:ListCardCompact:188"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListCard.tsx:fn:ListCard:29": {
      "id": "file:web/src/components/lists/ListCard.tsx:fn:ListCard:29",
      "type": "function",
      "name": "ListCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListCard.tsx",
      "line": 29,
      "endLine": 186,
      "parentFileId": "file:web/src/components/lists/ListCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  list,\n  onOpen,\n  onEdit,\n  onArchive,\n  onDelete,\n  compact = false,\n}",
          "type": "ListCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering interactive list card with progress, hover actions",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ListCard({\n  list,\n  onOpen,\n  onEdit,\n  onArchive,\n  onDelete,\n  compact = false,\n}: ListCardProps) {\n  const [showActions, setShowActions] = useState(false);\n\n  const itemCount = list.item_count ?? 0;\n  const completedCount = list.completed_count ?? 0;\n  const progress = itemCount > 0 ? Math.round((completedCount / itemCount) * 100) : 0;\n\n  return (\n    <motion.div\n      className={`\n        relative glass rounded-lg overflow-hidden\n        transition-all duration-200\n        hover:border-primary/50 cursor-pointer\n        ${list.is_pinned ? 'ring-1 ring-accent-gold/50' : ''}\n        ${list.color ? `border-l-4` : ''}\n      `}\n      style={list.color ? { borderLeftColor: list.color } : undefined}\n      onMouseEnter={() => setShowActions(true)}\n      onMouseLeave={() => setShowActions(false)}\n      onClick={() => onOpen?.(list)}\n      whileHover={{ scale: 1.01 }}\n      whileTap={{ scale: 0.99 }}\n    >\n      <div className={`p-4 ${compact ? 'pb-3' : ''}`}>\n        {/* Header row */}\n        <div className=\"flex items-start justify-between gap-2 mb-2\">\n          <div className=\"flex items-center gap-2 flex-wrap\">\n            {/* Pin indicator */}\n            {list.is_pinned && (\n              <span className=\"text-accent-gold text-sm\" title=\"Pinned\"></span>\n            )}\n            \n            {/* List type icon */}\n            <span className=\"text-sm\" title={listTypeLabels[list.list_type]}>\n              {listTypeIcons[list.list_type] || ''}\n            </span>\n\n            {/* Category badge */}\n            {list.category && (\n              <span className=\"text-xs px-2 py-0.5 rounded-full border bg-gray-500/20 text-gray-400 border-gray-500/30\">\n                {list.category}\n              </span>\n            )}\n          </div>\n\n          {/* Action buttons */}\n          {showActions && (\n            <div className=\"flex items-center gap-1\" onClick={(e) => e.stopPropagation()}>\n              <button\n                onClick={() => onEdit?.(list)}\n                className=\"p-1 rounded hover:bg-background-tertiary transition-colors\"\n                title=\"Edit\"\n              >\n                <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z\" />\n                </svg>\n              </button>\n              <button\n                onClick={() => onArchive?.(list)}\n                className=\"p-1 rounded hover:bg-background-tertiary transition-colors\"\n                title=\"Archive\"\n              >\n                <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4\" />\n                </svg>\n              </button>\n              <button\n                onClick={() => onDelete?.(list)}\n                className=\"p-1 rounded hover:bg-red-500/20 transition-colors\"\n                title=\"Delete\"\n              >\n                <svg className=\"w-4 h-4 text-red-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                </svg>\n              </button>\n            </div>\n          )}\n        </div>\n\n        {/* Name */}\n        <h3 className=\"text-sm font-medium text-foreground mb-1 line-clamp-1\">\n          {list.name}\n        </h3>\n\n        {/* Description */}\n        {list.description && !compact && (\n          <p className=\"text-sm text-foreground-muted line-clamp-2 mb-2\">\n            {list.description}\n          </p>\n        )}\n\n        {/* Progress bar (for checklists) */}\n        {list.list_type === 'checklist' && itemCount > 0 && (\n          <div className=\"mt-3\">\n            <div className=\"flex items-center justify-between text-xs text-foreground-muted mb-1\">\n              <span>{completedCount} of {itemCount} complete</span>\n              <span>{progress}%</span>\n            </div>\n            <div className=\"h-1.5 bg-background-tertiary rounded-full overflow-hidden\">\n              <motion.div\n                className=\"h-full bg-primary rounded-full\"\n                initial={{ width: 0 }}\n                animate={{ width: `${progress}%` }}\n                transition={{ duration: 0.3, ease: 'easeOut' }}\n              />\n            </div>\n          </div>\n        )}\n\n        {/* Simple/ranked just show item count */}\n        {list.list_type !== 'checklist' && itemCount > 0 && (\n          <div className=\"mt-2 text-xs text-foreground-muted\">\n            {itemCount} {itemCount === 1 ? 'item' : 'items'}\n          </div>\n        )}\n\n        {/* Footer */}\n        <div className=\"flex items-center justify-between mt-3 pt-2 border-t border-glass-border\">\n          {/* Entity badge */}\n          {list.primary_entity && (\n            <span className=\"text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary border border-primary/30\">\n              {list.primary_entity.name}\n            </span>\n          )}\n\n          {/* Timestamp */}\n          <span className=\"text-xs text-foreground-muted ml-auto\">\n            {formatRelativeTime(list.updated_at)}\n          </span>\n        </div>\n\n        {/* Tags */}\n        {list.tags.length > 0 && !compact && (\n          <div className=\"flex flex-wrap gap-1 mt-2\">\n            {list.tags.slice(0, 5).map((tag) => (\n              <span\n                key={tag}\n                className=\"text-xs px-1.5 py-0.5 rounded bg-background-tertiary text-foreground-muted\"\n              >\n                #{tag}\n              </span>\n            ))}\n            {list.tags.length > 5 && (\n              <span className=\"text-xs text-foreground-muted\">+{list.tags.length - 5}</span>\n            )}\n          </div>\n        )}\n      </div>\n    </motion.div>\n  );\n}",
      "references": [
        "showActions",
        "setShowActions",
        "useState",
        "list",
        "itemCount",
        "Math",
        "completedCount",
        "motion",
        "className",
        "style",
        "onMouseEnter",
        "onMouseLeave",
        "onClick",
        "onOpen",
        "whileHover",
        "whileTap",
        "div",
        "compact",
        "span",
        "title",
        "listTypeLabels",
        "listTypeIcons",
        "e",
        "button",
        "onEdit",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "onArchive",
        "onDelete",
        "h3",
        "p",
        "progress",
        "initial",
        "animate",
        "transition",
        "formatRelativeTime",
        "key",
        "tag"
      ]
    },
    "file:web/src/components/lists/ListCard.tsx:fn:ListCardCompact:188": {
      "id": "file:web/src/components/lists/ListCard.tsx:fn:ListCardCompact:188",
      "type": "function",
      "name": "ListCardCompact",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListCard.tsx",
      "line": 188,
      "endLine": 237,
      "parentFileId": "file:web/src/components/lists/ListCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  list,\n  onClick,\n}",
          "type": "{ list: List; onClick?: () => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a compact clickable card for a list with icon, name, and progress/items count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function ListCardCompact({\n  list,\n  onClick,\n}: {\n  list: List;\n  onClick?: () => void;\n}) {\n  const itemCount = list.item_count ?? 0;\n  const completedCount = list.completed_count ?? 0;\n  const progress = itemCount > 0 ? Math.round((completedCount / itemCount) * 100) : 0;\n\n  return (\n    <motion.button\n      className={`\n        w-full text-left p-3 rounded-lg\n        glass hover:border-primary/50\n        transition-all duration-200\n        ${list.is_pinned ? 'border-accent-gold/30' : ''}\n      `}\n      whileHover={{ scale: 1.02 }}\n      whileTap={{ scale: 0.98 }}\n      onClick={onClick}\n    >\n      <div className=\"flex items-start gap-2\">\n        <span className=\"text-sm\">{listTypeIcons[list.list_type] || ''}</span>\n        <div className=\"flex-1 min-w-0\">\n          <p className=\"text-sm font-medium text-foreground truncate\">{list.name}</p>\n          {list.list_type === 'checklist' && itemCount > 0 && (\n            <div className=\"mt-1\">\n              <div className=\"h-1 bg-background-tertiary rounded-full overflow-hidden\">\n                <div\n                  className=\"h-full bg-primary rounded-full transition-all\"\n                  style={{ width: `${progress}%` }}\n                />\n              </div>\n              <span className=\"text-xs text-foreground-muted mt-0.5\">\n                {completedCount}/{itemCount}\n              </span>\n            </div>\n          )}\n          {list.list_type !== 'checklist' && (\n            <span className=\"text-xs text-foreground-muted\">\n              {itemCount} {itemCount === 1 ? 'item' : 'items'}\n            </span>\n          )}\n        </div>\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "list",
        "itemCount",
        "Math",
        "completedCount",
        "motion",
        "className",
        "whileHover",
        "whileTap",
        "onClick",
        "div",
        "span",
        "listTypeIcons",
        "p",
        "style",
        "progress"
      ]
    },
    "file:web/src/components/lists/ListDetailView.tsx": {
      "id": "file:web/src/components/lists/ListDetailView.tsx",
      "type": "file",
      "name": "ListDetailView.tsx",
      "filePath": "web/src/components/lists/ListDetailView.tsx",
      "line": 1,
      "endLine": 301,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateListItemInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/lists",
          "items": [
            {
              "name": "fetchListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toggleItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "addItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "reorderItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "completeAllItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "clearCompletedItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "exportList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./ListView",
          "items": [
            {
              "name": "ListView",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/common",
          "items": [
            {
              "name": "ExportModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExportFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListDetailView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListDetailView",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListDetailView.tsx:fn:ListDetailView:34"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListDetailView.tsx:fn:ListDetailView:34": {
      "id": "file:web/src/components/lists/ListDetailView.tsx:fn:ListDetailView:34",
      "type": "function",
      "name": "ListDetailView",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListDetailView.tsx",
      "line": 34,
      "endLine": 298,
      "parentFileId": "file:web/src/components/lists/ListDetailView.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ listId, isOpen, onClose, onEdit }",
          "type": "ListDetailViewProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for viewing, loading, exporting, and toggling items in a list detail modal.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function ListDetailView({ listId, isOpen, onClose, onEdit }: ListDetailViewProps) {\n  const [list, setList] = useState<ListWithItems | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [showExportModal, setShowExportModal] = useState(false);\n\n  const handleExport = async (format: ExportFormat) => {\n    if (!list) return;\n    const blob = await exportList(list.id, format);\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    const ext = format === 'markdown' ? 'md' : format;\n    const safeName = list.name.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();\n    a.download = `${safeName}-${new Date().toISOString().split('T')[0]}.${ext}`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  const loadList = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const data = await fetchListWithItems(listId);\n      setList(data);\n    } catch (err) {\n      console.error('Failed to load list:', err);\n      setError('Failed to load list');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [listId]);\n\n  useEffect(() => {\n    if (isOpen && listId) {\n      loadList();\n    }\n  }, [isOpen, listId, loadList]);\n\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') onClose();\n  }, [onClose]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  const handleToggleItem = async (item: ListItem) => {\n    if (!list) return;\n    try {\n      const updated = await toggleItem(list.id, item.id);\n      setList({\n        ...list,\n        items: list.items.map((i) => (i.id === item.id ? updated : i)),\n      });\n    } catch (err) {\n      console.error('Failed to toggle item:', err);\n    }\n  };\n\n  const handleUpdateItem = async (item: ListItem, content: string) => {\n    if (!list) return;\n    try {\n      const updated = await updateItem(list.id, item.id, { content });\n      setList({\n        ...list,\n        items: list.items.map((i) => (i.id === item.id ? updated : i)),\n      });\n    } catch (err) {\n      console.error('Failed to update item:', err);\n    }\n  };\n\n  const handleDeleteItem = async (item: ListItem) => {\n    if (!list) return;\n    try {\n      await deleteItem(list.id, item.id);\n      setList({\n        ...list,\n        items: list.items.filter((i) => i.id !== item.id),\n      });\n    } catch (err) {\n      console.error('Failed to delete item:', err);\n    }\n  };\n\n  const handleAddItem = async (content: string) => {\n    if (!list) return;\n    try {\n      const newItem = await addItem(list.id, { content });\n      setList({\n        ...list,\n        items: [...list.items, newItem],\n      });\n    } catch (err) {\n      console.error('Failed to add item:', err);\n    }\n  };\n\n  const handleReorderItems = async (itemIds: string[]) => {\n    if (!list) return;\n    try {\n      await reorderItems(list.id, itemIds);\n    } catch (err) {\n      console.error('Failed to reorder items:', err);\n    }\n  };\n\n  const handleCompleteAll = async () => {\n    if (!list) return;\n    try {\n      await completeAllItems(list.id);\n      await loadList();\n    } catch (err) {\n      console.error('Failed to complete all:', err);\n    }\n  };\n\n  const handleClearCompleted = async () => {\n    if (!list) return;\n    try {\n      await clearCompletedItems(list.id);\n      await loadList();\n    } catch (err) {\n      console.error('Failed to clear completed:', err);\n    }\n  };\n\n  return (\n    <>\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Slide-out panel */}\n          <motion.div\n            initial={{ opacity: 0, x: 100 }}\n            animate={{ opacity: 1, x: 0 }}\n            exit={{ opacity: 0, x: 100 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed right-0 top-0 bottom-0 w-full max-w-xl z-50 glass border-l border-glass-border flex flex-col pt-[env(safe-area-inset-top)] pb-[env(safe-area-inset-bottom)]\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <div className=\"flex items-center gap-3\">\n                <button\n                  onClick={onClose}\n                  className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n                >\n                  <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\n                  </svg>\n                </button>\n                {list && (\n                  <div>\n                    <h2 className=\"text-lg font-semibold text-foreground\">{list.name}</h2>\n                    <p className=\"text-xs text-foreground-muted\">\n                      {listTypeLabels[list.list_type]}  Updated {formatRelativeTime(list.updated_at)}\n                    </p>\n                  </div>\n                )}\n              </div>\n              {list && (\n                <div className=\"flex items-center gap-1\">\n                  <button\n                    onClick={() => setShowExportModal(true)}\n                    className=\"p-2 rounded-lg hover:bg-background-tertiary transition-colors\"\n                    title=\"Export list\"\n                  >\n                    <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n                    </svg>\n                  </button>\n                  <button\n                    onClick={onEdit}\n                    className=\"p-2 rounded-lg hover:bg-background-tertiary transition-colors\"\n                    title=\"Edit list\"\n                  >\n                    <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z\" />\n                    </svg>\n                  </button>\n                </div>\n              )}\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6\">\n              {isLoading ? (\n                <div className=\"space-y-3\">\n                  {[...Array(5)].map((_, i) => (\n                    <div key={i} className=\"animate-pulse h-12 bg-background-tertiary rounded-lg\" />\n                  ))}\n                </div>\n              ) : error ? (\n                <div className=\"text-center py-8\">\n                  <p className=\"text-red-400 mb-2\">{error}</p>\n                  <button onClick={loadList} className=\"text-primary hover:underline\">\n                    Retry\n                  </button>\n                </div>\n              ) : list ? (\n                <>\n                  {/* Description */}\n                  {list.description && (\n                    <p className=\"text-sm text-foreground-muted mb-4\">{list.description}</p>\n                  )}\n\n                  {/* Entity badge */}\n                  {list.primary_entity && (\n                    <div className=\"mb-4\">\n                      <span className=\"text-xs px-2 py-1 rounded-full bg-primary/10 text-primary border border-primary/30\">\n                        {list.primary_entity.name}\n                      </span>\n                    </div>\n                  )}\n\n                  {/* List view */}\n                  <ListView\n                    list={list}\n                    onToggleItem={handleToggleItem}\n                    onUpdateItem={handleUpdateItem}\n                    onDeleteItem={handleDeleteItem}\n                    onAddItem={handleAddItem}\n                    onReorderItems={handleReorderItems}\n                    onCompleteAll={handleCompleteAll}\n                    onClearCompleted={handleClearCompleted}\n                  />\n                </>\n              ) : null}\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n\n      {/* Export Modal */}\n      <ExportModal\n        isOpen={showExportModal}\n        onClose={() => setShowExportModal(false)}\n        onExport={handleExport}\n        title={`Export \"${list?.name || 'List'}\"`}\n        formats={['json', 'markdown', 'csv', 'txt']}\n      />\n    </>\n  );\n}",
      "references": [
        "list",
        "setList",
        "useState",
        "isLoading",
        "setIsLoading",
        "error",
        "setError",
        "showExportModal",
        "setShowExportModal",
        "exportList",
        "format",
        "URL",
        "blob",
        "document",
        "a",
        "url",
        "safeName",
        "Date",
        "ext",
        "useCallback",
        "fetchListWithItems",
        "listId",
        "data",
        "console",
        "err",
        "useEffect",
        "isOpen",
        "loadList",
        "e",
        "onClose",
        "handleKeyDown",
        "toggleItem",
        "item",
        "i",
        "updated",
        "updateItem",
        "content",
        "deleteItem",
        "addItem",
        "newItem",
        "reorderItems",
        "itemIds",
        "completeAllItems",
        "clearCompletedItems",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h2",
        "p",
        "listTypeLabels",
        "formatRelativeTime",
        "title",
        "onEdit",
        "Array",
        "key",
        "span",
        "ListView",
        "onToggleItem",
        "handleToggleItem",
        "onUpdateItem",
        "handleUpdateItem",
        "onDeleteItem",
        "handleDeleteItem",
        "onAddItem",
        "handleAddItem",
        "onReorderItems",
        "handleReorderItems",
        "onCompleteAll",
        "handleCompleteAll",
        "onClearCompleted",
        "handleClearCompleted",
        "ExportModal",
        "onExport",
        "handleExport",
        "formats"
      ]
    },
    "file:web/src/components/lists/ListEditor.tsx": {
      "id": "file:web/src/components/lists/ListEditor.tsx",
      "type": "file",
      "name": "ListEditor.tsx",
      "filePath": "web/src/components/lists/ListEditor.tsx",
      "line": 1,
      "endLine": 373,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateListInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "../notes/EntityPicker",
          "items": [
            {
              "name": "EntityPicker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListEditor",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListEditor.tsx:fn:ListEditor:31"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListEditor.tsx:fn:ListEditor:31": {
      "id": "file:web/src/components/lists/ListEditor.tsx:fn:ListEditor:31",
      "type": "function",
      "name": "ListEditor",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListEditor.tsx",
      "line": 31,
      "endLine": 370,
      "parentFileId": "file:web/src/components/lists/ListEditor.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ list, isOpen, onClose, onSave }",
          "type": "ListEditorProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React modal component for editing/creating lists with name, desc, tags, etc.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function ListEditor({ list, isOpen, onClose, onSave }: ListEditorProps) {\n  const [name, setName] = useState('');\n  const [description, setDescription] = useState('');\n  const [listType, setListType] = useState<ListType>('checklist');\n  const [category, setCategory] = useState('');\n  const [tags, setTags] = useState<string[]>([]);\n  const [tagInput, setTagInput] = useState('');\n  const [isPinned, setIsPinned] = useState(false);\n  const [color, setColor] = useState<string | null>(null);\n  const [entity, setEntity] = useState<Entity | null>(null);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const isEditing = !!list;\n\n  useEffect(() => {\n    if (list) {\n      setName(list.name);\n      setDescription(list.description || '');\n      setListType(list.list_type);\n      setCategory(list.category || '');\n      setTags(list.tags);\n      setIsPinned(list.is_pinned);\n      setColor(list.color);\n      setEntity(list.primary_entity || null);\n    } else {\n      setName('');\n      setDescription('');\n      setListType('checklist');\n      setCategory('');\n      setTags([]);\n      setIsPinned(false);\n      setColor(null);\n      setEntity(null);\n    }\n    setTagInput('');\n  }, [list, isOpen]);\n\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') onClose();\n  }, [onClose]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  const handleAddTag = () => {\n    const tag = tagInput.trim().toLowerCase().replace(/[^a-z0-9-]/g, '');\n    if (tag && !tags.includes(tag)) {\n      setTags([...tags, tag]);\n    }\n    setTagInput('');\n  };\n\n  const handleRemoveTag = (tag: string) => {\n    setTags(tags.filter((t) => t !== tag));\n  };\n\n  const handleSave = async () => {\n    if (!name.trim()) return;\n\n    setIsSaving(true);\n    try {\n      const input: CreateListInput = {\n        name: name.trim(),\n        description: description.trim() || undefined,\n        list_type: listType,\n        category: category.trim() || undefined,\n        tags,\n        is_pinned: isPinned,\n        color: color || undefined,\n        primary_entity_id: entity?.id,\n      };\n\n      await onSave(input, list?.id);\n      onClose();\n    } catch (error) {\n      console.error('Failed to save list:', error);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Modal */}\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 20 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed top-[calc(env(safe-area-inset-top)+1.5rem)] right-[calc(env(safe-area-inset-right)+1.5rem)] bottom-[calc(env(safe-area-inset-bottom)+1.5rem)] left-[calc(env(safe-area-inset-left)+1.5rem)] md:inset-auto md:left-1/2 md:top-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:max-w-lg md:w-full md:max-h-[85vh] z-50 glass rounded-xl overflow-hidden flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <h2 className=\"text-lg font-semibold text-foreground\">\n                {isEditing ? 'Edit List' : 'New List'}\n              </h2>\n              <button\n                onClick={onClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6 space-y-4\">\n              {/* Name */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Name *\n                </label>\n                <input\n                  type=\"text\"\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"List name...\"\n                  className=\"\n                    w-full px-3 py-2 rounded-lg\n                    bg-background-tertiary border border-glass-border\n                    text-foreground placeholder:text-foreground-muted\n                    focus:outline-none focus:border-primary/50\n                  \"\n                />\n              </div>\n\n              {/* Description */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Description\n                </label>\n                <textarea\n                  value={description}\n                  onChange={(e) => setDescription(e.target.value)}\n                  placeholder=\"Optional description...\"\n                  rows={2}\n                  className=\"\n                    w-full px-3 py-2 rounded-lg resize-none\n                    bg-background-tertiary border border-glass-border\n                    text-foreground placeholder:text-foreground-muted\n                    focus:outline-none focus:border-primary/50\n                  \"\n                />\n              </div>\n\n              {/* List Type */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-2\">\n                  Type\n                </label>\n                <div className=\"grid grid-cols-3 gap-2\">\n                  {listTypes.map((type) => (\n                    <button\n                      key={type.value}\n                      type=\"button\"\n                      onClick={() => setListType(type.value)}\n                      className={`\n                        p-3 rounded-lg text-center transition-all\n                        ${listType === type.value\n                          ? 'bg-primary text-white ring-2 ring-primary ring-offset-2 ring-offset-background'\n                          : 'bg-background-tertiary text-foreground-muted hover:text-foreground'\n                        }\n                      `}\n                    >\n                      <span className=\"text-lg block mb-1\">{type.icon}</span>\n                      <span className=\"text-xs font-medium\">{type.label}</span>\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              {/* Entity Link */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Link to Entity\n                </label>\n                <EntityPicker\n                  value={entity}\n                  onChange={setEntity}\n                  placeholder=\"Search for entity...\"\n                />\n              </div>\n\n              {/* Category */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Category\n                </label>\n                <input\n                  type=\"text\"\n                  value={category}\n                  onChange={(e) => setCategory(e.target.value)}\n                  placeholder=\"e.g., work, personal, project...\"\n                  className=\"\n                    w-full px-3 py-2 rounded-lg\n                    bg-background-tertiary border border-glass-border\n                    text-foreground placeholder:text-foreground-muted\n                    focus:outline-none focus:border-primary/50\n                  \"\n                />\n              </div>\n\n              {/* Tags */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Tags\n                </label>\n                <div className=\"flex flex-wrap gap-2 mb-2\">\n                  {tags.map((tag) => (\n                    <span\n                      key={tag}\n                      className=\"inline-flex items-center gap-1 px-2 py-1 rounded bg-background-tertiary text-sm\"\n                    >\n                      #{tag}\n                      <button\n                        type=\"button\"\n                        onClick={() => handleRemoveTag(tag)}\n                        className=\"hover:text-red-400 transition-colors\"\n                      >\n                        <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                        </svg>\n                      </button>\n                    </span>\n                  ))}\n                </div>\n                <div className=\"flex gap-2\">\n                  <input\n                    type=\"text\"\n                    value={tagInput}\n                    onChange={(e) => setTagInput(e.target.value)}\n                    onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}\n                    placeholder=\"Add tag...\"\n                    className=\"\n                      flex-1 px-3 py-2 rounded-lg\n                      bg-background-tertiary border border-glass-border\n                      text-sm text-foreground placeholder:text-foreground-muted\n                      focus:outline-none focus:border-primary/50\n                    \"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={handleAddTag}\n                    className=\"px-3 py-2 rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n                  >\n                    Add\n                  </button>\n                </div>\n              </div>\n\n              {/* Color */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Color\n                </label>\n                <div className=\"flex gap-2\">\n                  {listColors.map((c) => (\n                    <button\n                      key={c.value || 'none'}\n                      type=\"button\"\n                      onClick={() => setColor(c.value)}\n                      className={`\n                        w-8 h-8 rounded-full transition-all\n                        ${c.value ? '' : 'bg-background-tertiary border border-glass-border'}\n                        ${color === c.value ? 'ring-2 ring-primary ring-offset-2 ring-offset-background' : ''}\n                      `}\n                      style={c.value ? { backgroundColor: c.value } : undefined}\n                      title={c.label}\n                    />\n                  ))}\n                </div>\n              </div>\n\n              {/* Pin toggle */}\n              <div className=\"flex items-center gap-3\">\n                <button\n                  type=\"button\"\n                  onClick={() => setIsPinned(!isPinned)}\n                  className={`\n                    flex items-center gap-2 px-3 py-2 rounded-lg transition-colors\n                    ${isPinned\n                      ? 'bg-accent-gold/20 text-accent-gold border border-accent-gold/30'\n                      : 'bg-background-tertiary text-foreground-muted hover:text-foreground'\n                    }\n                  `}\n                >\n                  <span></span>\n                  <span className=\"text-sm\">{isPinned ? 'Pinned' : 'Pin this list'}</span>\n                </button>\n              </div>\n            </div>\n\n            {/* Footer */}\n            <div className=\"flex items-center justify-end gap-3 px-6 py-4 border-t border-glass-border\">\n              <button\n                onClick={onClose}\n                className=\"px-4 py-2 rounded-lg text-sm text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={handleSave}\n                disabled={!name.trim() || isSaving}\n                className=\"\n                  px-4 py-2 rounded-lg text-sm\n                  bg-primary text-white\n                  hover:bg-primary/90 transition-colors\n                  disabled:opacity-50 disabled:cursor-not-allowed\n                \"\n              >\n                {isSaving ? 'Saving...' : isEditing ? 'Save Changes' : 'Create List'}\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "name",
        "setName",
        "useState",
        "description",
        "setDescription",
        "listType",
        "setListType",
        "category",
        "setCategory",
        "tags",
        "setTags",
        "tagInput",
        "setTagInput",
        "isPinned",
        "setIsPinned",
        "color",
        "setColor",
        "entity",
        "setEntity",
        "isSaving",
        "setIsSaving",
        "list",
        "useEffect",
        "isOpen",
        "useCallback",
        "e",
        "onClose",
        "document",
        "handleKeyDown",
        "tag",
        "t",
        "onSave",
        "input",
        "console",
        "error",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "h2",
        "isEditing",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "label",
        "value",
        "onChange",
        "placeholder",
        "textarea",
        "rows",
        "listTypes",
        "key",
        "span",
        "EntityPicker",
        "handleRemoveTag",
        "onKeyDown",
        "handleAddTag",
        "listColors",
        "c",
        "style",
        "title",
        "handleSave",
        "disabled"
      ]
    },
    "file:web/src/components/lists/ListItemRow.tsx": {
      "id": "file:web/src/components/lists/ListItemRow.tsx",
      "type": "file",
      "name": "ListItemRow.tsx",
      "filePath": "web/src/components/lists/ListItemRow.tsx",
      "line": 1,
      "endLine": 205,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ListItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListItemRow",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListItemRow",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListItemRow.tsx:fn:ListItemRow:18"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListItemRow.tsx:fn:ListItemRow:18": {
      "id": "file:web/src/components/lists/ListItemRow.tsx:fn:ListItemRow:18",
      "type": "function",
      "name": "ListItemRow",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListItemRow.tsx",
      "line": 18,
      "endLine": 202,
      "parentFileId": "file:web/src/components/lists/ListItemRow.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  item,\n  listType,\n  onToggle,\n  onUpdate,\n  onDelete,\n  isDragging = false,\n  dragHandleProps,\n}",
          "type": "ListItemRowProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders editable, draggable list item row component with toggle and actions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ListItemRow({\n  item,\n  listType,\n  onToggle,\n  onUpdate,\n  onDelete,\n  isDragging = false,\n  dragHandleProps,\n}: ListItemRowProps) {\n  const [isEditing, setIsEditing] = useState(false);\n  const [editContent, setEditContent] = useState(item.content);\n  const [showActions, setShowActions] = useState(false);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    if (isEditing && inputRef.current) {\n      inputRef.current.focus();\n      inputRef.current.select();\n    }\n  }, [isEditing]);\n\n  const handleSave = () => {\n    const trimmed = editContent.trim();\n    if (trimmed && trimmed !== item.content) {\n      onUpdate?.(item, trimmed);\n    }\n    setIsEditing(false);\n    setEditContent(item.content);\n  };\n\n  const handleCancel = () => {\n    setIsEditing(false);\n    setEditContent(item.content);\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter') {\n      handleSave();\n    } else if (e.key === 'Escape') {\n      handleCancel();\n    }\n  };\n\n  const isChecklist = listType === 'checklist';\n  const isRanked = listType === 'ranked';\n\n  return (\n    <motion.div\n      className={`\n        group flex items-center gap-3 px-3 py-2 rounded-lg\n        transition-all duration-150\n        ${isDragging ? 'opacity-50 bg-background-tertiary' : 'hover:bg-background-tertiary/50'}\n        ${item.is_completed ? 'opacity-60' : ''}\n      `}\n      onMouseEnter={() => setShowActions(true)}\n      onMouseLeave={() => setShowActions(false)}\n      layout\n    >\n      {/* Drag handle */}\n      <div\n        className=\"cursor-grab active:cursor-grabbing text-foreground-muted opacity-0 group-hover:opacity-100 transition-opacity\"\n        {...dragHandleProps}\n      >\n        <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 8h16M4 16h16\" />\n        </svg>\n      </div>\n\n      {/* Checkbox (for checklists) */}\n      {isChecklist && (\n        <button\n          onClick={() => onToggle?.(item)}\n          className={`\n            w-5 h-5 rounded border-2 flex items-center justify-center\n            transition-all duration-150\n            ${item.is_completed\n              ? 'bg-primary border-primary'\n              : 'border-glass-border hover:border-primary/50'\n            }\n          `}\n        >\n          {item.is_completed && (\n            <svg className=\"w-3 h-3 text-white\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={3} d=\"M5 13l4 4L19 7\" />\n            </svg>\n          )}\n        </button>\n      )}\n\n      {/* Priority badge (for ranked) */}\n      {isRanked && item.priority > 0 && (\n        <span className={`\n          w-6 h-6 rounded-full flex items-center justify-center text-xs font-medium\n          ${item.priority === 1 ? 'bg-yellow-500/20 text-yellow-400' :\n            item.priority === 2 ? 'bg-gray-400/20 text-gray-400' :\n            item.priority === 3 ? 'bg-orange-600/20 text-orange-400' :\n            'bg-background-tertiary text-foreground-muted'}\n        `}>\n          {item.priority}\n        </span>\n      )}\n\n      {/* Content */}\n      <div className=\"flex-1 min-w-0\">\n        {isEditing ? (\n          <input\n            ref={inputRef}\n            type=\"text\"\n            value={editContent}\n            onChange={(e) => setEditContent(e.target.value)}\n            onBlur={handleSave}\n            onKeyDown={handleKeyDown}\n            className=\"\n              w-full px-2 py-1 rounded\n              bg-background-secondary border border-primary/50\n              text-sm text-foreground\n              focus:outline-none\n            \"\n          />\n        ) : (\n          <span\n            className={`\n              text-sm cursor-text\n              ${item.is_completed ? 'line-through text-foreground-muted' : 'text-foreground'}\n            `}\n            onDoubleClick={() => setIsEditing(true)}\n          >\n            {item.content}\n          </span>\n        )}\n\n        {/* Notes preview */}\n        {item.notes && !isEditing && (\n          <p className=\"text-xs text-foreground-muted mt-0.5 line-clamp-1\">\n            {item.notes}\n          </p>\n        )}\n      </div>\n\n      {/* Due date */}\n      {item.due_at && (\n        <span className={`\n          text-xs px-2 py-0.5 rounded-full\n          ${new Date(item.due_at) < new Date()\n            ? 'bg-red-500/20 text-red-400'\n            : 'bg-background-tertiary text-foreground-muted'\n          }\n        `}>\n          {formatRelativeTime(item.due_at)}\n        </span>\n      )}\n\n      {/* Entity badge */}\n      {item.entity && (\n        <span className=\"text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary border border-primary/30\">\n          {item.entity.name}\n        </span>\n      )}\n\n      {/* Actions */}\n      {showActions && !isEditing && (\n        <div className=\"flex items-center gap-1\">\n          <button\n            onClick={() => setIsEditing(true)}\n            className=\"p-1 rounded hover:bg-background-secondary transition-colors\"\n            title=\"Edit\"\n          >\n            <svg className=\"w-3.5 h-3.5 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z\" />\n            </svg>\n          </button>\n          <button\n            onClick={() => onDelete?.(item)}\n            className=\"p-1 rounded hover:bg-red-500/20 transition-colors\"\n            title=\"Delete\"\n          >\n            <svg className=\"w-3.5 h-3.5 text-red-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n            </svg>\n          </button>\n        </div>\n      )}\n    </motion.div>\n  );\n}",
      "references": [
        "isEditing",
        "setIsEditing",
        "useState",
        "editContent",
        "setEditContent",
        "item",
        "showActions",
        "setShowActions",
        "useRef",
        "useEffect",
        "inputRef",
        "trimmed",
        "onUpdate",
        "e",
        "handleSave",
        "handleCancel",
        "listType",
        "motion",
        "className",
        "isDragging",
        "onMouseEnter",
        "onMouseLeave",
        "layout",
        "div",
        "dragHandleProps",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "isChecklist",
        "button",
        "onClick",
        "onToggle",
        "isRanked",
        "span",
        "input",
        "ref",
        "value",
        "onChange",
        "onBlur",
        "onKeyDown",
        "handleKeyDown",
        "onDoubleClick",
        "p",
        "Date",
        "formatRelativeTime",
        "title",
        "onDelete"
      ]
    },
    "file:web/src/components/lists/ListsList.tsx": {
      "id": "file:web/src/components/lists/ListsList.tsx",
      "type": "file",
      "name": "ListsList.tsx",
      "filePath": "web/src/components/lists/ListsList.tsx",
      "line": 1,
      "endLine": 303,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./ListCard",
          "items": [
            {
              "name": "ListCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/common",
          "items": [
            {
              "name": "ExportModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExportFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/lists",
          "items": [
            {
              "name": "exportAllLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListsList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListsList",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListsList.tsx:fn:ListsList:36"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListsList.tsx:fn:ListsList:36": {
      "id": "file:web/src/components/lists/ListsList.tsx:fn:ListsList:36",
      "type": "function",
      "name": "ListsList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListsList.tsx",
      "line": 36,
      "endLine": 300,
      "parentFileId": "file:web/src/components/lists/ListsList.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  lists,\n  isLoading = false,\n  onOpen,\n  onEdit,\n  onArchive,\n  onDelete,\n}",
          "type": "ListsListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for displaying, filtering, sorting, and exporting lists with local state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ListsList({\n  lists,\n  isLoading = false,\n  onOpen,\n  onEdit,\n  onArchive,\n  onDelete,\n}: ListsListProps) {\n  const [searchQuery, setSearchQuery] = useState('');\n  const [typeFilter, setTypeFilter] = useState<ListType | 'all'>('all');\n  const [pinnedFilter, setPinnedFilter] = useState<'all' | 'pinned' | 'unpinned'>('all');\n  const [sortBy, setSortBy] = useState<SortOption>('updated_desc');\n  const [viewMode, setViewMode] = useState<ViewMode>('grid');\n  const [showExportModal, setShowExportModal] = useState(false);\n\n  const handleExport = async (format: ExportFormat) => {\n    if (format === 'txt') return; // Use exportAllLists which supports json/markdown/csv\n    const blob = await exportAllLists(format as 'json' | 'markdown' | 'csv');\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `lists-export-${new Date().toISOString().split('T')[0]}.${format === 'markdown' ? 'md' : format}`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  const filteredLists = useMemo(() => {\n    let result = [...lists];\n\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase();\n      result = result.filter(\n        (list) =>\n          list.name.toLowerCase().includes(query) ||\n          list.description?.toLowerCase().includes(query) ||\n          list.tags.some((tag) => tag.includes(query))\n      );\n    }\n\n    if (typeFilter !== 'all') {\n      result = result.filter((list) => list.list_type === typeFilter);\n    }\n\n    if (pinnedFilter === 'pinned') {\n      result = result.filter((list) => list.is_pinned);\n    } else if (pinnedFilter === 'unpinned') {\n      result = result.filter((list) => !list.is_pinned);\n    }\n\n    result.sort((a, b) => {\n      switch (sortBy) {\n        case 'updated_desc':\n          return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();\n        case 'updated_asc':\n          return new Date(a.updated_at).getTime() - new Date(b.updated_at).getTime();\n        case 'created_desc':\n          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n        case 'name_asc':\n          return a.name.localeCompare(b.name);\n        default:\n          return 0;\n      }\n    });\n\n    const pinned = result.filter((l) => l.is_pinned);\n    const unpinned = result.filter((l) => !l.is_pinned);\n    return [...pinned, ...unpinned];\n  }, [lists, searchQuery, typeFilter, pinnedFilter, sortBy]);\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Filters bar */}\n      <div className=\"flex flex-col sm:flex-row gap-3\">\n        {/* Search */}\n        <div className=\"relative flex-1\">\n          <svg\n            className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-foreground-muted\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n          </svg>\n          <input\n            type=\"text\"\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            placeholder=\"Search lists...\"\n            className=\"\n              w-full pl-10 pr-4 py-2 rounded-lg\n              bg-background-tertiary border border-glass-border\n              text-sm text-foreground placeholder:text-foreground-muted\n              focus:outline-none focus:border-primary/50\n            \"\n          />\n        </div>\n\n        {/* Type filter */}\n        <select\n          value={typeFilter}\n          onChange={(e) => setTypeFilter(e.target.value as ListType | 'all')}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          {typeFilters.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label}\n            </option>\n          ))}\n        </select>\n\n        {/* Pinned filter */}\n        <select\n          value={pinnedFilter}\n          onChange={(e) => setPinnedFilter(e.target.value as 'all' | 'pinned' | 'unpinned')}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          <option value=\"all\">All Lists</option>\n          <option value=\"pinned\"> Pinned</option>\n          <option value=\"unpinned\">Unpinned</option>\n        </select>\n\n        {/* Sort */}\n        <select\n          value={sortBy}\n          onChange={(e) => setSortBy(e.target.value as SortOption)}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          {sortOptions.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label}\n            </option>\n          ))}\n        </select>\n\n        {/* View mode toggle */}\n        <div className=\"flex rounded-lg border border-glass-border overflow-hidden\">\n          <button\n            onClick={() => setViewMode('grid')}\n            className={`\n              px-3 py-2 transition-colors\n              ${viewMode === 'grid' ? 'bg-primary text-white' : 'bg-background-tertiary text-foreground-muted hover:text-foreground'}\n            `}\n            title=\"Grid view\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z\" />\n            </svg>\n          </button>\n          <button\n            onClick={() => setViewMode('list')}\n            className={`\n              px-3 py-2 transition-colors\n              ${viewMode === 'list' ? 'bg-primary text-white' : 'bg-background-tertiary text-foreground-muted hover:text-foreground'}\n            `}\n            title=\"List view\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h16\" />\n            </svg>\n          </button>\n        </div>\n\n        {/* Export button */}\n        <button\n          onClick={() => setShowExportModal(true)}\n          className=\"px-3 py-2 rounded-lg bg-background-tertiary border border-glass-border hover:border-foreground-muted transition-colors flex items-center gap-2\"\n          title=\"Export lists\"\n        >\n          <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n          </svg>\n          <span className=\"text-sm hidden sm:inline\">Export</span>\n        </button>\n      </div>\n\n      {/* Lists display */}\n      {isLoading ? (\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4\">\n          {[...Array(6)].map((_, i) => (\n            <div key={i} className=\"animate-pulse glass rounded-lg p-4 h-36\">\n              <div className=\"h-4 bg-background-tertiary rounded w-2/3 mb-3\" />\n              <div className=\"space-y-2\">\n                <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n                <div className=\"h-3 bg-background-tertiary rounded w-4/5\" />\n              </div>\n              <div className=\"h-2 bg-background-tertiary rounded w-full mt-4\" />\n            </div>\n          ))}\n        </div>\n      ) : filteredLists.length === 0 ? (\n        <div className=\"text-center py-12\">\n          <div className=\"text-4xl mb-3\"></div>\n          <p className=\"text-foreground-muted\">\n            {searchQuery || typeFilter !== 'all' || pinnedFilter !== 'all'\n              ? 'No lists match your filters'\n              : 'No lists yet. Create your first list!'}\n          </p>\n        </div>\n      ) : (\n        <AnimatePresence mode=\"popLayout\">\n          <motion.div\n            className={\n              viewMode === 'grid'\n                ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4'\n                : 'space-y-3'\n            }\n          >\n            {filteredLists.map((list) => (\n              <motion.div\n                key={list.id}\n                layout\n                initial={{ opacity: 0, scale: 0.95 }}\n                animate={{ opacity: 1, scale: 1 }}\n                exit={{ opacity: 0, scale: 0.95 }}\n                transition={{ duration: 0.2 }}\n              >\n                <ListCard\n                  list={list}\n                  onOpen={onOpen}\n                  onEdit={onEdit}\n                  onArchive={onArchive}\n                  onDelete={onDelete}\n                  compact={viewMode === 'list'}\n                />\n              </motion.div>\n            ))}\n          </motion.div>\n        </AnimatePresence>\n      )}\n\n      {/* Results count */}\n      {!isLoading && filteredLists.length > 0 && (\n        <p className=\"text-sm text-foreground-muted text-center\">\n          Showing {filteredLists.length} of {lists.length} lists\n        </p>\n      )}\n\n      {/* Export Modal */}\n      <ExportModal\n        isOpen={showExportModal}\n        onClose={() => setShowExportModal(false)}\n        onExport={handleExport}\n        title=\"Export Lists\"\n        formats={['json', 'markdown', 'csv']}\n      />\n    </div>\n  );\n}",
      "references": [
        "searchQuery",
        "setSearchQuery",
        "useState",
        "typeFilter",
        "setTypeFilter",
        "pinnedFilter",
        "setPinnedFilter",
        "sortBy",
        "setSortBy",
        "viewMode",
        "setViewMode",
        "showExportModal",
        "setShowExportModal",
        "format",
        "exportAllLists",
        "URL",
        "blob",
        "document",
        "a",
        "url",
        "Date",
        "useMemo",
        "lists",
        "result",
        "list",
        "query",
        "tag",
        "b",
        "l",
        "pinned",
        "unpinned",
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "input",
        "value",
        "onChange",
        "e",
        "placeholder",
        "select",
        "typeFilters",
        "option",
        "key",
        "opt",
        "sortOptions",
        "button",
        "onClick",
        "title",
        "span",
        "isLoading",
        "Array",
        "i",
        "filteredLists",
        "p",
        "AnimatePresence",
        "mode",
        "motion",
        "layout",
        "initial",
        "animate",
        "exit",
        "transition",
        "ListCard",
        "onOpen",
        "onEdit",
        "onArchive",
        "onDelete",
        "compact",
        "ExportModal",
        "isOpen",
        "onClose",
        "onExport",
        "handleExport",
        "formats"
      ]
    },
    "file:web/src/components/lists/ListView.tsx": {
      "id": "file:web/src/components/lists/ListView.tsx",
      "type": "file",
      "name": "ListView.tsx",
      "filePath": "web/src/components/lists/ListView.tsx",
      "line": 1,
      "endLine": 228,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Reorder",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./ListItemRow",
          "items": [
            {
              "name": "ListItemRow",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListView",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ListView",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/lists/ListView.tsx:fn:ListView:19"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/lists/ListView.tsx:fn:ListView:19": {
      "id": "file:web/src/components/lists/ListView.tsx:fn:ListView:19",
      "type": "function",
      "name": "ListView",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/lists/ListView.tsx",
      "line": 19,
      "endLine": 225,
      "parentFileId": "file:web/src/components/lists/ListView.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  list,\n  onToggleItem,\n  onUpdateItem,\n  onDeleteItem,\n  onAddItem,\n  onReorderItems,\n  onCompleteAll,\n  onClearCompleted,\n}",
          "type": "ListViewProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for rendering, adding, reordering, and managing checklist items",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function ListView({\n  list,\n  onToggleItem,\n  onUpdateItem,\n  onDeleteItem,\n  onAddItem,\n  onReorderItems,\n  onCompleteAll,\n  onClearCompleted,\n}: ListViewProps) {\n  const [newItemContent, setNewItemContent] = useState('');\n  const [items, setItems] = useState<ListItem[]>(list.items);\n  const [showCompletedActions, setShowCompletedActions] = useState(false);\n\n  const activeItems = items.filter((item) => !item.is_completed);\n  const completedItems = items.filter((item) => item.is_completed);\n\n  const handleAddItem = useCallback(() => {\n    const content = newItemContent.trim();\n    if (content) {\n      onAddItem(content);\n      setNewItemContent('');\n    }\n  }, [newItemContent, onAddItem]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleAddItem();\n    }\n  };\n\n  const handleReorder = useCallback(\n    (newOrder: ListItem[]) => {\n      setItems([...newOrder, ...completedItems]);\n      onReorderItems(newOrder.map((item) => item.id));\n    },\n    [completedItems, onReorderItems]\n  );\n\n  // Sync items when list changes\n  if (list.items !== items && JSON.stringify(list.items) !== JSON.stringify(items)) {\n    setItems(list.items);\n  }\n\n  const progress = items.length > 0\n    ? Math.round((completedItems.length / items.length) * 100)\n    : 0;\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Progress header (for checklists) */}\n      {list.list_type === 'checklist' && items.length > 0 && (\n        <div className=\"glass rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm text-foreground-muted\">\n              {completedItems.length} of {items.length} complete\n            </span>\n            <span className=\"text-sm font-medium text-foreground\">{progress}%</span>\n          </div>\n          <div className=\"h-2 bg-background-tertiary rounded-full overflow-hidden\">\n            <motion.div\n              className=\"h-full bg-primary rounded-full\"\n              initial={{ width: 0 }}\n              animate={{ width: `${progress}%` }}\n              transition={{ duration: 0.3, ease: 'easeOut' }}\n            />\n          </div>\n          \n          {/* Bulk actions */}\n          <div className=\"flex items-center gap-2 mt-3\">\n            {activeItems.length > 0 && (\n              <button\n                onClick={onCompleteAll}\n                className=\"text-xs px-2 py-1 rounded bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                Complete all\n              </button>\n            )}\n            {completedItems.length > 0 && (\n              <button\n                onClick={onClearCompleted}\n                className=\"text-xs px-2 py-1 rounded bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                Clear completed\n              </button>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Add new item */}\n      <div className=\"flex gap-2\">\n        <input\n          type=\"text\"\n          value={newItemContent}\n          onChange={(e) => setNewItemContent(e.target.value)}\n          onKeyDown={handleKeyDown}\n          placeholder=\"Add an item...\"\n          className=\"\n            flex-1 px-4 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground placeholder:text-foreground-muted\n            focus:outline-none focus:border-primary/50\n          \"\n        />\n        <button\n          onClick={handleAddItem}\n          disabled={!newItemContent.trim()}\n          className=\"\n            px-4 py-2 rounded-lg\n            bg-primary text-white\n            hover:bg-primary/90 transition-colors\n            disabled:opacity-50 disabled:cursor-not-allowed\n          \"\n        >\n          <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n          </svg>\n        </button>\n      </div>\n\n      {/* Active items (draggable) */}\n      {activeItems.length > 0 ? (\n        <Reorder.Group\n          axis=\"y\"\n          values={activeItems}\n          onReorder={handleReorder}\n          className=\"space-y-1\"\n        >\n          <AnimatePresence mode=\"popLayout\">\n            {activeItems.map((item) => (\n              <Reorder.Item\n                key={item.id}\n                value={item}\n                initial={{ opacity: 0, y: -10 }}\n                animate={{ opacity: 1, y: 0 }}\n                exit={{ opacity: 0, x: -20 }}\n              >\n                <ListItemRow\n                  item={item}\n                  listType={list.list_type}\n                  onToggle={onToggleItem}\n                  onUpdate={onUpdateItem}\n                  onDelete={onDeleteItem}\n                />\n              </Reorder.Item>\n            ))}\n          </AnimatePresence>\n        </Reorder.Group>\n      ) : completedItems.length === 0 ? (\n        <div className=\"text-center py-8\">\n          <div className=\"text-4xl mb-3\"></div>\n          <p className=\"text-foreground-muted text-sm\">\n            No items yet. Add your first item above!\n          </p>\n        </div>\n      ) : null}\n\n      {/* Completed items (collapsible) */}\n      {completedItems.length > 0 && (\n        <div className=\"mt-4\">\n          <button\n            onClick={() => setShowCompletedActions(!showCompletedActions)}\n            className=\"flex items-center gap-2 text-sm text-foreground-muted hover:text-foreground transition-colors mb-2\"\n          >\n            <svg\n              className={`w-4 h-4 transition-transform ${showCompletedActions ? 'rotate-90' : ''}`}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n            </svg>\n            <span>\n              {completedItems.length} completed {completedItems.length === 1 ? 'item' : 'items'}\n            </span>\n          </button>\n\n          <AnimatePresence>\n            {showCompletedActions && (\n              <motion.div\n                initial={{ height: 0, opacity: 0 }}\n                animate={{ height: 'auto', opacity: 1 }}\n                exit={{ height: 0, opacity: 0 }}\n                className=\"overflow-hidden\"\n              >\n                <div className=\"space-y-1 pl-4 border-l-2 border-glass-border\">\n                  {completedItems.map((item) => (\n                    <ListItemRow\n                      key={item.id}\n                      item={item}\n                      listType={list.list_type}\n                      onToggle={onToggleItem}\n                      onUpdate={onUpdateItem}\n                      onDelete={onDeleteItem}\n                    />\n                  ))}\n                </div>\n              </motion.div>\n            )}\n          </AnimatePresence>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "newItemContent",
        "setNewItemContent",
        "useState",
        "items",
        "setItems",
        "list",
        "showCompletedActions",
        "setShowCompletedActions",
        "item",
        "useCallback",
        "content",
        "onAddItem",
        "e",
        "handleAddItem",
        "newOrder",
        "completedItems",
        "onReorderItems",
        "JSON",
        "Math",
        "div",
        "className",
        "span",
        "progress",
        "motion",
        "initial",
        "animate",
        "transition",
        "activeItems",
        "button",
        "onClick",
        "onCompleteAll",
        "onClearCompleted",
        "input",
        "value",
        "onChange",
        "onKeyDown",
        "handleKeyDown",
        "placeholder",
        "disabled",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "Reorder",
        "axis",
        "values",
        "onReorder",
        "handleReorder",
        "AnimatePresence",
        "mode",
        "key",
        "exit",
        "ListItemRow",
        "listType",
        "onToggle",
        "onToggleItem",
        "onUpdate",
        "onUpdateItem",
        "onDelete",
        "onDeleteItem",
        "p"
      ]
    },
    "file:web/src/components/notes/EntityPicker.tsx": {
      "id": "file:web/src/components/notes/EntityPicker.tsx",
      "type": "file",
      "name": "EntityPicker.tsx",
      "filePath": "web/src/components/notes/EntityPicker.tsx",
      "line": 1,
      "endLine": 175,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/entities",
          "items": [
            {
              "name": "searchEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/colors",
          "items": [
            {
              "name": "getEntityIcon",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "EntityPicker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EntityPicker",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notes/EntityPicker.tsx:fn:EntityPicker:16"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/EntityPicker.tsx:fn:EntityPicker:16": {
      "id": "file:web/src/components/notes/EntityPicker.tsx:fn:EntityPicker:16",
      "type": "function",
      "name": "EntityPicker",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/EntityPicker.tsx",
      "line": 16,
      "endLine": 172,
      "parentFileId": "file:web/src/components/notes/EntityPicker.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  value,\n  onChange,\n  placeholder = 'Link to entity...',\n  disabled = false,\n}",
          "type": "EntityPickerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for selecting/linking entities via searchable dropdown.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function EntityPicker({\n  value,\n  onChange,\n  placeholder = 'Link to entity...',\n  disabled = false,\n}: EntityPickerProps) {\n  const [isOpen, setIsOpen] = useState(false);\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState<Entity[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (containerRef.current && !containerRef.current.contains(event.target as Node)) {\n        setIsOpen(false);\n      }\n    };\n\n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, []);\n\n  useEffect(() => {\n    if (!query.trim()) {\n      setResults([]);\n      return;\n    }\n\n    const debounce = setTimeout(async () => {\n      setIsLoading(true);\n      try {\n        const entities = await searchEntities(query);\n        setResults(entities.slice(0, 10));\n      } catch (error) {\n        console.error('Failed to search entities:', error);\n        setResults([]);\n      } finally {\n        setIsLoading(false);\n      }\n    }, 200);\n\n    return () => clearTimeout(debounce);\n  }, [query]);\n\n  const handleSelect = (entity: Entity) => {\n    onChange(entity);\n    setQuery('');\n    setIsOpen(false);\n  };\n\n  const handleClear = () => {\n    onChange(null);\n    setQuery('');\n  };\n\n  if (value) {\n    return (\n      <div className=\"flex items-center gap-2 px-3 py-2 rounded-lg bg-background-tertiary border border-glass-border\">\n        <span>{getEntityIcon(value.type)}</span>\n        <span className=\"text-sm text-foreground flex-1\">{value.name}</span>\n        <button\n          type=\"button\"\n          onClick={handleClear}\n          disabled={disabled}\n          className=\"p-1 rounded hover:bg-background-secondary transition-colors\"\n        >\n          <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n          </svg>\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div ref={containerRef} className=\"relative\">\n      <div className=\"relative\">\n        <input\n          ref={inputRef}\n          type=\"text\"\n          value={query}\n          onChange={(e) => {\n            setQuery(e.target.value);\n            setIsOpen(true);\n          }}\n          onFocus={() => setIsOpen(true)}\n          placeholder={placeholder}\n          disabled={disabled}\n          className=\"\n            w-full px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground placeholder:text-foreground-muted\n            focus:outline-none focus:border-primary/50\n            disabled:opacity-50 disabled:cursor-not-allowed\n          \"\n        />\n        <div className=\"absolute right-3 top-1/2 -translate-y-1/2\">\n          {isLoading ? (\n            <svg className=\"w-4 h-4 text-foreground-muted animate-spin\" fill=\"none\" viewBox=\"0 0 24 24\">\n              <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\" />\n              <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\" />\n            </svg>\n          ) : (\n            <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n            </svg>\n          )}\n        </div>\n      </div>\n\n      <AnimatePresence>\n        {isOpen && (query.trim() || results.length > 0) && (\n          <motion.div\n            initial={{ opacity: 0, y: -10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -10 }}\n            transition={{ duration: 0.15 }}\n            className=\"\n              absolute z-50 w-full mt-1\n              glass rounded-lg border border-glass-border\n              max-h-60 overflow-auto\n              shadow-lg\n            \"\n          >\n            {results.length > 0 ? (\n              <ul className=\"py-1\">\n                {results.map((entity) => (\n                  <li key={entity.id}>\n                    <button\n                      type=\"button\"\n                      onClick={() => handleSelect(entity)}\n                      className=\"\n                        w-full flex items-center gap-2 px-3 py-2\n                        text-left text-sm\n                        hover:bg-background-tertiary transition-colors\n                      \"\n                    >\n                      <span>{getEntityIcon(entity.type)}</span>\n                      <span className=\"text-foreground flex-1\">{entity.name}</span>\n                      <span className=\"text-xs text-foreground-muted capitalize\">{entity.type}</span>\n                    </button>\n                  </li>\n                ))}\n              </ul>\n            ) : query.trim() && !isLoading ? (\n              <div className=\"px-3 py-4 text-sm text-foreground-muted text-center\">\n                No entities found\n              </div>\n            ) : null}\n          </motion.div>\n        )}\n      </AnimatePresence>\n    </div>\n  );\n}",
      "references": [
        "isOpen",
        "setIsOpen",
        "useState",
        "query",
        "setQuery",
        "results",
        "setResults",
        "isLoading",
        "setIsLoading",
        "useRef",
        "useEffect",
        "containerRef",
        "event",
        "document",
        "handleClickOutside",
        "setTimeout",
        "searchEntities",
        "entities",
        "console",
        "error",
        "clearTimeout",
        "debounce",
        "onChange",
        "entity",
        "value",
        "div",
        "className",
        "span",
        "getEntityIcon",
        "button",
        "onClick",
        "handleClear",
        "disabled",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "ref",
        "input",
        "inputRef",
        "e",
        "onFocus",
        "placeholder",
        "circle",
        "cx",
        "cy",
        "r",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "ul",
        "li",
        "key",
        "handleSelect"
      ]
    },
    "file:web/src/components/notes/index.ts": {
      "id": "file:web/src/components/notes/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/notes/index.ts",
      "line": 1,
      "endLine": 7,
      "imports": [],
      "exports": [
        {
          "name": "NoteCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NoteEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NotesList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EntityPicker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PinnedNotesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NoteCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./NoteCard"
        },
        {
          "name": "NoteEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./NoteEditor"
        },
        {
          "name": "NotesList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./NotesList"
        },
        {
          "name": "EntityPicker",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./EntityPicker"
        },
        {
          "name": "PinnedNotesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./PinnedNotesPanel"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/NoteCard.tsx": {
      "id": "file:web/src/components/notes/NoteCard.tsx",
      "type": "file",
      "name": "NoteCard.tsx",
      "filePath": "web/src/components/notes/NoteCard.tsx",
      "line": 1,
      "endLine": 203,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "NoteCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NoteCard",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notes/NoteCard.tsx:fn:NoteCard:31",
        "file:web/src/components/notes/NoteCard.tsx:fn:NoteCardCompact:167"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/NoteCard.tsx:fn:NoteCard:31": {
      "id": "file:web/src/components/notes/NoteCard.tsx:fn:NoteCard:31",
      "type": "function",
      "name": "NoteCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/NoteCard.tsx",
      "line": 31,
      "endLine": 165,
      "parentFileId": "file:web/src/components/notes/NoteCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  note,\n  onEdit,\n  onPin,\n  onArchive,\n  onDelete,\n  compact = false,\n}",
          "type": "NoteCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering interactive note card with hover actions, truncation, and callbacks.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.598Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function NoteCard({\n  note,\n  onEdit,\n  onPin,\n  onArchive,\n  onDelete,\n  compact = false,\n}: NoteCardProps) {\n  const [showActions, setShowActions] = useState(false);\n\n  const maxLength = compact ? 100 : 200;\n  const truncatedContent =\n    note.content.length > maxLength\n      ? note.content.substring(0, maxLength) + '...'\n      : note.content;\n\n  const categoryColor = categoryColors[note.category || ''] || 'bg-gray-500/20 text-gray-400 border-gray-500/30';\n\n  return (\n    <motion.div\n      className={`\n        relative glass rounded-lg overflow-hidden\n        transition-all duration-200\n        hover:border-primary/50 cursor-pointer\n        ${note.is_pinned ? 'ring-1 ring-accent-gold/50' : ''}\n        ${note.color ? `border-l-4` : ''}\n      `}\n      style={note.color ? { borderLeftColor: note.color } : undefined}\n      onMouseEnter={() => setShowActions(true)}\n      onMouseLeave={() => setShowActions(false)}\n      onClick={() => onEdit?.(note)}\n      whileHover={{ scale: 1.01 }}\n      whileTap={{ scale: 0.99 }}\n    >\n      <div className={`p-4 ${compact ? 'pb-3' : ''}`}>\n        {/* Header row */}\n        <div className=\"flex items-start justify-between gap-2 mb-2\">\n          <div className=\"flex items-center gap-2 flex-wrap\">\n            {/* Pin indicator */}\n            {note.is_pinned && (\n              <span className=\"text-accent-gold text-sm\" title=\"Pinned\"></span>\n            )}\n            \n            {/* Category badge */}\n            {note.category && (\n              <span className={`text-xs px-2 py-0.5 rounded-full border ${categoryColor}`}>\n                {note.category}\n              </span>\n            )}\n\n            {/* Source icon */}\n            <span className=\"text-sm\" title={`Source: ${note.source_type}`}>\n              {sourceIcons[note.source_type] || ''}\n            </span>\n          </div>\n\n          {/* Action buttons */}\n          {showActions && (\n            <div className=\"flex items-center gap-1\" onClick={(e) => e.stopPropagation()}>\n              <button\n                onClick={() => onPin?.(note)}\n                className=\"p-1 rounded hover:bg-background-tertiary transition-colors\"\n                title={note.is_pinned ? 'Unpin' : 'Pin'}\n              >\n                <span className=\"text-sm\">{note.is_pinned ? '' : ''}</span>\n              </button>\n              <button\n                onClick={() => onArchive?.(note)}\n                className=\"p-1 rounded hover:bg-background-tertiary transition-colors\"\n                title=\"Archive\"\n              >\n                <svg className=\"w-4 h-4 text-foreground-muted\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4\" />\n                </svg>\n              </button>\n              <button\n                onClick={() => onDelete?.(note)}\n                className=\"p-1 rounded hover:bg-red-500/20 transition-colors\"\n                title=\"Delete\"\n              >\n                <svg className=\"w-4 h-4 text-red-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\" />\n                </svg>\n              </button>\n            </div>\n          )}\n        </div>\n\n        {/* Title */}\n        {note.title && (\n          <h3 className=\"text-sm font-medium text-foreground mb-1 line-clamp-1\">\n            {note.title}\n          </h3>\n        )}\n\n        {/* Content */}\n        <p className={`text-sm text-foreground-muted leading-relaxed ${compact ? 'line-clamp-2' : 'line-clamp-4'}`}>\n          {truncatedContent}\n        </p>\n\n        {/* Footer */}\n        <div className=\"flex items-center justify-between mt-3 pt-2 border-t border-glass-border\">\n          {/* Entity badge */}\n          {note.primary_entity && (\n            <span className=\"text-xs px-2 py-0.5 rounded-full bg-primary/10 text-primary border border-primary/30\">\n              {note.primary_entity.name}\n            </span>\n          )}\n\n          {/* Timestamp */}\n          <span className=\"text-xs text-foreground-muted ml-auto\">\n            {formatRelativeTime(note.created_at)}\n          </span>\n        </div>\n\n        {/* Tags */}\n        {note.tags.length > 0 && !compact && (\n          <div className=\"flex flex-wrap gap-1 mt-2\">\n            {note.tags.slice(0, 5).map((tag) => (\n              <span\n                key={tag}\n                className=\"text-xs px-1.5 py-0.5 rounded bg-background-tertiary text-foreground-muted\"\n              >\n                #{tag}\n              </span>\n            ))}\n            {note.tags.length > 5 && (\n              <span className=\"text-xs text-foreground-muted\">+{note.tags.length - 5}</span>\n            )}\n          </div>\n        )}\n      </div>\n    </motion.div>\n  );\n}",
      "references": [
        "showActions",
        "setShowActions",
        "useState",
        "compact",
        "note",
        "maxLength",
        "categoryColors",
        "motion",
        "className",
        "style",
        "onMouseEnter",
        "onMouseLeave",
        "onClick",
        "onEdit",
        "whileHover",
        "whileTap",
        "div",
        "span",
        "title",
        "categoryColor",
        "sourceIcons",
        "e",
        "button",
        "onPin",
        "onArchive",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "onDelete",
        "h3",
        "p",
        "truncatedContent",
        "formatRelativeTime",
        "key",
        "tag"
      ]
    },
    "file:web/src/components/notes/NoteCard.tsx:fn:NoteCardCompact:167": {
      "id": "file:web/src/components/notes/NoteCard.tsx:fn:NoteCardCompact:167",
      "type": "function",
      "name": "NoteCardCompact",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/NoteCard.tsx",
      "line": 167,
      "endLine": 200,
      "parentFileId": "file:web/src/components/notes/NoteCard.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  note,\n  onClick,\n}",
          "type": "{ note: Note; onClick?: () => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders compact UI card for a note with pin, title, content preview, and timestamp.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.372Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function NoteCardCompact({\n  note,\n  onClick,\n}: {\n  note: Note;\n  onClick?: () => void;\n}) {\n  return (\n    <motion.button\n      className={`\n        w-full text-left p-3 rounded-lg\n        glass hover:border-primary/50\n        transition-all duration-200\n        ${note.is_pinned ? 'border-accent-gold/30' : ''}\n      `}\n      whileHover={{ scale: 1.02 }}\n      whileTap={{ scale: 0.98 }}\n      onClick={onClick}\n    >\n      <div className=\"flex items-start gap-2\">\n        {note.is_pinned && <span className=\"text-accent-gold text-sm\"></span>}\n        <div className=\"flex-1 min-w-0\">\n          {note.title && (\n            <p className=\"text-sm font-medium text-foreground truncate\">{note.title}</p>\n          )}\n          <p className=\"text-sm text-foreground-muted line-clamp-2\">{note.content}</p>\n          <span className=\"text-xs text-foreground-muted mt-1\">\n            {formatRelativeTime(note.created_at)}\n          </span>\n        </div>\n      </div>\n    </motion.button>\n  );\n}",
      "references": [
        "motion",
        "className",
        "note",
        "whileHover",
        "whileTap",
        "onClick",
        "div",
        "span",
        "p",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/notes/NoteEditor.tsx": {
      "id": "file:web/src/components/notes/NoteEditor.tsx",
      "type": "file",
      "name": "NoteEditor.tsx",
      "filePath": "web/src/components/notes/NoteEditor.tsx",
      "line": 1,
      "endLine": 353,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "UpdateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "NoteCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./EntityPicker",
          "items": [
            {
              "name": "EntityPicker",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "NoteEditor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NoteEditor",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notes/NoteEditor.tsx:fn:NoteEditor:32"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/NoteEditor.tsx:fn:NoteEditor:32": {
      "id": "file:web/src/components/notes/NoteEditor.tsx:fn:NoteEditor:32",
      "type": "function",
      "name": "NoteEditor",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/NoteEditor.tsx",
      "line": 32,
      "endLine": 350,
      "parentFileId": "file:web/src/components/notes/NoteEditor.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ note, isOpen, onClose, onSave }",
          "type": "NoteEditorProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for editing/creating notes with local state, tags, and save handler",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function NoteEditor({ note, isOpen, onClose, onSave }: NoteEditorProps) {\n  const [title, setTitle] = useState('');\n  const [content, setContent] = useState('');\n  const [category, setCategory] = useState<NoteCategory | null>(null);\n  const [tags, setTags] = useState<string[]>([]);\n  const [tagInput, setTagInput] = useState('');\n  const [isPinned, setIsPinned] = useState(false);\n  const [color, setColor] = useState<string | null>(null);\n  const [entity, setEntity] = useState<Entity | null>(null);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const isEditing = !!note;\n\n  useEffect(() => {\n    if (note) {\n      setTitle(note.title || '');\n      setContent(note.content);\n      setCategory(note.category);\n      setTags(note.tags);\n      setIsPinned(note.is_pinned);\n      setColor(note.color);\n      setEntity(note.primary_entity || null);\n    } else {\n      setTitle('');\n      setContent('');\n      setCategory(null);\n      setTags([]);\n      setIsPinned(false);\n      setColor(null);\n      setEntity(null);\n    }\n    setTagInput('');\n  }, [note, isOpen]);\n\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\n    if (e.key === 'Escape') onClose();\n  }, [onClose]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = 'hidden';\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n      document.body.style.overflow = '';\n    };\n  }, [isOpen, handleKeyDown]);\n\n  const handleAddTag = () => {\n    const tag = tagInput.trim().toLowerCase().replace(/[^a-z0-9-]/g, '');\n    if (tag && !tags.includes(tag)) {\n      setTags([...tags, tag]);\n    }\n    setTagInput('');\n  };\n\n  const handleRemoveTag = (tag: string) => {\n    setTags(tags.filter((t) => t !== tag));\n  };\n\n  const handleSave = async () => {\n    if (!content.trim()) return;\n\n    setIsSaving(true);\n    try {\n      const input: CreateNoteInput | UpdateNoteInput = {\n        title: title.trim() || undefined,\n        content: content.trim(),\n        category: category || undefined,\n        tags,\n        is_pinned: isPinned,\n        color: color || undefined,\n      };\n\n      if (!isEditing && entity) {\n        (input as CreateNoteInput).primary_entity_id = entity.id;\n      }\n\n      await onSave(input, note?.id);\n      onClose();\n    } catch (error) {\n      console.error('Failed to save note:', error);\n    } finally {\n      setIsSaving(false);\n    }\n  };\n\n  return (\n    <AnimatePresence>\n      {isOpen && (\n        <>\n          {/* Backdrop */}\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50\"\n            onClick={onClose}\n          />\n\n          {/* Modal */}\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95, y: 20 }}\n            animate={{ opacity: 1, scale: 1, y: 0 }}\n            exit={{ opacity: 0, scale: 0.95, y: 20 }}\n            transition={{ duration: 0.2 }}\n            className=\"fixed top-[calc(env(safe-area-inset-top)+1.5rem)] right-[calc(env(safe-area-inset-right)+1.5rem)] bottom-[calc(env(safe-area-inset-bottom)+1.5rem)] left-[calc(env(safe-area-inset-left)+1.5rem)] md:inset-auto md:left-1/2 md:top-1/2 md:-translate-x-1/2 md:-translate-y-1/2 md:max-w-2xl md:w-full md:max-h-[85vh] z-50 glass rounded-xl overflow-hidden flex flex-col\"\n          >\n            {/* Header */}\n            <div className=\"flex items-center justify-between px-6 py-4 border-b border-glass-border\">\n              <h2 className=\"text-lg font-semibold text-foreground\">\n                {isEditing ? 'Edit Note' : 'New Note'}\n              </h2>\n              <button\n                onClick={onClose}\n                className=\"w-8 h-8 rounded-lg flex items-center justify-center hover:bg-background-tertiary transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex-1 overflow-auto p-6 space-y-4\">\n              {/* Title */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Title (optional)\n                </label>\n                <input\n                  type=\"text\"\n                  value={title}\n                  onChange={(e) => setTitle(e.target.value)}\n                  placeholder=\"Note title...\"\n                  className=\"\n                    w-full px-3 py-2 rounded-lg\n                    bg-background-tertiary border border-glass-border\n                    text-foreground placeholder:text-foreground-muted\n                    focus:outline-none focus:border-primary/50\n                  \"\n                />\n              </div>\n\n              {/* Content */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Content\n                </label>\n                <textarea\n                  value={content}\n                  onChange={(e) => setContent(e.target.value)}\n                  placeholder=\"Write your note...\"\n                  rows={6}\n                  className=\"\n                    w-full px-3 py-2 rounded-lg resize-none\n                    bg-background-tertiary border border-glass-border\n                    text-foreground placeholder:text-foreground-muted\n                    focus:outline-none focus:border-primary/50\n                  \"\n                />\n              </div>\n\n              {/* Entity Link */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Link to Entity\n                </label>\n                <EntityPicker\n                  value={entity}\n                  onChange={setEntity}\n                  placeholder=\"Search for entity...\"\n                />\n              </div>\n\n              {/* Category */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Category\n                </label>\n                <div className=\"flex flex-wrap gap-2\">\n                  {categories.map((cat) => (\n                    <button\n                      key={cat.value}\n                      type=\"button\"\n                      onClick={() => setCategory(category === cat.value ? null : cat.value)}\n                      className={`\n                        px-3 py-1.5 rounded-lg text-sm transition-colors\n                        ${category === cat.value\n                          ? `${cat.color} text-white`\n                          : 'bg-background-tertiary text-foreground-muted hover:text-foreground'\n                        }\n                      `}\n                    >\n                      {cat.label}\n                    </button>\n                  ))}\n                </div>\n              </div>\n\n              {/* Tags */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Tags\n                </label>\n                <div className=\"flex flex-wrap gap-2 mb-2\">\n                  {tags.map((tag) => (\n                    <span\n                      key={tag}\n                      className=\"inline-flex items-center gap-1 px-2 py-1 rounded bg-background-tertiary text-sm\"\n                    >\n                      #{tag}\n                      <button\n                        type=\"button\"\n                        onClick={() => handleRemoveTag(tag)}\n                        className=\"hover:text-red-400 transition-colors\"\n                      >\n                        <svg className=\"w-3 h-3\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                        </svg>\n                      </button>\n                    </span>\n                  ))}\n                </div>\n                <div className=\"flex gap-2\">\n                  <input\n                    type=\"text\"\n                    value={tagInput}\n                    onChange={(e) => setTagInput(e.target.value)}\n                    onKeyDown={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}\n                    placeholder=\"Add tag...\"\n                    className=\"\n                      flex-1 px-3 py-2 rounded-lg\n                      bg-background-tertiary border border-glass-border\n                      text-sm text-foreground placeholder:text-foreground-muted\n                      focus:outline-none focus:border-primary/50\n                    \"\n                  />\n                  <button\n                    type=\"button\"\n                    onClick={handleAddTag}\n                    className=\"px-3 py-2 rounded-lg bg-background-tertiary text-foreground-muted hover:text-foreground transition-colors\"\n                  >\n                    Add\n                  </button>\n                </div>\n              </div>\n\n              {/* Color */}\n              <div>\n                <label className=\"block text-sm font-medium text-foreground-muted mb-1\">\n                  Color\n                </label>\n                <div className=\"flex gap-2\">\n                  {noteColors.map((c) => (\n                    <button\n                      key={c.value || 'none'}\n                      type=\"button\"\n                      onClick={() => setColor(c.value)}\n                      className={`\n                        w-8 h-8 rounded-full transition-all\n                        ${c.value ? '' : 'bg-background-tertiary border border-glass-border'}\n                        ${color === c.value ? 'ring-2 ring-primary ring-offset-2 ring-offset-background' : ''}\n                      `}\n                      style={c.value ? { backgroundColor: c.value } : undefined}\n                      title={c.label}\n                    />\n                  ))}\n                </div>\n              </div>\n\n              {/* Pin toggle */}\n              <div className=\"flex items-center gap-3\">\n                <button\n                  type=\"button\"\n                  onClick={() => setIsPinned(!isPinned)}\n                  className={`\n                    flex items-center gap-2 px-3 py-2 rounded-lg transition-colors\n                    ${isPinned\n                      ? 'bg-accent-gold/20 text-accent-gold border border-accent-gold/30'\n                      : 'bg-background-tertiary text-foreground-muted hover:text-foreground'\n                    }\n                  `}\n                >\n                  <span></span>\n                  <span className=\"text-sm\">{isPinned ? 'Pinned' : 'Pin this note'}</span>\n                </button>\n              </div>\n            </div>\n\n            {/* Footer */}\n            <div className=\"flex items-center justify-end gap-3 px-6 py-4 border-t border-glass-border\">\n              <button\n                onClick={onClose}\n                className=\"px-4 py-2 rounded-lg text-sm text-foreground-muted hover:text-foreground transition-colors\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={handleSave}\n                disabled={!content.trim() || isSaving}\n                className=\"\n                  px-4 py-2 rounded-lg text-sm\n                  bg-primary text-white\n                  hover:bg-primary/90 transition-colors\n                  disabled:opacity-50 disabled:cursor-not-allowed\n                \"\n              >\n                {isSaving ? 'Saving...' : isEditing ? 'Save Changes' : 'Create Note'}\n              </button>\n            </div>\n          </motion.div>\n        </>\n      )}\n    </AnimatePresence>\n  );\n}",
      "references": [
        "title",
        "setTitle",
        "useState",
        "content",
        "setContent",
        "category",
        "setCategory",
        "tags",
        "setTags",
        "tagInput",
        "setTagInput",
        "isPinned",
        "setIsPinned",
        "color",
        "setColor",
        "entity",
        "setEntity",
        "isSaving",
        "setIsSaving",
        "note",
        "useEffect",
        "isOpen",
        "useCallback",
        "e",
        "onClose",
        "document",
        "handleKeyDown",
        "tag",
        "t",
        "isEditing",
        "input",
        "onSave",
        "console",
        "error",
        "AnimatePresence",
        "motion",
        "initial",
        "animate",
        "exit",
        "transition",
        "className",
        "onClick",
        "div",
        "h2",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "label",
        "value",
        "onChange",
        "placeholder",
        "textarea",
        "rows",
        "EntityPicker",
        "categories",
        "key",
        "cat",
        "span",
        "handleRemoveTag",
        "onKeyDown",
        "handleAddTag",
        "noteColors",
        "c",
        "style",
        "handleSave",
        "disabled"
      ]
    },
    "file:web/src/components/notes/NotesList.tsx": {
      "id": "file:web/src/components/notes/NotesList.tsx",
      "type": "file",
      "name": "NotesList.tsx",
      "filePath": "web/src/components/notes/NotesList.tsx",
      "line": 1,
      "endLine": 304,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "NoteCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./NoteCard",
          "items": [
            {
              "name": "NoteCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/common",
          "items": [
            {
              "name": "ExportModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExportFormat",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/notes",
          "items": [
            {
              "name": "exportNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "NotesList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NotesList",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notes/NotesList.tsx:fn:NotesList:37"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/NotesList.tsx:fn:NotesList:37": {
      "id": "file:web/src/components/notes/NotesList.tsx:fn:NotesList:37",
      "type": "function",
      "name": "NotesList",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/NotesList.tsx",
      "line": 37,
      "endLine": 301,
      "parentFileId": "file:web/src/components/notes/NotesList.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  notes,\n  isLoading = false,\n  onEdit,\n  onPin,\n  onArchive,\n  onDelete,\n}",
          "type": "NotesListProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for displaying, filtering, sorting, and exporting notes list",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function NotesList({\n  notes,\n  isLoading = false,\n  onEdit,\n  onPin,\n  onArchive,\n  onDelete,\n}: NotesListProps) {\n  const [searchQuery, setSearchQuery] = useState('');\n  const [categoryFilter, setCategoryFilter] = useState<NoteCategory | 'all'>('all');\n  const [pinnedFilter, setPinnedFilter] = useState<'all' | 'pinned' | 'unpinned'>('all');\n  const [sortBy, setSortBy] = useState<SortOption>('created_desc');\n  const [viewMode, setViewMode] = useState<ViewMode>('grid');\n  const [showExportModal, setShowExportModal] = useState(false);\n\n  const handleExport = async (format: ExportFormat) => {\n    if (format === 'txt') return; // Notes don't support txt\n    const blob = await exportNotes(format as 'json' | 'markdown' | 'csv');\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `notes-export-${new Date().toISOString().split('T')[0]}.${format === 'markdown' ? 'md' : format}`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  const filteredNotes = useMemo(() => {\n    let result = [...notes];\n\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase();\n      result = result.filter(\n        (note) =>\n          note.title?.toLowerCase().includes(query) ||\n          note.content.toLowerCase().includes(query) ||\n          note.tags.some((tag) => tag.includes(query))\n      );\n    }\n\n    if (categoryFilter !== 'all') {\n      result = result.filter((note) => note.category === categoryFilter);\n    }\n\n    if (pinnedFilter === 'pinned') {\n      result = result.filter((note) => note.is_pinned);\n    } else if (pinnedFilter === 'unpinned') {\n      result = result.filter((note) => !note.is_pinned);\n    }\n\n    result.sort((a, b) => {\n      switch (sortBy) {\n        case 'created_desc':\n          return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n        case 'created_asc':\n          return new Date(a.created_at).getTime() - new Date(b.created_at).getTime();\n        case 'updated_desc':\n          return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();\n        case 'title_asc':\n          return (a.title || '').localeCompare(b.title || '');\n        default:\n          return 0;\n      }\n    });\n\n    const pinned = result.filter((n) => n.is_pinned);\n    const unpinned = result.filter((n) => !n.is_pinned);\n    return [...pinned, ...unpinned];\n  }, [notes, searchQuery, categoryFilter, pinnedFilter, sortBy]);\n\n  return (\n    <div className=\"space-y-4\">\n      {/* Filters bar */}\n      <div className=\"flex flex-col sm:flex-row gap-3\">\n        {/* Search */}\n        <div className=\"relative flex-1\">\n          <svg\n            className=\"absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-foreground-muted\"\n            fill=\"none\"\n            stroke=\"currentColor\"\n            viewBox=\"0 0 24 24\"\n          >\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\n          </svg>\n          <input\n            type=\"text\"\n            value={searchQuery}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            placeholder=\"Search notes...\"\n            className=\"\n              w-full pl-10 pr-4 py-2 rounded-lg\n              bg-background-tertiary border border-glass-border\n              text-sm text-foreground placeholder:text-foreground-muted\n              focus:outline-none focus:border-primary/50\n            \"\n          />\n        </div>\n\n        {/* Category filter */}\n        <select\n          value={categoryFilter}\n          onChange={(e) => setCategoryFilter(e.target.value as NoteCategory | 'all')}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          {categoryFilters.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label}\n            </option>\n          ))}\n        </select>\n\n        {/* Pinned filter */}\n        <select\n          value={pinnedFilter}\n          onChange={(e) => setPinnedFilter(e.target.value as 'all' | 'pinned' | 'unpinned')}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          <option value=\"all\">All Notes</option>\n          <option value=\"pinned\"> Pinned</option>\n          <option value=\"unpinned\">Unpinned</option>\n        </select>\n\n        {/* Sort */}\n        <select\n          value={sortBy}\n          onChange={(e) => setSortBy(e.target.value as SortOption)}\n          className=\"\n            px-3 py-2 rounded-lg\n            bg-background-tertiary border border-glass-border\n            text-sm text-foreground\n            focus:outline-none focus:border-primary/50\n          \"\n        >\n          {sortOptions.map((opt) => (\n            <option key={opt.value} value={opt.value}>\n              {opt.label}\n            </option>\n          ))}\n        </select>\n\n        {/* View mode toggle */}\n        <div className=\"flex rounded-lg border border-glass-border overflow-hidden\">\n          <button\n            onClick={() => setViewMode('grid')}\n            className={`\n              px-3 py-2 transition-colors\n              ${viewMode === 'grid' ? 'bg-primary text-white' : 'bg-background-tertiary text-foreground-muted hover:text-foreground'}\n            `}\n            title=\"Grid view\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z\" />\n            </svg>\n          </button>\n          <button\n            onClick={() => setViewMode('list')}\n            className={`\n              px-3 py-2 transition-colors\n              ${viewMode === 'list' ? 'bg-primary text-white' : 'bg-background-tertiary text-foreground-muted hover:text-foreground'}\n            `}\n            title=\"List view\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h16\" />\n            </svg>\n          </button>\n        </div>\n\n        {/* Export button */}\n        <button\n          onClick={() => setShowExportModal(true)}\n          className=\"px-3 py-2 rounded-lg bg-background-tertiary border border-glass-border hover:border-foreground-muted transition-colors flex items-center gap-2\"\n          title=\"Export notes\"\n        >\n          <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4\" />\n          </svg>\n          <span className=\"text-sm hidden sm:inline\">Export</span>\n        </button>\n      </div>\n\n      {/* Notes display */}\n      {isLoading ? (\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4\">\n          {[...Array(6)].map((_, i) => (\n            <div key={i} className=\"animate-pulse glass rounded-lg p-4 h-40\">\n              <div className=\"h-4 bg-background-tertiary rounded w-1/3 mb-3\" />\n              <div className=\"space-y-2\">\n                <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n                <div className=\"h-3 bg-background-tertiary rounded w-5/6\" />\n                <div className=\"h-3 bg-background-tertiary rounded w-4/6\" />\n              </div>\n            </div>\n          ))}\n        </div>\n      ) : filteredNotes.length === 0 ? (\n        <div className=\"text-center py-12\">\n          <div className=\"text-4xl mb-3\"></div>\n          <p className=\"text-foreground-muted\">\n            {searchQuery || categoryFilter !== 'all' || pinnedFilter !== 'all'\n              ? 'No notes match your filters'\n              : 'No notes yet. Create your first note!'}\n          </p>\n        </div>\n      ) : (\n        <AnimatePresence mode=\"popLayout\">\n          <motion.div\n            className={\n              viewMode === 'grid'\n                ? 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4'\n                : 'space-y-3'\n            }\n          >\n            {filteredNotes.map((note) => (\n              <motion.div\n                key={note.id}\n                layout\n                initial={{ opacity: 0, scale: 0.95 }}\n                animate={{ opacity: 1, scale: 1 }}\n                exit={{ opacity: 0, scale: 0.95 }}\n                transition={{ duration: 0.2 }}\n              >\n                <NoteCard\n                  note={note}\n                  onEdit={onEdit}\n                  onPin={onPin}\n                  onArchive={onArchive}\n                  onDelete={onDelete}\n                  compact={viewMode === 'list'}\n                />\n              </motion.div>\n            ))}\n          </motion.div>\n        </AnimatePresence>\n      )}\n\n      {/* Results count */}\n      {!isLoading && filteredNotes.length > 0 && (\n        <p className=\"text-sm text-foreground-muted text-center\">\n          Showing {filteredNotes.length} of {notes.length} notes\n        </p>\n      )}\n\n      {/* Export Modal */}\n      <ExportModal\n        isOpen={showExportModal}\n        onClose={() => setShowExportModal(false)}\n        onExport={handleExport}\n        title=\"Export Notes\"\n        formats={['json', 'markdown', 'csv']}\n      />\n    </div>\n  );\n}",
      "references": [
        "searchQuery",
        "setSearchQuery",
        "useState",
        "categoryFilter",
        "setCategoryFilter",
        "pinnedFilter",
        "setPinnedFilter",
        "sortBy",
        "setSortBy",
        "viewMode",
        "setViewMode",
        "showExportModal",
        "setShowExportModal",
        "format",
        "exportNotes",
        "URL",
        "blob",
        "document",
        "a",
        "url",
        "Date",
        "useMemo",
        "notes",
        "result",
        "note",
        "query",
        "tag",
        "b",
        "n",
        "pinned",
        "unpinned",
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "input",
        "value",
        "onChange",
        "e",
        "placeholder",
        "select",
        "categoryFilters",
        "option",
        "key",
        "opt",
        "sortOptions",
        "button",
        "onClick",
        "title",
        "span",
        "isLoading",
        "Array",
        "i",
        "filteredNotes",
        "p",
        "AnimatePresence",
        "mode",
        "motion",
        "layout",
        "initial",
        "animate",
        "exit",
        "transition",
        "NoteCard",
        "onEdit",
        "onPin",
        "onArchive",
        "onDelete",
        "compact",
        "ExportModal",
        "isOpen",
        "onClose",
        "onExport",
        "handleExport",
        "formats"
      ]
    },
    "file:web/src/components/notes/PinnedNotesPanel.tsx": {
      "id": "file:web/src/components/notes/PinnedNotesPanel.tsx",
      "type": "file",
      "name": "PinnedNotesPanel.tsx",
      "filePath": "web/src/components/notes/PinnedNotesPanel.tsx",
      "line": 1,
      "endLine": 133,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/link",
          "items": [
            {
              "name": "Link",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "AnimatePresence",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/notes",
          "items": [
            {
              "name": "fetchPinnedNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/formatting",
          "items": [
            {
              "name": "formatRelativeTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "PinnedNotesPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PinnedNotesPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notes/PinnedNotesPanel.tsx:fn:PinnedNotesPanel:15"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notes/PinnedNotesPanel.tsx:fn:PinnedNotesPanel:15": {
      "id": "file:web/src/components/notes/PinnedNotesPanel.tsx:fn:PinnedNotesPanel:15",
      "type": "function",
      "name": "PinnedNotesPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notes/PinnedNotesPanel.tsx",
      "line": 15,
      "endLine": 130,
      "parentFileId": "file:web/src/components/notes/PinnedNotesPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ limit = 5, onNoteClick }",
          "type": "PinnedNotesPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component displaying pinned notes list with loading, error, and empty states.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function PinnedNotesPanel({ limit = 5, onNoteClick }: PinnedNotesPanelProps) {\n  const [notes, setNotes] = useState<Note[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    async function load() {\n      try {\n        setIsLoading(true);\n        const data = await fetchPinnedNotes();\n        setNotes(data.slice(0, limit));\n      } catch (err) {\n        console.error('Failed to load pinned notes:', err);\n        setError('Failed to load');\n      } finally {\n        setIsLoading(false);\n      }\n    }\n    load();\n  }, [limit]);\n\n  if (isLoading) {\n    return (\n      <div className=\"space-y-2\">\n        {[...Array(3)].map((_, i) => (\n          <div key={i} className=\"animate-pulse p-3 rounded-lg bg-background-tertiary/50\">\n            <div className=\"h-3 bg-background-tertiary rounded w-2/3 mb-2\" />\n            <div className=\"h-3 bg-background-tertiary rounded w-full\" />\n          </div>\n        ))}\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className=\"text-sm text-foreground-muted text-center py-4\">\n        {error}\n      </div>\n    );\n  }\n\n  if (notes.length === 0) {\n    return (\n      <div className=\"text-center py-6\">\n        <div className=\"text-3xl mb-2\"></div>\n        <p className=\"text-sm text-foreground-muted mb-3\">No pinned notes yet</p>\n        <Link\n          href=\"/app/notes\"\n          className=\"text-sm text-primary hover:underline\"\n        >\n          Go to Notes\n        </Link>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-2\">\n      <AnimatePresence mode=\"popLayout\">\n        {notes.map((note, index) => (\n          <motion.button\n            key={note.id}\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -10 }}\n            transition={{ delay: index * 0.05 }}\n            onClick={() => onNoteClick?.(note)}\n            className=\"\n              w-full text-left p-3 rounded-lg\n              bg-background-tertiary/50 border border-glass-border\n              hover:bg-background-tertiary hover:border-primary/30\n              transition-all duration-200\n            \"\n          >\n            <div className=\"flex items-start gap-2\">\n              <span className=\"text-accent-gold text-sm shrink-0\"></span>\n              <div className=\"flex-1 min-w-0\">\n                {note.title && (\n                  <p className=\"text-sm font-medium text-foreground truncate mb-0.5\">\n                    {note.title}\n                  </p>\n                )}\n                <p className=\"text-sm text-foreground-muted line-clamp-2\">\n                  {note.content}\n                </p>\n                <div className=\"flex items-center gap-2 mt-1.5\">\n                  <span className=\"text-xs text-foreground-muted\">\n                    {formatRelativeTime(note.created_at)}\n                  </span>\n                  {note.category && (\n                    <span className=\"text-xs px-1.5 py-0.5 rounded bg-background-tertiary text-foreground-muted\">\n                      {note.category}\n                    </span>\n                  )}\n                </div>\n              </div>\n            </div>\n          </motion.button>\n        ))}\n      </AnimatePresence>\n\n      {notes.length > 0 && (\n        <Link\n          href=\"/app/notes\"\n          className=\"\n            block w-full text-center text-sm text-foreground-muted\n            hover:text-primary transition-colors py-2\n          \"\n        >\n          View all notes \n        </Link>\n      )}\n    </div>\n  );\n}",
      "references": [
        "notes",
        "setNotes",
        "useState",
        "isLoading",
        "setIsLoading",
        "error",
        "setError",
        "useEffect",
        "fetchPinnedNotes",
        "data",
        "limit",
        "console",
        "err",
        "load",
        "div",
        "className",
        "Array",
        "key",
        "i",
        "p",
        "Link",
        "href",
        "AnimatePresence",
        "mode",
        "motion",
        "note",
        "initial",
        "animate",
        "exit",
        "transition",
        "index",
        "onClick",
        "onNoteClick",
        "span",
        "formatRelativeTime"
      ]
    },
    "file:web/src/components/notifications/index.ts": {
      "id": "file:web/src/components/notifications/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/notifications/index.ts",
      "line": 1,
      "endLine": 2,
      "imports": [],
      "exports": [
        {
          "name": "PushPermission",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PushPermission",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./PushPermission"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notifications/PushPermission.tsx": {
      "id": "file:web/src/components/notifications/PushPermission.tsx",
      "type": "file",
      "name": "PushPermission.tsx",
      "filePath": "web/src/components/notifications/PushPermission.tsx",
      "line": 1,
      "endLine": 269,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "usePushNotifications",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "PushPermission",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PushPermission",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/notifications/PushPermission.tsx:fn:PushPermission:15",
        "file:web/src/components/notifications/PushPermission.tsx:fn:BellIcon:207",
        "file:web/src/components/notifications/PushPermission.tsx:fn:BellOffIcon:225",
        "file:web/src/components/notifications/PushPermission.tsx:fn:LoadingSpinner:244"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/notifications/PushPermission.tsx:fn:PushPermission:15": {
      "id": "file:web/src/components/notifications/PushPermission.tsx:fn:PushPermission:15",
      "type": "function",
      "name": "PushPermission",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notifications/PushPermission.tsx",
      "line": 15,
      "endLine": 203,
      "parentFileId": "file:web/src/components/notifications/PushPermission.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  compact = false,\n  className = '',\n  onStateChange,\n}",
          "type": "PushPermissionProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for toggling push notification permissions and subscriptions",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function PushPermission({\n  compact = false,\n  className = '',\n  onStateChange,\n}: PushPermissionProps) {\n  const {\n    isSupported,\n    isRegistered,\n    permission,\n    isSubscribed,\n    isLoading,\n    error,\n    requestPermission,\n    subscribe,\n    unsubscribe,\n  } = usePushNotifications();\n\n  const [showError, setShowError] = useState(false);\n\n  // Handle subscribe/unsubscribe toggle\n  const handleToggle = async () => {\n    setShowError(false);\n\n    if (isSubscribed) {\n      const success = await unsubscribe();\n      if (success) {\n        onStateChange?.(false);\n      } else {\n        setShowError(true);\n      }\n    } else {\n      // First ensure permission\n      if (permission !== 'granted') {\n        const newPermission = await requestPermission();\n        if (newPermission !== 'granted') {\n          setShowError(true);\n          return;\n        }\n      }\n\n      const success = await subscribe();\n      if (success) {\n        onStateChange?.(true);\n      } else {\n        setShowError(true);\n      }\n    }\n  };\n\n  // Not supported - show nothing or disabled state\n  if (!isSupported) {\n    if (compact) return null;\n    return (\n      <div className={`text-sm text-gray-500 ${className}`}>\n        Push notifications not supported in this browser\n      </div>\n    );\n  }\n\n  // Permission denied - show how to enable\n  const isIOS = typeof navigator !== 'undefined' && /iPhone|iPad|iPod/.test(navigator.userAgent);\n\n  if (permission === 'denied') {\n    if (compact) {\n      return (\n        <button\n          disabled\n          className={`p-2 rounded-lg bg-gray-800/50 text-gray-500 cursor-not-allowed ${className}`}\n          title=\"Notifications blocked - enable in browser settings\"\n        >\n          <BellOffIcon className=\"w-5 h-5\" />\n        </button>\n      );\n    }\n    return (\n      <div className={`p-4 rounded-lg bg-gray-800/50 border border-gray-700 ${className}`}>\n        <div className=\"flex items-start gap-3\">\n          <BellOffIcon className=\"w-6 h-6 text-gray-500 shrink-0 mt-0.5\" />\n          <div>\n            <p className=\"text-sm text-gray-300\">Notifications blocked</p>\n            {isIOS ? (\n              <div className=\"text-xs text-gray-500 mt-1 space-y-1\">\n                <p>To fix on iOS:</p>\n                <ol className=\"list-decimal list-inside space-y-0.5\">\n                  <li>Close this app completely (swipe up)</li>\n                  <li>Go to Settings  Squire  Notifications</li>\n                  <li>Toggle OFF, wait 5 seconds, toggle ON</li>\n                  <li>Re-open Squire from home screen</li>\n                </ol>\n              </div>\n            ) : (\n              <p className=\"text-xs text-gray-500\">\n                Enable in browser settings to receive reminders\n              </p>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  // Compact mode - just a toggle button\n  if (compact) {\n    return (\n      <button\n        onClick={handleToggle}\n        disabled={isLoading || !isRegistered}\n        className={`\n          p-2 rounded-lg transition-all duration-200\n          ${isSubscribed\n            ? 'bg-cyan-500/20 text-cyan-400 hover:bg-cyan-500/30'\n            : 'bg-gray-800/50 text-gray-400 hover:bg-gray-700/50 hover:text-gray-300'\n          }\n          ${isLoading ? 'opacity-50 cursor-wait' : ''}\n          ${!isRegistered ? 'opacity-50 cursor-not-allowed' : ''}\n          ${className}\n        `}\n        title={isSubscribed ? 'Notifications enabled' : 'Enable notifications'}\n      >\n        {isLoading ? (\n          <LoadingSpinner className=\"w-5 h-5\" />\n        ) : isSubscribed ? (\n          <BellIcon className=\"w-5 h-5\" />\n        ) : (\n          <BellOffIcon className=\"w-5 h-5\" />\n        )}\n      </button>\n    );\n  }\n\n  // Full card mode\n  return (\n    <div className={`p-4 rounded-lg bg-gray-800/50 border border-gray-700 ${className}`}>\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-3\">\n          {isSubscribed ? (\n            <BellIcon className=\"w-6 h-6 text-cyan-400\" />\n          ) : (\n            <BellOffIcon className=\"w-6 h-6 text-gray-500\" />\n          )}\n          <div>\n            <p className=\"text-sm font-medium text-gray-200\">\n              Push Notifications\n            </p>\n            <p className=\"text-xs text-gray-500\">\n              {isSubscribed\n                ? 'Receiving reminder notifications'\n                : 'Enable to receive reminder alerts'}\n            </p>\n          </div>\n        </div>\n\n        <button\n          onClick={handleToggle}\n          disabled={isLoading || !isRegistered}\n          className={`\n            px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200\n            ${isSubscribed\n              ? 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n              : 'bg-cyan-500/20 text-cyan-400 hover:bg-cyan-500/30'\n            }\n            ${isLoading ? 'opacity-50 cursor-wait' : ''}\n            ${!isRegistered ? 'opacity-50 cursor-not-allowed' : ''}\n          `}\n        >\n          {isLoading ? (\n            <span className=\"flex items-center gap-2\">\n              <LoadingSpinner className=\"w-4 h-4\" />\n              {isSubscribed ? 'Disabling...' : 'Enabling...'}\n            </span>\n          ) : isSubscribed ? (\n            'Disable'\n          ) : (\n            'Enable'\n          )}\n        </button>\n      </div>\n\n      {/* Error display */}\n      {(showError || error) && (\n        <div className=\"mt-3 p-2 rounded bg-red-500/10 border border-red-500/20\">\n          <p className=\"text-xs text-red-400\">\n            {error || 'Failed to update notification settings'}\n          </p>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "isSupported",
        "isRegistered",
        "permission",
        "isSubscribed",
        "isLoading",
        "error",
        "requestPermission",
        "subscribe",
        "unsubscribe",
        "usePushNotifications",
        "showError",
        "setShowError",
        "useState",
        "success",
        "onStateChange",
        "newPermission",
        "compact",
        "div",
        "className",
        "navigator",
        "button",
        "disabled",
        "title",
        "BellOffIcon",
        "p",
        "isIOS",
        "ol",
        "li",
        "onClick",
        "handleToggle",
        "LoadingSpinner",
        "BellIcon",
        "span"
      ]
    },
    "file:web/src/components/notifications/PushPermission.tsx:fn:BellIcon:207": {
      "id": "file:web/src/components/notifications/PushPermission.tsx:fn:BellIcon:207",
      "type": "function",
      "name": "BellIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notifications/PushPermission.tsx",
      "line": 207,
      "endLine": 223,
      "parentFileId": "file:web/src/components/notifications/PushPermission.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ className = '' }",
          "type": "{ className?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a bell SVG icon with customizable className.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.878Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function BellIcon({ className = '' }: { className?: string }) {\n  return (\n    <svg\n      className={className}\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n    >\n      <path\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        d=\"M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9\"\n      />\n    </svg>\n  );\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "viewBox",
        "stroke",
        "strokeWidth",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "d"
      ]
    },
    "file:web/src/components/notifications/PushPermission.tsx:fn:BellOffIcon:225": {
      "id": "file:web/src/components/notifications/PushPermission.tsx:fn:BellOffIcon:225",
      "type": "function",
      "name": "BellOffIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notifications/PushPermission.tsx",
      "line": 225,
      "endLine": 242,
      "parentFileId": "file:web/src/components/notifications/PushPermission.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ className = '' }",
          "type": "{ className?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an SVG icon for a bell off notification symbol.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function BellOffIcon({ className = '' }: { className?: string }) {\n  return (\n    <svg\n      className={className}\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n      stroke=\"currentColor\"\n      strokeWidth={2}\n    >\n      <path\n        strokeLinecap=\"round\"\n        strokeLinejoin=\"round\"\n        d=\"M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9\"\n      />\n      <line x1=\"2\" y1=\"2\" x2=\"22\" y2=\"22\" strokeLinecap=\"round\" />\n    </svg>\n  );\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "viewBox",
        "stroke",
        "strokeWidth",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "d",
        "line",
        "x1",
        "y1",
        "x2",
        "y2"
      ]
    },
    "file:web/src/components/notifications/PushPermission.tsx:fn:LoadingSpinner:244": {
      "id": "file:web/src/components/notifications/PushPermission.tsx:fn:LoadingSpinner:244",
      "type": "function",
      "name": "LoadingSpinner",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/notifications/PushPermission.tsx",
      "line": 244,
      "endLine": 266,
      "parentFileId": "file:web/src/components/notifications/PushPermission.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ className = '' }",
          "type": "{ className?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated SVG loading spinner component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function LoadingSpinner({ className = '' }: { className?: string }) {\n  return (\n    <svg\n      className={`animate-spin ${className}`}\n      fill=\"none\"\n      viewBox=\"0 0 24 24\"\n    >\n      <circle\n        className=\"opacity-25\"\n        cx=\"12\"\n        cy=\"12\"\n        r=\"10\"\n        stroke=\"currentColor\"\n        strokeWidth=\"4\"\n      />\n      <path\n        className=\"opacity-75\"\n        fill=\"currentColor\"\n        d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"\n      />\n    </svg>\n  );\n}",
      "references": [
        "svg",
        "className",
        "fill",
        "viewBox",
        "circle",
        "cx",
        "cy",
        "r",
        "stroke",
        "strokeWidth",
        "path",
        "d"
      ]
    },
    "file:web/src/components/shared/Toast.tsx": {
      "id": "file:web/src/components/shared/Toast.tsx",
      "type": "file",
      "name": "Toast.tsx",
      "filePath": "web/src/components/shared/Toast.tsx",
      "line": 1,
      "endLine": 114,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "createContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useToast",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ToastProvider",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/shared/Toast.tsx:fn:useToast:18",
        "file:web/src/components/shared/Toast.tsx:fn:ToastItem:26",
        "file:web/src/components/shared/Toast.tsx:fn:ToastProvider:90"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/shared/Toast.tsx:fn:useToast:18": {
      "id": "file:web/src/components/shared/Toast.tsx:fn:useToast:18",
      "type": "function",
      "name": "useToast",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/shared/Toast.tsx",
      "line": 18,
      "endLine": 24,
      "parentFileId": "file:web/src/components/shared/Toast.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "ToastContextType",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook to access ToastContext, throws if not in ToastProvider.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within a ToastProvider');\n  }\n  return context;\n}",
      "references": [
        "useContext",
        "ToastContext",
        "context",
        "Error"
      ]
    },
    "file:web/src/components/shared/Toast.tsx:fn:ToastItem:26": {
      "id": "file:web/src/components/shared/Toast.tsx:fn:ToastItem:26",
      "type": "function",
      "name": "ToastItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/shared/Toast.tsx",
      "line": 26,
      "endLine": 88,
      "parentFileId": "file:web/src/components/shared/Toast.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ toast, onRemove }",
          "type": "{ toast: Toast; onRemove: (id: string) => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a toast notification item with fade in/out animations and auto-removal via callback.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function ToastItem({ toast, onRemove }: { toast: Toast; onRemove: (id: string) => void }) {\n  const [isVisible, setIsVisible] = useState(false);\n  const [isLeaving, setIsLeaving] = useState(false);\n\n  useEffect(() => {\n    // Fade in\n    requestAnimationFrame(() => setIsVisible(true));\n\n    // Start fade out before removal\n    const fadeOutTimer = setTimeout(() => {\n      setIsLeaving(true);\n    }, (toast.duration || 3000) - 300);\n\n    // Remove after fade out\n    const removeTimer = setTimeout(() => {\n      onRemove(toast.id);\n    }, toast.duration || 3000);\n\n    return () => {\n      clearTimeout(fadeOutTimer);\n      clearTimeout(removeTimer);\n    };\n  }, [toast.id, toast.duration, onRemove]);\n\n  const bgColor = {\n    success: 'bg-green-500/90 border-green-400/50',\n    error: 'bg-red-500/90 border-red-400/50',\n    info: 'bg-blue-500/90 border-blue-400/50',\n  }[toast.type];\n\n  const icon = {\n    success: (\n      <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n      </svg>\n    ),\n    error: (\n      <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n      </svg>\n    ),\n    info: (\n      <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n      </svg>\n    ),\n  }[toast.type];\n\n  return (\n    <div\n      className={`\n        flex items-center gap-3 px-4 py-3 rounded-lg border shadow-lg backdrop-blur-sm\n        text-white font-medium\n        transition-all duration-300 ease-out\n        ${bgColor}\n        ${isVisible && !isLeaving ? 'opacity-100 translate-y-0' : 'opacity-0 translate-y-2'}\n      `}\n    >\n      {icon}\n      <span>{toast.message}</span>\n    </div>\n  );\n}",
      "references": [
        "isVisible",
        "setIsVisible",
        "useState",
        "isLeaving",
        "setIsLeaving",
        "useEffect",
        "requestAnimationFrame",
        "setTimeout",
        "toast",
        "onRemove",
        "clearTimeout",
        "fadeOutTimer",
        "removeTimer",
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "div",
        "bgColor",
        "icon",
        "span"
      ]
    },
    "file:web/src/components/shared/Toast.tsx:fn:ToastProvider:90": {
      "id": "file:web/src/components/shared/Toast.tsx:fn:ToastProvider:90",
      "type": "function",
      "name": "ToastProvider",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/shared/Toast.tsx",
      "line": 90,
      "endLine": 113,
      "parentFileId": "file:web/src/components/shared/Toast.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ children }",
          "type": "{ children: React.ReactNode; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React context provider for managing and displaying toast notifications.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function ToastProvider({ children }: { children: ReactNode }) {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const showToast = useCallback((message: string, type: Toast['type'] = 'success', duration = 3000) => {\n    const id = `toast-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    setToasts(prev => [...prev, { id, message, type, duration }]);\n  }, []);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ showToast }}>\n      {children}\n      {/* Toast container - fixed at bottom center */}\n      <div className=\"fixed bottom-6 left-1/2 -translate-x-1/2 z-[100] flex flex-col gap-2 pointer-events-none\">\n        {toasts.map(toast => (\n          <ToastItem key={toast.id} toast={toast} onRemove={removeToast} />\n        ))}\n      </div>\n    </ToastContext.Provider>\n  );\n}",
      "references": [
        "toasts",
        "setToasts",
        "useState",
        "useCallback",
        "Date",
        "Math",
        "prev",
        "id",
        "message",
        "duration",
        "t",
        "ToastContext",
        "value",
        "showToast",
        "children",
        "div",
        "className",
        "ToastItem",
        "key",
        "toast",
        "onRemove",
        "removeToast"
      ]
    },
    "file:web/src/components/timeline/index.ts": {
      "id": "file:web/src/components/timeline/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/timeline/index.ts",
      "line": 1,
      "endLine": 14,
      "imports": [],
      "exports": [
        {
          "name": "TimelineFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "defaultFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getDateRangeBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "TimelineFilterState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DateRangePreset",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "LoadMoreTrigger",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EndOfTimeline",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "TimelineFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TimelineFilters"
        },
        {
          "name": "defaultFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TimelineFilters"
        },
        {
          "name": "getDateRangeBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TimelineFilters"
        },
        {
          "name": "TimelineFilterState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TimelineFilters"
        },
        {
          "name": "DateRangePreset",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./TimelineFilters"
        },
        {
          "name": "LoadMoreTrigger",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./LoadMoreTrigger"
        },
        {
          "name": "EndOfTimeline",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./LoadMoreTrigger"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/timeline/LoadMoreTrigger.tsx": {
      "id": "file:web/src/components/timeline/LoadMoreTrigger.tsx",
      "type": "file",
      "name": "LoadMoreTrigger.tsx",
      "filePath": "web/src/components/timeline/LoadMoreTrigger.tsx",
      "line": 1,
      "endLine": 101,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "LoadMoreTrigger",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EndOfTimeline",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadMoreTrigger:17",
        "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadingSpinner:66",
        "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:EndOfTimeline:86"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadMoreTrigger:17": {
      "id": "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadMoreTrigger:17",
      "type": "function",
      "name": "LoadMoreTrigger",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/timeline/LoadMoreTrigger.tsx",
      "line": 17,
      "endLine": 64,
      "parentFileId": "file:web/src/components/timeline/LoadMoreTrigger.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  onLoadMore,\n  hasMore,\n  isLoading,\n  threshold = 0.1,\n  rootMargin = '200px',\n}",
          "type": "LoadMoreTriggerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Infinite scroll trigger using IntersectionObserver to call onLoadMore when visible.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function LoadMoreTrigger({\n  onLoadMore,\n  hasMore,\n  isLoading,\n  threshold = 0.1,\n  rootMargin = '200px',\n}: LoadMoreTriggerProps) {\n  const triggerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const trigger = triggerRef.current;\n    if (!trigger) return;\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        const entry = entries[0];\n        if (entry.isIntersecting && hasMore && !isLoading) {\n          onLoadMore();\n        }\n      },\n      {\n        threshold,\n        rootMargin, // Start loading before trigger is visible\n      }\n    );\n\n    observer.observe(trigger);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, [onLoadMore, hasMore, isLoading, threshold, rootMargin]);\n\n  // Don't render anything if no more content\n  if (!hasMore && !isLoading) {\n    return null;\n  }\n\n  return (\n    <div ref={triggerRef} className=\"w-full py-8 flex justify-center\">\n      {isLoading ? (\n        <LoadingSpinner />\n      ) : hasMore ? (\n        <div className=\"text-xs text-foreground-muted\">Scroll for more</div>\n      ) : null}\n    </div>\n  );\n}",
      "references": [
        "useRef",
        "useEffect",
        "triggerRef",
        "trigger",
        "IntersectionObserver",
        "entries",
        "entry",
        "hasMore",
        "isLoading",
        "onLoadMore",
        "threshold",
        "rootMargin",
        "observer",
        "div",
        "ref",
        "className",
        "LoadingSpinner"
      ]
    },
    "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadingSpinner:66": {
      "id": "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:LoadingSpinner:66",
      "type": "function",
      "name": "LoadingSpinner",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/timeline/LoadMoreTrigger.tsx",
      "line": 66,
      "endLine": 81,
      "parentFileId": "file:web/src/components/timeline/LoadMoreTrigger.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading spinner with three bouncing dots and 'Loading more memories...' text.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function LoadingSpinner() {\n  return (\n    <div className=\"flex items-center gap-3\">\n      <div className=\"flex gap-1\">\n        {[0, 1, 2].map((i) => (\n          <div\n            key={i}\n            className=\"w-2 h-2 rounded-full bg-accent-primary animate-bounce\"\n            style={{ animationDelay: `${i * 150}ms` }}\n          />\n        ))}\n      </div>\n      <span className=\"text-sm text-foreground-muted\">Loading more memories...</span>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "key",
        "i",
        "style",
        "span"
      ]
    },
    "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:EndOfTimeline:86": {
      "id": "file:web/src/components/timeline/LoadMoreTrigger.tsx:fn:EndOfTimeline:86",
      "type": "function",
      "name": "EndOfTimeline",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/timeline/LoadMoreTrigger.tsx",
      "line": 86,
      "endLine": 100,
      "parentFileId": "file:web/src/components/timeline/LoadMoreTrigger.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ totalCount }",
          "type": "{ totalCount: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders UI indicating end of timeline with optional total memories count.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function EndOfTimeline({ totalCount }: { totalCount: number }) {\n  return (\n    <div className=\"w-full py-8 flex flex-col items-center gap-2 text-center animate-fade-in\">\n      <div className=\"w-12 h-0.5 bg-border rounded-full\" />\n      <p className=\"text-xs text-foreground-muted\">\n        You&apos;ve reached the beginning\n        {totalCount > 0 && (\n          <span className=\"block mt-0.5\">\n            <span className=\"font-medium text-foreground\">{totalCount}</span> memories total\n          </span>\n        )}\n      </p>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "p",
        "totalCount",
        "span"
      ]
    },
    "file:web/src/components/timeline/TimelineFilters.tsx": {
      "id": "file:web/src/components/timeline/TimelineFilters.tsx",
      "type": "file",
      "name": "TimelineFilters.tsx",
      "filePath": "web/src/components/timeline/TimelineFilters.tsx",
      "line": 1,
      "endLine": 388,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "MemorySource",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "TimelineFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDateRangeBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "TimelineFilterState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DateRangePreset",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "defaultFilters",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/components/timeline/TimelineFilters.tsx:fn:TimelineFilters:113",
        "file:web/src/components/timeline/TimelineFilters.tsx:fn:getDateRangeBounds:363"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "icons"
      ]
    },
    "file:web/src/components/timeline/TimelineFilters.tsx:fn:TimelineFilters:113": {
      "id": "file:web/src/components/timeline/TimelineFilters.tsx:fn:TimelineFilters:113",
      "type": "function",
      "name": "TimelineFilters",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/timeline/TimelineFilters.tsx",
      "line": 113,
      "endLine": 360,
      "parentFileId": "file:web/src/components/timeline/TimelineFilters.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  filters,\n  onFiltersChange,\n  isSearching = false,\n  resultCount,\n}",
          "type": "TimelineFiltersProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for managing timeline filters with search, sources, date range, and salience.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function TimelineFilters({\n  filters,\n  onFiltersChange,\n  isSearching = false,\n  resultCount,\n}: TimelineFiltersProps) {\n  const [localSearch, setLocalSearch] = useState(filters.searchQuery);\n  const [showFilters, setShowFilters] = useState(false);\n  const searchInputRef = useRef<HTMLInputElement>(null);\n  const debounceRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Sync local search with filters\n  useEffect(() => {\n    setLocalSearch(filters.searchQuery);\n  }, [filters.searchQuery]);\n\n  // Debounced search\n  const handleSearchChange = useCallback((value: string) => {\n    setLocalSearch(value);\n\n    if (debounceRef.current) {\n      clearTimeout(debounceRef.current);\n    }\n\n    debounceRef.current = setTimeout(() => {\n      onFiltersChange({ ...filters, searchQuery: value });\n    }, 300);\n  }, [filters, onFiltersChange]);\n\n  // Clear search\n  const handleClearSearch = useCallback(() => {\n    setLocalSearch('');\n    onFiltersChange({ ...filters, searchQuery: '' });\n    searchInputRef.current?.focus();\n  }, [filters, onFiltersChange]);\n\n  // Toggle source filter\n  const toggleSource = useCallback((source: MemorySource) => {\n    const newSources = filters.sources.includes(source)\n      ? filters.sources.filter(s => s !== source)\n      : [...filters.sources, source];\n    onFiltersChange({ ...filters, sources: newSources });\n  }, [filters, onFiltersChange]);\n\n  // Set date range\n  const setDateRange = useCallback((range: DateRangePreset) => {\n    onFiltersChange({ ...filters, dateRange: range });\n  }, [filters, onFiltersChange]);\n\n  // Set salience threshold\n  const setSalience = useCallback((minSalience: number) => {\n    onFiltersChange({ ...filters, minSalience });\n  }, [filters, onFiltersChange]);\n\n  // Clear all filters\n  const clearAllFilters = useCallback(() => {\n    setLocalSearch('');\n    onFiltersChange(defaultFilters);\n  }, [onFiltersChange]);\n\n  // Check if any filters are active\n  const hasActiveFilters =\n    filters.searchQuery !== '' ||\n    filters.sources.length > 0 ||\n    filters.dateRange !== 'all' ||\n    filters.minSalience > 0;\n\n  // Count active filters (excluding search)\n  const activeFilterCount =\n    (filters.sources.length > 0 ? 1 : 0) +\n    (filters.dateRange !== 'all' ? 1 : 0) +\n    (filters.minSalience > 0 ? 1 : 0);\n\n  return (\n    <div className=\"space-y-3 mb-6\">\n      {/* Main filter bar */}\n      <div className=\"flex items-center gap-3 p-3 bg-surface-elevated rounded-lg border border-border/50\">\n        {/* Search input */}\n        <div className=\"flex-1 flex items-center gap-2 px-3 py-2 bg-surface rounded-md border border-border/50 focus-within:border-accent-primary/50 transition-colors\">\n          <span className={`transition-colors ${localSearch ? 'text-accent-primary' : 'text-foreground-muted'}`}>\n            {icons.search}\n          </span>\n          <input\n            ref={searchInputRef}\n            type=\"text\"\n            value={localSearch}\n            onChange={(e) => handleSearchChange(e.target.value)}\n            placeholder=\"Search memories...\"\n            className=\"flex-1 bg-transparent text-sm text-foreground placeholder:text-foreground-muted focus:outline-none\"\n          />\n          {localSearch && (\n            <button\n              onClick={handleClearSearch}\n              className=\"p-0.5 text-foreground-muted hover:text-foreground transition-colors\"\n            >\n              {icons.x}\n            </button>\n          )}\n          {isSearching && (\n            <div className=\"w-4 h-4 border-2 border-accent-primary/30 border-t-accent-primary rounded-full animate-spin\" />\n          )}\n        </div>\n\n        {/* Filter toggle button */}\n        <button\n          onClick={() => setShowFilters(!showFilters)}\n          className={`\n            flex items-center gap-2 px-3 py-2 rounded-md border text-sm transition-all\n            ${showFilters || activeFilterCount > 0\n              ? 'bg-accent-primary/10 border-accent-primary/30 text-accent-primary'\n              : 'bg-surface border-border/50 text-foreground-muted hover:bg-surface-hover'\n            }\n          `}\n        >\n          <span className={showFilters ? 'rotate-180 transition-transform' : 'transition-transform'}>\n            {icons.chevronDown}\n          </span>\n          <span>Filters</span>\n          {activeFilterCount > 0 && (\n            <span className=\"px-1.5 py-0.5 text-xs font-medium bg-accent-primary text-background rounded-full\">\n              {activeFilterCount}\n            </span>\n          )}\n        </button>\n\n        {/* Clear all button */}\n        {hasActiveFilters && (\n          <button\n            onClick={clearAllFilters}\n            className=\"px-3 py-2 text-sm text-foreground-muted hover:text-foreground transition-colors\"\n          >\n            Clear all\n          </button>\n        )}\n      </div>\n\n      {/* Expanded filters panel */}\n      {showFilters && (\n        <div className=\"p-4 bg-surface-elevated rounded-lg border border-border/50 space-y-4 animate-fade-in\">\n          {/* Source filters */}\n          <div>\n            <label className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide mb-2 block\">\n              Source\n            </label>\n            <div className=\"flex flex-wrap gap-2\">\n              {sourceOptions.map(({ source, icon, label, color }) => {\n                const isActive = filters.sources.includes(source);\n                return (\n                  <button\n                    key={source}\n                    onClick={() => toggleSource(source)}\n                    className={`\n                      flex items-center gap-1.5 px-3 py-1.5 rounded-full text-xs font-medium transition-all\n                      ${isActive\n                        ? `\n                          ${color === 'primary' ? 'bg-accent-primary/20 text-accent-primary border-accent-primary/30' : ''}\n                          ${color === 'purple' ? 'bg-accent-purple/20 text-accent-purple border-accent-purple/30' : ''}\n                          ${color === 'info' ? 'bg-accent-info/20 text-accent-info border-accent-info/30' : ''}\n                          ${color === 'gold' ? 'bg-accent-gold/20 text-accent-gold border-accent-gold/30' : ''}\n                          ${color === 'muted' ? 'bg-foreground-muted/20 text-foreground-muted border-foreground-muted/30' : ''}\n                          border\n                        `\n                        : 'bg-surface border border-border/50 text-foreground-muted hover:bg-surface-hover'\n                      }\n                    `}\n                  >\n                    {icon}\n                    <span>{label}</span>\n                  </button>\n                );\n              })}\n            </div>\n          </div>\n\n          {/* Date range and salience row */}\n          <div className=\"flex flex-wrap gap-4\">\n            {/* Date range */}\n            <div className=\"flex-1 min-w-[200px]\">\n              <label className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide mb-2 flex items-center gap-1.5\">\n                {icons.calendar}\n                <span>Time Range</span>\n              </label>\n              <div className=\"flex flex-wrap gap-1.5\">\n                {dateRangeOptions.map(({ value, label }) => (\n                  <button\n                    key={value}\n                    onClick={() => setDateRange(value)}\n                    className={`\n                      px-3 py-1.5 rounded-md text-xs font-medium transition-all\n                      ${filters.dateRange === value\n                        ? 'bg-accent-primary text-background'\n                        : 'bg-surface border border-border/50 text-foreground-muted hover:bg-surface-hover'\n                      }\n                    `}\n                  >\n                    {label}\n                  </button>\n                ))}\n              </div>\n            </div>\n\n            {/* Salience threshold */}\n            <div className=\"flex-1 min-w-[160px]\">\n              <label className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide mb-2 flex items-center gap-1.5\">\n                {icons.star}\n                <span>Min Salience</span>\n              </label>\n              <div className=\"flex flex-wrap gap-1.5\">\n                {salienceOptions.map(({ value, label }) => (\n                  <button\n                    key={value}\n                    onClick={() => setSalience(value)}\n                    className={`\n                      px-3 py-1.5 rounded-md text-xs font-medium transition-all\n                      ${filters.minSalience === value\n                        ? 'bg-accent-gold text-background'\n                        : 'bg-surface border border-border/50 text-foreground-muted hover:bg-surface-hover'\n                      }\n                    `}\n                  >\n                    {label}\n                  </button>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Results indicator */}\n      {(filters.searchQuery || hasActiveFilters) && resultCount !== undefined && (\n        <div className=\"text-xs text-foreground-muted px-1\">\n          {resultCount === 0 ? (\n            <span>No memories match your filters</span>\n          ) : (\n            <span>\n              Showing <span className=\"font-medium text-foreground\">{resultCount}</span>\n              {resultCount === 1 ? ' memory' : ' memories'}\n              {filters.searchQuery && (\n                <span> matching &ldquo;<span className=\"text-accent-primary\">{filters.searchQuery}</span>&rdquo;</span>\n              )}\n            </span>\n          )}\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "localSearch",
        "setLocalSearch",
        "useState",
        "filters",
        "showFilters",
        "setShowFilters",
        "useRef",
        "useEffect",
        "useCallback",
        "value",
        "debounceRef",
        "clearTimeout",
        "setTimeout",
        "onFiltersChange",
        "searchInputRef",
        "source",
        "s",
        "newSources",
        "range",
        "minSalience",
        "defaultFilters",
        "div",
        "className",
        "span",
        "icons",
        "input",
        "ref",
        "onChange",
        "handleSearchChange",
        "e",
        "placeholder",
        "button",
        "onClick",
        "handleClearSearch",
        "isSearching",
        "activeFilterCount",
        "hasActiveFilters",
        "clearAllFilters",
        "label",
        "sourceOptions",
        "icon",
        "color",
        "key",
        "toggleSource",
        "isActive",
        "dateRangeOptions",
        "setDateRange",
        "salienceOptions",
        "setSalience",
        "resultCount"
      ]
    },
    "file:web/src/components/timeline/TimelineFilters.tsx:fn:getDateRangeBounds:363": {
      "id": "file:web/src/components/timeline/TimelineFilters.tsx:fn:getDateRangeBounds:363",
      "type": "function",
      "name": "getDateRangeBounds",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/timeline/TimelineFilters.tsx",
      "line": 363,
      "endLine": 387,
      "parentFileId": "file:web/src/components/timeline/TimelineFilters.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "range",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/timeline/TimelineFilters\").DateRangePreset",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ start: Date; end: Date; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Computes start and end date bounds for a given DateRangePreset.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getDateRangeBounds(range: DateRangePreset): { start: Date | null; end: Date | null } {\n  const now = new Date();\n  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n\n  switch (range) {\n    case 'today':\n      return { start: today, end: now };\n    case 'week': {\n      const weekStart = new Date(today);\n      weekStart.setDate(today.getDate() - today.getDay());\n      return { start: weekStart, end: now };\n    }\n    case 'month': {\n      const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);\n      return { start: monthStart, end: now };\n    }\n    case 'year': {\n      const yearStart = new Date(today.getFullYear(), 0, 1);\n      return { start: yearStart, end: now };\n    }\n    case 'all':\n    default:\n      return { start: null, end: null };\n  }\n}",
      "references": [
        "Date",
        "now",
        "today",
        "weekStart",
        "monthStart",
        "yearStart"
      ]
    },
    "file:web/src/components/village/AuroraSky.tsx": {
      "id": "file:web/src/components/village/AuroraSky.tsx",
      "type": "file",
      "name": "AuroraSky.tsx",
      "filePath": "web/src/components/village/AuroraSky.tsx",
      "line": 1,
      "endLine": 142,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "AuroraSky",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "AuroraSky",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/AuroraSky.tsx:fn:AuroraSky:99"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/AuroraSky.tsx:fn:AuroraSky:99": {
      "id": "file:web/src/components/village/AuroraSky.tsx:fn:AuroraSky:99",
      "type": "function",
      "name": "AuroraSky",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/AuroraSky.tsx",
      "line": 99,
      "endLine": 139,
      "parentFileId": "file:web/src/components/village/AuroraSky.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  radius = 80,\n  color1 = '#8b5cf6', // Violet\n  color2 = '#3b82f6', // Blue\n  color3 = '#10b981', // Emerald\n  intensity = 0.4,\n}",
          "type": "AuroraSkyProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated Three.js sphere mesh with aurora sky shader effect.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function AuroraSky({\n  radius = 80,\n  color1 = '#8b5cf6', // Violet\n  color2 = '#3b82f6', // Blue\n  color3 = '#10b981', // Emerald\n  intensity = 0.4,\n}: AuroraSkyProps) {\n  const materialRef = useRef<THREE.ShaderMaterial>(null);\n\n  const uniforms = useMemo(\n    () => ({\n      uTime: { value: 0 },\n      uColor1: { value: new THREE.Color(color1) },\n      uColor2: { value: new THREE.Color(color2) },\n      uColor3: { value: new THREE.Color(color3) },\n      uIntensity: { value: intensity },\n    }),\n    [color1, color2, color3, intensity]\n  );\n\n  useFrame(({ clock }) => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.uTime.value = clock.getElapsedTime();\n    }\n  });\n\n  return (\n    <mesh>\n      <sphereGeometry args={[radius, 32, 16]} />\n      <shaderMaterial\n        ref={materialRef}\n        vertexShader={auroraVertexShader}\n        fragmentShader={auroraFragmentShader}\n        uniforms={uniforms}\n        transparent\n        side={THREE.BackSide}\n        depthWrite={false}\n      />\n    </mesh>\n  );\n}",
      "references": [
        "useRef",
        "useMemo",
        "THREE",
        "color1",
        "color2",
        "color3",
        "intensity",
        "useFrame",
        "clock",
        "materialRef",
        "mesh",
        "sphereGeometry",
        "args",
        "radius",
        "shaderMaterial",
        "ref",
        "vertexShader",
        "auroraVertexShader",
        "fragmentShader",
        "auroraFragmentShader",
        "uniforms",
        "transparent",
        "side",
        "depthWrite"
      ]
    },
    "file:web/src/components/village/Building.tsx": {
      "id": "file:web/src/components/village/Building.tsx",
      "type": "file",
      "name": "Building.tsx",
      "filePath": "web/src/components/village/Building.tsx",
      "line": 1,
      "endLine": 238,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "React",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            },
            {
              "name": "memo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Suspense",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useThree",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "Group",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Mesh",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./BuildingModel",
          "items": [
            {
              "name": "BuildingModel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "BuildingsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "BuildingsLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/components/village/Building.tsx:fn:SimpleBuilding:28",
        "file:web/src/components/village/Building.tsx:fn:DistanceLOD:48"
      ],
      "classes": [],
      "topLevelReferences": [
        "Building",
        "building",
        "selected",
        "hovered",
        "onClick",
        "onPointerOver",
        "onPointerOut",
        "Number",
        "console",
        "baseScale",
        "emissiveIntensity",
        "salience",
        "groupRef",
        "baseY",
        "targetY",
        "delta",
        "e",
        "document",
        "group",
        "position",
        "handlePointerOver",
        "handlePointerOut",
        "handleClick",
        "ref",
        "DistanceLOD",
        "threshold",
        "near",
        "fallback",
        "SimpleBuilding",
        "scale",
        "color",
        "buildingType",
        "emissiveColor",
        "castShadow",
        "receiveShadow",
        "far",
        "BuildingsLayer",
        "buildings",
        "selectedBuildingId",
        "hoveredBuildingId",
        "onBuildingClick",
        "onBuildingHover",
        "b",
        "name",
        "key"
      ]
    },
    "file:web/src/components/village/Building.tsx:fn:SimpleBuilding:28": {
      "id": "file:web/src/components/village/Building.tsx:fn:SimpleBuilding:28",
      "type": "function",
      "name": "SimpleBuilding",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/Building.tsx",
      "line": 28,
      "endLine": 35,
      "parentFileId": "file:web/src/components/village/Building.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ scale, color }",
          "type": "SimpleBuildingProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a simple 3D building mesh with scalable dimensions and custom color.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SimpleBuilding({ scale, color }: SimpleBuildingProps) {\n  return (\n    <mesh castShadow receiveShadow>\n      <boxGeometry args={[0.8 * scale, 1.2 * scale, 0.8 * scale]} />\n      <meshStandardMaterial color={color} roughness={0.8} />\n    </mesh>\n  );\n}",
      "references": [
        "mesh",
        "castShadow",
        "receiveShadow",
        "boxGeometry",
        "args",
        "scale",
        "meshStandardMaterial",
        "color",
        "roughness"
      ]
    },
    "file:web/src/components/village/Building.tsx:fn:DistanceLOD:48": {
      "id": "file:web/src/components/village/Building.tsx:fn:DistanceLOD:48",
      "type": "function",
      "name": "DistanceLOD",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/Building.tsx",
      "line": 48,
      "endLine": 71,
      "parentFileId": "file:web/src/components/village/Building.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ threshold, near, far }",
          "type": "DistanceLODProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Toggles visibility of near/far LOD groups based on camera distance threshold.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function DistanceLOD({ threshold, near, far }: DistanceLODProps) {\n  const groupRef = useRef<THREE.Group>(null);\n  const nearRef = useRef<THREE.Group>(null);\n  const farRef = useRef<THREE.Group>(null);\n  const { camera } = useThree();\n\n  useFrame(() => {\n    if (!groupRef.current || !nearRef.current || !farRef.current) return;\n    groupRef.current.getWorldPosition(_worldPos);\n    const distance = camera.position.distanceTo(_worldPos);\n    const shouldBeNear = distance < threshold;\n\n    // Directly set visibility on THREE.js objects - no React re-render!\n    nearRef.current.visible = shouldBeNear;\n    farRef.current.visible = !shouldBeNear;\n  });\n\n  return (\n    <group ref={groupRef}>\n      <group ref={nearRef}>{near}</group>\n      <group ref={farRef} visible={false}>{far}</group>\n    </group>\n  );\n}",
      "references": [
        "useRef",
        "camera",
        "useThree",
        "useFrame",
        "groupRef",
        "nearRef",
        "farRef",
        "_worldPos",
        "distance",
        "threshold",
        "shouldBeNear",
        "group",
        "ref",
        "near",
        "visible",
        "far"
      ]
    },
    "file:web/src/components/village/BuildingModel.tsx": {
      "id": "file:web/src/components/village/BuildingModel.tsx",
      "type": "file",
      "name": "BuildingModel.tsx",
      "filePath": "web/src/components/village/BuildingModel.tsx",
      "line": 1,
      "endLine": 120,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/drei",
          "items": [
            {
              "name": "useGLTF",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "BuildingType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "getModelConfig",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "BuildingModel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BuildingModel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/BuildingModel.tsx:fn:GLTFModel:42",
        "file:web/src/components/village/BuildingModel.tsx:fn:BuildingModel:115"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/BuildingModel.tsx:fn:GLTFModel:42": {
      "id": "file:web/src/components/village/BuildingModel.tsx:fn:GLTFModel:42",
      "type": "function",
      "name": "GLTFModel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/BuildingModel.tsx",
      "line": 42,
      "endLine": 94,
      "parentFileId": "file:web/src/components/village/BuildingModel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  buildingType,\n  scale = 1,\n  emissiveIntensity = 0,\n  emissiveColor = '#ffffff',\n  castShadow = true,\n  receiveShadow = true,\n}",
          "type": "BuildingModelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders cloned GLTF building model with emissive, scale, and shadow configs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function GLTFModel({\n  buildingType,\n  scale = 1,\n  emissiveIntensity = 0,\n  emissiveColor = '#ffffff',\n  castShadow = true,\n  receiveShadow = true,\n}: BuildingModelProps) {\n  const config = getModelConfig(buildingType);\n  const { scene } = useGLTF(config.path);\n  const clonedSceneRef = useRef<THREE.Object3D | null>(null);\n  const materialsRef = useRef<THREE.MeshStandardMaterial[]>([]);\n\n  // Clone scene once and keep stable reference\n  if (!clonedSceneRef.current) {\n    const clone = scene.clone(true);\n    const materials: THREE.MeshStandardMaterial[] = [];\n\n    clone.traverse((child) => {\n      if (child instanceof THREE.Mesh && child.material) {\n        const material = child.material.clone();\n        if (material instanceof THREE.MeshStandardMaterial) {\n          materials.push(material);\n        }\n        child.material = material;\n        child.castShadow = castShadow;\n        child.receiveShadow = receiveShadow;\n      }\n    });\n\n    materialsRef.current = materials;\n    clonedSceneRef.current = clone;\n  }\n\n  // Update emissive properties imperatively each render\n  const color = new THREE.Color(emissiveColor);\n  materialsRef.current.forEach((material) => {\n    material.emissive = color;\n    material.emissiveIntensity = emissiveIntensity;\n  });\n\n  // Apply config transforms\n  const finalScale = scale * config.scale;\n\n  return (\n    <primitive\n      object={clonedSceneRef.current}\n      scale={[finalScale, finalScale, finalScale]}\n      rotation={[0, config.rotationY, 0]}\n      position={[0, config.yOffset, 0]}\n    />\n  );\n}",
      "references": [
        "getModelConfig",
        "buildingType",
        "scene",
        "useGLTF",
        "config",
        "useRef",
        "clonedSceneRef",
        "clone",
        "child",
        "THREE",
        "material",
        "materials",
        "castShadow",
        "receiveShadow",
        "materialsRef",
        "emissiveColor",
        "color",
        "emissiveIntensity",
        "scale",
        "primitive",
        "finalScale",
        "rotation",
        "position"
      ]
    },
    "file:web/src/components/village/BuildingModel.tsx:fn:BuildingModel:115": {
      "id": "file:web/src/components/village/BuildingModel.tsx:fn:BuildingModel:115",
      "type": "function",
      "name": "BuildingModel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/BuildingModel.tsx",
      "line": 115,
      "endLine": 117,
      "parentFileId": "file:web/src/components/village/BuildingModel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "props",
          "type": "BuildingModelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Wrapper component rendering GLTFModel with spread props.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function BuildingModel(props: BuildingModelProps) {\n  return <GLTFModel {...props} />;\n}",
      "references": [
        "GLTFModel"
      ]
    },
    "file:web/src/components/village/DistrictGround.tsx": {
      "id": "file:web/src/components/village/DistrictGround.tsx",
      "type": "file",
      "name": "DistrictGround.tsx",
      "filePath": "web/src/components/village/DistrictGround.tsx",
      "line": 1,
      "endLine": 184,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageDistrict",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "HexCoord",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/hexGrid",
          "items": [
            {
              "name": "worldToHex",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "hexToWorld",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_HEX_SIZE",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./HexTile",
          "items": [
            {
              "name": "HexTilesLayer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DISTRICT_GROUND_COLORS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "VillageGround",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DistrictGroundProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageGroundProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageGround",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/DistrictGround.tsx:fn:generateHexGridForBounds:23",
        "file:web/src/components/village/DistrictGround.tsx:fn:DistrictGround:81",
        "file:web/src/components/village/DistrictGround.tsx:fn:VillageGround:122"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/DistrictGround.tsx:fn:generateHexGridForBounds:23": {
      "id": "file:web/src/components/village/DistrictGround.tsx:fn:generateHexGridForBounds:23",
      "type": "function",
      "name": "generateHexGridForBounds",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DistrictGround.tsx",
      "line": 23,
      "endLine": 63,
      "parentFileId": "file:web/src/components/village/DistrictGround.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "bounds",
          "type": "{ minX: number; maxX: number; minZ: number; maxZ: number; }",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "hexSize",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "padding",
          "type": "number",
          "isOptional": true,
          "defaultValue": "1"
        }
      ],
      "returnType": "HexCoord[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates hex grid coordinates overlapping given world bounds with padding.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:13.879Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateHexGridForBounds(\n  bounds: { minX: number; maxX: number; minZ: number; maxZ: number },\n  hexSize: number,\n  padding: number = 1\n): HexCoord[] {\n  const hexCoords: HexCoord[] = [];\n  const seen = new Set<string>();\n\n  // Convert bounds corners to hex coordinates\n  const minHex = worldToHex({ x: bounds.minX, z: bounds.minZ }, hexSize);\n  const maxHex = worldToHex({ x: bounds.maxX, z: bounds.maxZ }, hexSize);\n\n  // Expand range with padding\n  const qMin = minHex.q - padding;\n  const qMax = maxHex.q + padding;\n  const rMin = minHex.r - padding;\n  const rMax = maxHex.r + padding;\n\n  // Iterate through hex grid range\n  for (let q = qMin; q <= qMax; q++) {\n    for (let r = rMin; r <= rMax; r++) {\n      const key = `${q},${r}`;\n      if (seen.has(key)) continue;\n      seen.add(key);\n\n      // Verify this hex overlaps with bounds\n      const worldPos = hexToWorld({ q, r }, hexSize);\n      const inBounds =\n        worldPos.x >= bounds.minX - hexSize * 2 &&\n        worldPos.x <= bounds.maxX + hexSize * 2 &&\n        worldPos.z >= bounds.minZ - hexSize * 2 &&\n        worldPos.z <= bounds.maxZ + hexSize * 2;\n\n      if (inBounds) {\n        hexCoords.push({ q, r });\n      }\n    }\n  }\n\n  return hexCoords;\n}",
      "references": [
        "Set",
        "worldToHex",
        "minHex",
        "maxHex",
        "qMin",
        "q",
        "qMax",
        "rMin",
        "r",
        "rMax",
        "seen",
        "key",
        "hexToWorld",
        "worldPos",
        "inBounds",
        "hexCoords"
      ]
    },
    "file:web/src/components/village/DistrictGround.tsx:fn:DistrictGround:81": {
      "id": "file:web/src/components/village/DistrictGround.tsx:fn:DistrictGround:81",
      "type": "function",
      "name": "DistrictGround",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DistrictGround.tsx",
      "line": 81,
      "endLine": 102,
      "parentFileId": "file:web/src/components/village/DistrictGround.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  district,\n  hexSize = DEFAULT_HEX_SIZE,\n  padding = 1,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/DistrictGround\").DistrictGroundProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders hex tiles layer for a district using its bounds and category.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.472Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function DistrictGround({\n  district,\n  hexSize = DEFAULT_HEX_SIZE,\n  padding = 1,\n}: DistrictGroundProps) {\n  // Generate hex tiles for this district\n  const tiles = useMemo(() => {\n    const hexCoords = generateHexGridForBounds(district.bounds, hexSize, padding);\n    return hexCoords.map(coord => ({\n      coord,\n      category: district.category,\n    }));\n  }, [district.bounds, district.category, hexSize, padding]);\n\n  return (\n    <HexTilesLayer\n      tiles={tiles}\n      hexSize={hexSize}\n      yOffset={-0.01} // Slightly below y=0\n    />\n  );\n}",
      "references": [
        "useMemo",
        "generateHexGridForBounds",
        "district",
        "hexSize",
        "padding",
        "hexCoords",
        "coord",
        "HexTilesLayer",
        "tiles",
        "yOffset"
      ]
    },
    "file:web/src/components/village/DistrictGround.tsx:fn:VillageGround:122": {
      "id": "file:web/src/components/village/DistrictGround.tsx:fn:VillageGround:122",
      "type": "function",
      "name": "VillageGround",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DistrictGround.tsx",
      "line": 122,
      "endLine": 181,
      "parentFileId": "file:web/src/components/village/DistrictGround.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  layout,\n  hexSize = DEFAULT_HEX_SIZE,\n  padding = 1,\n  showConnector = true,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/DistrictGround\").VillageGroundProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders hex tiles for village districts and optional center connector with shadow plane.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.118Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function VillageGround({\n  layout,\n  hexSize = DEFAULT_HEX_SIZE,\n  padding = 1,\n  showConnector = true,\n}: VillageGroundProps) {\n  // Generate tiles for all districts plus connector\n  const allTiles = useMemo(() => {\n    const tiles: { coord: HexCoord; category: MemoryCategory }[] = [];\n    const seen = new Set<string>();\n\n    // Add tiles for each district\n    for (const district of layout.districts) {\n      const hexCoords = generateHexGridForBounds(district.bounds, hexSize, padding);\n      for (const coord of hexCoords) {\n        const key = `${coord.q},${coord.r}`;\n        if (!seen.has(key)) {\n          seen.add(key);\n          tiles.push({ coord, category: district.category });\n        }\n      }\n    }\n\n    // Add connector tiles in center (misc category)\n    if (showConnector) {\n      const centerRange = 3;\n      for (let q = -centerRange; q <= centerRange; q++) {\n        for (let r = -centerRange; r <= centerRange; r++) {\n          const key = `${q},${r}`;\n          if (!seen.has(key)) {\n            seen.add(key);\n            tiles.push({ coord: { q, r }, category: 'misc' });\n          }\n        }\n      }\n    }\n\n    return tiles;\n  }, [layout.districts, hexSize, padding, showConnector]);\n\n  return (\n    <group>\n      <HexTilesLayer\n        tiles={allTiles}\n        hexSize={hexSize}\n        yOffset={-0.01}\n      />\n\n      {/* Shadow receiver plane (invisible but catches shadows) */}\n      <mesh\n        rotation={[-Math.PI / 2, 0, 0]}\n        position={[0, -0.02, 0]}\n        receiveShadow\n      >\n        <planeGeometry args={[200, 200]} />\n        <shadowMaterial opacity={0.3} />\n      </mesh>\n    </group>\n  );\n}",
      "references": [
        "useMemo",
        "Set",
        "layout",
        "generateHexGridForBounds",
        "district",
        "hexSize",
        "padding",
        "hexCoords",
        "coord",
        "seen",
        "key",
        "tiles",
        "showConnector",
        "centerRange",
        "q",
        "r",
        "group",
        "HexTilesLayer",
        "allTiles",
        "yOffset",
        "mesh",
        "rotation",
        "Math",
        "position",
        "receiveShadow",
        "planeGeometry",
        "args",
        "shadowMaterial",
        "opacity"
      ]
    },
    "file:web/src/components/village/DreamEffects.tsx": {
      "id": "file:web/src/components/village/DreamEffects.tsx",
      "type": "file",
      "name": "DreamEffects.tsx",
      "filePath": "web/src/components/village/DreamEffects.tsx",
      "line": 1,
      "endLine": 177,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/postprocessing",
          "items": [
            {
              "name": "EffectComposer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Bloom",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Vignette",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChromaticAberration",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DepthOfField",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Noise",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "postprocessing",
          "items": [
            {
              "name": "BlendFunction",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "KernelSize",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Resolution",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DreamEffects",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamEffects",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/DreamEffects.tsx:fn:DreamEffects:39"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/DreamEffects.tsx:fn:DreamEffects:39": {
      "id": "file:web/src/components/village/DreamEffects.tsx:fn:DreamEffects:39",
      "type": "function",
      "name": "DreamEffects",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamEffects.tsx",
      "line": 39,
      "endLine": 174,
      "parentFileId": "file:web/src/components/village/DreamEffects.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  bloomIntensity = 0.6,\n  vignetteDarkness = 0.5,\n  chromaticOffset = 0.002,\n  enableDOF = false,\n  enableNoise = true,\n}",
          "type": "DreamEffectsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders conditional Three.js post-processing effects with animated chromatic aberration",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.118Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function DreamEffects({\n  bloomIntensity = 0.6,\n  vignetteDarkness = 0.5,\n  chromaticOffset = 0.002,\n  enableDOF = false,\n  enableNoise = true,\n}: DreamEffectsProps) {\n  const chromaticRef = useRef<THREE.Vector2 | null>(null);\n\n  // Subtle animated chromatic aberration\n  useFrame(({ clock }) => {\n    if (chromaticRef.current) {\n      const time = clock.getElapsedTime();\n      const offset = chromaticOffset * (1 + Math.sin(time * 0.5) * 0.3);\n      chromaticRef.current.set(offset, offset);\n    }\n  });\n\n  // Use different composer configurations based on options\n  if (enableDOF && enableNoise) {\n    return (\n      <EffectComposer>\n        <Bloom\n          intensity={bloomIntensity}\n          kernelSize={KernelSize.MEDIUM}\n          luminanceThreshold={0.5}\n          luminanceSmoothing={0.8}\n          resolutionScale={0.5}\n        />\n        <Vignette\n          offset={0.3}\n          darkness={vignetteDarkness}\n          blendFunction={BlendFunction.NORMAL}\n        />\n        <ChromaticAberration\n          offset={new THREE.Vector2(chromaticOffset, chromaticOffset)}\n          blendFunction={BlendFunction.NORMAL}\n          radialModulation={true}\n          modulationOffset={0.5}\n        />\n        <DepthOfField\n          focusDistance={0.02}\n          focalLength={0.05}\n          bokehScale={3}\n        />\n        <Noise\n          opacity={0.08}\n          blendFunction={BlendFunction.SOFT_LIGHT}\n        />\n      </EffectComposer>\n    );\n  }\n\n  if (enableDOF) {\n    return (\n      <EffectComposer>\n        <Bloom\n          intensity={bloomIntensity}\n          kernelSize={KernelSize.MEDIUM}\n          luminanceThreshold={0.5}\n          luminanceSmoothing={0.8}\n          resolutionScale={0.5}\n        />\n        <Vignette\n          offset={0.3}\n          darkness={vignetteDarkness}\n          blendFunction={BlendFunction.NORMAL}\n        />\n        <ChromaticAberration\n          offset={new THREE.Vector2(chromaticOffset, chromaticOffset)}\n          blendFunction={BlendFunction.NORMAL}\n          radialModulation={true}\n          modulationOffset={0.5}\n        />\n        <DepthOfField\n          focusDistance={0.02}\n          focalLength={0.05}\n          bokehScale={3}\n        />\n      </EffectComposer>\n    );\n  }\n\n  if (enableNoise) {\n    return (\n      <EffectComposer>\n        <Bloom\n          intensity={bloomIntensity}\n          kernelSize={KernelSize.MEDIUM}\n          luminanceThreshold={0.5}\n          luminanceSmoothing={0.8}\n          resolutionScale={0.5}\n        />\n        <Vignette\n          offset={0.3}\n          darkness={vignetteDarkness}\n          blendFunction={BlendFunction.NORMAL}\n        />\n        <ChromaticAberration\n          offset={new THREE.Vector2(chromaticOffset, chromaticOffset)}\n          blendFunction={BlendFunction.NORMAL}\n          radialModulation={true}\n          modulationOffset={0.5}\n        />\n        <Noise\n          opacity={0.08}\n          blendFunction={BlendFunction.SOFT_LIGHT}\n        />\n      </EffectComposer>\n    );\n  }\n\n  // Base effects only\n  return (\n    <EffectComposer>\n      <Bloom\n        intensity={bloomIntensity}\n        kernelSize={KernelSize.LARGE}\n        luminanceThreshold={0.4}\n        luminanceSmoothing={0.9}\n        mipmapBlur\n      />\n      <Vignette\n        offset={0.3}\n        darkness={vignetteDarkness}\n        blendFunction={BlendFunction.NORMAL}\n      />\n      <ChromaticAberration\n        offset={new THREE.Vector2(chromaticOffset, chromaticOffset)}\n        blendFunction={BlendFunction.NORMAL}\n        radialModulation={true}\n        modulationOffset={0.5}\n      />\n    </EffectComposer>\n  );\n}",
      "references": [
        "useRef",
        "useFrame",
        "clock",
        "chromaticRef",
        "chromaticOffset",
        "Math",
        "time",
        "offset",
        "enableDOF",
        "enableNoise",
        "EffectComposer",
        "Bloom",
        "intensity",
        "bloomIntensity",
        "kernelSize",
        "KernelSize",
        "luminanceThreshold",
        "luminanceSmoothing",
        "resolutionScale",
        "Vignette",
        "darkness",
        "vignetteDarkness",
        "blendFunction",
        "BlendFunction",
        "ChromaticAberration",
        "THREE",
        "radialModulation",
        "modulationOffset",
        "DepthOfField",
        "focusDistance",
        "focalLength",
        "bokehScale",
        "Noise",
        "opacity",
        "mipmapBlur"
      ]
    },
    "file:web/src/components/village/DreamLighting.tsx": {
      "id": "file:web/src/components/village/DreamLighting.tsx",
      "type": "file",
      "name": "DreamLighting.tsx",
      "filePath": "web/src/components/village/DreamLighting.tsx",
      "line": 1,
      "endLine": 247,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DreamLighting",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamAtmosphere",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamLighting",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/DreamLighting.tsx:fn:AnimatedHemisphereLight:28",
        "file:web/src/components/village/DreamLighting.tsx:fn:PulsingPointLight:75",
        "file:web/src/components/village/DreamLighting.tsx:fn:DreamLighting:116",
        "file:web/src/components/village/DreamLighting.tsx:fn:DreamAtmosphere:236"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/DreamLighting.tsx:fn:AnimatedHemisphereLight:28": {
      "id": "file:web/src/components/village/DreamLighting.tsx:fn:AnimatedHemisphereLight:28",
      "type": "function",
      "name": "AnimatedHemisphereLight",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamLighting.tsx",
      "line": 28,
      "endLine": 56,
      "parentFileId": "file:web/src/components/village/DreamLighting.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  skyColorA = '#8b5cf6', // Violet\n  skyColorB = '#3b82f6', // Blue\n  groundColor = '#2d1f47', // Dark purple\n  intensity = 0.4,\n}",
          "type": "AnimatedHemisphereLightProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an animated Three.js HemisphereLight shifting sky color slowly.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.359Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function AnimatedHemisphereLight({\n  skyColorA = '#8b5cf6', // Violet\n  skyColorB = '#3b82f6', // Blue\n  groundColor = '#2d1f47', // Dark purple\n  intensity = 0.4,\n}: AnimatedHemisphereLightProps) {\n  const lightRef = useRef<THREE.HemisphereLight>(null);\n  const colorA = new THREE.Color(skyColorA);\n  const colorB = new THREE.Color(skyColorB);\n  const targetColor = new THREE.Color();\n\n  useFrame(({ clock }) => {\n    if (lightRef.current) {\n      // Very slow color shift (full cycle every ~30 seconds)\n      const t = (Math.sin(clock.getElapsedTime() * 0.2) + 1) * 0.5;\n      targetColor.lerpColors(colorA, colorB, t);\n      lightRef.current.color.lerp(targetColor, 0.02);\n    }\n  });\n\n  return (\n    <hemisphereLight\n      ref={lightRef}\n      color={skyColorA}\n      groundColor={groundColor}\n      intensity={intensity}\n    />\n  );\n}",
      "references": [
        "useRef",
        "THREE",
        "skyColorA",
        "skyColorB",
        "useFrame",
        "clock",
        "lightRef",
        "Math",
        "targetColor",
        "colorA",
        "colorB",
        "t",
        "hemisphereLight",
        "ref",
        "color",
        "groundColor",
        "intensity"
      ]
    },
    "file:web/src/components/village/DreamLighting.tsx:fn:PulsingPointLight:75": {
      "id": "file:web/src/components/village/DreamLighting.tsx:fn:PulsingPointLight:75",
      "type": "function",
      "name": "PulsingPointLight",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamLighting.tsx",
      "line": 75,
      "endLine": 102,
      "parentFileId": "file:web/src/components/village/DreamLighting.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  position,\n  color = '#ffa500',\n  intensity = 0.5,\n  distance = 30,\n  pulseSpeed = 0.5,\n  pulseAmount = 0.3,\n}",
          "type": "PulsingPointLightProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a pulsing point light in Three.js with animated intensity via useFrame.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.235Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function PulsingPointLight({\n  position,\n  color = '#ffa500',\n  intensity = 0.5,\n  distance = 30,\n  pulseSpeed = 0.5,\n  pulseAmount = 0.3,\n}: PulsingPointLightProps) {\n  const lightRef = useRef<THREE.PointLight>(null);\n\n  useFrame(({ clock }) => {\n    if (lightRef.current) {\n      const t = Math.sin(clock.getElapsedTime() * pulseSpeed);\n      lightRef.current.intensity = intensity * (1 + t * pulseAmount);\n    }\n  });\n\n  return (\n    <pointLight\n      ref={lightRef}\n      position={position}\n      color={color}\n      intensity={intensity}\n      distance={distance}\n      decay={2}\n    />\n  );\n}",
      "references": [
        "useRef",
        "useFrame",
        "clock",
        "lightRef",
        "Math",
        "pulseSpeed",
        "intensity",
        "t",
        "pulseAmount",
        "pointLight",
        "ref",
        "position",
        "color",
        "distance",
        "decay"
      ]
    },
    "file:web/src/components/village/DreamLighting.tsx:fn:DreamLighting:116": {
      "id": "file:web/src/components/village/DreamLighting.tsx:fn:DreamLighting:116",
      "type": "function",
      "name": "DreamLighting",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamLighting.tsx",
      "line": 116,
      "endLine": 220,
      "parentFileId": "file:web/src/components/village/DreamLighting.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ enableAnimation = true }",
          "type": "DreamLightingProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated Three.js lights for dreamy village scene with color-shifting directional light.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function DreamLighting({ enableAnimation = true }: DreamLightingProps) {\n  const directionalRef = useRef<THREE.DirectionalLight>(null);\n\n  // Subtle directional light color shift\n  useFrame(({ clock }) => {\n    if (enableAnimation && directionalRef.current) {\n      const t = (Math.sin(clock.getElapsedTime() * 0.1) + 1) * 0.5;\n      // Shift between warm golden and soft peach\n      const r = 1.0;\n      const g = 0.9 + t * 0.05;\n      const b = 0.85 + t * 0.1;\n      directionalRef.current.color.setRGB(r, g, b);\n    }\n  });\n\n  return (\n    <>\n      {/* Ambient base - warm and soft */}\n      <ambientLight intensity={0.2} color=\"#ffe4c4\" />\n\n      {/* Animated hemisphere - aurora-like color shifts */}\n      {enableAnimation ? (\n        <AnimatedHemisphereLight\n          skyColorA=\"#8b5cf6\"\n          skyColorB=\"#6366f1\"\n          groundColor=\"#1a1525\"\n          intensity={0.4}\n        />\n      ) : (\n        <hemisphereLight\n          color=\"#8b5cf6\"\n          groundColor=\"#1a1525\"\n          intensity={0.4}\n        />\n      )}\n\n      {/* Main sun light - golden hour, soft shadows */}\n      <directionalLight\n        ref={directionalRef}\n        position={[-20, 25, -15]}\n        intensity={1.0} // Slightly reduced for dreamier feel\n        color=\"#ffeedd\"\n        castShadow\n        shadow-mapSize={[2048, 2048]}\n        shadow-camera-far={100}\n        shadow-camera-left={-40}\n        shadow-camera-right={40}\n        shadow-camera-top={40}\n        shadow-camera-bottom={-40}\n        shadow-bias={-0.0001}\n        shadow-radius={4} // Softer shadows\n      />\n\n      {/* Cool fill light - softer */}\n      <directionalLight\n        position={[15, 12, 20]}\n        intensity={0.2}\n        color=\"#b4d4ff\"\n      />\n\n      {/* Rim light - ethereal backlight */}\n      <directionalLight\n        position={[0, 8, -25]}\n        intensity={0.12}\n        color=\"#e0b0ff\"\n      />\n\n      {/* Center warmth - pulsing */}\n      {enableAnimation ? (\n        <PulsingPointLight\n          position={[0, 6, 0]}\n          color=\"#ffa500\"\n          intensity={0.35}\n          distance={35}\n          pulseSpeed={0.3}\n          pulseAmount={0.25}\n        />\n      ) : (\n        <pointLight\n          position={[0, 6, 0]}\n          intensity={0.35}\n          color=\"#ffa500\"\n          distance={35}\n          decay={2}\n        />\n      )}\n\n      {/* Additional ethereal accent lights */}\n      <pointLight\n        position={[-15, 3, 10]}\n        intensity={0.15}\n        color=\"#a78bfa\"\n        distance={20}\n        decay={2}\n      />\n      <pointLight\n        position={[15, 3, -10]}\n        intensity={0.15}\n        color=\"#60a5fa\"\n        distance={20}\n        decay={2}\n      />\n    </>\n  );\n}",
      "references": [
        "useRef",
        "useFrame",
        "clock",
        "enableAnimation",
        "directionalRef",
        "Math",
        "t",
        "r",
        "g",
        "b",
        "ambientLight",
        "intensity",
        "color",
        "AnimatedHemisphereLight",
        "skyColorA",
        "skyColorB",
        "groundColor",
        "hemisphereLight",
        "directionalLight",
        "ref",
        "position",
        "castShadow",
        "shadow-mapSize",
        "shadow-camera-far",
        "shadow-camera-left",
        "shadow-camera-right",
        "shadow-camera-top",
        "shadow-camera-bottom",
        "shadow-bias",
        "shadow-radius",
        "PulsingPointLight",
        "distance",
        "pulseSpeed",
        "pulseAmount",
        "pointLight",
        "decay"
      ]
    },
    "file:web/src/components/village/DreamLighting.tsx:fn:DreamAtmosphere:236": {
      "id": "file:web/src/components/village/DreamLighting.tsx:fn:DreamAtmosphere:236",
      "type": "function",
      "name": "DreamAtmosphere",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamLighting.tsx",
      "line": 236,
      "endLine": 244,
      "parentFileId": "file:web/src/components/village/DreamLighting.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  fogColor = '#1a1525',\n  fogNear = 25,\n  fogFar = 100,\n}",
          "type": "DreamAtmosphereProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a fog effect in a 3D scene with customizable color, near, and far distances.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function DreamAtmosphere({\n  fogColor = '#1a1525',\n  fogNear = 25,\n  fogFar = 100,\n}: DreamAtmosphereProps) {\n  return (\n    <fog attach=\"fog\" args={[fogColor, fogNear, fogFar]} />\n  );\n}",
      "references": [
        "fog",
        "attach",
        "args",
        "fogColor",
        "fogNear",
        "fogFar"
      ]
    },
    "file:web/src/components/village/DreamParticles.tsx": {
      "id": "file:web/src/components/village/DreamParticles.tsx",
      "type": "file",
      "name": "DreamParticles.tsx",
      "filePath": "web/src/components/village/DreamParticles.tsx",
      "line": 1,
      "endLine": 227,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DreamParticles",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamParticles",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/DreamParticles.tsx:fn:DreamParticles:93",
        "file:web/src/components/village/DreamParticles.tsx:fn:Fireflies:209"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/DreamParticles.tsx:fn:DreamParticles:93": {
      "id": "file:web/src/components/village/DreamParticles.tsx:fn:DreamParticles:93",
      "type": "function",
      "name": "DreamParticles",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamParticles.tsx",
      "line": 93,
      "endLine": 203,
      "parentFileId": "file:web/src/components/village/DreamParticles.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  count = 500,\n  bounds = { minX: -30, maxX: 30, minZ: -30, maxZ: 30 },\n  color1 = '#ffd700', // Warm gold\n  color2 = '#a78bfa', // Soft violet\n  size = 12, // Smaller default\n}",
          "type": "DreamParticlesProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated Three.js particle system for dream-like effects in React Three Fiber",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.305Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function DreamParticles({\n  count = 500,\n  bounds = { minX: -30, maxX: 30, minZ: -30, maxZ: 30 },\n  color1 = '#ffd700', // Warm gold\n  color2 = '#a78bfa', // Soft violet\n  size = 12, // Smaller default\n}: DreamParticlesProps) {\n  const pointsRef = useRef<THREE.Points>(null);\n  const materialRef = useRef<THREE.ShaderMaterial>(null);\n\n  // Generate particle attributes\n  const { positions, scales, phases, velocities } = useMemo(() => {\n    const positions = new Float32Array(count * 3);\n    const scales = new Float32Array(count);\n    const phases = new Float32Array(count);\n    const velocities = new Float32Array(count * 3);\n\n    const rangeX = bounds.maxX - bounds.minX;\n    const rangeZ = bounds.maxZ - bounds.minZ;\n\n    for (let i = 0; i < count; i++) {\n      const i3 = i * 3;\n\n      // Random position within bounds\n      positions[i3] = bounds.minX + Math.random() * rangeX;\n      positions[i3 + 1] = Math.random() * 15 - 2; // -2 to 13 height\n      positions[i3 + 2] = bounds.minZ + Math.random() * rangeZ;\n\n      // Random scale (some bigger \"fireflies\", many small dust motes)\n      scales[i] = Math.random() < 0.1 ? 0.8 + Math.random() * 0.4 : 0.2 + Math.random() * 0.3;\n\n      // Random phase for animation offset\n      phases[i] = Math.random();\n\n      // Random velocity for drift\n      velocities[i3] = (Math.random() - 0.5) * 0.5;\n      velocities[i3 + 1] = 0.1 + Math.random() * 0.3; // Upward drift\n      velocities[i3 + 2] = (Math.random() - 0.5) * 0.5;\n    }\n\n    return { positions, scales, phases, velocities };\n  }, [count, bounds.minX, bounds.maxX, bounds.minZ, bounds.maxZ]);\n\n  // Animation\n  useFrame(({ clock }) => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.uTime.value = clock.getElapsedTime();\n    }\n  });\n\n  const uniforms = useMemo(\n    () => ({\n      uTime: { value: 0 },\n      uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },\n      uColor1: { value: new THREE.Color(color1) },\n      uColor2: { value: new THREE.Color(color2) },\n      uSize: { value: size },\n    }),\n    [color1, color2, size]\n  );\n\n  // Create buffer attributes with useMemo for stability\n  const positionAttr = useMemo(\n    () => new THREE.BufferAttribute(positions, 3),\n    [positions]\n  );\n  const scaleAttr = useMemo(\n    () => new THREE.BufferAttribute(scales, 1),\n    [scales]\n  );\n  const phaseAttr = useMemo(\n    () => new THREE.BufferAttribute(phases, 1),\n    [phases]\n  );\n  const velocityAttr = useMemo(\n    () => new THREE.BufferAttribute(velocities, 3),\n    [velocities]\n  );\n\n  // Cleanup: dispose geometry and material on unmount\n  useEffect(() => {\n    return () => {\n      if (pointsRef.current) {\n        pointsRef.current.geometry?.dispose();\n        if (pointsRef.current.material instanceof THREE.Material) {\n          pointsRef.current.material.dispose();\n        }\n      }\n    };\n  }, []);\n\n  return (\n    <points ref={pointsRef}>\n      <bufferGeometry>\n        <primitive attach=\"attributes-position\" object={positionAttr} />\n        <primitive attach=\"attributes-aScale\" object={scaleAttr} />\n        <primitive attach=\"attributes-aPhase\" object={phaseAttr} />\n        <primitive attach=\"attributes-aVelocity\" object={velocityAttr} />\n      </bufferGeometry>\n      <shaderMaterial\n        ref={materialRef}\n        vertexShader={particleVertexShader}\n        fragmentShader={particleFragmentShader}\n        uniforms={uniforms}\n        transparent\n        depthWrite={false}\n        blending={THREE.AdditiveBlending}\n      />\n    </points>\n  );\n}",
      "references": [
        "useRef",
        "positions",
        "scales",
        "phases",
        "velocities",
        "useMemo",
        "Float32Array",
        "count",
        "bounds",
        "i",
        "i3",
        "Math",
        "rangeX",
        "rangeZ",
        "useFrame",
        "clock",
        "materialRef",
        "window",
        "THREE",
        "color1",
        "color2",
        "size",
        "useEffect",
        "pointsRef",
        "points",
        "ref",
        "bufferGeometry",
        "primitive",
        "attach",
        "positionAttr",
        "scaleAttr",
        "phaseAttr",
        "velocityAttr",
        "shaderMaterial",
        "vertexShader",
        "particleVertexShader",
        "fragmentShader",
        "particleFragmentShader",
        "uniforms",
        "transparent",
        "depthWrite",
        "blending"
      ]
    },
    "file:web/src/components/village/DreamParticles.tsx:fn:Fireflies:209": {
      "id": "file:web/src/components/village/DreamParticles.tsx:fn:Fireflies:209",
      "type": "function",
      "name": "Fireflies",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/DreamParticles.tsx",
      "line": 209,
      "endLine": 224,
      "parentFileId": "file:web/src/components/village/DreamParticles.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  count = 30,\n  bounds = { minX: -30, maxX: 30, minZ: -30, maxZ: 30 },\n}",
          "type": "{ count?: number; bounds?: { minX: number; maxX: number; minZ: number; maxZ: number; }; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders DreamParticles with firefly colors, given count and bounds.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:17.986Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function Fireflies({\n  count = 30,\n  bounds = { minX: -30, maxX: 30, minZ: -30, maxZ: 30 },\n}: {\n  count?: number;\n  bounds?: { minX: number; maxX: number; minZ: number; maxZ: number };\n}) {\n  return (\n    <DreamParticles\n      count={count}\n      bounds={bounds}\n      color1=\"#ffdd44\"\n      color2=\"#ff9944\"\n    />\n  );\n}",
      "references": [
        "DreamParticles",
        "count",
        "bounds",
        "color1",
        "color2"
      ]
    },
    "file:web/src/components/village/FirstPersonControls.tsx": {
      "id": "file:web/src/components/village/FirstPersonControls.tsx",
      "type": "file",
      "name": "FirstPersonControls.tsx",
      "filePath": "web/src/components/village/FirstPersonControls.tsx",
      "line": 1,
      "endLine": 318,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ElementRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useThree",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/drei",
          "items": [
            {
              "name": "PointerLockControls",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "Vector3",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useSetPointerLocked",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "FirstPersonControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FirstPersonControlsProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FirstPersonControls",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/FirstPersonControls.tsx:fn:useKeyboardState:41",
        "file:web/src/components/village/FirstPersonControls.tsx:fn:MovementController:129",
        "file:web/src/components/village/FirstPersonControls.tsx:fn:ProximityDetector:190",
        "file:web/src/components/village/FirstPersonControls.tsx:fn:FirstPersonControls:247"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/FirstPersonControls.tsx:fn:useKeyboardState:41": {
      "id": "file:web/src/components/village/FirstPersonControls.tsx:fn:useKeyboardState:41",
      "type": "function",
      "name": "useKeyboardState",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/FirstPersonControls.tsx",
      "line": 41,
      "endLine": 118,
      "parentFileId": "file:web/src/components/village/FirstPersonControls.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "KeyboardState",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook tracking keyboard states (WASD/arrows, shift, E) via global event listeners",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function useKeyboardState(): KeyboardState {\n  const state = useRef<KeyboardState>({\n    forward: false,\n    backward: false,\n    left: false,\n    right: false,\n    sprint: false,\n    interact: false,\n  });\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      switch (e.code) {\n        case 'KeyW':\n        case 'ArrowUp':\n          state.current.forward = true;\n          break;\n        case 'KeyS':\n        case 'ArrowDown':\n          state.current.backward = true;\n          break;\n        case 'KeyA':\n        case 'ArrowLeft':\n          state.current.left = true;\n          break;\n        case 'KeyD':\n        case 'ArrowRight':\n          state.current.right = true;\n          break;\n        case 'ShiftLeft':\n        case 'ShiftRight':\n          state.current.sprint = true;\n          break;\n        case 'KeyE':\n          state.current.interact = true;\n          break;\n      }\n    };\n\n    const handleKeyUp = (e: KeyboardEvent) => {\n      switch (e.code) {\n        case 'KeyW':\n        case 'ArrowUp':\n          state.current.forward = false;\n          break;\n        case 'KeyS':\n        case 'ArrowDown':\n          state.current.backward = false;\n          break;\n        case 'KeyA':\n        case 'ArrowLeft':\n          state.current.left = false;\n          break;\n        case 'KeyD':\n        case 'ArrowRight':\n          state.current.right = false;\n          break;\n        case 'ShiftLeft':\n        case 'ShiftRight':\n          state.current.sprint = false;\n          break;\n        case 'KeyE':\n          state.current.interact = false;\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, []);\n\n  return state.current;\n}",
      "references": [
        "useRef",
        "useEffect",
        "e",
        "state",
        "window",
        "handleKeyDown",
        "handleKeyUp"
      ]
    },
    "file:web/src/components/village/FirstPersonControls.tsx:fn:MovementController:129": {
      "id": "file:web/src/components/village/FirstPersonControls.tsx:fn:MovementController:129",
      "type": "function",
      "name": "MovementController",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/FirstPersonControls.tsx",
      "line": 129,
      "endLine": 177,
      "parentFileId": "file:web/src/components/village/FirstPersonControls.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ keyboard, bounds }",
          "type": "MovementControllerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Updates camera position for first-person movement using keyboard input and bounds.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function MovementController({ keyboard, bounds }: MovementControllerProps) {\n  const { camera } = useThree();\n  const direction = useRef(new Vector3());\n  const velocity = useRef(new Vector3());\n\n  useFrame((_, delta) => {\n    // Reset direction\n    direction.current.set(0, 0, 0);\n\n    // Calculate movement direction based on camera orientation\n    if (keyboard.forward) direction.current.z -= 1;\n    if (keyboard.backward) direction.current.z += 1;\n    if (keyboard.left) direction.current.x -= 1;\n    if (keyboard.right) direction.current.x += 1;\n\n    // Normalize if moving diagonally\n    if (direction.current.length() > 0) {\n      direction.current.normalize();\n    }\n\n    // Apply speed\n    const speed = keyboard.sprint ? SPRINT_SPEED : WALK_SPEED;\n    velocity.current.copy(direction.current).multiplyScalar(speed * delta);\n\n    // Transform direction to world space (based on camera yaw only)\n    const yaw = Math.atan2(\n      camera.matrix.elements[8],\n      camera.matrix.elements[10]\n    );\n    const cos = Math.cos(-yaw);\n    const sin = Math.sin(-yaw);\n    const newX = velocity.current.x * cos - velocity.current.z * sin;\n    const newZ = velocity.current.x * sin + velocity.current.z * cos;\n\n    // Apply movement\n    camera.position.x += newX;\n    camera.position.z += newZ;\n\n    // Lock Y to eye height (ground constraint)\n    camera.position.y = EYE_HEIGHT;\n\n    // Clamp to bounds with padding\n    const padding = 5;\n    camera.position.x = Math.max(bounds.minX - padding, Math.min(bounds.maxX + padding, camera.position.x));\n    camera.position.z = Math.max(bounds.minZ - padding, Math.min(bounds.maxZ + padding, camera.position.z));\n  });\n\n  return null;\n}",
      "references": [
        "camera",
        "useThree",
        "useRef",
        "Vector3",
        "useFrame",
        "direction",
        "keyboard",
        "SPRINT_SPEED",
        "WALK_SPEED",
        "velocity",
        "speed",
        "delta",
        "Math",
        "yaw",
        "cos",
        "sin",
        "newX",
        "newZ",
        "EYE_HEIGHT",
        "bounds",
        "padding"
      ]
    },
    "file:web/src/components/village/FirstPersonControls.tsx:fn:ProximityDetector:190": {
      "id": "file:web/src/components/village/FirstPersonControls.tsx:fn:ProximityDetector:190",
      "type": "function",
      "name": "ProximityDetector",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/FirstPersonControls.tsx",
      "line": 190,
      "endLine": 233,
      "parentFileId": "file:web/src/components/village/FirstPersonControls.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  buildings,\n  keyboard,\n  onProximityChange,\n  onInteract,\n}",
          "type": "ProximityDetectorProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Detects closest building to camera, notifies on proximity change, handles E-key interaction.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function ProximityDetector({\n  buildings,\n  keyboard,\n  onProximityChange,\n  onInteract,\n}: ProximityDetectorProps) {\n  const { camera } = useThree();\n  const lastNearbyRef = useRef<VillageBuilding | null>(null);\n  const interactedRef = useRef(false);\n\n  useFrame(() => {\n    // Find closest building within interaction distance\n    let closest: VillageBuilding | null = null;\n    let closestDist = INTERACTION_DISTANCE;\n\n    for (const building of buildings) {\n      const dx = camera.position.x - building.position.x;\n      const dz = camera.position.z - building.position.z;\n      const dist = Math.sqrt(dx * dx + dz * dz);\n\n      if (dist < closestDist) {\n        closest = building;\n        closestDist = dist;\n      }\n    }\n\n    // Notify if proximity changed\n    if (closest !== lastNearbyRef.current) {\n      lastNearbyRef.current = closest;\n      onProximityChange(closest);\n    }\n\n    // Handle E key interaction\n    if (keyboard.interact && closest && !interactedRef.current) {\n      interactedRef.current = true;\n      onInteract(closest);\n    }\n    if (!keyboard.interact) {\n      interactedRef.current = false;\n    }\n  });\n\n  return null;\n}",
      "references": [
        "camera",
        "useThree",
        "useRef",
        "useFrame",
        "INTERACTION_DISTANCE",
        "buildings",
        "building",
        "Math",
        "dx",
        "dz",
        "dist",
        "closestDist",
        "closest",
        "lastNearbyRef",
        "onProximityChange",
        "keyboard",
        "interactedRef",
        "onInteract"
      ]
    },
    "file:web/src/components/village/FirstPersonControls.tsx:fn:FirstPersonControls:247": {
      "id": "file:web/src/components/village/FirstPersonControls.tsx:fn:FirstPersonControls:247",
      "type": "function",
      "name": "FirstPersonControls",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/FirstPersonControls.tsx",
      "line": 247,
      "endLine": 315,
      "parentFileId": "file:web/src/components/village/FirstPersonControls.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  bounds,\n  buildings,\n  onBuildingProximity,\n  onBuildingInteract,\n  initialPosition,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/FirstPersonControls\").FirstPersonControlsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for first-person controls with pointer lock, camera positioning, and building proximity in 3D village.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function FirstPersonControls({\n  bounds,\n  buildings,\n  onBuildingProximity,\n  onBuildingInteract,\n  initialPosition,\n}: FirstPersonControlsProps) {\n  const controlsRef = useRef<ElementRef<typeof PointerLockControls>>(null);\n  const { camera } = useThree();\n  const setPointerLocked = useSetPointerLocked();\n  const keyboard = useKeyboardState();\n\n  // Set initial camera position (only once on mount)\n  useEffect(() => {\n    const centerX = initialPosition?.x ?? (bounds.minX + bounds.maxX) / 2;\n    const centerZ = initialPosition?.z ?? (bounds.minZ + bounds.maxZ) / 2;\n\n    if (lastWalkPosition) {\n      // Returning from fly mode - restore saved walk position\n      camera.position.set(lastWalkPosition.x, EYE_HEIGHT, lastWalkPosition.z);\n    } else {\n      // First load - start at center\n      camera.position.set(centerX, EYE_HEIGHT, centerZ);\n      camera.lookAt(centerX, EYE_HEIGHT, centerZ - 10);\n    }\n\n    // Save position on unmount (for when returning from fly mode)\n    return () => {\n      lastWalkPosition = { x: camera.position.x, z: camera.position.z };\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Empty deps - only run once per mount\n\n  // Handle pointer lock events\n  const handleLock = useCallback(() => {\n    setPointerLocked(true);\n  }, [setPointerLocked]);\n\n  const handleUnlock = useCallback(() => {\n    setPointerLocked(false);\n  }, [setPointerLocked]);\n\n  // Handle proximity changes\n  const handleProximityChange = useCallback((building: VillageBuilding | null) => {\n    onBuildingProximity?.(building);\n  }, [onBuildingProximity]);\n\n  // Handle building interaction\n  const handleInteract = useCallback((building: VillageBuilding) => {\n    onBuildingInteract?.(building);\n  }, [onBuildingInteract]);\n\n  return (\n    <>\n      <PointerLockControls\n        ref={controlsRef}\n        onLock={handleLock}\n        onUnlock={handleUnlock}\n      />\n      <MovementController keyboard={keyboard} bounds={bounds} />\n      <ProximityDetector\n        buildings={buildings}\n        keyboard={keyboard}\n        onProximityChange={handleProximityChange}\n        onInteract={handleInteract}\n      />\n    </>\n  );\n}",
      "references": [
        "useRef",
        "camera",
        "useThree",
        "useSetPointerLocked",
        "useKeyboardState",
        "useEffect",
        "initialPosition",
        "bounds",
        "lastWalkPosition",
        "EYE_HEIGHT",
        "centerX",
        "centerZ",
        "useCallback",
        "setPointerLocked",
        "onBuildingProximity",
        "building",
        "onBuildingInteract",
        "PointerLockControls",
        "ref",
        "controlsRef",
        "onLock",
        "handleLock",
        "onUnlock",
        "handleUnlock",
        "MovementController",
        "keyboard",
        "ProximityDetector",
        "buildings",
        "onProximityChange",
        "handleProximityChange",
        "onInteract",
        "handleInteract"
      ]
    },
    "file:web/src/components/village/GroundMist.tsx": {
      "id": "file:web/src/components/village/GroundMist.tsx",
      "type": "file",
      "name": "GroundMist.tsx",
      "filePath": "web/src/components/village/GroundMist.tsx",
      "line": 1,
      "endLine": 362,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "GroundMist",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EtherealWisps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GroundMist",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/GroundMist.tsx:fn:GroundMist:165",
        "file:web/src/components/village/GroundMist.tsx:fn:EtherealWisps:290"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/GroundMist.tsx:fn:GroundMist:165": {
      "id": "file:web/src/components/village/GroundMist.tsx:fn:GroundMist:165",
      "type": "function",
      "name": "GroundMist",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/GroundMist.tsx",
      "line": 165,
      "endLine": 233,
      "parentFileId": "file:web/src/components/village/GroundMist.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  size = 100,\n  height = 0.5,\n  color = '#8b7ec8',\n  opacity = 0.4,\n  layers = 3,\n}",
          "type": "GroundMistProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated multi-layer ground mist effect using Three.js shaders.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function GroundMist({\n  size = 100,\n  height = 0.5,\n  color = '#8b7ec8',\n  opacity = 0.4,\n  layers = 3,\n}: GroundMistProps) {\n  const materialRefs = useRef<THREE.ShaderMaterial[]>([]);\n\n  // Create stable uniforms for each layer - NO spreading on every render\n  const layerUniforms = useMemo(() => {\n    const uniformsArray = [];\n    for (let i = 0; i < layers; i++) {\n      uniformsArray.push({\n        uTime: { value: 0 },\n        uColor: { value: new THREE.Color(color) },\n        uOpacity: { value: opacity * (1 - i * 0.2) },\n        uCameraPosition: { value: new THREE.Vector3() },\n      });\n    }\n    return uniformsArray;\n  }, [color, opacity, layers]);\n\n  // Animation - update uniforms directly via refs\n  useFrame(({ clock, camera }) => {\n    const time = clock.getElapsedTime();\n    materialRefs.current.forEach((mat) => {\n      if (mat) {\n        mat.uniforms.uTime.value = time;\n        mat.uniforms.uCameraPosition.value.copy(camera.position);\n      }\n    });\n  });\n\n  // Create multiple layers at different heights\n  const layerHeights = useMemo(() => {\n    const heights: number[] = [];\n    for (let i = 0; i < layers; i++) {\n      heights.push(height + i * 0.8);\n    }\n    return heights;\n  }, [layers, height]);\n\n  return (\n    <group>\n      {layerHeights.map((y, index) => (\n        <mesh\n          key={index}\n          rotation={[-Math.PI / 2, 0, 0]}\n          position={[0, y, 0]}\n        >\n          <planeGeometry args={[size, size, 1, 1]} />\n          <shaderMaterial\n            ref={(el) => {\n              if (el) materialRefs.current[index] = el;\n            }}\n            vertexShader={mistVertexShader}\n            fragmentShader={mistFragmentShader}\n            uniforms={layerUniforms[index]}\n            transparent\n            depthWrite={false}\n            side={THREE.DoubleSide}\n            blending={THREE.NormalBlending}\n          />\n        </mesh>\n      ))}\n    </group>\n  );\n}",
      "references": [
        "useRef",
        "useMemo",
        "i",
        "layers",
        "uniformsArray",
        "THREE",
        "color",
        "opacity",
        "useFrame",
        "clock",
        "camera",
        "materialRefs",
        "mat",
        "time",
        "heights",
        "height",
        "group",
        "layerHeights",
        "mesh",
        "key",
        "index",
        "rotation",
        "Math",
        "position",
        "y",
        "planeGeometry",
        "args",
        "size",
        "shaderMaterial",
        "ref",
        "el",
        "vertexShader",
        "mistVertexShader",
        "fragmentShader",
        "mistFragmentShader",
        "uniforms",
        "layerUniforms",
        "transparent",
        "depthWrite",
        "side",
        "blending"
      ]
    },
    "file:web/src/components/village/GroundMist.tsx:fn:EtherealWisps:290": {
      "id": "file:web/src/components/village/GroundMist.tsx:fn:EtherealWisps:290",
      "type": "function",
      "name": "EtherealWisps",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/GroundMist.tsx",
      "line": 290,
      "endLine": 359,
      "parentFileId": "file:web/src/components/village/GroundMist.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  count = 15,\n  bounds = { minX: -25, maxX: 25, minZ: -25, maxZ: 25 },\n  color = '#a78bfa',\n}",
          "type": "EtherealWispsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated ethereal wisp meshes using Three.js shaders in bounds.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function EtherealWisps({\n  count = 15,\n  bounds = { minX: -25, maxX: 25, minZ: -25, maxZ: 25 },\n  color = '#a78bfa',\n}: EtherealWispsProps) {\n  const groupRef = useRef<THREE.Group>(null);\n  const materialsRef = useRef<THREE.ShaderMaterial[]>([]);\n\n  // Generate wisp data (positions, dimensions) - memoized to prevent recalc\n  const wispData = useMemo(() => {\n    const data: Array<{\n      pos: [number, number, number];\n      height: number;\n      width: number;\n    }> = [];\n    for (let i = 0; i < count; i++) {\n      data.push({\n        pos: [\n          bounds.minX + Math.random() * (bounds.maxX - bounds.minX),\n          0,\n          bounds.minZ + Math.random() * (bounds.maxZ - bounds.minZ),\n        ],\n        height: 4 + Math.random() * 4,\n        width: 0.8 + Math.random() * 0.6,\n      });\n    }\n    return data;\n  }, [count, bounds.minX, bounds.maxX, bounds.minZ, bounds.maxZ]);\n\n  // Create stable uniforms for each wisp - NO spreading\n  const wispUniforms = useMemo(() => {\n    return wispData.map(() => ({\n      uTime: { value: 0 },\n      uColor: { value: new THREE.Color(color) },\n      uOpacity: { value: 0.15 },\n    }));\n  }, [wispData, color]);\n\n  // Animation\n  useFrame(({ clock }) => {\n    const time = clock.getElapsedTime();\n    materialsRef.current.forEach((mat) => {\n      if (mat) {\n        mat.uniforms.uTime.value = time;\n      }\n    });\n  });\n\n  return (\n    <group ref={groupRef}>\n      {wispData.map((wisp, index) => (\n        <mesh key={index} position={wisp.pos}>\n          <planeGeometry args={[wisp.width, wisp.height]} />\n          <shaderMaterial\n            ref={(el) => {\n              if (el) materialsRef.current[index] = el;\n            }}\n            vertexShader={wispVertexShader}\n            fragmentShader={wispFragmentShader}\n            uniforms={wispUniforms[index]}\n            transparent\n            depthWrite={false}\n            side={THREE.DoubleSide}\n            blending={THREE.AdditiveBlending}\n          />\n        </mesh>\n      ))}\n    </group>\n  );\n}",
      "references": [
        "useRef",
        "useMemo",
        "i",
        "count",
        "data",
        "bounds",
        "Math",
        "wispData",
        "THREE",
        "color",
        "useFrame",
        "clock",
        "materialsRef",
        "mat",
        "time",
        "group",
        "ref",
        "groupRef",
        "mesh",
        "key",
        "index",
        "position",
        "wisp",
        "planeGeometry",
        "args",
        "shaderMaterial",
        "el",
        "vertexShader",
        "wispVertexShader",
        "fragmentShader",
        "wispFragmentShader",
        "uniforms",
        "wispUniforms",
        "transparent",
        "depthWrite",
        "side",
        "blending"
      ]
    },
    "file:web/src/components/village/HexTile.tsx": {
      "id": "file:web/src/components/village/HexTile.tsx",
      "type": "file",
      "name": "HexTile.tsx",
      "filePath": "web/src/components/village/HexTile.tsx",
      "line": 1,
      "endLine": 189,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "HexCoord",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillagePosition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/hexGrid",
          "items": [
            {
              "name": "hexToWorld",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_HEX_SIZE",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "HexTilesLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DISTRICT_GROUND_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DISTRICT_EDGE_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "HexTileProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "HexTilesLayerProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "HexTilesLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/HexTile.tsx:fn:createHexShape:51",
        "file:web/src/components/village/HexTile.tsx:fn:HexTile:94",
        "file:web/src/components/village/HexTile.tsx:fn:HexTilesLayer:168"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/HexTile.tsx:fn:createHexShape:51": {
      "id": "file:web/src/components/village/HexTile.tsx:fn:createHexShape:51",
      "type": "function",
      "name": "createHexShape",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/HexTile.tsx",
      "line": 51,
      "endLine": 70,
      "parentFileId": "file:web/src/components/village/HexTile.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "size",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/extras/core/Shape\").Shape",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a pointy-top hexagonal THREE.Shape given a size.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.737Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createHexShape(size: number): THREE.Shape {\n  const shape = new THREE.Shape();\n\n  // Pointy-top hexagon: first vertex at top\n  for (let i = 0; i < 6; i++) {\n    // Start at -90 degrees (top) and go clockwise\n    const angle = (Math.PI / 3) * i - Math.PI / 2;\n    const x = size * Math.cos(angle);\n    const y = size * Math.sin(angle);\n\n    if (i === 0) {\n      shape.moveTo(x, y);\n    } else {\n      shape.lineTo(x, y);\n    }\n  }\n  shape.closePath();\n\n  return shape;\n}",
      "references": [
        "THREE",
        "i",
        "Math",
        "angle",
        "shape",
        "x",
        "y"
      ]
    },
    "file:web/src/components/village/HexTile.tsx:fn:HexTile:94": {
      "id": "file:web/src/components/village/HexTile.tsx:fn:HexTile:94",
      "type": "function",
      "name": "HexTile",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/HexTile.tsx",
      "line": 94,
      "endLine": 150,
      "parentFileId": "file:web/src/components/village/HexTile.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  hexCoord,\n  category,\n  hexSize = DEFAULT_HEX_SIZE,\n  opacity = 1,\n  showEdge = false,\n  yOffset = 0,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/HexTile\").HexTileProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a Three.js hexagonal tile mesh with optional edge based on hex coord and category.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.819Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function HexTile({\n  hexCoord,\n  category,\n  hexSize = DEFAULT_HEX_SIZE,\n  opacity = 1,\n  showEdge = false,\n  yOffset = 0,\n}: HexTileProps) {\n  // Convert hex coord to world position\n  const position = useMemo(() => {\n    return hexToWorld(hexCoord, hexSize);\n  }, [hexCoord.q, hexCoord.r, hexSize]);\n\n  // Create hex geometry\n  const geometry = useMemo(() => {\n    const shape = createHexShape(hexSize * 0.95); // Slightly smaller for gaps\n    const geo = new THREE.ShapeGeometry(shape);\n    geo.rotateX(-Math.PI / 2); // Lay flat\n    return geo;\n  }, [hexSize]);\n\n  // Edge geometry (slightly larger)\n  const edgeGeometry = useMemo(() => {\n    if (!showEdge) return null;\n    const shape = createHexShape(hexSize * 0.98);\n    const geo = new THREE.ShapeGeometry(shape);\n    geo.rotateX(-Math.PI / 2);\n    return geo;\n  }, [hexSize, showEdge]);\n\n  const groundColor = DISTRICT_GROUND_COLORS[category];\n  const edgeColor = DISTRICT_EDGE_COLORS[category];\n\n  return (\n    <group position={[position.x, yOffset, position.z]}>\n      {/* Edge layer (below) */}\n      {showEdge && edgeGeometry && (\n        <mesh geometry={edgeGeometry} position={[0, -0.02, 0]} receiveShadow>\n          <meshStandardMaterial\n            color={edgeColor}\n            opacity={opacity * 0.5}\n            transparent\n          />\n        </mesh>\n      )}\n\n      {/* Main tile */}\n      <mesh geometry={geometry} receiveShadow>\n        <meshStandardMaterial\n          color={groundColor}\n          opacity={opacity}\n          transparent={opacity < 1}\n        />\n      </mesh>\n    </group>\n  );\n}",
      "references": [
        "useMemo",
        "hexToWorld",
        "hexCoord",
        "hexSize",
        "createHexShape",
        "THREE",
        "shape",
        "geo",
        "Math",
        "showEdge",
        "DISTRICT_GROUND_COLORS",
        "category",
        "DISTRICT_EDGE_COLORS",
        "group",
        "position",
        "yOffset",
        "edgeGeometry",
        "mesh",
        "geometry",
        "receiveShadow",
        "meshStandardMaterial",
        "color",
        "edgeColor",
        "opacity",
        "transparent",
        "groundColor"
      ]
    },
    "file:web/src/components/village/HexTile.tsx:fn:HexTilesLayer:168": {
      "id": "file:web/src/components/village/HexTile.tsx:fn:HexTilesLayer:168",
      "type": "function",
      "name": "HexTilesLayer",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/HexTile.tsx",
      "line": 168,
      "endLine": 186,
      "parentFileId": "file:web/src/components/village/HexTile.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  tiles,\n  hexSize = DEFAULT_HEX_SIZE,\n  yOffset = 0,\n}",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/HexTile\").HexTilesLayerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a group of HexTile components for given tiles with hexSize and yOffset.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.926Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function HexTilesLayer({\n  tiles,\n  hexSize = DEFAULT_HEX_SIZE,\n  yOffset = 0,\n}: HexTilesLayerProps) {\n  return (\n    <group>\n      {tiles.map((tile, index) => (\n        <HexTile\n          key={`hex-${tile.coord.q}-${tile.coord.r}`}\n          hexCoord={tile.coord}\n          category={tile.category}\n          hexSize={hexSize}\n          yOffset={yOffset}\n        />\n      ))}\n    </group>\n  );\n}",
      "references": [
        "group",
        "tiles",
        "HexTile",
        "key",
        "tile",
        "hexCoord",
        "category",
        "hexSize",
        "yOffset"
      ]
    },
    "file:web/src/components/village/index.ts": {
      "id": "file:web/src/components/village/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/components/village/index.ts",
      "line": 1,
      "endLine": 19,
      "imports": [],
      "exports": [
        {
          "name": "VillageScene",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "VillageCanvas",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MemoryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BuildingsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "BuildingModel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "RoadsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "LightBeamsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "HexTilesLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DISTRICT_GROUND_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DISTRICT_EDGE_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "VillageGround",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PropsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "PropPlacement",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillagersLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FirstPersonControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamParticles",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "AuroraSky",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GroundMist",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "EtherealWisps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamEffects",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamLighting",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DreamAtmosphere",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "default",
          "alias": "VillageScene",
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./VillageScene"
        },
        {
          "name": "VillageCanvas",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./VillageCanvas"
        },
        {
          "name": "MemoryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./MemoryPanel"
        },
        {
          "name": "BuildingsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./Building"
        },
        {
          "name": "BuildingModel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./BuildingModel"
        },
        {
          "name": "RoadsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./Road"
        },
        {
          "name": "LightBeamsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./LightBeamRoad"
        },
        {
          "name": "HexTilesLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./HexTile"
        },
        {
          "name": "DISTRICT_GROUND_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./HexTile"
        },
        {
          "name": "DISTRICT_EDGE_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./HexTile"
        },
        {
          "name": "VillageGround",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DistrictGround"
        },
        {
          "name": "PropsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./InstancedProps"
        },
        {
          "name": "PropPlacement",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./InstancedProps"
        },
        {
          "name": "VillagersLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./Villager"
        },
        {
          "name": "FirstPersonControls",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./FirstPersonControls"
        },
        {
          "name": "DreamParticles",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DreamParticles"
        },
        {
          "name": "AuroraSky",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./AuroraSky"
        },
        {
          "name": "GroundMist",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GroundMist"
        },
        {
          "name": "EtherealWisps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./GroundMist"
        },
        {
          "name": "DreamEffects",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DreamEffects"
        },
        {
          "name": "DreamLighting",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DreamLighting"
        },
        {
          "name": "DreamAtmosphere",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./DreamLighting"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/InstancedProps.tsx": {
      "id": "file:web/src/components/village/InstancedProps.tsx",
      "type": "file",
      "name": "InstancedProps.tsx",
      "filePath": "web/src/components/village/InstancedProps.tsx",
      "line": 1,
      "endLine": 226,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "React",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            },
            {
              "name": "memo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/drei",
          "items": [
            {
              "name": "useGLTF",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "PropType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "getPropConfig",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPropPath",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageProp",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "PropPlacement",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PropsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "PropsLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "PropModel",
        "propType",
        "position",
        "rotation",
        "scale",
        "scene",
        "config",
        "primitive",
        "clonedScene",
        "finalRotation",
        "finalScale",
        "PropsLayer",
        "props",
        "group",
        "name",
        "key",
        "prop",
        "InstancedPropGroup",
        "placements",
        "child",
        "geo",
        "mat",
        "geometry",
        "meshRef",
        "placement",
        "quaternion",
        "s",
        "matrix",
        "mesh",
        "i",
        "instancedMesh",
        "ref",
        "args",
        "material",
        "castShadow",
        "receiveShadow",
        "OptimizedPropsLayer",
        "instanceThreshold",
        "grouped",
        "instanced",
        "Map",
        "byType",
        "list"
      ]
    },
    "file:web/src/components/village/LightBeamRoad.tsx": {
      "id": "file:web/src/components/village/LightBeamRoad.tsx",
      "type": "file",
      "name": "LightBeamRoad.tsx",
      "filePath": "web/src/components/village/LightBeamRoad.tsx",
      "line": 1,
      "endLine": 227,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageRoad",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/beamShader",
          "items": [
            {
              "name": "createBeamMaterial",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateBeamTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createOuterGlowMaterial",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "LightBeamsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "LightBeamsLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/LightBeamRoad.tsx:fn:createBeamCurve:54",
        "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamRoad:92",
        "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamsLayer:197"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/LightBeamRoad.tsx:fn:createBeamCurve:54": {
      "id": "file:web/src/components/village/LightBeamRoad.tsx:fn:createBeamCurve:54",
      "type": "function",
      "name": "createBeamCurve",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/LightBeamRoad.tsx",
      "line": 54,
      "endLine": 74,
      "parentFileId": "file:web/src/components/village/LightBeamRoad.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "fromX",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "fromZ",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "toX",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "toZ",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/extras/curves/QuadraticBezierCurve3\").QuadraticBezierCurve3",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a quadratic Bezier curve for light beam from (fromX,fromZ) to (toX,toZ) with arched control point.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.926Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function createBeamCurve(\n  fromX: number,\n  fromZ: number,\n  toX: number,\n  toZ: number\n): THREE.QuadraticBezierCurve3 {\n  // Start and end points slightly above ground\n  const start = new THREE.Vector3(fromX, 0.5, fromZ);\n  const end = new THREE.Vector3(toX, 0.5, toZ);\n\n  // Calculate arc height based on distance\n  const distance = start.distanceTo(end);\n  const arcHeight = Math.min(Math.max(distance * ARC_HEIGHT_RATIO, MIN_ARC_HEIGHT), MAX_ARC_HEIGHT);\n\n  // Control point at midpoint, elevated\n  const midX = (fromX + toX) / 2;\n  const midZ = (fromZ + toZ) / 2;\n  const control = new THREE.Vector3(midX, arcHeight, midZ);\n\n  return new THREE.QuadraticBezierCurve3(start, control, end);\n}",
      "references": [
        "THREE",
        "start",
        "end",
        "Math",
        "distance",
        "ARC_HEIGHT_RATIO",
        "MIN_ARC_HEIGHT",
        "MAX_ARC_HEIGHT",
        "midX",
        "arcHeight",
        "midZ",
        "control"
      ]
    },
    "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamRoad:92": {
      "id": "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamRoad:92",
      "type": "function",
      "name": "LightBeamRoad",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/LightBeamRoad.tsx",
      "line": 92,
      "endLine": 182,
      "parentFileId": "file:web/src/components/village/LightBeamRoad.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  road,\n  phaseOffset = 0,\n  showGlow = true,\n}",
          "type": "LightBeamRoadProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders animated 3D light beam road with optional glow using Three.js.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.156Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function LightBeamRoad({\n  road,\n  phaseOffset = 0,\n  showGlow = true,\n}: LightBeamRoadProps) {\n  const meshRef = useRef<THREE.Mesh>(null);\n  const glowMeshRef = useRef<THREE.Mesh>(null);\n  const materialRef = useRef<THREE.ShaderMaterial | null>(null);\n\n  const { fromPosition, toPosition, edgeType } = road;\n\n  // Get beam color from edge type\n  const beamColor = ROAD_COLORS[edgeType] || ROAD_COLORS.default;\n\n  // Memoize curve - only recalculate if positions change\n  const curve = useMemo(() => {\n    return createBeamCurve(\n      fromPosition.x,\n      fromPosition.z,\n      toPosition.x,\n      toPosition.z\n    );\n  }, [fromPosition.x, fromPosition.z, toPosition.x, toPosition.z]);\n\n  // Memoize tube geometry\n  const geometry = useMemo(() => {\n    return new THREE.TubeGeometry(\n      curve,\n      TUBE_SEGMENTS,\n      TUBE_RADIUS,\n      RADIAL_SEGMENTS,\n      false // not closed\n    );\n  }, [curve]);\n\n  // Memoize outer glow geometry (larger radius)\n  const glowGeometry = useMemo(() => {\n    if (!showGlow) return null;\n    return new THREE.TubeGeometry(\n      curve,\n      TUBE_SEGMENTS,\n      TUBE_RADIUS * GLOW_RADIUS_MULTIPLIER,\n      RADIAL_SEGMENTS,\n      false\n    );\n  }, [curve, showGlow]);\n\n  // Create materials\n  const material = useMemo(() => {\n    const mat = createBeamMaterial({\n      color: beamColor,\n      phase: phaseOffset,\n    });\n    materialRef.current = mat;\n    return mat;\n  }, [beamColor, phaseOffset]);\n\n  const glowMaterial = useMemo(() => {\n    if (!showGlow) return null;\n    return createOuterGlowMaterial(beamColor);\n  }, [beamColor, showGlow]);\n\n  // Animate the beam\n  useFrame((state) => {\n    if (materialRef.current) {\n      updateBeamTime(materialRef.current, state.clock.elapsedTime);\n    }\n  });\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      geometry.dispose();\n      material.dispose();\n      if (glowGeometry) glowGeometry.dispose();\n      if (glowMaterial) glowMaterial.dispose();\n    };\n  }, [geometry, material, glowGeometry, glowMaterial]);\n\n  return (\n    <group>\n      {/* Main beam with undulating shader */}\n      <mesh ref={meshRef} geometry={geometry} material={material} />\n\n      {/* Outer glow layer */}\n      {showGlow && glowGeometry && glowMaterial && (\n        <mesh ref={glowMeshRef} geometry={glowGeometry} material={glowMaterial} />\n      )}\n    </group>\n  );\n}",
      "references": [
        "useRef",
        "fromPosition",
        "toPosition",
        "edgeType",
        "road",
        "ROAD_COLORS",
        "useMemo",
        "createBeamCurve",
        "THREE",
        "curve",
        "TUBE_SEGMENTS",
        "TUBE_RADIUS",
        "RADIAL_SEGMENTS",
        "showGlow",
        "GLOW_RADIUS_MULTIPLIER",
        "createBeamMaterial",
        "beamColor",
        "phaseOffset",
        "materialRef",
        "mat",
        "createOuterGlowMaterial",
        "useFrame",
        "updateBeamTime",
        "state",
        "useEffect",
        "geometry",
        "material",
        "glowGeometry",
        "glowMaterial",
        "group",
        "mesh",
        "ref",
        "meshRef",
        "glowMeshRef"
      ]
    },
    "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamsLayer:197": {
      "id": "file:web/src/components/village/LightBeamRoad.tsx:fn:LightBeamsLayer:197",
      "type": "function",
      "name": "LightBeamsLayer",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/LightBeamRoad.tsx",
      "line": 197,
      "endLine": 224,
      "parentFileId": "file:web/src/components/village/LightBeamRoad.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ roads, selectedBuildingId }",
          "type": "LightBeamsLayerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders light beam roads for roads connected to selected building.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.955Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function LightBeamsLayer({ roads, selectedBuildingId }: LightBeamsLayerProps) {\n  // Filter to only roads connected to the selected building\n  const visibleRoads = useMemo(() => {\n    if (!selectedBuildingId) return [];\n    return roads.filter(\n      (road) =>\n        road.fromId === selectedBuildingId || road.toId === selectedBuildingId\n    );\n  }, [roads, selectedBuildingId]);\n\n  // If nothing selected, render nothing\n  if (visibleRoads.length === 0) {\n    return null;\n  }\n\n  return (\n    <group name=\"light-beams\">\n      {visibleRoads.map((road, index) => (\n        <LightBeamRoad\n          key={road.id}\n          road={road}\n          phaseOffset={index * 0.7} // Stagger phases for variety\n          showGlow={true}\n        />\n      ))}\n    </group>\n  );\n}",
      "references": [
        "useMemo",
        "selectedBuildingId",
        "roads",
        "road",
        "visibleRoads",
        "group",
        "name",
        "LightBeamRoad",
        "key",
        "phaseOffset",
        "index",
        "showGlow"
      ]
    },
    "file:web/src/components/village/MemoryPanel.tsx": {
      "id": "file:web/src/components/village/MemoryPanel.tsx",
      "type": "file",
      "name": "MemoryPanel.tsx",
      "filePath": "web/src/components/village/MemoryPanel.tsx",
      "line": 1,
      "endLine": 271,
      "imports": [
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "BUILDING_COLORS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "MemoryPanel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MemoryPanelProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryPanel",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/MemoryPanel.tsx:fn:PanelSkeleton:70",
        "file:web/src/components/village/MemoryPanel.tsx:fn:MemoryPanel:88"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/components/village/MemoryPanel.tsx:fn:PanelSkeleton:70": {
      "id": "file:web/src/components/village/MemoryPanel.tsx:fn:PanelSkeleton:70",
      "type": "function",
      "name": "PanelSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/MemoryPanel.tsx",
      "line": 70,
      "endLine": 82,
      "parentFileId": "file:web/src/components/village/MemoryPanel.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a skeleton loading UI for a panel with animated placeholder divs.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.955Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function PanelSkeleton() {\n  return (\n    <div className=\"space-y-4 animate-pulse\">\n      <div className=\"h-6 w-3/4 bg-surface-sunken rounded\" />\n      <div className=\"h-4 w-1/2 bg-surface-sunken rounded\" />\n      <div className=\"space-y-2\">\n        <div className=\"h-3 w-full bg-surface-sunken rounded\" />\n        <div className=\"h-3 w-full bg-surface-sunken rounded\" />\n        <div className=\"h-3 w-2/3 bg-surface-sunken rounded\" />\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className"
      ]
    },
    "file:web/src/components/village/MemoryPanel.tsx:fn:MemoryPanel:88": {
      "id": "file:web/src/components/village/MemoryPanel.tsx:fn:MemoryPanel:88",
      "type": "function",
      "name": "MemoryPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/MemoryPanel.tsx",
      "line": 88,
      "endLine": 268,
      "parentFileId": "file:web/src/components/village/MemoryPanel.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ memoryId, building, onClose }",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/MemoryPanel\").MemoryPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a UI panel for building memory with fetch via useMemory hook, loading/error states",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.955Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function MemoryPanel({ memoryId, building, onClose }: MemoryPanelProps) {\n  const { data: memory, isLoading, isError } = useMemory(memoryId ?? undefined);\n\n  // Don't render if no selection\n  if (!memoryId || !building) {\n    return null;\n  }\n\n  const categoryConfig = CATEGORY_CONFIG[building.category] || CATEGORY_CONFIG.misc;\n  const buildingColor = BUILDING_COLORS[building.buildingType] || BUILDING_COLORS.house;\n\n  return (\n    <div className=\"pointer-events-auto absolute right-4 top-4 bottom-4 w-80 flex flex-col rounded-xl border border-border bg-background/95 shadow-2xl backdrop-blur-md overflow-hidden\">\n      {/* Header */}\n      <div\n        className=\"flex items-center justify-between px-4 py-3 border-b border-border\"\n        style={{ backgroundColor: `${buildingColor}15` }}\n      >\n        <div className=\"flex items-center gap-3\">\n          <div\n            className=\"w-10 h-10 rounded-lg flex items-center justify-center\"\n            style={{\n              backgroundColor: `${buildingColor}25`,\n              borderColor: `${buildingColor}50`,\n              borderWidth: 1,\n            }}\n          >\n            <span style={{ color: buildingColor }}>{icons.memory}</span>\n          </div>\n          <div>\n            <h3 className=\"text-sm font-medium text-foreground capitalize\">\n              {building.buildingType}\n            </h3>\n            <p className=\"text-xs text-foreground-muted\">\n              {categoryConfig.emoji} {categoryConfig.label}\n            </p>\n          </div>\n        </div>\n        <button\n          onClick={onClose}\n          className=\"p-2 rounded-lg hover:bg-surface-sunken transition-colors text-foreground-muted hover:text-foreground\"\n          title=\"Close\"\n        >\n          {icons.close}\n        </button>\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto p-4\">\n        {isLoading ? (\n          <PanelSkeleton />\n        ) : isError || !memory ? (\n          <div className=\"flex flex-col items-center justify-center h-full text-center\">\n            <p className=\"text-sm text-foreground-muted\">\n              Unable to load memory details\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-5\">\n            {/* Memory Label */}\n            <div>\n              <h2 className=\"text-base font-semibold text-foreground leading-tight\">\n                {building.label}\n              </h2>\n            </div>\n\n            {/* Stats Row */}\n            <div className=\"flex gap-3\">\n              {/* Salience */}\n              <div className=\"flex-1 px-3 py-2 rounded-lg bg-surface-sunken\">\n                <div className=\"flex items-center gap-1.5 text-xs text-foreground-muted mb-1\">\n                  {icons.sparkle}\n                  <span>Salience</span>\n                </div>\n                <div className=\"flex items-center gap-2\">\n                  <div className=\"flex-1 h-1.5 bg-border rounded-full overflow-hidden\">\n                    <div\n                      className=\"h-full rounded-full transition-all\"\n                      style={{\n                        width: `${(memory.salience || 0) * 100}%`,\n                        backgroundColor: buildingColor,\n                      }}\n                    />\n                  </div>\n                  <span className=\"text-xs font-medium text-foreground\">\n                    {Math.round((memory.salience || 0) * 100)}%\n                  </span>\n                </div>\n              </div>\n            </div>\n\n            {/* Date */}\n            <div className=\"flex items-center gap-2 text-xs text-foreground-muted\">\n              {icons.calendar}\n              <span>\n                {new Date(memory.created_at).toLocaleDateString(undefined, {\n                  weekday: 'short',\n                  year: 'numeric',\n                  month: 'short',\n                  day: 'numeric',\n                })}\n              </span>\n            </div>\n\n            {/* Memory Content */}\n            <div className=\"space-y-2\">\n              <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n                Memory Content\n              </h4>\n              <div className=\"text-sm text-foreground leading-relaxed bg-surface-sunken rounded-lg p-3 max-h-48 overflow-y-auto\">\n                {memory.content}\n              </div>\n            </div>\n\n            {/* Source Badge */}\n            <div className=\"flex items-center gap-2\">\n              <span className=\"text-xs text-foreground-muted\">Source:</span>\n              <span className=\"inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-surface-sunken text-foreground-muted capitalize\">\n                {memory.source}\n              </span>\n            </div>\n\n            {/* Emotional Valence (if available) */}\n            {building.emotionalValence !== undefined && building.emotionalValence !== 0 && (\n              <div className=\"px-3 py-2 rounded-lg bg-surface-sunken\">\n                <div className=\"text-xs text-foreground-muted mb-1\">Emotional Tone</div>\n                <div className=\"flex items-center gap-2\">\n                  <span className=\"text-lg\">\n                    {building.emotionalValence > 0.3 ? '' :\n                     building.emotionalValence < -0.3 ? '' : ''}\n                  </span>\n                  <div className=\"flex-1 h-1.5 bg-border rounded-full overflow-hidden relative\">\n                    <div className=\"absolute inset-0 flex items-center justify-center\">\n                      <div className=\"w-0.5 h-full bg-foreground-muted opacity-30\" />\n                    </div>\n                    <div\n                      className=\"absolute top-0 h-full rounded-full transition-all\"\n                      style={{\n                        width: `${Math.abs(building.emotionalValence) * 50}%`,\n                        left: building.emotionalValence >= 0 ? '50%' : undefined,\n                        right: building.emotionalValence < 0 ? '50%' : undefined,\n                        backgroundColor: building.emotionalValence >= 0 ? '#34d399' : '#f472b6',\n                      }}\n                    />\n                  </div>\n                  <span className=\"text-xs font-medium text-foreground min-w-[3rem] text-right\">\n                    {building.emotionalValence > 0 ? '+' : ''}{(building.emotionalValence * 100).toFixed(0)}%\n                  </span>\n                </div>\n              </div>\n            )}\n\n            {/* Connected Entities (if available) */}\n            {memory.entities && memory.entities.length > 0 && (\n              <div className=\"space-y-2\">\n                <h4 className=\"text-xs font-medium text-foreground-muted uppercase tracking-wide\">\n                  Mentioned Entities\n                </h4>\n                <div className=\"flex flex-wrap gap-1.5\">\n                  {memory.entities.slice(0, 6).map((entity) => (\n                    <span\n                      key={entity.id}\n                      className=\"inline-flex items-center px-2 py-1 rounded-md text-xs bg-surface-sunken text-foreground hover:bg-border transition-colors cursor-default\"\n                    >\n                      {entity.name}\n                    </span>\n                  ))}\n                  {memory.entities.length > 6 && (\n                    <span className=\"inline-flex items-center px-2 py-1 rounded-md text-xs bg-surface-sunken text-foreground-muted\">\n                      +{memory.entities.length - 6} more\n                    </span>\n                  )}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "data",
        "memory",
        "isLoading",
        "isError",
        "useMemory",
        "memoryId",
        "building",
        "CATEGORY_CONFIG",
        "BUILDING_COLORS",
        "div",
        "className",
        "style",
        "buildingColor",
        "span",
        "icons",
        "h3",
        "p",
        "categoryConfig",
        "button",
        "onClick",
        "onClose",
        "title",
        "PanelSkeleton",
        "h2",
        "Math",
        "Date",
        "h4",
        "key",
        "entity"
      ]
    },
    "file:web/src/components/village/MistPuffs.tsx": {
      "id": "file:web/src/components/village/MistPuffs.tsx",
      "type": "file",
      "name": "MistPuffs.tsx",
      "filePath": "web/src/components/village/MistPuffs.tsx",
      "line": 1,
      "endLine": 190,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "MistPuffs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "MistPuffs",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/MistPuffs.tsx:fn:MistPuffs:96"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/MistPuffs.tsx:fn:MistPuffs:96": {
      "id": "file:web/src/components/village/MistPuffs.tsx:fn:MistPuffs:96",
      "type": "function",
      "name": "MistPuffs",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/MistPuffs.tsx",
      "line": 96,
      "endLine": 187,
      "parentFileId": "file:web/src/components/village/MistPuffs.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  count = 20,\n  bounds = { minX: -25, maxX: 25, minZ: -25, maxZ: 25 },\n  color = '#a78bfa',\n  opacity = 0.15,\n  minSize = 4,\n  maxSize = 10,\n  minHeight = 0.5,\n  maxHeight = 4,\n}",
          "type": "MistPuffsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders instanced animated mist puffs using Three.js PlaneGeometry in a React component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:15.955Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function MistPuffs({\n  count = 20,\n  bounds = { minX: -25, maxX: 25, minZ: -25, maxZ: 25 },\n  color = '#a78bfa',\n  opacity = 0.15,\n  minSize = 4,\n  maxSize = 10,\n  minHeight = 0.5,\n  maxHeight = 4,\n}: MistPuffsProps) {\n  const meshRef = useRef<THREE.InstancedMesh>(null);\n  const materialRef = useRef<THREE.ShaderMaterial>(null);\n\n  // Generate puff attributes\n  const { offsets, phases, speeds, sizes } = useMemo(() => {\n    const offsets = new Float32Array(count * 3);\n    const phases = new Float32Array(count);\n    const speeds = new Float32Array(count);\n    const sizes = new Float32Array(count);\n\n    const rangeX = bounds.maxX - bounds.minX;\n    const rangeZ = bounds.maxZ - bounds.minZ;\n\n    for (let i = 0; i < count; i++) {\n      const i3 = i * 3;\n\n      // Random position within bounds\n      offsets[i3] = bounds.minX + Math.random() * rangeX;\n      offsets[i3 + 1] = minHeight + Math.random() * (maxHeight - minHeight);\n      offsets[i3 + 2] = bounds.minZ + Math.random() * rangeZ;\n\n      phases[i] = Math.random();\n      speeds[i] = 0.5 + Math.random() * 1.0;\n      sizes[i] = minSize + Math.random() * (maxSize - minSize);\n    }\n\n    return { offsets, phases, speeds, sizes };\n  }, [count, bounds.minX, bounds.maxX, bounds.minZ, bounds.maxZ, minHeight, maxHeight, minSize, maxSize]);\n\n  // Create geometry with attributes\n  const geometry = useMemo(() => {\n    const geo = new THREE.PlaneGeometry(1, 1);\n\n    // Add instanced attributes\n    geo.setAttribute('aOffset', new THREE.InstancedBufferAttribute(offsets, 3));\n    geo.setAttribute('aPhase', new THREE.InstancedBufferAttribute(phases, 1));\n    geo.setAttribute('aSpeed', new THREE.InstancedBufferAttribute(speeds, 1));\n    geo.setAttribute('aSize', new THREE.InstancedBufferAttribute(sizes, 1));\n\n    return geo;\n  }, [offsets, phases, speeds, sizes]);\n\n  // Uniforms\n  const uniforms = useMemo(() => ({\n    uTime: { value: 0 },\n    uColor: { value: new THREE.Color(color) },\n    uOpacity: { value: opacity },\n  }), [color, opacity]);\n\n  // Animation\n  useFrame(({ clock }) => {\n    if (materialRef.current) {\n      materialRef.current.uniforms.uTime.value = clock.getElapsedTime();\n    }\n  });\n\n  // Cleanup\n  useEffect(() => {\n    return () => {\n      geometry?.dispose();\n    };\n  }, [geometry]);\n\n  return (\n    <instancedMesh\n      ref={meshRef}\n      args={[geometry, undefined, count]}\n      frustumCulled={false}\n    >\n      <shaderMaterial\n        ref={materialRef}\n        vertexShader={puffVertexShader}\n        fragmentShader={puffFragmentShader}\n        uniforms={uniforms}\n        transparent\n        depthWrite={false}\n        side={THREE.DoubleSide}\n        blending={THREE.NormalBlending}\n      />\n    </instancedMesh>\n  );\n}",
      "references": [
        "useRef",
        "offsets",
        "phases",
        "speeds",
        "sizes",
        "useMemo",
        "Float32Array",
        "count",
        "bounds",
        "i",
        "i3",
        "Math",
        "rangeX",
        "minHeight",
        "maxHeight",
        "rangeZ",
        "minSize",
        "maxSize",
        "THREE",
        "geo",
        "color",
        "opacity",
        "useFrame",
        "clock",
        "materialRef",
        "useEffect",
        "geometry",
        "instancedMesh",
        "ref",
        "meshRef",
        "args",
        "frustumCulled",
        "shaderMaterial",
        "vertexShader",
        "puffVertexShader",
        "fragmentShader",
        "puffFragmentShader",
        "uniforms",
        "transparent",
        "depthWrite",
        "side",
        "blending"
      ]
    },
    "file:web/src/components/village/Road.tsx": {
      "id": "file:web/src/components/village/Road.tsx",
      "type": "file",
      "name": "Road.tsx",
      "filePath": "web/src/components/village/Road.tsx",
      "line": 1,
      "endLine": 134,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageRoad",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "RoadsLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "RoadsLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/Road.tsx:fn:Road:41",
        "file:web/src/components/village/Road.tsx:fn:RoadsLayer:111"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/Road.tsx:fn:Road:41": {
      "id": "file:web/src/components/village/Road.tsx:fn:Road:41",
      "type": "function",
      "name": "Road",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/Road.tsx",
      "line": 41,
      "endLine": 96,
      "parentFileId": "file:web/src/components/village/Road.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ road, highlighted = false, opacity = 1 }",
          "type": "RoadProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a 3D road mesh between positions using Three.js, with dynamic width, color, and highlighting.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:22.755Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function Road({ road, highlighted = false, opacity = 1 }: RoadProps) {\n  const { fromPosition, toPosition, weight, edgeType } = road;\n\n  // Validate positions - skip rendering if invalid\n  const isValidPosition = (pos: { x: number; z: number }) =>\n    Number.isFinite(pos.x) && Number.isFinite(pos.z);\n\n  if (!isValidPosition(fromPosition) || !isValidPosition(toPosition)) {\n    console.warn('[Road] Invalid positions:', road.id, fromPosition, toPosition);\n    return null;\n  }\n\n  // Calculate road geometry\n  const geometry = useMemo(() => {\n    const start = new THREE.Vector3(fromPosition.x, 0.02, fromPosition.z);\n    const end = new THREE.Vector3(toPosition.x, 0.02, toPosition.z);\n\n    // Create a path between the two points\n    const direction = end.clone().sub(start);\n    const length = direction.length();\n    const center = start.clone().add(direction.clone().multiplyScalar(0.5));\n\n    // Calculate rotation to align with direction\n    const angle = Math.atan2(direction.x, direction.z);\n\n    // Road width based on weight (0.1 to 0.4)\n    const baseWidth = 0.15;\n    const maxWidth = 0.4;\n    const roadWidth = baseWidth + (weight * (maxWidth - baseWidth));\n\n    return { length, center, angle, roadWidth };\n  }, [fromPosition, toPosition, weight]);\n\n  // Get color\n  const color = ROAD_COLORS[edgeType] || ROAD_COLORS.default;\n\n  // Adjust color for highlighting\n  const finalColor = highlighted ? '#f0f0f0' : color;\n  const finalOpacity = highlighted ? 1 : opacity * 0.6;\n\n  return (\n    <mesh\n      position={[geometry.center.x, geometry.center.y, geometry.center.z]}\n      rotation={[0, geometry.angle, 0]}\n    >\n      <boxGeometry args={[geometry.roadWidth, 0.02, geometry.length]} />\n      <meshStandardMaterial\n        color={finalColor}\n        transparent\n        opacity={finalOpacity}\n        roughness={0.9}\n        metalness={0.1}\n      />\n    </mesh>\n  );\n}",
      "references": [
        "fromPosition",
        "toPosition",
        "weight",
        "edgeType",
        "road",
        "Number",
        "pos",
        "isValidPosition",
        "console",
        "useMemo",
        "THREE",
        "end",
        "start",
        "direction",
        "Math",
        "baseWidth",
        "maxWidth",
        "length",
        "center",
        "angle",
        "roadWidth",
        "ROAD_COLORS",
        "highlighted",
        "color",
        "opacity",
        "mesh",
        "position",
        "geometry",
        "rotation",
        "boxGeometry",
        "args",
        "meshStandardMaterial",
        "finalColor",
        "transparent",
        "finalOpacity",
        "roughness",
        "metalness"
      ]
    },
    "file:web/src/components/village/Road.tsx:fn:RoadsLayer:111": {
      "id": "file:web/src/components/village/Road.tsx:fn:RoadsLayer:111",
      "type": "function",
      "name": "RoadsLayer",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/Road.tsx",
      "line": 111,
      "endLine": 131,
      "parentFileId": "file:web/src/components/village/Road.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ roads, selectedBuildingId }",
          "type": "RoadsLayerProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders roads layer with highlighting for selected building connections",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.232Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function RoadsLayer({ roads, selectedBuildingId }: RoadsLayerProps) {\n  return (\n    <group name=\"roads\">\n      {roads.map(road => {\n        // Check if road is connected to selected building\n        const isHighlighted = selectedBuildingId\n          ? road.fromId === selectedBuildingId || road.toId === selectedBuildingId\n          : false;\n\n        return (\n          <Road\n            key={road.id}\n            road={road}\n            highlighted={isHighlighted}\n            opacity={selectedBuildingId && !isHighlighted ? 0.3 : 1}\n          />\n        );\n      })}\n    </group>\n  );\n}",
      "references": [
        "group",
        "name",
        "roads",
        "selectedBuildingId",
        "road",
        "Road",
        "key",
        "highlighted",
        "isHighlighted",
        "opacity"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx": {
      "id": "file:web/src/components/village/VillageCanvas.tsx",
      "type": "file",
      "name": "VillageCanvas.tsx",
      "filePath": "web/src/components/village/VillageCanvas.tsx",
      "line": 1,
      "endLine": 520,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/drei",
          "items": [
            {
              "name": "OrbitControls",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PerspectiveCamera",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Html",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useVillageLayout",
          "items": [
            {
              "name": "useVillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useVillageSelection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useCameraMode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./Building",
          "items": [
            {
              "name": "BuildingsLayer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./LightBeamRoad",
          "items": [
            {
              "name": "LightBeamsLayer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./DistrictGround",
          "items": [
            {
              "name": "VillageGround",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./HexTile",
          "items": [
            {
              "name": "DISTRICT_EDGE_COLORS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./InstancedProps",
          "items": [
            {
              "name": "PropsLayer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./Villager",
          "items": [
            {
              "name": "VillagersLayer",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./FirstPersonControls",
          "items": [
            {
              "name": "FirstPersonControls",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./GroundMist",
          "items": [
            {
              "name": "GroundMist",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EtherealWisps",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./MistPuffs",
          "items": [
            {
              "name": "MistPuffs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./AuroraSky",
          "items": [
            {
              "name": "AuroraSky",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./DreamParticles",
          "items": [
            {
              "name": "DreamParticles",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./DreamLighting",
          "items": [
            {
              "name": "DreamLighting",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DreamAtmosphere",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "preloadAllBuildingModels",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "preloadAllPropModels",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageDistrict",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageProp",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageVillager",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "CameraMode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "VillageCanvas",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "VillageCanvasProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageCanvas",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/VillageCanvas.tsx:fn:SimpleGround:40",
        "file:web/src/components/village/VillageCanvas.tsx:fn:DistrictLights:75",
        "file:web/src/components/village/VillageCanvas.tsx:fn:CameraRig:120",
        "file:web/src/components/village/VillageCanvas.tsx:fn:FlyModeCamera:166",
        "file:web/src/components/village/VillageCanvas.tsx:fn:EmptyState:201",
        "file:web/src/components/village/VillageCanvas.tsx:fn:LoadingState:221",
        "file:web/src/components/village/VillageCanvas.tsx:fn:UpdatingIndicator:241",
        "file:web/src/components/village/VillageCanvas.tsx:fn:VillageContent:279",
        "file:web/src/components/village/VillageCanvas.tsx:fn:VillageCanvas:409",
        "file:web/src/components/village/VillageCanvas.tsx:fn:useCameraCenter:108"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:SimpleGround:40": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:SimpleGround:40",
      "type": "function",
      "name": "SimpleGround",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 40,
      "endLine": 55,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders simple dark ground plane and shadow receiver meshes for 3D scene.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function SimpleGround() {\n  return (\n    <>\n      {/* Simple dark ground plane for loading/empty states */}\n      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.01, 0]} receiveShadow>\n        <circleGeometry args={[30, 32]} />\n        <meshStandardMaterial color=\"#1a1a2e\" />\n      </mesh>\n      {/* Shadow receiver */}\n      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, -0.02, 0]} receiveShadow>\n        <planeGeometry args={[100, 100]} />\n        <shadowMaterial opacity={0.3} />\n      </mesh>\n    </>\n  );\n}",
      "references": [
        "mesh",
        "rotation",
        "Math",
        "position",
        "receiveShadow",
        "circleGeometry",
        "args",
        "meshStandardMaterial",
        "color",
        "planeGeometry",
        "shadowMaterial",
        "opacity"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:DistrictLights:75": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:DistrictLights:75",
      "type": "function",
      "name": "DistrictLights",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 75,
      "endLine": 93,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ districts }",
          "type": "DistrictLightsProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders point lights for districts at center positions with category colors.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function DistrictLights({ districts }: DistrictLightsProps) {\n  return (\n    <group>\n      {districts.map((district) => {\n        const color = DISTRICT_EDGE_COLORS[district.category];\n        return (\n          <pointLight\n            key={`district-light-${district.category}`}\n            position={[district.center.x, 4, district.center.z]}\n            intensity={0.4}\n            color={color}\n            distance={15}\n            decay={2}\n          />\n        );\n      })}\n    </group>\n  );\n}",
      "references": [
        "group",
        "districts",
        "DISTRICT_EDGE_COLORS",
        "district",
        "pointLight",
        "key",
        "position",
        "intensity",
        "color",
        "distance",
        "decay"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:CameraRig:120": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:CameraRig:120",
      "type": "function",
      "name": "CameraRig",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 120,
      "endLine": 163,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ bounds, mode, buildings, onBuildingProximity, onBuildingInteract }",
          "type": "CameraRigProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders 3D camera and controls for village canvas in walk or fly mode.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function CameraRig({ bounds, mode, buildings, onBuildingProximity, onBuildingInteract }: CameraRigProps) {\n  const { centerX, centerZ, cameraDistance } = useCameraCenter(bounds);\n\n  if (mode === 'walk') {\n    return (\n      <>\n        <PerspectiveCamera\n          makeDefault\n          fov={70}\n          near={0.1}\n          far={500}\n        />\n        <FirstPersonControls\n          bounds={bounds}\n          buildings={buildings}\n          onBuildingProximity={onBuildingProximity}\n          onBuildingInteract={onBuildingInteract}\n          initialPosition={{ x: centerX, z: centerZ }}\n        />\n      </>\n    );\n  }\n\n  // Fly mode - separate camera and controls\n  return (\n    <>\n      <FlyModeCamera\n        centerX={centerX}\n        centerZ={centerZ}\n        cameraDistance={cameraDistance}\n      />\n      <OrbitControls\n        target={[centerX, 0, centerZ]}\n        enableDamping\n        dampingFactor={0.05}\n        minDistance={5}\n        maxDistance={100}\n        maxPolarAngle={Math.PI / 2.1}\n        minPolarAngle={0.2}\n        zoomSpeed={0.3}\n      />\n    </>\n  );\n}",
      "references": [
        "centerX",
        "centerZ",
        "cameraDistance",
        "useCameraCenter",
        "bounds",
        "mode",
        "PerspectiveCamera",
        "makeDefault",
        "fov",
        "near",
        "far",
        "FirstPersonControls",
        "buildings",
        "onBuildingProximity",
        "onBuildingInteract",
        "initialPosition",
        "FlyModeCamera",
        "OrbitControls",
        "target",
        "enableDamping",
        "dampingFactor",
        "minDistance",
        "maxDistance",
        "maxPolarAngle",
        "Math",
        "minPolarAngle",
        "zoomSpeed"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:FlyModeCamera:166": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:FlyModeCamera:166",
      "type": "function",
      "name": "FlyModeCamera",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 166,
      "endLine": 195,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ centerX, centerZ, cameraDistance }",
          "type": "{ centerX: number; centerZ: number; cameraDistance: number; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders and positions a fly-mode PerspectiveCamera in Three.js scene.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function FlyModeCamera({ centerX, centerZ, cameraDistance }: {\n  centerX: number;\n  centerZ: number;\n  cameraDistance: number;\n}) {\n  const cameraRef = useRef<THREE.PerspectiveCamera>(null);\n\n  // Set camera position after mount\n  useEffect(() => {\n    if (cameraRef.current) {\n      cameraRef.current.position.set(\n        centerX + cameraDistance,\n        cameraDistance * 0.7,\n        centerZ + cameraDistance\n      );\n      cameraRef.current.lookAt(centerX, 0, centerZ);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []); // Only on mount\n\n  return (\n    <PerspectiveCamera\n      ref={cameraRef}\n      makeDefault\n      fov={50}\n      near={0.1}\n      far={500}\n    />\n  );\n}",
      "references": [
        "useRef",
        "useEffect",
        "cameraRef",
        "centerX",
        "cameraDistance",
        "centerZ",
        "PerspectiveCamera",
        "ref",
        "makeDefault",
        "fov",
        "near",
        "far"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:EmptyState:201": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:EmptyState:201",
      "type": "function",
      "name": "EmptyState",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 201,
      "endLine": 215,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a simple 3D box indicator for empty village state",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EmptyState() {\n  return (\n    <group>\n      {/* Show a simple indicator that village is empty */}\n      <mesh position={[0, 0.5, 0]}>\n        <boxGeometry args={[1, 1, 1]} />\n        <meshStandardMaterial\n          color=\"#475569\"\n          opacity={0.5}\n          transparent\n        />\n      </mesh>\n    </group>\n  );\n}",
      "references": [
        "group",
        "mesh",
        "position",
        "boxGeometry",
        "args",
        "meshStandardMaterial",
        "color",
        "opacity",
        "transparent"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:LoadingState:221": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:LoadingState:221",
      "type": "function",
      "name": "LoadingState",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 221,
      "endLine": 235,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a static purple emissive sphere mesh as a 3D loading indicator.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function LoadingState() {\n  return (\n    <group>\n      {/* Animated loading indicator */}\n      <mesh position={[0, 1, 0]}>\n        <sphereGeometry args={[0.3, 16, 16]} />\n        <meshStandardMaterial\n          color=\"#a78bfa\"\n          emissive=\"#a78bfa\"\n          emissiveIntensity={0.5}\n        />\n      </mesh>\n    </group>\n  );\n}",
      "references": [
        "group",
        "mesh",
        "position",
        "sphereGeometry",
        "args",
        "meshStandardMaterial",
        "color",
        "emissive",
        "emissiveIntensity"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:UpdatingIndicator:241": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:UpdatingIndicator:241",
      "type": "function",
      "name": "UpdatingIndicator",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 241,
      "endLine": 260,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a fixed-position 'Updating...' indicator overlay in a 3D canvas.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function UpdatingIndicator() {\n  return (\n    <Html\n      position={[0, 0, 0]}\n      center\n      style={{\n        position: 'fixed',\n        top: '16px',\n        right: '16px',\n        transform: 'none',\n      }}\n      calculatePosition={() => [window.innerWidth - 120, 16, 0]}\n    >\n      <div className=\"flex items-center gap-2 rounded-lg border border-violet-500/30 bg-background/90 px-3 py-1.5 backdrop-blur-sm\">\n        <div className=\"h-2 w-2 animate-pulse rounded-full bg-violet-500\" />\n        <span className=\"text-xs text-violet-400\">Updating...</span>\n      </div>\n    </Html>\n  );\n}",
      "references": [
        "Html",
        "position",
        "center",
        "style",
        "calculatePosition",
        "window",
        "div",
        "className",
        "span"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:VillageContent:279": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:VillageContent:279",
      "type": "function",
      "name": "VillageContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 279,
      "endLine": 392,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  layout,\n  props,\n  villagers,\n  selectedBuildingId,\n  hoveredBuildingId,\n  nearbyBuildingId,\n  cameraMode,\n  onBuildingClick,\n  onBuildingHover,\n  onBuildingProximity,\n}",
          "type": "VillageContentProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders village scene with camera rig, atmospheric effects, lighting, and mists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function VillageContent({\n  layout,\n  props,\n  villagers,\n  selectedBuildingId,\n  hoveredBuildingId,\n  nearbyBuildingId,\n  cameraMode,\n  onBuildingClick,\n  onBuildingHover,\n  onBuildingProximity,\n}: VillageContentProps) {\n  // Combine hover and proximity for highlighting\n  const highlightedBuildingId = hoveredBuildingId || nearbyBuildingId;\n\n  // Calculate bounds for atmospheric effects\n  const effectBounds = useMemo(() => ({\n    minX: layout.bounds.minX - 10,\n    maxX: layout.bounds.maxX + 10,\n    minZ: layout.bounds.minZ - 10,\n    maxZ: layout.bounds.maxZ + 10,\n  }), [layout.bounds]);\n\n  return (\n    <>\n      <CameraRig\n        bounds={layout.bounds}\n        mode={cameraMode}\n        buildings={layout.buildings}\n        onBuildingProximity={onBuildingProximity}\n        onBuildingInteract={onBuildingClick}\n      />\n\n      {/* Dream World Atmosphere */}\n      <DreamAtmosphere fogNear={20} fogFar={90} />\n      <DreamLighting enableAnimation />\n\n      {/* District accent lights */}\n      <DistrictLights districts={layout.districts} />\n\n      {/* Ground mist - swirling fog layers (heavy for floating feel) */}\n      <GroundMist\n        size={Math.max(effectBounds.maxX - effectBounds.minX, effectBounds.maxZ - effectBounds.minZ) + 30}\n        height={0.1}\n        opacity={0.6}\n        layers={3}\n        color=\"#9333ea\"\n      />\n\n      {/* Ethereal wisps - vertical mist columns */}\n      <EtherealWisps count={10} bounds={effectBounds} color=\"#a855f7\" />\n\n      {/* Drifting mist puffs - large soft fog patches floating through */}\n      <MistPuffs\n        count={15}\n        bounds={effectBounds}\n        color=\"#c4b5fd\"\n        opacity={0.12}\n        minSize={5}\n        maxSize={12}\n        minHeight={1}\n        maxHeight={5}\n      />\n\n      {/* Aurora sky - purple/green, wraps horizon */}\n      <AuroraSky\n        intensity={0.6}\n        color1=\"#a855f7\"\n        color2=\"#22c55e\"\n        color3=\"#7c3aed\"\n      />\n\n      {/* Floating particles - small, sparse, drifting through village (tight bounds) */}\n      <DreamParticles\n        count={80}\n        bounds={{\n          minX: layout.bounds.minX,\n          maxX: layout.bounds.maxX,\n          minZ: layout.bounds.minZ,\n          maxZ: layout.bounds.maxZ,\n        }}\n        color1=\"#c4b5fd\"\n        color2=\"#86efac\"\n        size={10}\n      />\n\n      {/* District hex tile ground */}\n      <VillageGround layout={layout} />\n\n      {/* Light beam roads (curved, animated, only show for selected building) */}\n      <LightBeamsLayer\n        roads={layout.roads}\n        selectedBuildingId={selectedBuildingId}\n      />\n\n      {/* Props (barrels, trees, rocks - between roads and buildings) */}\n      <PropsLayer props={props} />\n\n      {/* Villagers (entities as characters) */}\n      <VillagersLayer villagers={villagers} />\n\n      {/* Buildings */}\n      <BuildingsLayer\n        buildings={layout.buildings}\n        selectedBuildingId={selectedBuildingId}\n        hoveredBuildingId={highlightedBuildingId}\n        onBuildingClick={onBuildingClick}\n        onBuildingHover={onBuildingHover}\n      />\n\n      {/* Post-processing removed - too GPU heavy */}\n    </>\n  );\n}",
      "references": [
        "hoveredBuildingId",
        "nearbyBuildingId",
        "useMemo",
        "layout",
        "CameraRig",
        "bounds",
        "mode",
        "cameraMode",
        "buildings",
        "onBuildingProximity",
        "onBuildingInteract",
        "onBuildingClick",
        "DreamAtmosphere",
        "fogNear",
        "fogFar",
        "DreamLighting",
        "enableAnimation",
        "DistrictLights",
        "districts",
        "GroundMist",
        "size",
        "Math",
        "effectBounds",
        "height",
        "opacity",
        "layers",
        "color",
        "EtherealWisps",
        "count",
        "MistPuffs",
        "minSize",
        "maxSize",
        "minHeight",
        "maxHeight",
        "AuroraSky",
        "intensity",
        "color1",
        "color2",
        "color3",
        "DreamParticles",
        "VillageGround",
        "LightBeamsLayer",
        "roads",
        "selectedBuildingId",
        "PropsLayer",
        "props",
        "VillagersLayer",
        "villagers",
        "BuildingsLayer",
        "highlightedBuildingId",
        "onBuildingHover"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:VillageCanvas:409": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:VillageCanvas:409",
      "type": "function",
      "name": "VillageCanvas",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 409,
      "endLine": 517,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ onBuildingSelect, onBuildingHover }",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas\").VillageCanvasProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders village canvas with building selection, hover, proximity handling, and camera modes",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function VillageCanvas({ onBuildingSelect, onBuildingHover }: VillageCanvasProps) {\n  // Fetch layout data\n  const { layout, props, villagers, isLoading, isFetching, isError, isEmpty } = useVillageLayout({\n    maxBuildings: 120,\n    minSalience: 0,\n  });\n\n  // Track if we're updating (fetching but not initial load)\n  const isUpdating = isFetching && !isLoading;\n\n  // Camera mode from store\n  const cameraMode = useCameraMode();\n\n  // Selection state\n  const {\n    selection,\n    selectBuilding,\n    hoverBuilding,\n  } = useVillageSelection();\n\n  // Track nearby building for walk mode proximity\n  const [nearbyBuildingId, setNearbyBuildingId] = useState<string | null>(null);\n\n  // Handle building click\n  const handleBuildingClick = useCallback((building: VillageBuilding) => {\n    const isAlreadySelected = selection.buildingId === building.id;\n    const newBuildingId = isAlreadySelected ? null : building.id;\n    const newMemoryId = isAlreadySelected ? null : building.memoryId;\n    const newBuilding = isAlreadySelected ? null : building;\n\n    selectBuilding(newBuildingId, newMemoryId);\n    onBuildingSelect?.(newBuilding);\n  }, [selection.buildingId, selectBuilding, onBuildingSelect]);\n\n  // Handle building hover (fly mode)\n  const handleBuildingHover = useCallback((building: VillageBuilding | null) => {\n    hoverBuilding(building?.id ?? null);\n    onBuildingHover?.(building);\n  }, [hoverBuilding, onBuildingHover]);\n\n  // Handle building proximity (walk mode)\n  const handleBuildingProximity = useCallback((building: VillageBuilding | null) => {\n    setNearbyBuildingId(building?.id ?? null);\n    // Also update hover state for tooltip display\n    onBuildingHover?.(building);\n  }, [onBuildingHover]);\n\n  // Default camera for loading/empty states\n  const defaultBounds = { minX: -10, maxX: 10, minZ: -10, maxZ: 10 };\n\n  // Loading state - always use fly mode\n  if (isLoading) {\n    return (\n      <>\n        <CameraRig bounds={defaultBounds} mode=\"fly\" buildings={[]} />\n        <DreamLighting enableAnimation={false} />\n        <DreamAtmosphere />\n        <SimpleGround />\n        <LoadingState />\n      </>\n    );\n  }\n\n  // Error state - always use fly mode\n  if (isError) {\n    return (\n      <>\n        <CameraRig bounds={defaultBounds} mode=\"fly\" buildings={[]} />\n        <DreamLighting enableAnimation={false} />\n        <DreamAtmosphere />\n        <SimpleGround />\n        <EmptyState />\n      </>\n    );\n  }\n\n  // Empty state - always use fly mode\n  if (isEmpty) {\n    return (\n      <>\n        <CameraRig bounds={defaultBounds} mode=\"fly\" buildings={[]} />\n        <DreamLighting enableAnimation={false} />\n        <DreamAtmosphere />\n        <SimpleGround />\n        <EmptyState />\n      </>\n    );\n  }\n\n  // Main content\n  return (\n    <>\n      <VillageContent\n        layout={layout}\n        props={props}\n        villagers={villagers}\n        selectedBuildingId={selection.buildingId}\n        hoveredBuildingId={selection.hoveredBuildingId}\n        nearbyBuildingId={nearbyBuildingId}\n        cameraMode={cameraMode}\n        onBuildingClick={handleBuildingClick}\n        onBuildingHover={handleBuildingHover}\n        onBuildingProximity={handleBuildingProximity}\n      />\n      {/* Subtle updating indicator during refetch */}\n      {isUpdating && <UpdatingIndicator />}\n    </>\n  );\n}",
      "references": [
        "layout",
        "props",
        "villagers",
        "isLoading",
        "isFetching",
        "isError",
        "isEmpty",
        "useVillageLayout",
        "useCameraMode",
        "selection",
        "selectBuilding",
        "hoverBuilding",
        "useVillageSelection",
        "nearbyBuildingId",
        "setNearbyBuildingId",
        "useState",
        "useCallback",
        "building",
        "isAlreadySelected",
        "newBuildingId",
        "newMemoryId",
        "onBuildingSelect",
        "newBuilding",
        "onBuildingHover",
        "CameraRig",
        "bounds",
        "defaultBounds",
        "mode",
        "buildings",
        "DreamLighting",
        "enableAnimation",
        "DreamAtmosphere",
        "SimpleGround",
        "LoadingState",
        "EmptyState",
        "VillageContent",
        "selectedBuildingId",
        "hoveredBuildingId",
        "cameraMode",
        "onBuildingClick",
        "handleBuildingClick",
        "handleBuildingHover",
        "onBuildingProximity",
        "handleBuildingProximity",
        "isUpdating",
        "UpdatingIndicator"
      ]
    },
    "file:web/src/components/village/VillageCanvas.tsx:fn:useCameraCenter:108": {
      "id": "file:web/src/components/village/VillageCanvas.tsx:fn:useCameraCenter:108",
      "type": "function",
      "name": "useCameraCenter",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageCanvas.tsx",
      "line": 108,
      "endLine": 118,
      "parentFileId": "file:web/src/components/village/VillageCanvas.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "bounds",
          "type": "VillageLayout",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ centerX: number; centerZ: number; cameraDistance: number; }",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Computes camera center and distance from village bounds using useMemo.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.233Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "const useCameraCenter = (bounds: VillageLayout['bounds']) => {\n  return useMemo(() => {\n    const centerX = (bounds.minX + bounds.maxX) / 2;\n    const centerZ = (bounds.minZ + bounds.maxZ) / 2;\n    const rangeX = bounds.maxX - bounds.minX;\n    const rangeZ = bounds.maxZ - bounds.minZ;\n    const maxRange = Math.max(rangeX, rangeZ, 20);\n    const cameraDistance = maxRange * 0.8;\n    return { centerX, centerZ, cameraDistance };\n  }, [bounds.minX, bounds.maxX, bounds.minZ, bounds.maxZ]);\n};",
      "references": [
        "useMemo",
        "Math",
        "rangeX",
        "rangeZ",
        "maxRange",
        "centerX",
        "centerZ",
        "cameraDistance"
      ]
    },
    "file:web/src/components/village/Villager.tsx": {
      "id": "file:web/src/components/village/Villager.tsx",
      "type": "file",
      "name": "Villager.tsx",
      "filePath": "web/src/components/village/Villager.tsx",
      "line": 1,
      "endLine": 136,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "React",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            },
            {
              "name": "memo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "useFrame",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageVillager",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillagerType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "VillagersLayer",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "VillagersLayer",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": [
        "VillagerFigure",
        "villager",
        "hovered",
        "onClick",
        "onPointerOver",
        "onPointerOut",
        "VILLAGER_COLORS",
        "groupRef",
        "state",
        "Math",
        "t",
        "phase",
        "group",
        "ref",
        "position",
        "rotation",
        "handleClick",
        "handlePointerOver",
        "mesh",
        "castShadow",
        "capsuleGeometry",
        "args",
        "meshStandardMaterial",
        "color",
        "colors",
        "roughness",
        "emissive",
        "emissiveIntensity",
        "sphereGeometry",
        "meshBasicMaterial",
        "VillagersLayer",
        "villagers",
        "hoveredVillagerId",
        "onVillagerClick",
        "onVillagerHover",
        "name",
        "key",
        "v"
      ]
    },
    "file:web/src/components/village/VillageScene.tsx": {
      "id": "file:web/src/components/village/VillageScene.tsx",
      "type": "file",
      "name": "VillageScene.tsx",
      "filePath": "web/src/components/village/VillageScene.tsx",
      "line": 1,
      "endLine": 183,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "Suspense",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@react-three/fiber",
          "items": [
            {
              "name": "Canvas",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./VillageCanvas",
          "items": [
            {
              "name": "VillageCanvas",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./MemoryPanel",
          "items": [
            {
              "name": "MemoryPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useCameraMode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useToggleCameraMode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useIsPointerLocked",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "VillageScene",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/components/village/VillageScene.tsx:fn:VillageScene:10"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/components/village/VillageScene.tsx:fn:VillageScene:10": {
      "id": "file:web/src/components/village/VillageScene.tsx:fn:VillageScene:10",
      "type": "function",
      "name": "VillageScene",
      "filePath": "/home/ridgetop/projects/squire/web/src/components/village/VillageScene.tsx",
      "line": 10,
      "endLine": 182,
      "parentFileId": "file:web/src/components/village/VillageScene.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering 3D village scene with building selection, hover, and camera controls",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function VillageScene() {\n  // Selection state\n  const [selectedMemoryId, setSelectedMemoryId] = useState<string | null>(null);\n  const [selectedBuilding, setSelectedBuilding] = useState<VillageBuilding | null>(null);\n\n  // Hover state for tooltip\n  const [hoveredBuilding, setHoveredBuilding] = useState<VillageBuilding | null>(null);\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n\n  // Camera mode\n  const cameraMode = useCameraMode();\n  const toggleCameraMode = useToggleCameraMode();\n  const isPointerLocked = useIsPointerLocked();\n  const isWalkMode = cameraMode === 'walk';\n\n  const handleBuildingSelect = useCallback((building: VillageBuilding | null) => {\n    setSelectedBuilding(building);\n    setSelectedMemoryId(building?.memoryId ?? null);\n  }, []);\n\n  const handleBuildingHover = useCallback((building: VillageBuilding | null) => {\n    setHoveredBuilding(building);\n  }, []);\n\n  const handleMouseMove = useCallback((e: React.MouseEvent) => {\n    setMousePosition({ x: e.clientX, y: e.clientY });\n  }, []);\n\n  const handleClosePanel = useCallback(() => {\n    setSelectedMemoryId(null);\n    setSelectedBuilding(null);\n  }, []);\n\n  return (\n    <div className=\"relative h-full w-full bg-background\" onMouseMove={handleMouseMove}>\n      <Canvas\n        shadows\n        frameloop=\"always\"\n        gl={{\n          antialias: true,\n          alpha: false,\n          powerPreference: 'high-performance',\n        }}\n        onCreated={({ gl }) => {\n          gl.setClearColor('#0a0a0f');\n        }}\n      >\n        <Suspense fallback={null}>\n          <VillageCanvas\n            onBuildingSelect={handleBuildingSelect}\n            onBuildingHover={handleBuildingHover}\n          />\n        </Suspense>\n      </Canvas>\n\n      {/* Overlay UI */}\n      <div className=\"pointer-events-none absolute inset-0\">\n        {/* Top left - Title */}\n        <div className=\"absolute left-4 top-4\">\n          <h1 className=\"text-lg font-semibold text-foreground\">Memory Village</h1>\n          <p className=\"text-sm text-foreground-muted\">\n            {isWalkMode ? 'Walk through your memories' : 'Click a building to view memory'}\n          </p>\n        </div>\n\n        {/* Top right - Camera mode toggle */}\n        <div className=\"absolute right-4 top-4 pointer-events-auto\">\n          <button\n            onClick={toggleCameraMode}\n            className=\"flex items-center gap-2 rounded-lg border border-border bg-background/90 px-3 py-2 text-sm font-medium text-foreground backdrop-blur-sm transition-colors hover:bg-accent hover:text-accent-foreground\"\n          >\n            {isWalkMode ? (\n              <>\n                <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z\" />\n                </svg>\n                Switch to Fly\n              </>\n            ) : (\n              <>\n                <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z\" />\n                </svg>\n                Switch to Walk\n              </>\n            )}\n          </button>\n        </div>\n\n        {/* Bottom left - Controls hint */}\n        <div className=\"absolute bottom-4 left-4 rounded-lg border border-border bg-background/80 px-3 py-2 backdrop-blur-sm\">\n          {isWalkMode ? (\n            <>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Move:</span> WASD or Arrow keys\n              </p>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Look:</span> Click to lock mouse, move to look\n              </p>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Sprint:</span> Hold Shift\n              </p>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Interact:</span> E key near a building\n              </p>\n            </>\n          ) : (\n            <>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Mouse:</span> Drag to rotate, Scroll to zoom\n              </p>\n              <p className=\"text-xs text-foreground-muted\">\n                <span className=\"font-medium text-foreground\">Touch:</span> Drag to rotate, Pinch to zoom\n              </p>\n            </>\n          )}\n        </div>\n\n        {/* Center - Click to enter walk mode prompt */}\n        {isWalkMode && !isPointerLocked && (\n          <div className=\"absolute inset-0 flex items-center justify-center\">\n            <div className=\"rounded-lg border border-violet-500/50 bg-background/90 px-6 py-4 backdrop-blur-sm\">\n              <p className=\"text-center text-sm font-medium text-foreground\">\n                Click anywhere to start walking\n              </p>\n              <p className=\"text-center text-xs text-foreground-muted mt-1\">\n                Press Escape to exit walk mode\n              </p>\n            </div>\n          </div>\n        )}\n\n        {/* Walk mode - nearby building interaction hint */}\n        {isWalkMode && isPointerLocked && hoveredBuilding && !selectedBuilding && (\n          <div className=\"absolute bottom-20 left-1/2 -translate-x-1/2\">\n            <div className=\"rounded-lg border border-violet-500/50 bg-background/90 px-4 py-2 backdrop-blur-sm\">\n              <p className=\"text-center text-sm font-medium text-foreground\">\n                Press <span className=\"text-violet-400\">E</span> to view: {hoveredBuilding.label}\n              </p>\n            </div>\n          </div>\n        )}\n\n        {/* Hover Tooltip (fly mode only) */}\n        {!isWalkMode && hoveredBuilding && !selectedBuilding && (\n          <div\n            className=\"pointer-events-none fixed z-50 rounded-lg border border-border bg-background/95 px-3 py-2 shadow-lg backdrop-blur-sm\"\n            style={{\n              left: mousePosition.x + 16,\n              top: mousePosition.y + 16,\n              maxWidth: 280,\n            }}\n          >\n            <p className=\"text-sm font-medium text-foreground truncate\">\n              {hoveredBuilding.label}\n            </p>\n            <p className=\"text-xs text-foreground-muted capitalize\">\n              {hoveredBuilding.category}  {hoveredBuilding.buildingType}\n            </p>\n          </div>\n        )}\n      </div>\n\n      {/* Memory Panel Overlay */}\n      <MemoryPanel\n        memoryId={selectedMemoryId}\n        building={selectedBuilding}\n        onClose={handleClosePanel}\n      />\n    </div>\n  );\n}",
      "references": [
        "selectedMemoryId",
        "setSelectedMemoryId",
        "useState",
        "selectedBuilding",
        "setSelectedBuilding",
        "hoveredBuilding",
        "setHoveredBuilding",
        "mousePosition",
        "setMousePosition",
        "useCameraMode",
        "useToggleCameraMode",
        "useIsPointerLocked",
        "cameraMode",
        "useCallback",
        "building",
        "e",
        "div",
        "className",
        "onMouseMove",
        "handleMouseMove",
        "Canvas",
        "shadows",
        "frameloop",
        "gl",
        "onCreated",
        "Suspense",
        "fallback",
        "VillageCanvas",
        "onBuildingSelect",
        "handleBuildingSelect",
        "onBuildingHover",
        "handleBuildingHover",
        "h1",
        "p",
        "isWalkMode",
        "button",
        "onClick",
        "toggleCameraMode",
        "svg",
        "fill",
        "viewBox",
        "stroke",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "span",
        "isPointerLocked",
        "style",
        "MemoryPanel",
        "memoryId",
        "onClose",
        "handleClosePanel"
      ]
    },
    "file:web/src/lib/api/beliefs.ts": {
      "id": "file:web/src/lib/api/beliefs.ts",
      "type": "file",
      "name": "beliefs.ts",
      "filePath": "web/src/lib/api/beliefs.ts",
      "line": 1,
      "endLine": 135,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchBelief",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchBeliefStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchBeliefsByCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchBeliefConflicts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BeliefConflict",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FetchBeliefsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/beliefs.ts:fn:transformBelief:33",
        "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefs:91",
        "file:web/src/lib/api/beliefs.ts:fn:fetchBelief:107",
        "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefStats:115",
        "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefsByCategory:123",
        "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefConflicts:131"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/beliefs.ts:fn:transformBelief:33": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:transformBelief:33",
      "type": "function",
      "name": "transformBelief",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 33,
      "endLine": 44,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backend",
          "type": "BackendBelief",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Belief",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms BackendBelief to Belief by mapping and renaming properties.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformBelief(backend: BackendBelief): Belief {\n  return {\n    id: backend.id,\n    statement: backend.content,\n    category: backend.belief_type,\n    confidence: backend.confidence,\n    evidence_count: backend.source_memory_count,\n    first_observed: backend.first_extracted_at,\n    last_reinforced: backend.last_reinforced_at || backend.first_extracted_at,\n    status: backend.status === 'superseded' ? 'deprecated' : backend.status,\n  };\n}",
      "references": []
    },
    "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefs:91": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefs:91",
      "type": "function",
      "name": "fetchBeliefs",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 91,
      "endLine": 102,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/beliefs\").FetchBeliefsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Belief[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches beliefs from API with filters and transforms them",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchBeliefs(options: FetchBeliefsOptions = {}): Promise<Belief[]> {\n  const { type, status, minConfidence, limit = 50 } = options;\n  const response = await apiGet<BeliefsListResponse>('/api/beliefs', {\n    params: {\n      type,\n      status,\n      minConfidence,\n      limit,\n    },\n  });\n  return response.beliefs.map(transformBelief);\n}",
      "references": [
        "status",
        "minConfidence",
        "limit",
        "apiGet",
        "response",
        "transformBelief"
      ]
    },
    "file:web/src/lib/api/beliefs.ts:fn:fetchBelief:107": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:fetchBelief:107",
      "type": "function",
      "name": "fetchBelief",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 107,
      "endLine": 110,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Belief>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a belief by ID via API and transforms the response.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchBelief(id: string): Promise<Belief> {\n  const response = await apiGet<BeliefResponse>(`/api/beliefs/${id}`);\n  return transformBelief(response.belief);\n}",
      "references": [
        "apiGet",
        "transformBelief",
        "response"
      ]
    },
    "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefStats:115": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefStats:115",
      "type": "function",
      "name": "fetchBeliefStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 115,
      "endLine": 118,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; byCategory: Record<BeliefCategory, number>; byStatus: Record<string, number>; avgConfidence: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches belief statistics from API endpoint and returns stats object",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchBeliefStats(): Promise<BeliefStatsResponse['stats']> {\n  const response = await apiGet<BeliefStatsResponse>('/api/beliefs/stats');\n  return response.stats;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefsByCategory:123": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefsByCategory:123",
      "type": "function",
      "name": "fetchBeliefsByCategory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 123,
      "endLine": 126,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "category",
          "type": "BeliefCategory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Belief[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches beliefs by category from API and transforms them",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchBeliefsByCategory(category: BeliefCategory): Promise<Belief[]> {\n  const response = await apiGet<BeliefsListResponse>(`/api/beliefs/type/${category}`);\n  return response.beliefs.map(transformBelief);\n}",
      "references": [
        "apiGet",
        "response",
        "transformBelief"
      ]
    },
    "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefConflicts:131": {
      "id": "file:web/src/lib/api/beliefs.ts:fn:fetchBeliefConflicts:131",
      "type": "function",
      "name": "fetchBeliefConflicts",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/beliefs.ts",
      "line": 131,
      "endLine": 134,
      "parentFileId": "file:web/src/lib/api/beliefs.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/beliefs\").BeliefConflict[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches belief conflicts from API endpoint '/api/beliefs/conflicts'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchBeliefConflicts(): Promise<BeliefConflict[]> {\n  const response = await apiGet<BeliefConflictsResponse>('/api/beliefs/conflicts');\n  return response.conflicts;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/chat.ts": {
      "id": "file:web/src/lib/api/chat.ts",
      "type": "file",
      "name": "chat.ts",
      "filePath": "web/src/lib/api/chat.ts",
      "line": 1,
      "endLine": 75,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ChatMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "sendChatMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "prepareHistoryForApi",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ChatApiRequest",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatContextInfo",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatApiResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/chat.ts:fn:sendChatMessage:51",
        "file:web/src/lib/api/chat.ts:fn:prepareHistoryForApi:67"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/chat.ts:fn:sendChatMessage:51": {
      "id": "file:web/src/lib/api/chat.ts:fn:sendChatMessage:51",
      "type": "function",
      "name": "sendChatMessage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/chat.ts",
      "line": 51,
      "endLine": 59,
      "parentFileId": "file:web/src/lib/api/chat.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "request",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/chat\").ChatApiRequest",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/chat\").ChatApiResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends a chat message via API POST request and returns the response.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function sendChatMessage(\n  request: ChatApiRequest\n): Promise<ChatApiResponse> {\n  const response = await apiPost<ApiSuccessResponse<ChatApiResponse>>(\n    '/api/chat',\n    request\n  );\n  return response.data;\n}",
      "references": [
        "apiPost",
        "response"
      ]
    },
    "file:web/src/lib/api/chat.ts:fn:prepareHistoryForApi:67": {
      "id": "file:web/src/lib/api/chat.ts:fn:prepareHistoryForApi:67",
      "type": "function",
      "name": "prepareHistoryForApi",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/chat.ts",
      "line": 67,
      "endLine": 74,
      "parentFileId": "file:web/src/lib/api/chat.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "messages",
          "type": "ChatMessage[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "ChatMessage[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps chat messages to API format with id, role, content, timestamp",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function prepareHistoryForApi(messages: ChatMessage[]): ChatMessage[] {\n  return messages.map((msg) => ({\n    id: msg.id,\n    role: msg.role,\n    content: msg.content,\n    timestamp: msg.timestamp,\n  }));\n}",
      "references": [
        "msg"
      ]
    },
    "file:web/src/lib/api/client.ts": {
      "id": "file:web/src/lib/api/client.ts",
      "type": "file",
      "name": "client.ts",
      "filePath": "web/src/lib/api/client.ts",
      "line": 1,
      "endLine": 153,
      "imports": [],
      "exports": [
        {
          "name": "apiGet",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "apiPost",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "apiPatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "apiDelete",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/api/client.ts:fn:handleResponse:27",
        "file:web/src/lib/api/client.ts:fn:buildUrl:49",
        "file:web/src/lib/api/client.ts:fn:apiGet:73",
        "file:web/src/lib/api/client.ts:fn:apiPost:92",
        "file:web/src/lib/api/client.ts:fn:apiPatch:113",
        "file:web/src/lib/api/client.ts:fn:apiDelete:134"
      ],
      "classes": [
        "file:web/src/lib/api/client.ts:class:ApiError:12"
      ],
      "topLevelReferences": [
        "window",
        "process"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:handleResponse:27": {
      "id": "file:web/src/lib/api/client.ts:fn:handleResponse:27",
      "type": "function",
      "name": "handleResponse",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 27,
      "endLine": 47,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "response",
          "type": "Response",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<T>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Processes HTTP Response: throws ApiError on failure, parses JSON body on success.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "async function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    const errorBody = await response.text();\n    let message = `API Error: ${response.status} ${response.statusText}`;\n    try {\n      const parsed = JSON.parse(errorBody);\n      message = parsed.error || parsed.message || message;\n    } catch {\n      // Use default message\n    }\n    throw new ApiError(response.status, response.statusText, message);\n  }\n\n  // Handle empty responses\n  const text = await response.text();\n  if (!text) {\n    return {} as T;\n  }\n\n  return JSON.parse(text);\n}",
      "references": [
        "JSON",
        "errorBody",
        "message",
        "parsed",
        "ApiError",
        "text"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:buildUrl:49": {
      "id": "file:web/src/lib/api/client.ts:fn:buildUrl:49",
      "type": "function",
      "name": "buildUrl",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 49,
      "endLine": 71,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "params",
          "type": "Record<string, string | number | boolean>",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Builds URL by optionally prepending base and appending query params",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function buildUrl(\n  endpoint: string,\n  params?: Record<string, string | number | boolean | undefined>\n): string {\n  // For relative URLs (browser), just use the endpoint directly\n  // For absolute URLs (SSR), prepend the base\n  let urlString = API_BASE_URL ? `${API_BASE_URL}${endpoint}` : endpoint;\n\n  if (params) {\n    const searchParams = new URLSearchParams();\n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        searchParams.append(key, String(value));\n      }\n    });\n    const queryString = searchParams.toString();\n    if (queryString) {\n      urlString += `?${queryString}`;\n    }\n  }\n\n  return urlString;\n}",
      "references": [
        "API_BASE_URL",
        "URLSearchParams",
        "Object",
        "key",
        "value",
        "searchParams",
        "String",
        "queryString",
        "urlString"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:apiGet:73": {
      "id": "file:web/src/lib/api/client.ts:fn:apiGet:73",
      "type": "function",
      "name": "apiGet",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 73,
      "endLine": 90,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "FetchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<T>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Makes an HTTP GET request to an API endpoint with optional params.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function apiGet<T>(\n  endpoint: string,\n  options: FetchOptions = {}\n): Promise<T> {\n  const { params, ...fetchOptions } = options;\n  const url = buildUrl(endpoint, params);\n\n  const response = await fetch(url, {\n    method: 'GET',\n    headers: {\n      'Content-Type': 'application/json',\n      ...fetchOptions.headers,\n    },\n    ...fetchOptions,\n  });\n\n  return handleResponse<T>(response);\n}",
      "references": [
        "params",
        "fetchOptions",
        "buildUrl",
        "fetch",
        "url",
        "handleResponse",
        "response"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:apiPost:92": {
      "id": "file:web/src/lib/api/client.ts:fn:apiPost:92",
      "type": "function",
      "name": "apiPost",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 92,
      "endLine": 111,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "body",
          "type": "B",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "FetchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<T>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Makes a POST HTTP request to endpoint with optional body and handles response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function apiPost<T, B = unknown>(\n  endpoint: string,\n  body?: B,\n  options: FetchOptions = {}\n): Promise<T> {\n  const { params, ...fetchOptions } = options;\n  const url = buildUrl(endpoint, params);\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      ...fetchOptions.headers,\n    },\n    body: body ? JSON.stringify(body) : undefined,\n    ...fetchOptions,\n  });\n\n  return handleResponse<T>(response);\n}",
      "references": [
        "params",
        "fetchOptions",
        "buildUrl",
        "fetch",
        "url",
        "JSON",
        "handleResponse",
        "response"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:apiPatch:113": {
      "id": "file:web/src/lib/api/client.ts:fn:apiPatch:113",
      "type": "function",
      "name": "apiPatch",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 113,
      "endLine": 132,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "body",
          "type": "B",
          "isOptional": true,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "FetchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<T>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Makes a PATCH HTTP request to an API endpoint with optional body and handles response.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function apiPatch<T, B = unknown>(\n  endpoint: string,\n  body?: B,\n  options: FetchOptions = {}\n): Promise<T> {\n  const { params, ...fetchOptions } = options;\n  const url = buildUrl(endpoint, params);\n\n  const response = await fetch(url, {\n    method: 'PATCH',\n    headers: {\n      'Content-Type': 'application/json',\n      ...fetchOptions.headers,\n    },\n    body: body ? JSON.stringify(body) : undefined,\n    ...fetchOptions,\n  });\n\n  return handleResponse<T>(response);\n}",
      "references": [
        "params",
        "fetchOptions",
        "buildUrl",
        "fetch",
        "url",
        "JSON",
        "handleResponse",
        "response"
      ]
    },
    "file:web/src/lib/api/client.ts:fn:apiDelete:134": {
      "id": "file:web/src/lib/api/client.ts:fn:apiDelete:134",
      "type": "function",
      "name": "apiDelete",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/client.ts",
      "line": 134,
      "endLine": 151,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "FetchOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<T>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Performs DELETE HTTP request to endpoint with params and handles response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function apiDelete<T>(\n  endpoint: string,\n  options: FetchOptions = {}\n): Promise<T> {\n  const { params, ...fetchOptions } = options;\n  const url = buildUrl(endpoint, params);\n\n  const response = await fetch(url, {\n    method: 'DELETE',\n    headers: {\n      'Content-Type': 'application/json',\n      ...fetchOptions.headers,\n    },\n    ...fetchOptions,\n  });\n\n  return handleResponse<T>(response);\n}",
      "references": [
        "params",
        "fetchOptions",
        "buildUrl",
        "fetch",
        "url",
        "handleResponse",
        "response"
      ]
    },
    "file:web/src/lib/api/client.ts:class:ApiError:12": {
      "id": "file:web/src/lib/api/client.ts:class:ApiError:12",
      "type": "class",
      "name": "ApiError",
      "filePath": "web/src/lib/api/client.ts",
      "line": 12,
      "endLine": 21,
      "parentFileId": "file:web/src/lib/api/client.ts",
      "methods": [],
      "properties": [],
      "isExported": false,
      "extends": "Error",
      "implements": []
    },
    "file:web/src/lib/api/consolidation.ts": {
      "id": "file:web/src/lib/api/consolidation.ts",
      "type": "file",
      "name": "consolidation.ts",
      "filePath": "web/src/lib/api/consolidation.ts",
      "line": 1,
      "endLine": 112,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "triggerConsolidation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConsolidationStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ConsolidationResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConsolidationStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/consolidation.ts:fn:triggerConsolidation:86",
        "file:web/src/lib/api/consolidation.ts:fn:getConsolidationStats:101"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/consolidation.ts:fn:triggerConsolidation:86": {
      "id": "file:web/src/lib/api/consolidation.ts:fn:triggerConsolidation:86",
      "type": "function",
      "name": "triggerConsolidation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/consolidation.ts",
      "line": 86,
      "endLine": 96,
      "parentFileId": "file:web/src/lib/api/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/consolidation\").ConsolidationResult>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Triggers consolidation by POSTing to /api/consolidation/run and returns result",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function triggerConsolidation(): Promise<ConsolidationResult> {\n  const response = await apiPost<ApiSuccessResponse<ConsolidationResult>>(\n    '/api/consolidation/run'\n  );\n\n  if (!response.result) {\n    throw new Error('Consolidation failed - no result returned');\n  }\n\n  return response.result;\n}",
      "references": [
        "apiPost",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/consolidation.ts:fn:getConsolidationStats:101": {
      "id": "file:web/src/lib/api/consolidation.ts:fn:getConsolidationStats:101",
      "type": "function",
      "name": "getConsolidationStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/consolidation.ts",
      "line": 101,
      "endLine": 111,
      "parentFileId": "file:web/src/lib/api/consolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/consolidation\").ConsolidationStats>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches consolidation stats from API endpoint and returns structured stats object",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getConsolidationStats(): Promise<ConsolidationStats> {\n  const response = await apiGet<ApiSuccessResponse<never> & ConsolidationStats>(\n    '/api/consolidation/stats'\n  );\n\n  return {\n    stats: response.stats!,\n    sessions: response.sessions!,\n    config: response.config!,\n  };\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/context.ts": {
      "id": "file:web/src/lib/api/context.ts",
      "type": "file",
      "name": "context.ts",
      "filePath": "web/src/lib/api/context.ts",
      "line": 1,
      "endLine": 47,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ContextPackage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listContextProfiles",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FetchContextRequest",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextProfile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/context.ts:fn:fetchContext:30",
        "file:web/src/lib/api/context.ts:fn:listContextProfiles:40"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/context.ts:fn:fetchContext:30": {
      "id": "file:web/src/lib/api/context.ts:fn:fetchContext:30",
      "type": "function",
      "name": "fetchContext",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/context.ts",
      "line": 30,
      "endLine": 34,
      "parentFileId": "file:web/src/lib/api/context.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "request",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/context\").FetchContextRequest",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<ContextPackage>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches context data via POST request to /api/context",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.235Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchContext(\n  request: FetchContextRequest = {}\n): Promise<ContextPackage> {\n  return apiPost<ContextPackage>('/api/context', request);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/context.ts:fn:listContextProfiles:40": {
      "id": "file:web/src/lib/api/context.ts:fn:listContextProfiles:40",
      "type": "function",
      "name": "listContextProfiles",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/context.ts",
      "line": 40,
      "endLine": 45,
      "parentFileId": "file:web/src/lib/api/context.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/context\").ContextProfile[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches and returns a list of context profiles from the API",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.235Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listContextProfiles(): Promise<ContextProfile[]> {\n  const response = await apiGet<{ profiles: ContextProfile[] }>(\n    '/api/context/profiles'\n  );\n  return response.profiles;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/conversations.ts": {
      "id": "file:web/src/lib/api/conversations.ts",
      "type": "file",
      "name": "conversations.ts",
      "filePath": "web/src/lib/api/conversations.ts",
      "line": 1,
      "endLine": 97,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPatch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "fetchRecentConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveConversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ConversationResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MessageResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/conversations.ts:fn:fetchRecentConversation:49",
        "file:web/src/lib/api/conversations.ts:fn:createConversation:64",
        "file:web/src/lib/api/conversations.ts:fn:updateConversation:79",
        "file:web/src/lib/api/conversations.ts:fn:archiveConversation:94"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/conversations.ts:fn:fetchRecentConversation:49": {
      "id": "file:web/src/lib/api/conversations.ts:fn:fetchRecentConversation:49",
      "type": "function",
      "name": "fetchRecentConversation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/conversations.ts",
      "line": 49,
      "endLine": 59,
      "parentFileId": "file:web/src/lib/api/conversations.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ conversation: import(\"/home/ridgetop/projects/squire/web/src/lib/api/conversations\").ConversationResponse; messages: import(\"/home/ridgetop/projects/squire/web/src/lib/api/conversations\").MessageResponse[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches recent conversation and messages via API call.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:16.235Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchRecentConversation(): Promise<{\n  conversation: ConversationResponse;\n  messages: MessageResponse[];\n} | null> {\n  const response = await apiGet<ApiResponse<{\n    conversation: ConversationResponse;\n    messages: MessageResponse[];\n  } | null>>('/api/chat/conversations/recent');\n\n  return response.data;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/conversations.ts:fn:createConversation:64": {
      "id": "file:web/src/lib/api/conversations.ts:fn:createConversation:64",
      "type": "function",
      "name": "createConversation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/conversations.ts",
      "line": 64,
      "endLine": 74,
      "parentFileId": "file:web/src/lib/api/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "{ clientId?: string; title?: string; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/conversations\").ConversationResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a conversation via API POST to '/api/chat/conversations' with optional clientId and title",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.639Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createConversation(input: {\n  clientId?: string;\n  title?: string;\n}): Promise<ConversationResponse> {\n  const response = await apiPost<ApiResponse<ConversationResponse>>(\n    '/api/chat/conversations',\n    input\n  );\n\n  return response.data;\n}",
      "references": [
        "apiPost",
        "response"
      ]
    },
    "file:web/src/lib/api/conversations.ts:fn:updateConversation:79": {
      "id": "file:web/src/lib/api/conversations.ts:fn:updateConversation:79",
      "type": "function",
      "name": "updateConversation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/conversations.ts",
      "line": 79,
      "endLine": 89,
      "parentFileId": "file:web/src/lib/api/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "updates",
          "type": "{ title?: string; status?: \"archived\"; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/conversations\").ConversationResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates conversation title or status via API PATCH request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.454Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateConversation(\n  id: string,\n  updates: { title?: string; status?: 'archived' }\n): Promise<ConversationResponse> {\n  const response = await apiPatch<ApiResponse<ConversationResponse>>(\n    `/api/chat/conversations/${id}`,\n    updates\n  );\n\n  return response.data;\n}",
      "references": [
        "apiPatch",
        "response"
      ]
    },
    "file:web/src/lib/api/conversations.ts:fn:archiveConversation:94": {
      "id": "file:web/src/lib/api/conversations.ts:fn:archiveConversation:94",
      "type": "function",
      "name": "archiveConversation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/conversations.ts",
      "line": 94,
      "endLine": 96,
      "parentFileId": "file:web/src/lib/api/conversations.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/conversations\").ConversationResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a conversation by updating its status to 'archived'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.027Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveConversation(id: string): Promise<ConversationResponse> {\n  return updateConversation(id, { status: 'archived' });\n}",
      "references": [
        "updateConversation"
      ]
    },
    "file:web/src/lib/api/documents.ts": {
      "id": "file:web/src/lib/api/documents.ts",
      "type": "file",
      "name": "documents.ts",
      "filePath": "web/src/lib/api/documents.ts",
      "line": 1,
      "endLine": 387,
      "imports": [
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentChunk",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DocumentSearchResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChunkingOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ExtractedFact",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FactExtractionOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "extractDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "chunkDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDocumentChunks",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateChunkEmbeddings",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchDocuments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getFileTypeLabel",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatFileSize",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "listDocuments",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "extractDocumentFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDocumentFacts",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getDocumentFactStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "bulkUpdateFactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateFactContent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "SUPPORTED_EXTENSIONS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "StoredDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentListOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/documents.ts:fn:extractDocument:18",
        "file:web/src/lib/api/documents.ts:fn:chunkDocument:53",
        "file:web/src/lib/api/documents.ts:fn:getDocumentChunks:74",
        "file:web/src/lib/api/documents.ts:fn:generateChunkEmbeddings:84",
        "file:web/src/lib/api/documents.ts:fn:searchDocuments:95",
        "file:web/src/lib/api/documents.ts:fn:getFileTypeLabel:151",
        "file:web/src/lib/api/documents.ts:fn:formatFileSize:155",
        "file:web/src/lib/api/documents.ts:fn:listDocuments:202",
        "file:web/src/lib/api/documents.ts:fn:getDocument:227",
        "file:web/src/lib/api/documents.ts:fn:deleteDocument:236",
        "file:web/src/lib/api/documents.ts:fn:extractDocumentFacts:257",
        "file:web/src/lib/api/documents.ts:fn:getDocumentFacts:287",
        "file:web/src/lib/api/documents.ts:fn:getDocumentFactStats:321",
        "file:web/src/lib/api/documents.ts:fn:updateFactStatus:334",
        "file:web/src/lib/api/documents.ts:fn:bulkUpdateFactStatus:353",
        "file:web/src/lib/api/documents.ts:fn:updateFactContent:371"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/documents.ts:fn:extractDocument:18": {
      "id": "file:web/src/lib/api/documents.ts:fn:extractDocument:18",
      "type": "function",
      "name": "extractDocument",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 18,
      "endLine": 47,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "file",
          "type": "File",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxTextLength?: number; preservePageBreaks?: boolean; ocrLanguage?: string; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ objectId: string; extraction: ExtractedDocument; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Uploads file to API endpoint for document extraction via POST request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:18.996Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractDocument(\n  file: File,\n  options?: {\n    maxTextLength?: number;\n    preservePageBreaks?: boolean;\n    ocrLanguage?: string;\n  }\n): Promise<{ objectId: string; extraction: ExtractedDocument }> {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  const params = new URLSearchParams();\n  if (options?.maxTextLength) params.set('maxTextLength', String(options.maxTextLength));\n  if (options?.preservePageBreaks) params.set('preservePageBreaks', 'true');\n  if (options?.ocrLanguage) params.set('ocrLanguage', options.ocrLanguage);\n\n  const url = `${API_BASE}/extract${params.toString() ? `?${params.toString()}` : ''}`;\n\n  const response = await fetch(url, {\n    method: 'POST',\n    body: formData,\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: 'Upload failed' }));\n    throw new Error(error.error || 'Failed to extract document');\n  }\n\n  return response.json();\n}",
      "references": [
        "FormData",
        "formData",
        "URLSearchParams",
        "params",
        "String",
        "API_BASE",
        "fetch",
        "url",
        "response",
        "Error",
        "error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:chunkDocument:53": {
      "id": "file:web/src/lib/api/documents.ts:fn:chunkDocument:53",
      "type": "function",
      "name": "chunkDocument",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 53,
      "endLine": 69,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "ChunkingOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ chunks: DocumentChunk[]; totalTokens: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Chunks a document via API POST request and returns chunks with total tokens",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function chunkDocument(\n  objectId: string,\n  options?: ChunkingOptions\n): Promise<{ chunks: DocumentChunk[]; totalTokens: number }> {\n  const response = await fetch(`${API_BASE}/${objectId}/chunk`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(options || {}),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: 'Chunking failed' }));\n    throw new Error(error.error || 'Failed to chunk document');\n  }\n\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "Error",
        "error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:getDocumentChunks:74": {
      "id": "file:web/src/lib/api/documents.ts:fn:getDocumentChunks:74",
      "type": "function",
      "name": "getDocumentChunks",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 74,
      "endLine": 78,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ chunks: DocumentChunk[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches document chunks from API endpoint using objectId",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.074Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDocumentChunks(objectId: string): Promise<{ chunks: DocumentChunk[] }> {\n  const response = await fetch(`${API_BASE}/${objectId}/chunks`);\n  if (!response.ok) throw new Error('Failed to get chunks');\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:generateChunkEmbeddings:84": {
      "id": "file:web/src/lib/api/documents.ts:fn:generateChunkEmbeddings:84",
      "type": "function",
      "name": "generateChunkEmbeddings",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 84,
      "endLine": 90,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ embedded: number; failed: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "POST request to generate embeddings for document chunks via API",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.537Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function generateChunkEmbeddings(\n  objectId: string\n): Promise<{ embedded: number; failed: number }> {\n  const response = await fetch(`${API_BASE}/${objectId}/chunks/embed`, { method: 'POST' });\n  if (!response.ok) throw new Error('Failed to generate embeddings');\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:searchDocuments:95": {
      "id": "file:web/src/lib/api/documents.ts:fn:searchDocuments:95",
      "type": "function",
      "name": "searchDocuments",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 95,
      "endLine": 111,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; threshold?: number; objectIds?: string[]; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ results: DocumentSearchResult[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches documents via HTTP API using query and optional parameters.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.447Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchDocuments(\n  query: string,\n  options?: {\n    limit?: number;\n    threshold?: number;\n    objectIds?: string[];\n  }\n): Promise<{ results: DocumentSearchResult[] }> {\n  const params = new URLSearchParams({ query });\n  if (options?.limit) params.set('limit', String(options.limit));\n  if (options?.threshold) params.set('threshold', String(options.threshold));\n  if (options?.objectIds) params.set('objectIds', options.objectIds.join(','));\n\n  const response = await fetch(`${API_BASE}/search?${params.toString()}`);\n  if (!response.ok) throw new Error('Search failed');\n  return response.json();\n}",
      "references": [
        "URLSearchParams",
        "params",
        "String",
        "fetch",
        "API_BASE",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:getFileTypeLabel:151": {
      "id": "file:web/src/lib/api/documents.ts:fn:getFileTypeLabel:151",
      "type": "function",
      "name": "getFileTypeLabel",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 151,
      "endLine": 153,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a human-readable label for a given MIME type from a predefined map or 'Unknown'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.397Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getFileTypeLabel(mimeType: string): string {\n  return MIME_TYPE_MAP[mimeType] || 'Unknown';\n}",
      "references": [
        "MIME_TYPE_MAP"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:formatFileSize:155": {
      "id": "file:web/src/lib/api/documents.ts:fn:formatFileSize:155",
      "type": "function",
      "name": "formatFileSize",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 155,
      "endLine": 161,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "bytes",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats file size in bytes to human-readable string (e.g., '1.23 MB').",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.038Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatFileSize(bytes: number): string {\n  if (bytes === 0) return '0 Bytes';\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}",
      "references": [
        "Math",
        "k",
        "parseFloat",
        "i",
        "sizes"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:listDocuments:202": {
      "id": "file:web/src/lib/api/documents.ts:fn:listDocuments:202",
      "type": "function",
      "name": "listDocuments",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 202,
      "endLine": 222,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/documents\").DocumentListOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ documents: import(\"/home/ridgetop/projects/squire/web/src/lib/api/documents\").StoredDocument[]; count: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches list of documents from API with optional filters, search, and pagination",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.439Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function listDocuments(\n  options: DocumentListOptions = {}\n): Promise<{ documents: StoredDocument[]; count: number }> {\n  const params = new URLSearchParams({ type: 'document' });\n\n  if (options.status) params.set('status', options.status);\n  if (options.processingStatus) params.set('processingStatus', options.processingStatus);\n  if (options.tag) params.set('tag', options.tag);\n  if (options.search) params.set('search', options.search);\n  if (options.limit) params.set('limit', String(options.limit));\n  if (options.offset) params.set('offset', String(options.offset));\n\n  const response = await fetch(`/api/objects?${params.toString()}`);\n  if (!response.ok) throw new Error('Failed to list documents');\n\n  const data = await response.json();\n  return {\n    documents: data.objects as StoredDocument[],\n    count: data.count,\n  };\n}",
      "references": [
        "URLSearchParams",
        "params",
        "String",
        "fetch",
        "response",
        "Error",
        "data"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:getDocument:227": {
      "id": "file:web/src/lib/api/documents.ts:fn:getDocument:227",
      "type": "function",
      "name": "getDocument",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 227,
      "endLine": 231,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/documents\").StoredDocument>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a document by ID from the /api/objects endpoint.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.978Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDocument(id: string): Promise<StoredDocument> {\n  const response = await fetch(`/api/objects/${id}`);\n  if (!response.ok) throw new Error('Failed to get document');\n  return response.json();\n}",
      "references": [
        "fetch",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:deleteDocument:236": {
      "id": "file:web/src/lib/api/documents.ts:fn:deleteDocument:236",
      "type": "function",
      "name": "deleteDocument",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 236,
      "endLine": 239,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a document by ID via API DELETE request.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.739Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteDocument(id: string): Promise<void> {\n  const response = await fetch(`/api/objects/${id}`, { method: 'DELETE' });\n  if (!response.ok) throw new Error('Failed to delete document');\n}",
      "references": [
        "fetch",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:extractDocumentFacts:257": {
      "id": "file:web/src/lib/api/documents.ts:fn:extractDocumentFacts:257",
      "type": "function",
      "name": "extractDocumentFacts",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 257,
      "endLine": 282,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "FactExtractionOptions",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ success: boolean; batchId: string; objectId: string; chunksProcessed: number; factsExtracted: number; factsAutoApproved: number; totalDurationMs: number; errors?: string[]; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Makes POST request to API to extract facts from document and returns result",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.929Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function extractDocumentFacts(\n  objectId: string,\n  options?: FactExtractionOptions\n): Promise<{\n  success: boolean;\n  batchId: string;\n  objectId: string;\n  chunksProcessed: number;\n  factsExtracted: number;\n  factsAutoApproved: number;\n  totalDurationMs: number;\n  errors?: string[];\n}> {\n  const response = await fetch(`${API_BASE}/${objectId}/extract-facts`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(options || {}),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: 'Extraction failed' }));\n    throw new Error(error.error || 'Failed to extract facts');\n  }\n\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "Error",
        "error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:getDocumentFacts:287": {
      "id": "file:web/src/lib/api/documents.ts:fn:getDocumentFacts:287",
      "type": "function",
      "name": "getDocumentFacts",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 287,
      "endLine": 316,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ status?: any; factType?: any; minConfidence?: number; limit?: number; offset?: number; }",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ facts: ExtractedFact[]; count: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches document facts from API endpoint with optional filters (status, type, confidence, limit, offset)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.714Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDocumentFacts(\n  objectId: string,\n  options?: {\n    status?: FactStatus | FactStatus[];\n    factType?: FactType | FactType[];\n    minConfidence?: number;\n    limit?: number;\n    offset?: number;\n  }\n): Promise<{ facts: ExtractedFact[]; count: number }> {\n  const params = new URLSearchParams();\n\n  if (options?.status) {\n    const statuses = Array.isArray(options.status) ? options.status : [options.status];\n    params.set('status', statuses.join(','));\n  }\n  if (options?.factType) {\n    const types = Array.isArray(options.factType) ? options.factType : [options.factType];\n    params.set('factType', types.join(','));\n  }\n  if (options?.minConfidence) params.set('minConfidence', String(options.minConfidence));\n  if (options?.limit) params.set('limit', String(options.limit));\n  if (options?.offset) params.set('offset', String(options.offset));\n\n  const url = `${API_BASE}/${objectId}/facts${params.toString() ? `?${params.toString()}` : ''}`;\n  const response = await fetch(url);\n\n  if (!response.ok) throw new Error('Failed to get facts');\n  return response.json();\n}",
      "references": [
        "URLSearchParams",
        "Array",
        "params",
        "statuses",
        "types",
        "String",
        "API_BASE",
        "fetch",
        "url",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:getDocumentFactStats:321": {
      "id": "file:web/src/lib/api/documents.ts:fn:getDocumentFactStats:321",
      "type": "function",
      "name": "getDocumentFactStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 321,
      "endLine": 328,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "objectId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ hasBeenExtracted: boolean; stats: FactExtractionStats; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches document fact extraction stats via API for given object ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:20.877Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function getDocumentFactStats(objectId: string): Promise<{\n  hasBeenExtracted: boolean;\n  stats: FactExtractionStats;\n}> {\n  const response = await fetch(`${API_BASE}/${objectId}/facts/stats`);\n  if (!response.ok) throw new Error('Failed to get fact stats');\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:updateFactStatus:334": {
      "id": "file:web/src/lib/api/documents.ts:fn:updateFactStatus:334",
      "type": "function",
      "name": "updateFactStatus",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 334,
      "endLine": 348,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "FactStatus",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates fact status via PATCH API request and returns the updated fact",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:22.648Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateFactStatus(\n  factId: string,\n  status: FactStatus,\n  notes?: string\n): Promise<ExtractedFact> {\n  const response = await fetch(`${API_BASE}/facts/${factId}/status`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ status, notes }),\n  });\n\n  if (!response.ok) throw new Error('Failed to update fact status');\n  const data = await response.json();\n  return data.fact;\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "Error",
        "data"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:bulkUpdateFactStatus:353": {
      "id": "file:web/src/lib/api/documents.ts:fn:bulkUpdateFactStatus:353",
      "type": "function",
      "name": "bulkUpdateFactStatus",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 353,
      "endLine": 366,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "status",
          "type": "FactStatus",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<{ updatedCount: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Bulk updates fact statuses via POST API call and returns updated count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.875Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function bulkUpdateFactStatus(\n  factIds: string[],\n  status: FactStatus,\n  notes?: string\n): Promise<{ updatedCount: number }> {\n  const response = await fetch(`${API_BASE}/facts/bulk-status`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ factIds, status, notes }),\n  });\n\n  if (!response.ok) throw new Error('Failed to bulk update fact statuses');\n  return response.json();\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/documents.ts:fn:updateFactContent:371": {
      "id": "file:web/src/lib/api/documents.ts:fn:updateFactContent:371",
      "type": "function",
      "name": "updateFactContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/documents.ts",
      "line": 371,
      "endLine": 385,
      "parentFileId": "file:web/src/lib/api/documents.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "factId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "notes",
          "type": "string",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ExtractedFact>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates fact content via API PATCH request and returns the updated fact",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateFactContent(\n  factId: string,\n  content: string,\n  notes?: string\n): Promise<ExtractedFact> {\n  const response = await fetch(`${API_BASE}/facts/${factId}/content`, {\n    method: 'PATCH',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ content, notes }),\n  });\n\n  if (!response.ok) throw new Error('Failed to update fact content');\n  const data = await response.json();\n  return data.fact;\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "Error",
        "data"
      ]
    },
    "file:web/src/lib/api/entities.ts": {
      "id": "file:web/src/lib/api/entities.ts",
      "type": "file",
      "name": "entities.ts",
      "filePath": "web/src/lib/api/entities.ts",
      "line": 1,
      "endLine": 154,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityMemoryMention",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ConnectedEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchTopEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchEntityDetails",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FetchEntitiesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/entities.ts:fn:transformEntity:37",
        "file:web/src/lib/api/entities.ts:fn:transformEntityDetail:53",
        "file:web/src/lib/api/entities.ts:fn:fetchEntities:87",
        "file:web/src/lib/api/entities.ts:fn:fetchEntity:106",
        "file:web/src/lib/api/entities.ts:fn:searchEntities:114",
        "file:web/src/lib/api/entities.ts:fn:fetchTopEntities:127",
        "file:web/src/lib/api/entities.ts:fn:fetchEntityDetails:148"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/entities.ts:fn:transformEntity:37": {
      "id": "file:web/src/lib/api/entities.ts:fn:transformEntity:37",
      "type": "function",
      "name": "transformEntity",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 37,
      "endLine": 48,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backend",
          "type": "BackendEntity",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Entity",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms BackendEntity to Entity by mapping properties",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformEntity(backend: BackendEntity): Entity {\n  return {\n    id: backend.id,\n    name: backend.name,\n    type: backend.entity_type,\n    aliases: backend.aliases,\n    mention_count: backend.mention_count,\n    first_seen: backend.first_seen_at,\n    last_seen: backend.last_seen_at,\n    metadata: backend.attributes,\n  };\n}",
      "references": []
    },
    "file:web/src/lib/api/entities.ts:fn:transformEntityDetail:53": {
      "id": "file:web/src/lib/api/entities.ts:fn:transformEntityDetail:53",
      "type": "function",
      "name": "transformEntityDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 53,
      "endLine": 60,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backend",
          "type": "BackendEntityDetail",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "EntityDetail",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms BackendEntityDetail to EntityDetail using transformEntity and adding specific fields",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformEntityDetail(backend: BackendEntityDetail): EntityDetail {\n  return {\n    ...transformEntity(backend),\n    memories: backend.memories,\n    connected_entities: backend.connected_entities,\n    primary_relationship: backend.primary_relationship,\n  };\n}",
      "references": [
        "transformEntity"
      ]
    },
    "file:web/src/lib/api/entities.ts:fn:fetchEntities:87": {
      "id": "file:web/src/lib/api/entities.ts:fn:fetchEntities:87",
      "type": "function",
      "name": "fetchEntities",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 87,
      "endLine": 101,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/entities\").FetchEntitiesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ entities: Entity[]; counts: Record<EntityType, number>; total: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entities from API with optional type, limit, offset, search; transforms and returns with counts/total",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchEntities(options: FetchEntitiesOptions = {}): Promise<{\n  entities: Entity[];\n  counts: Record<EntityType, number>;\n  total: number;\n}> {\n  const { type, limit = 50, offset = 0, search } = options;\n  const response = await apiGet<EntitiesListResponse>('/api/entities', {\n    params: { type, limit, offset, search },\n  });\n  return {\n    entities: response.entities.map(transformEntity),\n    counts: response.counts,\n    total: response.total,\n  };\n}",
      "references": [
        "limit",
        "offset",
        "search",
        "apiGet",
        "response",
        "transformEntity"
      ]
    },
    "file:web/src/lib/api/entities.ts:fn:fetchEntity:106": {
      "id": "file:web/src/lib/api/entities.ts:fn:fetchEntity:106",
      "type": "function",
      "name": "fetchEntity",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 106,
      "endLine": 109,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Entity>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entity by ID from API and transforms to Entity type",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchEntity(id: string): Promise<Entity> {\n  const response = await apiGet<BackendEntity>(`/api/entities/${id}`);\n  return transformEntity(response);\n}",
      "references": [
        "apiGet",
        "transformEntity",
        "response"
      ]
    },
    "file:web/src/lib/api/entities.ts:fn:searchEntities:114": {
      "id": "file:web/src/lib/api/entities.ts:fn:searchEntities:114",
      "type": "function",
      "name": "searchEntities",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 114,
      "endLine": 122,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "type",
          "type": "EntityType",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Entity[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches entities by query and optional type via API GET, maps to transformed entities.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchEntities(\n  query: string,\n  type?: EntityType\n): Promise<Entity[]> {\n  const response = await apiGet<EntitySearchResponse>('/api/entities/search', {\n    params: { query, type },\n  });\n  return response.entities.map(transformEntity);\n}",
      "references": [
        "apiGet",
        "response",
        "transformEntity"
      ]
    },
    "file:web/src/lib/api/entities.ts:fn:fetchTopEntities:127": {
      "id": "file:web/src/lib/api/entities.ts:fn:fetchTopEntities:127",
      "type": "function",
      "name": "fetchTopEntities",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 127,
      "endLine": 143,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "12"
        }
      ],
      "returnType": "Promise<{ entities: Entity[]; counts: Record<EntityType, number>; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches top entities from API, transforms, sorts by mention count descending, returns with counts",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.481Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchTopEntities(limit = 12): Promise<{\n  entities: Entity[];\n  counts: Record<EntityType, number>;\n}> {\n  const response = await apiGet<EntitiesListResponse>('/api/entities', {\n    params: { limit },\n  });\n\n  // Transform and sort by mention count descending\n  const transformed = response.entities.map(transformEntity);\n  const sorted = transformed.sort((a, b) => b.mention_count - a.mention_count);\n\n  return {\n    entities: sorted,\n    counts: response.counts,\n  };\n}",
      "references": [
        "apiGet",
        "response",
        "transformEntity",
        "transformed",
        "b",
        "a",
        "sorted"
      ]
    },
    "file:web/src/lib/api/entities.ts:fn:fetchEntityDetails:148": {
      "id": "file:web/src/lib/api/entities.ts:fn:fetchEntityDetails:148",
      "type": "function",
      "name": "fetchEntityDetails",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/entities.ts",
      "line": 148,
      "endLine": 153,
      "parentFileId": "file:web/src/lib/api/entities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<EntityDetail>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entity details by ID via API and transforms response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchEntityDetails(id: string): Promise<EntityDetail> {\n  const response = await apiGet<BackendEntityDetail>(`/api/entities/${id}`, {\n    params: { include: 'full' },\n  });\n  return transformEntityDetail(response);\n}",
      "references": [
        "apiGet",
        "transformEntityDetail",
        "response"
      ]
    },
    "file:web/src/lib/api/graph.ts": {
      "id": "file:web/src/lib/api/graph.ts",
      "type": "file",
      "name": "graph.ts",
      "filePath": "web/src/lib/api/graph.ts",
      "line": 1,
      "endLine": 240,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "fetchGraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchEntitySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchMemorySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchEntityNeighbors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchGraphVisualization",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "toForceGraphData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "NodeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GraphNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SubgraphResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityNeighbor",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityNeighborsResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VisualizationOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VisualizationResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ForceGraphData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ForceGraphNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ForceGraphLink",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/graph.ts:fn:fetchGraphStats:68",
        "file:web/src/lib/api/graph.ts:fn:fetchEntitySubgraph:75",
        "file:web/src/lib/api/graph.ts:fn:fetchMemorySubgraph:92",
        "file:web/src/lib/api/graph.ts:fn:fetchEntityNeighbors:108",
        "file:web/src/lib/api/graph.ts:fn:fetchGraphVisualization:142",
        "file:web/src/lib/api/graph.ts:fn:toForceGraphData:220"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/graph.ts:fn:fetchGraphStats:68": {
      "id": "file:web/src/lib/api/graph.ts:fn:fetchGraphStats:68",
      "type": "function",
      "name": "fetchGraphStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 68,
      "endLine": 70,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").GraphStats>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches graph statistics from API endpoint '/api/graph/stats'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchGraphStats(): Promise<GraphStats> {\n  return apiGet<GraphStats>('/api/graph/stats');\n}",
      "references": [
        "apiGet"
      ]
    },
    "file:web/src/lib/api/graph.ts:fn:fetchEntitySubgraph:75": {
      "id": "file:web/src/lib/api/graph.ts:fn:fetchEntitySubgraph:75",
      "type": "function",
      "name": "fetchEntitySubgraph",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 75,
      "endLine": 87,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ memoryLimit?: number; entityLimit?: number; includeEdges?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").SubgraphResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches entity subgraph from API with memory/entity limits and edge option.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchEntitySubgraph(\n  entityId: string,\n  options: {\n    memoryLimit?: number;\n    entityLimit?: number;\n    includeEdges?: boolean;\n  } = {}\n): Promise<SubgraphResponse> {\n  const { memoryLimit = 20, entityLimit = 10, includeEdges = true } = options;\n  return apiGet<SubgraphResponse>(`/api/graph/entities/${entityId}/subgraph`, {\n    params: { memoryLimit, entityLimit, includeEdges },\n  });\n}",
      "references": [
        "memoryLimit",
        "entityLimit",
        "includeEdges",
        "apiGet"
      ]
    },
    "file:web/src/lib/api/graph.ts:fn:fetchMemorySubgraph:92": {
      "id": "file:web/src/lib/api/graph.ts:fn:fetchMemorySubgraph:92",
      "type": "function",
      "name": "fetchMemorySubgraph",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 92,
      "endLine": 103,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ maxHops?: number; includeEntities?: boolean; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").SubgraphResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches memory subgraph via API with max hops and entity options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchMemorySubgraph(\n  memoryId: string,\n  options: {\n    maxHops?: number;\n    includeEntities?: boolean;\n  } = {}\n): Promise<SubgraphResponse> {\n  const { maxHops = 1, includeEntities = true } = options;\n  return apiGet<SubgraphResponse>(`/api/graph/memories/${memoryId}/subgraph`, {\n    params: { maxHops, includeEntities },\n  });\n}",
      "references": [
        "maxHops",
        "includeEntities",
        "apiGet"
      ]
    },
    "file:web/src/lib/api/graph.ts:fn:fetchEntityNeighbors:108": {
      "id": "file:web/src/lib/api/graph.ts:fn:fetchEntityNeighbors:108",
      "type": "function",
      "name": "fetchEntityNeighbors",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 108,
      "endLine": 120,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minShared?: number; type?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").EntityNeighborsResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches neighboring entities for given entity ID via API with limit, minShared, and type options",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchEntityNeighbors(\n  entityId: string,\n  options: {\n    limit?: number;\n    minShared?: number;\n    type?: string;\n  } = {}\n): Promise<EntityNeighborsResponse> {\n  const { limit = 20, minShared = 1, type } = options;\n  return apiGet<EntityNeighborsResponse>(`/api/graph/entities/${entityId}/neighbors`, {\n    params: { limit, minShared, type },\n  });\n}",
      "references": [
        "limit",
        "minShared",
        "apiGet"
      ]
    },
    "file:web/src/lib/api/graph.ts:fn:fetchGraphVisualization:142": {
      "id": "file:web/src/lib/api/graph.ts:fn:fetchGraphVisualization:142",
      "type": "function",
      "name": "fetchGraphVisualization",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 142,
      "endLine": 167,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").VisualizationOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").VisualizationResponse>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches graph visualization data from API using provided options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchGraphVisualization(\n  options: VisualizationOptions = {}\n): Promise<VisualizationResponse> {\n  const {\n    nodeLimit = 100,\n    entityLimit = 30,\n    memoryLimit = 70,\n    minSalience = 0,\n    entityTypes,\n    includeEdges = true,\n  } = options;\n\n  const params: Record<string, string | number | boolean> = {\n    nodeLimit,\n    entityLimit,\n    memoryLimit,\n    minSalience,\n    includeEdges,\n  };\n\n  if (entityTypes && entityTypes.length > 0) {\n    params.entityTypes = entityTypes.join(',');\n  }\n\n  return apiGet<VisualizationResponse>('/api/graph/visualization', { params });\n}",
      "references": [
        "nodeLimit",
        "entityLimit",
        "memoryLimit",
        "minSalience",
        "entityTypes",
        "includeEdges",
        "params",
        "apiGet"
      ]
    },
    "file:web/src/lib/api/graph.ts:fn:toForceGraphData:220": {
      "id": "file:web/src/lib/api/graph.ts:fn:toForceGraphData:220",
      "type": "function",
      "name": "toForceGraphData",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/graph.ts",
      "line": 220,
      "endLine": 239,
      "parentFileId": "file:web/src/lib/api/graph.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subgraph",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").SubgraphResponse",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/graph\").ForceGraphData",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms SubgraphResponse into ForceGraphData by mapping nodes and edges.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function toForceGraphData(subgraph: SubgraphResponse): ForceGraphData {\n  const nodes: ForceGraphNode[] = subgraph.nodes.map((node) => ({\n    id: node.id,\n    type: node.type,\n    label: node.label,\n    val: node.type === 'entity' ? 8 : 4, // Entities are larger\n    color: NODE_COLORS[node.type],\n    attributes: node.attributes,\n  }));\n\n  const links: ForceGraphLink[] = subgraph.edges.map((edge) => ({\n    source: edge.source,\n    target: edge.target,\n    type: edge.type,\n    weight: edge.weight,\n    color: EDGE_COLORS[edge.type] || EDGE_COLORS.default,\n  }));\n\n  return { nodes, links };\n}",
      "references": [
        "node",
        "NODE_COLORS",
        "edge",
        "EDGE_COLORS",
        "nodes",
        "links"
      ]
    },
    "file:web/src/lib/api/insights.ts": {
      "id": "file:web/src/lib/api/insights.ts",
      "type": "file",
      "name": "insights.ts",
      "filePath": "web/src/lib/api/insights.ts",
      "line": 1,
      "endLine": 146,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchInsight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchInsightStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchInsightsByType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchNewInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FetchInsightsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/insights.ts:fn:mapInsightStatus:33",
        "file:web/src/lib/api/insights.ts:fn:transformInsight:51",
        "file:web/src/lib/api/insights.ts:fn:fetchInsights:96",
        "file:web/src/lib/api/insights.ts:fn:fetchInsight:115",
        "file:web/src/lib/api/insights.ts:fn:fetchInsightStats:123",
        "file:web/src/lib/api/insights.ts:fn:fetchInsightsByType:131",
        "file:web/src/lib/api/insights.ts:fn:fetchNewInsights:139"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/insights.ts:fn:mapInsightStatus:33": {
      "id": "file:web/src/lib/api/insights.ts:fn:mapInsightStatus:33",
      "type": "function",
      "name": "mapInsightStatus",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 33,
      "endLine": 46,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backendStatus",
          "type": "BackendInsightStatus",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "InsightStatus",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps backend insight status to frontend insight status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function mapInsightStatus(backendStatus: BackendInsightStatus): InsightStatus {\n  switch (backendStatus) {\n    case 'active':\n      return 'new';\n    case 'stale':\n      return 'reviewed';\n    case 'actioned':\n      return 'actioned';\n    case 'dismissed':\n      return 'dismissed';\n    default:\n      return 'new';\n  }\n}",
      "references": []
    },
    "file:web/src/lib/api/insights.ts:fn:transformInsight:51": {
      "id": "file:web/src/lib/api/insights.ts:fn:transformInsight:51",
      "type": "function",
      "name": "transformInsight",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 51,
      "endLine": 61,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backend",
          "type": "BackendInsight",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Insight",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms BackendInsight to Insight object with mapped status and empty sources.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformInsight(backend: BackendInsight): Insight {\n  return {\n    id: backend.id,\n    content: backend.content,\n    type: backend.insight_type,\n    priority: backend.priority,\n    status: mapInsightStatus(backend.status),\n    source_memories: [], // Sources fetched separately via /api/insights/:id/sources\n    created_at: backend.created_at,\n  };\n}",
      "references": [
        "mapInsightStatus"
      ]
    },
    "file:web/src/lib/api/insights.ts:fn:fetchInsights:96": {
      "id": "file:web/src/lib/api/insights.ts:fn:fetchInsights:96",
      "type": "function",
      "name": "fetchInsights",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 96,
      "endLine": 110,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/insights\").FetchInsightsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insights from API with filters (type,status,priority,confidence,limit) and transforms them",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchInsights(options: FetchInsightsOptions = {}): Promise<Insight[]> {\n  const { type, status, priority, minConfidence, limit = 50 } = options;\n  // Map frontend status to backend status for filtering\n  const backendStatus = status === 'new' ? 'active' : status === 'reviewed' ? 'stale' : status;\n  const response = await apiGet<InsightsListResponse>('/api/insights', {\n    params: {\n      type,\n      status: backendStatus,\n      priority,\n      minConfidence,\n      limit,\n    },\n  });\n  return response.insights.map(transformInsight);\n}",
      "references": [
        "status",
        "priority",
        "minConfidence",
        "limit",
        "apiGet",
        "backendStatus",
        "response",
        "transformInsight"
      ]
    },
    "file:web/src/lib/api/insights.ts:fn:fetchInsight:115": {
      "id": "file:web/src/lib/api/insights.ts:fn:fetchInsight:115",
      "type": "function",
      "name": "fetchInsight",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 115,
      "endLine": 118,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Insight>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insight by ID via API and transforms response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchInsight(id: string): Promise<Insight> {\n  const response = await apiGet<InsightResponse>(`/api/insights/${id}`);\n  return transformInsight(response.insight);\n}",
      "references": [
        "apiGet",
        "transformInsight",
        "response"
      ]
    },
    "file:web/src/lib/api/insights.ts:fn:fetchInsightStats:123": {
      "id": "file:web/src/lib/api/insights.ts:fn:fetchInsightStats:123",
      "type": "function",
      "name": "fetchInsightStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 123,
      "endLine": 126,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; byType: Record<InsightType, number>; byPriority: Record<InsightPriority, number>; byStatus: Record<InsightStatus, number>; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insight stats from '/api/insights/stats' endpoint",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchInsightStats(): Promise<InsightStatsResponse['stats']> {\n  const response = await apiGet<InsightStatsResponse>('/api/insights/stats');\n  return response.stats;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/insights.ts:fn:fetchInsightsByType:131": {
      "id": "file:web/src/lib/api/insights.ts:fn:fetchInsightsByType:131",
      "type": "function",
      "name": "fetchInsightsByType",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 131,
      "endLine": 134,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "InsightType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches insights by type via API and transforms them into Insight array",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchInsightsByType(type: InsightType): Promise<Insight[]> {\n  const response = await apiGet<InsightsListResponse>(`/api/insights/type/${type}`);\n  return response.insights.map(transformInsight);\n}",
      "references": [
        "apiGet",
        "response",
        "transformInsight"
      ]
    },
    "file:web/src/lib/api/insights.ts:fn:fetchNewInsights:139": {
      "id": "file:web/src/lib/api/insights.ts:fn:fetchNewInsights:139",
      "type": "function",
      "name": "fetchNewInsights",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/insights.ts",
      "line": 139,
      "endLine": 145,
      "parentFileId": "file:web/src/lib/api/insights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "6"
        }
      ],
      "returnType": "Promise<Insight[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches active insights from API with limit and transforms them",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:19.482Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchNewInsights(limit = 6): Promise<Insight[]> {\n  // Backend uses 'active' for what frontend calls 'new'\n  const response = await apiGet<InsightsListResponse>('/api/insights', {\n    params: { status: 'active', limit },\n  });\n  return response.insights.map(transformInsight);\n}",
      "references": [
        "apiGet",
        "response",
        "transformInsight"
      ]
    },
    "file:web/src/lib/api/lists.ts": {
      "id": "file:web/src/lib/api/lists.ts",
      "type": "file",
      "name": "lists.ts",
      "filePath": "web/src/lib/api/lists.ts",
      "line": 1,
      "endLine": 189,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPatch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiDelete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListWithItems",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListItem",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateListInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateListItemInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchLists",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchListWithItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "completeAllItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearCompletedItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "reorderItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "addItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "toggleItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportList",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportAllLists",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/api/lists.ts:fn:fetchLists:30",
        "file:web/src/lib/api/lists.ts:fn:fetchListWithItems:46",
        "file:web/src/lib/api/lists.ts:fn:createList:53",
        "file:web/src/lib/api/lists.ts:fn:updateList:60",
        "file:web/src/lib/api/lists.ts:fn:archiveList:70",
        "file:web/src/lib/api/lists.ts:fn:deleteList:77",
        "file:web/src/lib/api/lists.ts:fn:completeAllItems:84",
        "file:web/src/lib/api/lists.ts:fn:clearCompletedItems:91",
        "file:web/src/lib/api/lists.ts:fn:reorderItems:98",
        "file:web/src/lib/api/lists.ts:fn:addItem:112",
        "file:web/src/lib/api/lists.ts:fn:updateItem:125",
        "file:web/src/lib/api/lists.ts:fn:deleteItem:139",
        "file:web/src/lib/api/lists.ts:fn:toggleItem:146",
        "file:web/src/lib/api/lists.ts:fn:exportList:156",
        "file:web/src/lib/api/lists.ts:fn:exportAllLists:170"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/lists.ts:fn:fetchLists:30": {
      "id": "file:web/src/lib/api/lists.ts:fn:fetchLists:30",
      "type": "function",
      "name": "fetchLists",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 30,
      "endLine": 41,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "ListListOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<List[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches lists from API with optional params for filtering and pagination",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:22.278Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchLists(options: ListListOptions = {}): Promise<List[]> {\n  const params: Record<string, string | number | boolean | undefined> = {};\n  if (options.category) params.category = options.category;\n  if (options.entity_id) params.entity_id = options.entity_id;\n  if (options.is_pinned !== undefined) params.is_pinned = options.is_pinned;\n  if (options.list_type) params.list_type = options.list_type;\n  if (options.limit) params.limit = options.limit;\n  if (options.offset) params.offset = options.offset;\n\n  const response = await apiGet<{ lists: List[] }>('/api/lists', { params });\n  return response.lists;\n}",
      "references": [
        "params",
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:fetchListWithItems:46": {
      "id": "file:web/src/lib/api/lists.ts:fn:fetchListWithItems:46",
      "type": "function",
      "name": "fetchListWithItems",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 46,
      "endLine": 48,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ListWithItems>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a list with items by ID via API GET request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.925Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchListWithItems(id: string): Promise<ListWithItems> {\n  return apiGet<ListWithItems>(`/api/lists/${id}`, { params: { items: true } });\n}",
      "references": [
        "apiGet"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:createList:53": {
      "id": "file:web/src/lib/api/lists.ts:fn:createList:53",
      "type": "function",
      "name": "createList",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 53,
      "endLine": 55,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "CreateListInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Creates a list by POSTing CreateListInput to /api/lists endpoint",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:22.569Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createList(input: CreateListInput): Promise<List> {\n  return apiPost<List, CreateListInput>('/api/lists', input);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:updateList:60": {
      "id": "file:web/src/lib/api/lists.ts:fn:updateList:60",
      "type": "function",
      "name": "updateList",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 60,
      "endLine": 65,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "CreateListInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<List>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates a list via PATCH API call using ID and partial input.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.205Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateList(\n  id: string,\n  input: Partial<CreateListInput>\n): Promise<List> {\n  return apiPatch<List, Partial<CreateListInput>>(`/api/lists/${id}`, input);\n}",
      "references": [
        "apiPatch"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:archiveList:70": {
      "id": "file:web/src/lib/api/lists.ts:fn:archiveList:70",
      "type": "function",
      "name": "archiveList",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 70,
      "endLine": 72,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a list by ID via API POST request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveList(id: string): Promise<void> {\n  await apiPost<void>(`/api/lists/${id}/archive`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:deleteList:77": {
      "id": "file:web/src/lib/api/lists.ts:fn:deleteList:77",
      "type": "function",
      "name": "deleteList",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 77,
      "endLine": 79,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a list by ID via API DELETE request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.015Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteList(id: string): Promise<void> {\n  await apiDelete<void>(`/api/lists/${id}`);\n}",
      "references": [
        "apiDelete"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:completeAllItems:84": {
      "id": "file:web/src/lib/api/lists.ts:fn:completeAllItems:84",
      "type": "function",
      "name": "completeAllItems",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 84,
      "endLine": 86,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Posts to API to complete all items in a list by ID",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function completeAllItems(listId: string): Promise<void> {\n  await apiPost<void>(`/api/lists/${listId}/complete-all`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:clearCompletedItems:91": {
      "id": "file:web/src/lib/api/lists.ts:fn:clearCompletedItems:91",
      "type": "function",
      "name": "clearCompletedItems",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 91,
      "endLine": 93,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Clears completed items from a list via API POST request.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.743Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function clearCompletedItems(listId: string): Promise<void> {\n  await apiPost<void>(`/api/lists/${listId}/clear-completed`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:reorderItems:98": {
      "id": "file:web/src/lib/api/lists.ts:fn:reorderItems:98",
      "type": "function",
      "name": "reorderItems",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 98,
      "endLine": 103,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "itemIds",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends POST request to reorder items in a list by item IDs",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.552Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function reorderItems(\n  listId: string,\n  itemIds: string[]\n): Promise<void> {\n  await apiPost<void>(`/api/lists/${listId}/reorder`, { item_ids: itemIds });\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:addItem:112": {
      "id": "file:web/src/lib/api/lists.ts:fn:addItem:112",
      "type": "function",
      "name": "addItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 112,
      "endLine": 120,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "CreateListItemInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Posts a new list item to the API endpoint `/api/lists/${listId}/items`.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.612Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function addItem(\n  listId: string,\n  input: CreateListItemInput\n): Promise<ListItem> {\n  return apiPost<ListItem, CreateListItemInput>(\n    `/api/lists/${listId}/items`,\n    input\n  );\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:updateItem:125": {
      "id": "file:web/src/lib/api/lists.ts:fn:updateItem:125",
      "type": "function",
      "name": "updateItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 125,
      "endLine": 134,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "CreateListItemInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates a list item via PATCH API request.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateItem(\n  listId: string,\n  itemId: string,\n  input: Partial<CreateListItemInput>\n): Promise<ListItem> {\n  return apiPatch<ListItem, Partial<CreateListItemInput>>(\n    `/api/lists/${listId}/items/${itemId}`,\n    input\n  );\n}",
      "references": [
        "apiPatch"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:deleteItem:139": {
      "id": "file:web/src/lib/api/lists.ts:fn:deleteItem:139",
      "type": "function",
      "name": "deleteItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 139,
      "endLine": 141,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a specific item from a list via API DELETE request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.039Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteItem(listId: string, itemId: string): Promise<void> {\n  await apiDelete<void>(`/api/lists/${listId}/items/${itemId}`);\n}",
      "references": [
        "apiDelete"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:toggleItem:146": {
      "id": "file:web/src/lib/api/lists.ts:fn:toggleItem:146",
      "type": "function",
      "name": "toggleItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 146,
      "endLine": 151,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "listId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "itemId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<ListItem>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Toggles a list item by making a POST request to the API endpoint.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function toggleItem(\n  listId: string,\n  itemId: string\n): Promise<ListItem> {\n  return apiPost<ListItem>(`/api/lists/${listId}/items/${itemId}/toggle`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:exportList:156": {
      "id": "file:web/src/lib/api/lists.ts:fn:exportList:156",
      "type": "function",
      "name": "exportList",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 156,
      "endLine": 165,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "format",
          "type": "\"txt\" | \"json\" | \"markdown\" | \"csv\"",
          "isOptional": true,
          "defaultValue": "'markdown'"
        }
      ],
      "returnType": "Promise<Blob>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches and returns a Blob of the list export in specified format.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.321Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportList(\n  id: string,\n  format: 'json' | 'markdown' | 'csv' | 'txt' = 'markdown'\n): Promise<Blob> {\n  const response = await fetch(`/api/lists/${id}/export?format=${format}`);\n  if (!response.ok) {\n    throw new Error('Failed to export list');\n  }\n  return response.blob();\n}",
      "references": [
        "fetch",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/lists.ts:fn:exportAllLists:170": {
      "id": "file:web/src/lib/api/lists.ts:fn:exportAllLists:170",
      "type": "function",
      "name": "exportAllLists",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/lists.ts",
      "line": 170,
      "endLine": 188,
      "parentFileId": "file:web/src/lib/api/lists.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "format",
          "type": "\"json\" | \"markdown\" | \"csv\"",
          "isOptional": true,
          "defaultValue": "'markdown'"
        },
        {
          "name": "options",
          "type": "{ entity_id?: string; category?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Blob>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Exports all lists in specified format via API, returns Blob.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:22.886Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportAllLists(\n  format: 'json' | 'markdown' | 'csv' = 'markdown',\n  options: { entity_id?: string; category?: string } = {}\n): Promise<Blob> {\n  const params: Record<string, string | undefined> = {\n    format,\n    ...options,\n  };\n\n  const response = await fetch(\n    `/api/lists/export?${new URLSearchParams(params as Record<string, string>).toString()}`\n  );\n\n  if (!response.ok) {\n    throw new Error('Failed to export lists');\n  }\n\n  return response.blob();\n}",
      "references": [
        "fetch",
        "URLSearchParams",
        "params",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/memories.ts": {
      "id": "file:web/src/lib/api/memories.ts",
      "type": "file",
      "name": "memories.ts",
      "filePath": "web/src/lib/api/memories.ts",
      "line": 1,
      "endLine": 239,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchMemoriesPage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchRecentHighSalienceMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "searchMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchMemoriesByIds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "memoryToScoredMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FetchMemoriesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoriesPage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/memories.ts:fn:getCachedMemory:16",
        "file:web/src/lib/api/memories.ts:fn:setCachedMemory:26",
        "file:web/src/lib/api/memories.ts:fn:transformMemory:44",
        "file:web/src/lib/api/memories.ts:fn:fetchMemories:87",
        "file:web/src/lib/api/memories.ts:fn:fetchMemoriesPage:104",
        "file:web/src/lib/api/memories.ts:fn:fetchRecentHighSalienceMemories:126",
        "file:web/src/lib/api/memories.ts:fn:fetchMemory:154",
        "file:web/src/lib/api/memories.ts:fn:searchMemories:162",
        "file:web/src/lib/api/memories.ts:fn:fetchMemoriesByIds:181",
        "file:web/src/lib/api/memories.ts:fn:memoryToScoredMemory:226"
      ],
      "classes": [],
      "topLevelReferences": [
        "Map"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:getCachedMemory:16": {
      "id": "file:web/src/lib/api/memories.ts:fn:getCachedMemory:16",
      "type": "function",
      "name": "getCachedMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 16,
      "endLine": 24,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "any",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves cached memory by ID if not expired, else deletes cache entries and returns null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function getCachedMemory(id: string): Memory | null {\n  const timestamp = cacheTimestamps.get(id);\n  if (!timestamp || Date.now() - timestamp > CACHE_TTL) {\n    memoryCache.delete(id);\n    cacheTimestamps.delete(id);\n    return null;\n  }\n  return memoryCache.get(id) ?? null;\n}",
      "references": [
        "cacheTimestamps",
        "timestamp",
        "Date",
        "CACHE_TTL",
        "memoryCache"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:setCachedMemory:26": {
      "id": "file:web/src/lib/api/memories.ts:fn:setCachedMemory:26",
      "type": "function",
      "name": "setCachedMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 26,
      "endLine": 29,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "Memory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Caches a memory object by ID and sets its timestamp in global caches.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function setCachedMemory(memory: Memory): void {\n  memoryCache.set(memory.id, memory);\n  cacheTimestamps.set(memory.id, Date.now());\n}",
      "references": [
        "memoryCache",
        "cacheTimestamps",
        "Date"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:transformMemory:44": {
      "id": "file:web/src/lib/api/memories.ts:fn:transformMemory:44",
      "type": "function",
      "name": "transformMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 44,
      "endLine": 53,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "apiMemory",
          "type": "ApiMemory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Memory",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms ApiMemory to Memory by mapping and renaming fields.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformMemory(apiMemory: ApiMemory): Memory {\n  return {\n    id: apiMemory.id,\n    content: apiMemory.content,\n    source: apiMemory.source as Memory['source'],\n    salience: apiMemory.salience_score ?? 0,  // Map salience_score -> salience\n    created_at: apiMemory.created_at,\n    updated_at: apiMemory.occurred_at ?? apiMemory.created_at,  // Use occurred_at or fallback to created_at\n  };\n}",
      "references": []
    },
    "file:web/src/lib/api/memories.ts:fn:fetchMemories:87": {
      "id": "file:web/src/lib/api/memories.ts:fn:fetchMemories:87",
      "type": "function",
      "name": "fetchMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 87,
      "endLine": 99,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/memories\").FetchMemoriesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<{ memories: Memory[]; total: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches memories from API with limit, offset, and optional source filter",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchMemories(options: FetchMemoriesOptions = {}): Promise<{\n  memories: Memory[];\n  total: number;\n}> {\n  const { limit = 50, offset = 0, source } = options;\n  const response = await apiGet<MemoriesListResponse>('/api/memories', {\n    params: { limit, offset, source },\n  });\n  return {\n    memories: response.memories.map(transformMemory),\n    total: response.total,\n  };\n}",
      "references": [
        "limit",
        "offset",
        "source",
        "apiGet",
        "response",
        "transformMemory"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:fetchMemoriesPage:104": {
      "id": "file:web/src/lib/api/memories.ts:fn:fetchMemoriesPage:104",
      "type": "function",
      "name": "fetchMemoriesPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 104,
      "endLine": 120,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/memories\").FetchMemoriesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<import(\"/home/ridgetop/projects/squire/web/src/lib/api/memories\").MemoriesPage>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches paginated memories from API with options, transforms, and computes pagination metadata.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchMemoriesPage(options: FetchMemoriesOptions = {}): Promise<MemoriesPage> {\n  const { limit = 30, offset = 0, source } = options;\n  const response = await apiGet<MemoriesListResponse>('/api/memories', {\n    params: { limit, offset, source },\n  });\n\n  const hasMore = offset + response.memories.length < response.total;\n\n  return {\n    memories: response.memories.map(transformMemory),\n    total: response.total,\n    offset,\n    limit,\n    hasMore,\n    nextOffset: hasMore ? offset + limit : null,\n  };\n}",
      "references": [
        "limit",
        "offset",
        "source",
        "apiGet",
        "response",
        "transformMemory",
        "hasMore"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:fetchRecentHighSalienceMemories:126": {
      "id": "file:web/src/lib/api/memories.ts:fn:fetchRecentHighSalienceMemories:126",
      "type": "function",
      "name": "fetchRecentHighSalienceMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 126,
      "endLine": 149,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "10"
        }
      ],
      "returnType": "Promise<Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches recent memories via API, sorts by salience/recency descending, returns top limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchRecentHighSalienceMemories(\n  limit = 10\n): Promise<Memory[]> {\n  // Fetch more than needed to filter for high salience\n  const response = await apiGet<MemoriesListResponse>('/api/memories', {\n    params: { limit: limit * 3, offset: 0 },\n  });\n\n  // Transform to frontend type\n  const memories = response.memories.map(transformMemory);\n\n  // Sort by salience (descending) then by recency (descending)\n  const sorted = memories.sort((a, b) => {\n    // Primary: salience score\n    if (b.salience !== a.salience) {\n      return b.salience - a.salience;\n    }\n    // Secondary: recency\n    return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();\n  });\n\n  // Return top N\n  return sorted.slice(0, limit);\n}",
      "references": [
        "apiGet",
        "response",
        "transformMemory",
        "memories",
        "b",
        "a",
        "Date",
        "sorted"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:fetchMemory:154": {
      "id": "file:web/src/lib/api/memories.ts:fn:fetchMemory:154",
      "type": "function",
      "name": "fetchMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 154,
      "endLine": 157,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Memory>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a memory by ID from API and transforms response",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchMemory(id: string): Promise<Memory> {\n  const response = await apiGet<ApiMemory>(`/api/memories/${id}`);\n  return transformMemory(response);\n}",
      "references": [
        "apiGet",
        "transformMemory",
        "response"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:searchMemories:162": {
      "id": "file:web/src/lib/api/memories.ts:fn:searchMemories:162",
      "type": "function",
      "name": "searchMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 162,
      "endLine": 171,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSimilarity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Searches memories via API using query, limit, and min similarity; returns transformed results.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.701Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function searchMemories(\n  query: string,\n  options: { limit?: number; minSimilarity?: number } = {}\n): Promise<Memory[]> {\n  const { limit = 10, minSimilarity = 0.3 } = options;\n  const response = await apiGet<MemorySearchResponse>('/api/memories/search', {\n    params: { query, limit, min_similarity: minSimilarity },\n  });\n  return response.results.map(transformMemory);\n}",
      "references": [
        "limit",
        "minSimilarity",
        "apiGet",
        "response",
        "transformMemory"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:fetchMemoriesByIds:181": {
      "id": "file:web/src/lib/api/memories.ts:fn:fetchMemoriesByIds:181",
      "type": "function",
      "name": "fetchMemoriesByIds",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 181,
      "endLine": 220,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "ids",
          "type": "string[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Memory[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches memories by IDs from cache or API, caches misses in parallel, returns in order.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.702Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchMemoriesByIds(ids: string[]): Promise<Memory[]> {\n  if (ids.length === 0) return [];\n\n  const results: Map<string, Memory> = new Map();\n  const idsToFetch: string[] = [];\n\n  // Check cache first\n  for (const id of ids) {\n    const cached = getCachedMemory(id);\n    if (cached) {\n      results.set(id, cached);\n    } else {\n      idsToFetch.push(id);\n    }\n  }\n\n  // Fetch missing ones in parallel\n  if (idsToFetch.length > 0) {\n    const fetchPromises = idsToFetch.map(async (id) => {\n      try {\n        const memory = await fetchMemory(id);\n        setCachedMemory(memory);\n        return memory;\n      } catch (error) {\n        console.warn(`Failed to fetch memory ${id}:`, error);\n        return null;\n      }\n    });\n\n    const fetched = await Promise.all(fetchPromises);\n    fetched.forEach((memory) => {\n      if (memory) {\n        results.set(memory.id, memory);\n      }\n    });\n  }\n\n  // Return in original order, filtering out any that failed\n  return ids.map((id) => results.get(id)).filter((m): m is Memory => m != null);\n}",
      "references": [
        "Map",
        "getCachedMemory",
        "id",
        "cached",
        "results",
        "idsToFetch",
        "fetchMemory",
        "setCachedMemory",
        "memory",
        "console",
        "error",
        "Promise",
        "fetchPromises",
        "fetched",
        "m"
      ]
    },
    "file:web/src/lib/api/memories.ts:fn:memoryToScoredMemory:226": {
      "id": "file:web/src/lib/api/memories.ts:fn:memoryToScoredMemory:226",
      "type": "function",
      "name": "memoryToScoredMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/memories.ts",
      "line": 226,
      "endLine": 238,
      "parentFileId": "file:web/src/lib/api/memories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "Memory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "ScoredMemory",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms Memory to ScoredMemory with hardcoded scores and token estimate",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.702Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function memoryToScoredMemory(memory: Memory): ScoredMemory {\n  return {\n    id: memory.id,\n    content: memory.content,\n    created_at: memory.created_at,\n    salience_score: memory.salience,\n    current_strength: 1,\n    recency_score: 1,\n    final_score: memory.salience,\n    token_estimate: Math.ceil(memory.content.length / 4),\n    category: 'relevant' as const,\n  };\n}",
      "references": [
        "Math"
      ]
    },
    "file:web/src/lib/api/notes.ts": {
      "id": "file:web/src/lib/api/notes.ts",
      "type": "file",
      "name": "notes.ts",
      "filePath": "web/src/lib/api/notes.ts",
      "line": 1,
      "endLine": 104,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPost",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiPatch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "apiDelete",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "UpdateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListNotesOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchPinnedNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "archiveNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "deleteNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "pinNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "unpinNote",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportNotes",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/api/notes.ts:fn:fetchNotes:20",
        "file:web/src/lib/api/notes.ts:fn:fetchPinnedNotes:35",
        "file:web/src/lib/api/notes.ts:fn:createNote:43",
        "file:web/src/lib/api/notes.ts:fn:updateNote:50",
        "file:web/src/lib/api/notes.ts:fn:archiveNote:57",
        "file:web/src/lib/api/notes.ts:fn:deleteNote:64",
        "file:web/src/lib/api/notes.ts:fn:pinNote:71",
        "file:web/src/lib/api/notes.ts:fn:unpinNote:78",
        "file:web/src/lib/api/notes.ts:fn:exportNotes:85"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/notes.ts:fn:fetchNotes:20": {
      "id": "file:web/src/lib/api/notes.ts:fn:fetchNotes:20",
      "type": "function",
      "name": "fetchNotes",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 20,
      "endLine": 30,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "ListNotesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Note[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches notes from API endpoint with optional filters (category, entity_id, pinned, limit, offset)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:21.702Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchNotes(options: ListNotesOptions = {}): Promise<Note[]> {\n  const params: Record<string, string | number | boolean | undefined> = {};\n  if (options.category) params.category = options.category;\n  if (options.entity_id) params.entity_id = options.entity_id;\n  if (options.is_pinned !== undefined) params.is_pinned = options.is_pinned;\n  if (options.limit) params.limit = options.limit;\n  if (options.offset) params.offset = options.offset;\n\n  const response = await apiGet<{ notes: Note[] }>('/api/notes', { params });\n  return response.notes;\n}",
      "references": [
        "params",
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:fetchPinnedNotes:35": {
      "id": "file:web/src/lib/api/notes.ts:fn:fetchPinnedNotes:35",
      "type": "function",
      "name": "fetchPinnedNotes",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 35,
      "endLine": 38,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<Note[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pinned notes from the API endpoint '/api/notes/pinned'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.097Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchPinnedNotes(): Promise<Note[]> {\n  const response = await apiGet<{ notes: Note[] }>('/api/notes/pinned');\n  return response.notes;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:createNote:43": {
      "id": "file:web/src/lib/api/notes.ts:fn:createNote:43",
      "type": "function",
      "name": "createNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 43,
      "endLine": 45,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "input",
          "type": "CreateNoteInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Posts a new note to /api/notes endpoint and returns the created Note",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.556Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function createNote(input: CreateNoteInput): Promise<Note> {\n  return apiPost<Note, CreateNoteInput>('/api/notes', input);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:updateNote:50": {
      "id": "file:web/src/lib/api/notes.ts:fn:updateNote:50",
      "type": "function",
      "name": "updateNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 50,
      "endLine": 52,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "input",
          "type": "UpdateNoteInput",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Updates a note by making a PATCH API request.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.311Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function updateNote(id: string, input: UpdateNoteInput): Promise<Note> {\n  return apiPatch<Note, UpdateNoteInput>(`/api/notes/${id}`, input);\n}",
      "references": [
        "apiPatch"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:archiveNote:57": {
      "id": "file:web/src/lib/api/notes.ts:fn:archiveNote:57",
      "type": "function",
      "name": "archiveNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 57,
      "endLine": 59,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Archives a note via POST to /api/notes/{id}/archive",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function archiveNote(id: string): Promise<void> {\n  await apiPost<void>(`/api/notes/${id}/archive`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:deleteNote:64": {
      "id": "file:web/src/lib/api/notes.ts:fn:deleteNote:64",
      "type": "function",
      "name": "deleteNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 64,
      "endLine": 66,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Deletes a note by ID via API DELETE request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:26.278Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function deleteNote(id: string): Promise<void> {\n  await apiDelete<void>(`/api/notes/${id}`);\n}",
      "references": [
        "apiDelete"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:pinNote:71": {
      "id": "file:web/src/lib/api/notes.ts:fn:pinNote:71",
      "type": "function",
      "name": "pinNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 71,
      "endLine": 73,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Pins a note by ID via API POST to /api/notes/{id}/pin, returns Note",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:26.367Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function pinNote(id: string): Promise<Note> {\n  return apiPost<Note>(`/api/notes/${id}/pin`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:unpinNote:78": {
      "id": "file:web/src/lib/api/notes.ts:fn:unpinNote:78",
      "type": "function",
      "name": "unpinNote",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 78,
      "endLine": 80,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Note>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Unpins a note by ID via API POST request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:26.597Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function unpinNote(id: string): Promise<Note> {\n  return apiPost<Note>(`/api/notes/${id}/unpin`);\n}",
      "references": [
        "apiPost"
      ]
    },
    "file:web/src/lib/api/notes.ts:fn:exportNotes:85": {
      "id": "file:web/src/lib/api/notes.ts:fn:exportNotes:85",
      "type": "function",
      "name": "exportNotes",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/notes.ts",
      "line": 85,
      "endLine": 103,
      "parentFileId": "file:web/src/lib/api/notes.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "format",
          "type": "\"json\" | \"markdown\" | \"csv\"",
          "isOptional": true,
          "defaultValue": "'markdown'"
        },
        {
          "name": "options",
          "type": "{ entity_id?: string; category?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Blob>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Exports notes via API in specified format (json/markdown/csv) and returns Blob",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.436Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function exportNotes(\n  format: 'json' | 'markdown' | 'csv' = 'markdown',\n  options: { entity_id?: string; category?: string } = {}\n): Promise<Blob> {\n  const params: Record<string, string | undefined> = {\n    format,\n    ...options,\n  };\n\n  const response = await fetch(\n    `/api/notes/export?${new URLSearchParams(params as Record<string, string>).toString()}`\n  );\n\n  if (!response.ok) {\n    throw new Error('Failed to export notes');\n  }\n\n  return response.blob();\n}",
      "references": [
        "fetch",
        "URLSearchParams",
        "params",
        "response",
        "Error"
      ]
    },
    "file:web/src/lib/api/patterns.ts": {
      "id": "file:web/src/lib/api/patterns.ts",
      "type": "file",
      "name": "patterns.ts",
      "filePath": "web/src/lib/api/patterns.ts",
      "line": 1,
      "endLine": 107,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchPatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchPattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchPatternStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "FetchPatternsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/api/patterns.ts:fn:transformPattern:30",
        "file:web/src/lib/api/patterns.ts:fn:fetchPatterns:76",
        "file:web/src/lib/api/patterns.ts:fn:fetchPattern:94",
        "file:web/src/lib/api/patterns.ts:fn:fetchPatternStats:102"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/patterns.ts:fn:transformPattern:30": {
      "id": "file:web/src/lib/api/patterns.ts:fn:transformPattern:30",
      "type": "function",
      "name": "transformPattern",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/patterns.ts",
      "line": 30,
      "endLine": 40,
      "parentFileId": "file:web/src/lib/api/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "backend",
          "type": "BackendPattern",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Pattern",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Transforms BackendPattern into Pattern by mapping properties.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function transformPattern(backend: BackendPattern): Pattern {\n  return {\n    id: backend.id,\n    description: backend.content,\n    type: backend.pattern_type,\n    frequency: backend.frequency,\n    confidence: backend.confidence,\n    first_detected: backend.first_detected_at,\n    last_detected: backend.last_observed_at || backend.first_detected_at,\n  };\n}",
      "references": []
    },
    "file:web/src/lib/api/patterns.ts:fn:fetchPatterns:76": {
      "id": "file:web/src/lib/api/patterns.ts:fn:fetchPatterns:76",
      "type": "function",
      "name": "fetchPatterns",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/patterns.ts",
      "line": 76,
      "endLine": 89,
      "parentFileId": "file:web/src/lib/api/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/api/patterns\").FetchPatternsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "Promise<Pattern[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches patterns from API with filters and transforms them",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchPatterns(options: FetchPatternsOptions = {}): Promise<Pattern[]> {\n  const { type, status, minConfidence, timeOfDay, dayOfWeek, limit = 50 } = options;\n  const response = await apiGet<PatternsListResponse>('/api/patterns', {\n    params: {\n      type,\n      status,\n      minConfidence,\n      timeOfDay,\n      dayOfWeek,\n      limit,\n    },\n  });\n  return response.patterns.map(transformPattern);\n}",
      "references": [
        "status",
        "minConfidence",
        "timeOfDay",
        "dayOfWeek",
        "limit",
        "apiGet",
        "response",
        "transformPattern"
      ]
    },
    "file:web/src/lib/api/patterns.ts:fn:fetchPattern:94": {
      "id": "file:web/src/lib/api/patterns.ts:fn:fetchPattern:94",
      "type": "function",
      "name": "fetchPattern",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/patterns.ts",
      "line": 94,
      "endLine": 97,
      "parentFileId": "file:web/src/lib/api/patterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<Pattern>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches a pattern by ID from API and transforms the response.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchPattern(id: string): Promise<Pattern> {\n  const response = await apiGet<PatternResponse>(`/api/patterns/${id}`);\n  return transformPattern(response.pattern);\n}",
      "references": [
        "apiGet",
        "transformPattern",
        "response"
      ]
    },
    "file:web/src/lib/api/patterns.ts:fn:fetchPatternStats:102": {
      "id": "file:web/src/lib/api/patterns.ts:fn:fetchPatternStats:102",
      "type": "function",
      "name": "fetchPatternStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/patterns.ts",
      "line": 102,
      "endLine": 105,
      "parentFileId": "file:web/src/lib/api/patterns.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; byType: Record<PatternType, number>; avgConfidence: number; avgFrequency: number; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches pattern stats from API and returns them.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchPatternStats(): Promise<PatternStatsResponse['stats']> {\n  const response = await apiGet<PatternStatsResponse>('/api/patterns/stats');\n  return response.stats;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/summaries.ts": {
      "id": "file:web/src/lib/api/summaries.ts",
      "type": "file",
      "name": "summaries.ts",
      "filePath": "web/src/lib/api/summaries.ts",
      "line": 1,
      "endLine": 44,
      "imports": [
        {
          "source": "./client",
          "items": [
            {
              "name": "apiGet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SummaryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "fetchSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "fetchSummaryStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/api/summaries.ts:fn:fetchSummaries:30",
        "file:web/src/lib/api/summaries.ts:fn:fetchSummaryStats:40"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/api/summaries.ts:fn:fetchSummaries:30": {
      "id": "file:web/src/lib/api/summaries.ts:fn:fetchSummaries:30",
      "type": "function",
      "name": "fetchSummaries",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/summaries.ts",
      "line": 30,
      "endLine": 35,
      "parentFileId": "file:web/src/lib/api/summaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "nonEmptyOnly",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": "true"
        }
      ],
      "returnType": "Promise<LivingSummary[]>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches summaries from API endpoint with optional non-empty filter",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchSummaries(nonEmptyOnly = true): Promise<LivingSummary[]> {\n  const response = await apiGet<SummariesListResponse>('/api/summaries', {\n    params: { nonEmpty: nonEmptyOnly },\n  });\n  return response.summaries;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/api/summaries.ts:fn:fetchSummaryStats:40": {
      "id": "file:web/src/lib/api/summaries.ts:fn:fetchSummaryStats:40",
      "type": "function",
      "name": "fetchSummaryStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/api/summaries.ts",
      "line": 40,
      "endLine": 43,
      "parentFileId": "file:web/src/lib/api/summaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<{ total: number; nonEmpty: number; totalMemories: number; byCategory: Record<SummaryCategory, { version: number; memoryCount: number; hasContent: boolean; }>; }>",
      "isExported": true,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches summary stats via API GET request and returns response.stats",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export async function fetchSummaryStats(): Promise<SummaryStatsResponse['stats']> {\n  const response = await apiGet<SummaryStatsResponse>('/api/summaries/stats');\n  return response.stats;\n}",
      "references": [
        "apiGet",
        "response"
      ]
    },
    "file:web/src/lib/hooks/index.ts": {
      "id": "file:web/src/lib/hooks/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/lib/hooks/index.ts",
      "line": 1,
      "endLine": 59,
      "imports": [],
      "exports": [
        {
          "name": "useSpeechRecognition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseSpeechRecognitionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseSpeechRecognitionReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "useSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useSummaryStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useRecentHighSalienceMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemorySearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useBeliefStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "usePatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "usePattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "usePatternStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntityDetails",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useTopEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useNewInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useGraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntitySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemorySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntityNeighbors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useGraphVisualization",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useGraphInteractions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseGraphInteractionsResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "useWebSocket",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConnectionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseWebSocketReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatChunkPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatContextPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatErrorPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatDonePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatMessagePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectionStatusPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "usePushNotifications",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PushNotificationState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UsePushNotificationsReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "useSpeechRecognition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useSpeechRecognition"
        },
        {
          "name": "UseSpeechRecognitionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./useSpeechRecognition"
        },
        {
          "name": "UseSpeechRecognitionReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./useSpeechRecognition"
        },
        {
          "name": "useSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useSummaries"
        },
        {
          "name": "useSummaryStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useSummaries"
        },
        {
          "name": "useMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useMemories"
        },
        {
          "name": "useRecentHighSalienceMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useMemories"
        },
        {
          "name": "useMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useMemories"
        },
        {
          "name": "useMemorySearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useMemories"
        },
        {
          "name": "useBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useBeliefs"
        },
        {
          "name": "useBeliefStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useBeliefs"
        },
        {
          "name": "usePatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePatterns"
        },
        {
          "name": "usePattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePatterns"
        },
        {
          "name": "usePatternStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePatterns"
        },
        {
          "name": "useEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useEntities"
        },
        {
          "name": "useEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useEntities"
        },
        {
          "name": "useEntityDetails",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useEntities"
        },
        {
          "name": "useTopEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useEntities"
        },
        {
          "name": "useInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useInsights"
        },
        {
          "name": "useNewInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useInsights"
        },
        {
          "name": "useGraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphData"
        },
        {
          "name": "useEntitySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphData"
        },
        {
          "name": "useMemorySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphData"
        },
        {
          "name": "useEntityNeighbors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphData"
        },
        {
          "name": "useGraphVisualization",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphData"
        },
        {
          "name": "useGraphInteractions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphInteractions"
        },
        {
          "name": "UseGraphInteractionsResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useGraphInteractions"
        },
        {
          "name": "useWebSocket",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "getConnectionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "UseWebSocketReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ChatChunkPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ChatContextPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ChatErrorPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ChatDonePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ChatMessagePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "MemoryCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "InsightCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "ConnectionStatusPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./useWebSocket"
        },
        {
          "name": "usePushNotifications",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePushNotifications"
        },
        {
          "name": "PushNotificationState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePushNotifications"
        },
        {
          "name": "UsePushNotificationsReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./usePushNotifications"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useBeliefs.ts": {
      "id": "file:web/src/lib/hooks/useBeliefs.ts",
      "type": "file",
      "name": "useBeliefs.ts",
      "filePath": "web/src/lib/hooks/useBeliefs.ts",
      "line": 1,
      "endLine": 37,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/beliefs",
          "items": [
            {
              "name": "fetchBeliefs",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchBeliefStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FetchBeliefsOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useBeliefs",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useBeliefStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefs:14",
        "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefStats:28"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefs:14": {
      "id": "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefs:14",
      "type": "function",
      "name": "useBeliefs",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useBeliefs.ts",
      "line": 14,
      "endLine": 23,
      "parentFileId": "file:web/src/lib/hooks/useBeliefs.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "FetchBeliefsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Belief[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching beliefs with filters: type, status, minConfidence, limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.774Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useBeliefs(options: FetchBeliefsOptions = {}) {\n  const { type, status, minConfidence, limit = 50 } = options;\n\n  return useQuery<Belief[]>({\n    queryKey: ['beliefs', { type, status, minConfidence, limit }],\n    queryFn: () => fetchBeliefs({ type, status, minConfidence, limit }),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "status",
        "minConfidence",
        "limit",
        "useQuery",
        "fetchBeliefs"
      ]
    },
    "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefStats:28": {
      "id": "file:web/src/lib/hooks/useBeliefs.ts:fn:useBeliefStats:28",
      "type": "function",
      "name": "useBeliefStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useBeliefs.ts",
      "line": 28,
      "endLine": 35,
      "parentFileId": "file:web/src/lib/hooks/useBeliefs.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<unknown, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom hook using useQuery to fetch and cache belief stats for 5 minutes",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:34.177Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useBeliefStats() {\n  return useQuery({\n    queryKey: ['beliefs', 'stats'],\n    queryFn: fetchBeliefStats,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchBeliefStats"
      ]
    },
    "file:web/src/lib/hooks/useConsolidation.ts": {
      "id": "file:web/src/lib/hooks/useConsolidation.ts",
      "type": "file",
      "name": "useConsolidation.ts",
      "filePath": "web/src/lib/hooks/useConsolidation.ts",
      "line": 1,
      "endLine": 79,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useMutation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useQueryClient",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/consolidation",
          "items": [
            {
              "name": "triggerConsolidation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ConsolidationResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useConsolidation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatConsolidationResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useConsolidation.ts:fn:useConsolidation:22",
        "file:web/src/lib/hooks/useConsolidation.ts:fn:formatConsolidationResult:48"
      ],
      "classes": [],
      "topLevelReferences": [
        "consolidationKeys"
      ]
    },
    "file:web/src/lib/hooks/useConsolidation.ts:fn:useConsolidation:22": {
      "id": "file:web/src/lib/hooks/useConsolidation.ts:fn:useConsolidation:22",
      "type": "function",
      "name": "useConsolidation",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useConsolidation.ts",
      "line": 22,
      "endLine": 42,
      "parentFileId": "file:web/src/lib/hooks/useConsolidation.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseMutationResult<unknown, Error, void, unknown>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query mutation hook for triggering consolidation and invalidating related queries on success",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.234Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useConsolidation() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: triggerConsolidation,\n    onSuccess: (result) => {\n      console.log('[useConsolidation] Consolidation complete:', result);\n\n      // Invalidate all memory-related queries so UI refreshes\n      queryClient.invalidateQueries({ queryKey: ['memories'] });\n      queryClient.invalidateQueries({ queryKey: ['beliefs'] });\n      queryClient.invalidateQueries({ queryKey: ['patterns'] });\n      queryClient.invalidateQueries({ queryKey: ['insights'] });\n      queryClient.invalidateQueries({ queryKey: ['entities'] });\n      queryClient.invalidateQueries({ queryKey: consolidationKeys.stats() });\n    },\n    onError: (error) => {\n      console.error('[useConsolidation] Consolidation failed:', error);\n    },\n  });\n}",
      "references": [
        "useQueryClient",
        "useMutation",
        "triggerConsolidation",
        "console",
        "result",
        "queryClient",
        "consolidationKeys",
        "error"
      ]
    },
    "file:web/src/lib/hooks/useConsolidation.ts:fn:formatConsolidationResult:48": {
      "id": "file:web/src/lib/hooks/useConsolidation.ts:fn:formatConsolidationResult:48",
      "type": "function",
      "name": "formatConsolidationResult",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useConsolidation.ts",
      "line": 48,
      "endLine": 78,
      "parentFileId": "file:web/src/lib/hooks/useConsolidation.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "result",
          "type": "ConsolidationResult",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats ConsolidationResult stats into a human-readable summary string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:23.235Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatConsolidationResult(result: ConsolidationResult): string {\n  const parts: string[] = [];\n\n  if (result.chatMemoriesCreated > 0) {\n    parts.push(`${result.chatMemoriesCreated} memories extracted from chat`);\n  }\n\n  if (result.memoriesDecayed > 0 || result.memoriesStrengthened > 0) {\n    parts.push(\n      `${result.memoriesStrengthened} memories strengthened, ${result.memoriesDecayed} decayed`\n    );\n  }\n\n  if (result.edgesCreated > 0) {\n    parts.push(`${result.edgesCreated} new connections formed`);\n  }\n\n  if (result.patternsCreated > 0) {\n    parts.push(`${result.patternsCreated} patterns discovered`);\n  }\n\n  if (result.insightsCreated > 0) {\n    parts.push(`${result.insightsCreated} insights generated`);\n  }\n\n  if (parts.length === 0) {\n    return 'No changes during consolidation';\n  }\n\n  return parts.join(', ');\n}",
      "references": [
        "parts"
      ]
    },
    "file:web/src/lib/hooks/useEntities.ts": {
      "id": "file:web/src/lib/hooks/useEntities.ts",
      "type": "file",
      "name": "useEntities.ts",
      "filePath": "web/src/lib/hooks/useEntities.ts",
      "line": 1,
      "endLine": 65,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/entities",
          "items": [
            {
              "name": "fetchEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchEntity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchEntityDetails",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchTopEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FetchEntitiesOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useTopEntities",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntityDetails",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useEntities.ts:fn:useEntities:16",
        "file:web/src/lib/hooks/useEntities.ts:fn:useEntity:30",
        "file:web/src/lib/hooks/useEntities.ts:fn:useTopEntities:44",
        "file:web/src/lib/hooks/useEntities.ts:fn:useEntityDetails:56"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useEntities.ts:fn:useEntities:16": {
      "id": "file:web/src/lib/hooks/useEntities.ts:fn:useEntities:16",
      "type": "function",
      "name": "useEntities",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useEntities.ts",
      "line": 16,
      "endLine": 25,
      "parentFileId": "file:web/src/lib/hooks/useEntities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "FetchEntitiesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<any, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook using useQuery to fetch entities by type, limit, offset, search",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.628Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useEntities(options: FetchEntitiesOptions = {}) {\n  const { type, limit = 50, offset = 0, search } = options;\n\n  return useQuery({\n    queryKey: ['entities', { type, limit, offset, search }],\n    queryFn: () => fetchEntities({ type, limit, offset, search }),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "limit",
        "offset",
        "search",
        "useQuery",
        "fetchEntities"
      ]
    },
    "file:web/src/lib/hooks/useEntities.ts:fn:useEntity:30": {
      "id": "file:web/src/lib/hooks/useEntities.ts:fn:useEntity:30",
      "type": "function",
      "name": "useEntity",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useEntities.ts",
      "line": 30,
      "endLine": 38,
      "parentFileId": "file:web/src/lib/hooks/useEntities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Entity, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch and cache entity by ID.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:30.380Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useEntity(id: string | undefined) {\n  return useQuery<Entity>({\n    queryKey: ['entities', id],\n    queryFn: () => fetchEntity(id!),\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchEntity"
      ]
    },
    "file:web/src/lib/hooks/useEntities.ts:fn:useTopEntities:44": {
      "id": "file:web/src/lib/hooks/useEntities.ts:fn:useTopEntities:44",
      "type": "function",
      "name": "useTopEntities",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useEntities.ts",
      "line": 44,
      "endLine": 51,
      "parentFileId": "file:web/src/lib/hooks/useEntities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "12"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<any, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching top entities with given limit (default 12).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:33.346Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useTopEntities(limit = 12) {\n  return useQuery({\n    queryKey: ['entities', 'top', limit],\n    queryFn: () => fetchTopEntities(limit),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchTopEntities"
      ]
    },
    "file:web/src/lib/hooks/useEntities.ts:fn:useEntityDetails:56": {
      "id": "file:web/src/lib/hooks/useEntities.ts:fn:useEntityDetails:56",
      "type": "function",
      "name": "useEntityDetails",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useEntities.ts",
      "line": 56,
      "endLine": 64,
      "parentFileId": "file:web/src/lib/hooks/useEntities.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<EntityDetail, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching entity details by ID with caching.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.722Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useEntityDetails(id: string | undefined) {\n  return useQuery<EntityDetail>({\n    queryKey: ['entities', 'details', id],\n    queryFn: () => fetchEntityDetails(id!),\n    enabled: !!id,\n    staleTime: 1000 * 60 * 2, // 2 minutes - shorter since this is detail data\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchEntityDetails"
      ]
    },
    "file:web/src/lib/hooks/useGraphData.ts": {
      "id": "file:web/src/lib/hooks/useGraphData.ts",
      "type": "file",
      "name": "useGraphData.ts",
      "filePath": "web/src/lib/hooks/useGraphData.ts",
      "line": 1,
      "endLine": 177,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "fetchGraphStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchEntitySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchMemorySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchEntityNeighbors",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchGraphVisualization",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "toForceGraphData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GraphStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntityNeighborsResponse",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VisualizationOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useGraphStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntitySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemorySubgraph",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useEntityNeighbors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useGraphVisualization",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseEntitySubgraphOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseMemorySubgraphOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseEntityNeighborsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseGraphVisualizationOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphStats:25",
        "file:web/src/lib/hooks/useGraphData.ts:fn:useEntitySubgraph:44",
        "file:web/src/lib/hooks/useGraphData.ts:fn:useMemorySubgraph:76",
        "file:web/src/lib/hooks/useGraphData.ts:fn:useEntityNeighbors:108",
        "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphVisualization:137"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphStats:25": {
      "id": "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphStats:25",
      "type": "function",
      "name": "useGraphStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData.ts",
      "line": 25,
      "endLine": 31,
      "parentFileId": "file:web/src/lib/hooks/useGraphData.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<GraphStats, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching graph stats with 1min stale time via fetchGraphStats.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useGraphStats() {\n  return useQuery<GraphStats>({\n    queryKey: ['graph', 'stats'],\n    queryFn: fetchGraphStats,\n    staleTime: 60 * 1000, // 1 minute\n  });\n}",
      "references": [
        "useQuery",
        "fetchGraphStats"
      ]
    },
    "file:web/src/lib/hooks/useGraphData.ts:fn:useEntitySubgraph:44": {
      "id": "file:web/src/lib/hooks/useGraphData.ts:fn:useEntitySubgraph:44",
      "type": "function",
      "name": "useEntitySubgraph",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData.ts",
      "line": 44,
      "endLine": 64,
      "parentFileId": "file:web/src/lib/hooks/useGraphData.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData\").UseEntitySubgraphOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<ForceGraphData, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching entity subgraph data via API and transforming to ForceGraphData",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useEntitySubgraph(\n  entityId: string | null,\n  options: UseEntitySubgraphOptions = {}\n) {\n  const { memoryLimit, entityLimit, includeEdges, enabled = true } = options;\n\n  return useQuery<ForceGraphData>({\n    queryKey: ['graph', 'entity-subgraph', entityId, { memoryLimit, entityLimit, includeEdges }],\n    queryFn: async () => {\n      if (!entityId) throw new Error('Entity ID required');\n      const response = await fetchEntitySubgraph(entityId, {\n        memoryLimit,\n        entityLimit,\n        includeEdges,\n      });\n      return toForceGraphData(response);\n    },\n    enabled: enabled && !!entityId,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n}",
      "references": [
        "memoryLimit",
        "entityLimit",
        "includeEdges",
        "enabled",
        "useQuery",
        "Error",
        "fetchEntitySubgraph",
        "toForceGraphData",
        "response"
      ]
    },
    "file:web/src/lib/hooks/useGraphData.ts:fn:useMemorySubgraph:76": {
      "id": "file:web/src/lib/hooks/useGraphData.ts:fn:useMemorySubgraph:76",
      "type": "function",
      "name": "useMemorySubgraph",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData.ts",
      "line": 76,
      "endLine": 95,
      "parentFileId": "file:web/src/lib/hooks/useGraphData.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memoryId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData\").UseMemorySubgraphOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<ForceGraphData, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook fetching memory subgraph data for force graph via useQuery",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useMemorySubgraph(\n  memoryId: string | null,\n  options: UseMemorySubgraphOptions = {}\n) {\n  const { maxHops, includeEntities, enabled = true } = options;\n\n  return useQuery<ForceGraphData>({\n    queryKey: ['graph', 'memory-subgraph', memoryId, { maxHops, includeEntities }],\n    queryFn: async () => {\n      if (!memoryId) throw new Error('Memory ID required');\n      const response = await fetchMemorySubgraph(memoryId, {\n        maxHops,\n        includeEntities,\n      });\n      return toForceGraphData(response);\n    },\n    enabled: enabled && !!memoryId,\n    staleTime: 30 * 1000,\n  });\n}",
      "references": [
        "maxHops",
        "includeEntities",
        "enabled",
        "useQuery",
        "Error",
        "fetchMemorySubgraph",
        "toForceGraphData",
        "response"
      ]
    },
    "file:web/src/lib/hooks/useGraphData.ts:fn:useEntityNeighbors:108": {
      "id": "file:web/src/lib/hooks/useGraphData.ts:fn:useEntityNeighbors:108",
      "type": "function",
      "name": "useEntityNeighbors",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData.ts",
      "line": 108,
      "endLine": 123,
      "parentFileId": "file:web/src/lib/hooks/useGraphData.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "entityId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData\").UseEntityNeighborsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<EntityNeighborsResponse, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch entity neighbors for a given entityId.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useEntityNeighbors(\n  entityId: string | null,\n  options: UseEntityNeighborsOptions = {}\n) {\n  const { limit, minShared, type, enabled = true } = options;\n\n  return useQuery<EntityNeighborsResponse>({\n    queryKey: ['graph', 'entity-neighbors', entityId, { limit, minShared, type }],\n    queryFn: async () => {\n      if (!entityId) throw new Error('Entity ID required');\n      return fetchEntityNeighbors(entityId, { limit, minShared, type });\n    },\n    enabled: enabled && !!entityId,\n    staleTime: 30 * 1000,\n  });\n}",
      "references": [
        "limit",
        "minShared",
        "enabled",
        "useQuery",
        "Error",
        "fetchEntityNeighbors"
      ]
    },
    "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphVisualization:137": {
      "id": "file:web/src/lib/hooks/useGraphData.ts:fn:useGraphVisualization:137",
      "type": "function",
      "name": "useGraphVisualization",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData.ts",
      "line": 137,
      "endLine": 176,
      "parentFileId": "file:web/src/lib/hooks/useGraphData.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphData\").UseGraphVisualizationOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<ForceGraphData, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching and transforming graph visualization data via fetchGraphVisualization",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useGraphVisualization(\n  options: UseGraphVisualizationOptions = {}\n) {\n  const {\n    nodeLimit,\n    entityLimit,\n    memoryLimit,\n    minSalience,\n    entityTypes,\n    includeEdges,\n    enabled = true,\n  } = options;\n\n  return useQuery<ForceGraphData>({\n    queryKey: [\n      'graph',\n      'visualization',\n      { nodeLimit, entityLimit, memoryLimit, minSalience, entityTypes, includeEdges },\n    ],\n    queryFn: async () => {\n      const response = await fetchGraphVisualization({\n        nodeLimit,\n        entityLimit,\n        memoryLimit,\n        minSalience,\n        entityTypes,\n        includeEdges,\n      });\n      // Transform to ForceGraphData format\n      return toForceGraphData({\n        nodeCount: response.nodeCount,\n        edgeCount: response.edgeCount,\n        nodes: response.nodes,\n        edges: response.edges,\n      });\n    },\n    enabled,\n    staleTime: 30 * 1000, // 30 seconds\n  });\n}",
      "references": [
        "nodeLimit",
        "entityLimit",
        "memoryLimit",
        "minSalience",
        "entityTypes",
        "includeEdges",
        "enabled",
        "useQuery",
        "fetchGraphVisualization",
        "toForceGraphData",
        "response"
      ]
    },
    "file:web/src/lib/hooks/useGraphInteractions.ts": {
      "id": "file:web/src/lib/hooks/useGraphInteractions.ts",
      "type": "file",
      "name": "useGraphInteractions.ts",
      "filePath": "web/src/lib/hooks/useGraphInteractions.ts",
      "line": 1,
      "endLine": 279,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "ForceGraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphLink",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useGraphInteractions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "GraphInteractionState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphInteractionHandlers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseGraphInteractionsOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseGraphInteractionsResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useGraphInteractions.ts:fn:useGraphInteractions:79"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useGraphInteractions.ts:fn:useGraphInteractions:79": {
      "id": "file:web/src/lib/hooks/useGraphInteractions.ts:fn:useGraphInteractions:79",
      "type": "function",
      "name": "useGraphInteractions",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphInteractions.ts",
      "line": 79,
      "endLine": 278,
      "parentFileId": "file:web/src/lib/hooks/useGraphInteractions.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphInteractions\").UseGraphInteractionsOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useGraphInteractions\").UseGraphInteractionsResult",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook managing graph node hover, selection, context menu, and highlighting connected nodes/links",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function useGraphInteractions(\n  options: UseGraphInteractionsOptions\n): UseGraphInteractionsResult {\n  const { graphData, onNodeSelect, onEntityClick, onMemoryClick, onZoomToNode } = options;\n\n  // State\n  const [hoveredNode, setHoveredNode] = useState<ForceGraphNode | null>(null);\n  const [selectedNode, setSelectedNode] = useState<ForceGraphNode | null>(null);\n  const [contextMenuOpen, setContextMenuOpen] = useState(false);\n  const [contextMenuPosition, setContextMenuPosition] = useState<{ x: number; y: number } | null>(\n    null\n  );\n  const [contextMenuNode, setContextMenuNode] = useState<ForceGraphNode | null>(null);\n\n  // Track last click time for double-click detection\n  const lastClickRef = useRef<{ nodeId: string; time: number } | null>(null);\n\n  // Build adjacency map for highlighting connected nodes\n  const adjacencyMap = useMemo(() => {\n    const map = new Map<string, Set<string>>();\n    if (!graphData) return map;\n\n    graphData.links.forEach((link) => {\n      const source = typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n      const target = typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n\n      if (!map.has(source)) map.set(source, new Set());\n      if (!map.has(target)) map.set(target, new Set());\n\n      map.get(source)!.add(target);\n      map.get(target)!.add(source);\n    });\n\n    return map;\n  }, [graphData]);\n\n  // Compute highlighted nodes and links based on hovered node\n  const { highlightedNodes, highlightedLinks } = useMemo(() => {\n    const nodes = new Set<string>();\n    const links = new Set<string>();\n\n    if (hoveredNode) {\n      // Add hovered node\n      nodes.add(hoveredNode.id);\n\n      // Add connected nodes\n      const connected = adjacencyMap.get(hoveredNode.id);\n      if (connected) {\n        connected.forEach((id) => nodes.add(id));\n      }\n\n      // Add connected links\n      if (graphData) {\n        graphData.links.forEach((link) => {\n          const source =\n            typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n          const target =\n            typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n\n          if (source === hoveredNode.id || target === hoveredNode.id) {\n            links.add(`${source}-${target}`);\n          }\n        });\n      }\n    }\n\n    return { highlightedNodes: nodes, highlightedLinks: links };\n  }, [hoveredNode, adjacencyMap, graphData]);\n\n  // Handlers\n  const handleNodeClick = useCallback(\n    (node: ForceGraphNode, event: MouseEvent) => {\n      const now = Date.now();\n      const last = lastClickRef.current;\n\n      // Check for double click (within 300ms on same node)\n      if (last && last.nodeId === node.id && now - last.time < 300) {\n        // Double click - zoom to node\n        onZoomToNode?.(node);\n        lastClickRef.current = null;\n        return;\n      }\n\n      // Single click - select node\n      lastClickRef.current = { nodeId: node.id, time: now };\n      setSelectedNode(node);\n      onNodeSelect?.(node);\n\n      // Type-specific callbacks\n      if (node.type === 'entity') {\n        onEntityClick?.(node.id);\n      } else if (node.type === 'memory') {\n        onMemoryClick?.(node.id);\n      }\n    },\n    [onNodeSelect, onEntityClick, onMemoryClick, onZoomToNode]\n  );\n\n  const handleNodeDoubleClick = useCallback(\n    (node: ForceGraphNode) => {\n      onZoomToNode?.(node);\n    },\n    [onZoomToNode]\n  );\n\n  const handleNodeRightClick = useCallback((node: ForceGraphNode, event: MouseEvent) => {\n    event.preventDefault();\n    setContextMenuOpen(true);\n    setContextMenuPosition({ x: event.clientX, y: event.clientY });\n    setContextMenuNode(node);\n  }, []);\n\n  const handleNodeHover = useCallback((node: ForceGraphNode | null) => {\n    setHoveredNode(node);\n  }, []);\n\n  const handleBackgroundClick = useCallback(() => {\n    setSelectedNode(null);\n    setContextMenuOpen(false);\n    onNodeSelect?.(null);\n  }, [onNodeSelect]);\n\n  const closeContextMenu = useCallback(() => {\n    setContextMenuOpen(false);\n    setContextMenuPosition(null);\n    setContextMenuNode(null);\n  }, []);\n\n  const clearSelection = useCallback(() => {\n    setSelectedNode(null);\n    setHoveredNode(null);\n    onNodeSelect?.(null);\n  }, [onNodeSelect]);\n\n  // Highlight helpers\n  const isNodeHighlighted = useCallback(\n    (nodeId: string) => {\n      if (!hoveredNode) return true; // All nodes visible when nothing hovered\n      return highlightedNodes.has(nodeId);\n    },\n    [hoveredNode, highlightedNodes]\n  );\n\n  const isLinkHighlighted = useCallback(\n    (link: ForceGraphLink) => {\n      if (!hoveredNode) return true;\n      const source =\n        typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n      const target =\n        typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n      return highlightedLinks.has(`${source}-${target}`);\n    },\n    [hoveredNode, highlightedLinks]\n  );\n\n  const getNodeOpacity = useCallback(\n    (nodeId: string) => {\n      if (!hoveredNode) return 1;\n      return highlightedNodes.has(nodeId) ? 1 : 0.15;\n    },\n    [hoveredNode, highlightedNodes]\n  );\n\n  const getLinkOpacity = useCallback(\n    (link: ForceGraphLink) => {\n      if (!hoveredNode) return 0.6;\n      const source =\n        typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n      const target =\n        typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n      return highlightedLinks.has(`${source}-${target}`) ? 1 : 0.1;\n    },\n    [hoveredNode, highlightedLinks]\n  );\n\n  return {\n    state: {\n      hoveredNode,\n      selectedNode,\n      highlightedNodes,\n      highlightedLinks,\n      contextMenuOpen,\n      contextMenuPosition,\n      contextMenuNode,\n    },\n    handlers: {\n      handleNodeClick,\n      handleNodeDoubleClick,\n      handleNodeRightClick,\n      handleNodeHover,\n      handleBackgroundClick,\n      closeContextMenu,\n      clearSelection,\n    },\n    isNodeHighlighted,\n    isLinkHighlighted,\n    getNodeOpacity,\n    getLinkOpacity,\n  };\n}",
      "references": [
        "graphData",
        "onNodeSelect",
        "onEntityClick",
        "onMemoryClick",
        "onZoomToNode",
        "hoveredNode",
        "setHoveredNode",
        "useState",
        "selectedNode",
        "setSelectedNode",
        "contextMenuOpen",
        "setContextMenuOpen",
        "contextMenuPosition",
        "setContextMenuPosition",
        "contextMenuNode",
        "setContextMenuNode",
        "useRef",
        "useMemo",
        "Map",
        "map",
        "link",
        "source",
        "Set",
        "target",
        "highlightedNodes",
        "highlightedLinks",
        "nodes",
        "adjacencyMap",
        "connected",
        "id",
        "links",
        "useCallback",
        "Date",
        "lastClickRef",
        "last",
        "node",
        "now",
        "event",
        "nodeId",
        "handleNodeClick",
        "handleNodeDoubleClick",
        "handleNodeRightClick",
        "handleNodeHover",
        "handleBackgroundClick",
        "closeContextMenu",
        "clearSelection",
        "isNodeHighlighted",
        "isLinkHighlighted",
        "getNodeOpacity",
        "getLinkOpacity"
      ]
    },
    "file:web/src/lib/hooks/useInsights.ts": {
      "id": "file:web/src/lib/hooks/useInsights.ts",
      "type": "file",
      "name": "useInsights.ts",
      "filePath": "web/src/lib/hooks/useInsights.ts",
      "line": 1,
      "endLine": 36,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/insights",
          "items": [
            {
              "name": "fetchInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchNewInsights",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FetchInsightsOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useNewInsights",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useInsights.ts:fn:useInsights:14",
        "file:web/src/lib/hooks/useInsights.ts:fn:useNewInsights:28"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useInsights.ts:fn:useInsights:14": {
      "id": "file:web/src/lib/hooks/useInsights.ts:fn:useInsights:14",
      "type": "function",
      "name": "useInsights",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useInsights.ts",
      "line": 14,
      "endLine": 23,
      "parentFileId": "file:web/src/lib/hooks/useInsights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "FetchInsightsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Insight[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch filtered insights data with caching.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:33.998Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useInsights(options: FetchInsightsOptions = {}) {\n  const { type, status, priority, minConfidence, limit = 50 } = options;\n\n  return useQuery<Insight[]>({\n    queryKey: ['insights', { type, status, priority, minConfidence, limit }],\n    queryFn: () => fetchInsights({ type, status, priority, minConfidence, limit }),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "status",
        "priority",
        "minConfidence",
        "limit",
        "useQuery",
        "fetchInsights"
      ]
    },
    "file:web/src/lib/hooks/useInsights.ts:fn:useNewInsights:28": {
      "id": "file:web/src/lib/hooks/useInsights.ts:fn:useNewInsights:28",
      "type": "function",
      "name": "useNewInsights",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useInsights.ts",
      "line": 28,
      "endLine": 35,
      "parentFileId": "file:web/src/lib/hooks/useInsights.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "6"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Insight[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching newest insights with configurable limit.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:34.290Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useNewInsights(limit = 6) {\n  return useQuery<Insight[]>({\n    queryKey: ['insights', 'new', limit],\n    queryFn: () => fetchNewInsights(limit),\n    staleTime: 1000 * 60 * 2, // 2 minutes - check more frequently for new insights\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchNewInsights"
      ]
    },
    "file:web/src/lib/hooks/useMemories.ts": {
      "id": "file:web/src/lib/hooks/useMemories.ts",
      "type": "file",
      "name": "useMemories.ts",
      "filePath": "web/src/lib/hooks/useMemories.ts",
      "line": 1,
      "endLine": 88,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useInfiniteQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/memories",
          "items": [
            {
              "name": "fetchMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchMemoriesPage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchRecentHighSalienceMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "searchMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FetchMemoriesOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoriesPage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useRecentHighSalienceMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useMemorySearch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useInfiniteMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useMemories.ts:fn:useMemories:18",
        "file:web/src/lib/hooks/useMemories.ts:fn:useRecentHighSalienceMemories:32",
        "file:web/src/lib/hooks/useMemories.ts:fn:useMemory:44",
        "file:web/src/lib/hooks/useMemories.ts:fn:useMemorySearch:57",
        "file:web/src/lib/hooks/useMemories.ts:fn:useInfiniteMemories:75"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useMemories.ts:fn:useMemories:18": {
      "id": "file:web/src/lib/hooks/useMemories.ts:fn:useMemories:18",
      "type": "function",
      "name": "useMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useMemories.ts",
      "line": 18,
      "endLine": 27,
      "parentFileId": "file:web/src/lib/hooks/useMemories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "FetchMemoriesOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<any, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch memories with pagination (limit/offset) and optional source filter",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useMemories(options: FetchMemoriesOptions = {}) {\n  const { limit = 50, offset = 0, source } = options;\n\n  return useQuery({\n    queryKey: ['memories', { limit, offset, source }],\n    queryFn: () => fetchMemories({ limit, offset, source }),\n    staleTime: 1000 * 60 * 2, // 2 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "limit",
        "offset",
        "source",
        "useQuery",
        "fetchMemories"
      ]
    },
    "file:web/src/lib/hooks/useMemories.ts:fn:useRecentHighSalienceMemories:32": {
      "id": "file:web/src/lib/hooks/useMemories.ts:fn:useRecentHighSalienceMemories:32",
      "type": "function",
      "name": "useRecentHighSalienceMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useMemories.ts",
      "line": 32,
      "endLine": 39,
      "parentFileId": "file:web/src/lib/hooks/useMemories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "limit",
          "type": "number",
          "isOptional": true,
          "defaultValue": "8"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Memory[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch recent high-salience memories (limit=8 default)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useRecentHighSalienceMemories(limit = 8) {\n  return useQuery<Memory[]>({\n    queryKey: ['memories', 'recent-high-salience', limit],\n    queryFn: () => fetchRecentHighSalienceMemories(limit),\n    staleTime: 1000 * 60 * 2, // 2 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchRecentHighSalienceMemories"
      ]
    },
    "file:web/src/lib/hooks/useMemories.ts:fn:useMemory:44": {
      "id": "file:web/src/lib/hooks/useMemories.ts:fn:useMemory:44",
      "type": "function",
      "name": "useMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useMemories.ts",
      "line": 44,
      "endLine": 52,
      "parentFileId": "file:web/src/lib/hooks/useMemories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Memory, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch a memory by ID with caching.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useMemory(id: string | undefined) {\n  return useQuery<Memory>({\n    queryKey: ['memories', id],\n    queryFn: () => fetchMemory(id!),\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchMemory"
      ]
    },
    "file:web/src/lib/hooks/useMemories.ts:fn:useMemorySearch:57": {
      "id": "file:web/src/lib/hooks/useMemories.ts:fn:useMemorySearch:57",
      "type": "function",
      "name": "useMemorySearch",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useMemories.ts",
      "line": 57,
      "endLine": 70,
      "parentFileId": "file:web/src/lib/hooks/useMemories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "query",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ limit?: number; minSimilarity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Memory[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook for searching memories by query with limit and minSimilarity options.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useMemorySearch(\n  query: string,\n  options: { limit?: number; minSimilarity?: number } = {}\n) {\n  const { limit = 10, minSimilarity = 0.3 } = options;\n\n  return useQuery<Memory[]>({\n    queryKey: ['memories', 'search', query, limit, minSimilarity],\n    queryFn: () => searchMemories(query, { limit, minSimilarity }),\n    enabled: query.length > 2,\n    staleTime: 1000 * 60 * 2, // 2 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "limit",
        "minSimilarity",
        "useQuery",
        "searchMemories"
      ]
    },
    "file:web/src/lib/hooks/useMemories.ts:fn:useInfiniteMemories:75": {
      "id": "file:web/src/lib/hooks/useMemories.ts:fn:useInfiniteMemories:75",
      "type": "function",
      "name": "useInfiniteMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useMemories.ts",
      "line": 75,
      "endLine": 87,
      "parentFileId": "file:web/src/lib/hooks/useMemories.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "{ pageSize?: number; source?: string; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseInfiniteQueryResult<import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+query-core@5.90.12/node_modules/@tanstack/query-core/build/legacy/hydration-DksKBgQq\").a8<MemoriesPage, unknown>, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook for infinite paginated memories query using useInfiniteQuery.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useInfiniteMemories(options: { pageSize?: number; source?: string } = {}) {\n  const { pageSize = 30, source } = options;\n\n  return useInfiniteQuery<MemoriesPage>({\n    queryKey: ['memories', 'infinite', { pageSize, source }],\n    queryFn: ({ pageParam = 0 }) =>\n      fetchMemoriesPage({ limit: pageSize, offset: pageParam as number, source }),\n    getNextPageParam: (lastPage) => lastPage.nextOffset,\n    initialPageParam: 0,\n    staleTime: 1000 * 60 * 2, // 2 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "pageSize",
        "source",
        "useInfiniteQuery",
        "pageParam",
        "fetchMemoriesPage",
        "lastPage"
      ]
    },
    "file:web/src/lib/hooks/useNavigationGuard.ts": {
      "id": "file:web/src/lib/hooks/useNavigationGuard.ts",
      "type": "file",
      "name": "useNavigationGuard.ts",
      "filePath": "web/src/lib/hooks/useNavigationGuard.ts",
      "line": 1,
      "endLine": 79,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useNavigationGuard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useChatNavigationGuard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useConsolidationNavigationGuard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useNavigationGuard:23",
        "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useChatNavigationGuard:57",
        "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useConsolidationNavigationGuard:72"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useNavigationGuard:23": {
      "id": "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useNavigationGuard:23",
      "type": "function",
      "name": "useNavigationGuard",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useNavigationGuard.ts",
      "line": 23,
      "endLine": 51,
      "parentFileId": "file:web/src/lib/hooks/useNavigationGuard.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  enabled,\n  message = 'You have unsaved changes. Are you sure you want to leave?',\n  onNavigationAttempt,\n}",
          "type": "UseNavigationGuardOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook adding beforeunload listener to prevent unsaved changes navigation.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.207Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useNavigationGuard({\n  enabled,\n  message = 'You have unsaved changes. Are you sure you want to leave?',\n  onNavigationAttempt,\n}: UseNavigationGuardOptions): void {\n  const handleBeforeUnload = useCallback(\n    (e: BeforeUnloadEvent) => {\n      if (!enabled) return;\n\n      onNavigationAttempt?.();\n\n      // Standard way to show confirmation dialog\n      e.preventDefault();\n      // Chrome requires returnValue to be set\n      e.returnValue = message;\n      return message;\n    },\n    [enabled, message, onNavigationAttempt]\n  );\n\n  useEffect(() => {\n    if (enabled) {\n      window.addEventListener('beforeunload', handleBeforeUnload);\n      return () => {\n        window.removeEventListener('beforeunload', handleBeforeUnload);\n      };\n    }\n  }, [enabled, handleBeforeUnload]);\n}",
      "references": [
        "useCallback",
        "enabled",
        "onNavigationAttempt",
        "e",
        "message",
        "useEffect",
        "window",
        "handleBeforeUnload"
      ]
    },
    "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useChatNavigationGuard:57": {
      "id": "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useChatNavigationGuard:57",
      "type": "function",
      "name": "useChatNavigationGuard",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useNavigationGuard.ts",
      "line": 57,
      "endLine": 67,
      "parentFileId": "file:web/src/lib/hooks/useNavigationGuard.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Enables navigation guard when chat is busy to prevent data loss on leave.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useChatNavigationGuard(): void {\n  // Import dynamically to avoid circular dependency\n  const { useIsChatBusy } = require('@/lib/stores/chatStore');\n  const isBusy = useIsChatBusy();\n\n  useNavigationGuard({\n    enabled: isBusy,\n    message:\n      'Your message is still being processed. Leaving now may cause data loss. Are you sure?',\n  });\n}",
      "references": [
        "useIsChatBusy",
        "require",
        "useNavigationGuard",
        "isBusy"
      ]
    },
    "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useConsolidationNavigationGuard:72": {
      "id": "file:web/src/lib/hooks/useNavigationGuard.ts:fn:useConsolidationNavigationGuard:72",
      "type": "function",
      "name": "useConsolidationNavigationGuard",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useNavigationGuard.ts",
      "line": 72,
      "endLine": 78,
      "parentFileId": "file:web/src/lib/hooks/useNavigationGuard.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "isConsolidating",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Enables navigation guard when consolidation is in progress.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useConsolidationNavigationGuard(isConsolidating: boolean): void {\n  useNavigationGuard({\n    enabled: isConsolidating,\n    message:\n      'Memory consolidation is in progress. Please wait for it to complete before navigating away.',\n  });\n}",
      "references": [
        "useNavigationGuard"
      ]
    },
    "file:web/src/lib/hooks/usePatterns.ts": {
      "id": "file:web/src/lib/hooks/usePatterns.ts",
      "type": "file",
      "name": "usePatterns.ts",
      "filePath": "web/src/lib/hooks/usePatterns.ts",
      "line": 1,
      "endLine": 51,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/patterns",
          "items": [
            {
              "name": "fetchPatterns",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchPattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchPatternStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "FetchPatternsOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "usePatterns",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "usePattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "usePatternStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/usePatterns.ts:fn:usePatterns:15",
        "file:web/src/lib/hooks/usePatterns.ts:fn:usePattern:29",
        "file:web/src/lib/hooks/usePatterns.ts:fn:usePatternStats:42"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/usePatterns.ts:fn:usePatterns:15": {
      "id": "file:web/src/lib/hooks/usePatterns.ts:fn:usePatterns:15",
      "type": "function",
      "name": "usePatterns",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePatterns.ts",
      "line": 15,
      "endLine": 24,
      "parentFileId": "file:web/src/lib/hooks/usePatterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "FetchPatternsOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Pattern[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch filtered patterns data with caching.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function usePatterns(options: FetchPatternsOptions = {}) {\n  const { type, status, minConfidence, timeOfDay, dayOfWeek, limit = 50 } = options;\n\n  return useQuery<Pattern[]>({\n    queryKey: ['patterns', { type, status, minConfidence, timeOfDay, dayOfWeek, limit }],\n    queryFn: () => fetchPatterns({ type, status, minConfidence, timeOfDay, dayOfWeek, limit }),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "status",
        "minConfidence",
        "timeOfDay",
        "dayOfWeek",
        "limit",
        "useQuery",
        "fetchPatterns"
      ]
    },
    "file:web/src/lib/hooks/usePatterns.ts:fn:usePattern:29": {
      "id": "file:web/src/lib/hooks/usePatterns.ts:fn:usePattern:29",
      "type": "function",
      "name": "usePattern",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePatterns.ts",
      "line": 29,
      "endLine": 37,
      "parentFileId": "file:web/src/lib/hooks/usePatterns.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "id",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<Pattern, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook to fetch Pattern by ID with 5min stale time.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function usePattern(id: string | undefined) {\n  return useQuery<Pattern>({\n    queryKey: ['patterns', id],\n    queryFn: () => fetchPattern(id!),\n    enabled: !!id,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchPattern"
      ]
    },
    "file:web/src/lib/hooks/usePatterns.ts:fn:usePatternStats:42": {
      "id": "file:web/src/lib/hooks/usePatterns.ts:fn:usePatternStats:42",
      "type": "function",
      "name": "usePatternStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePatterns.ts",
      "line": 42,
      "endLine": 49,
      "parentFileId": "file:web/src/lib/hooks/usePatterns.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<unknown, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom React Query hook fetching and caching pattern stats for 5min.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function usePatternStats() {\n  return useQuery({\n    queryKey: ['patterns', 'stats'],\n    queryFn: fetchPatternStats,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchPatternStats"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts",
      "type": "file",
      "name": "usePushNotifications.ts",
      "filePath": "web/src/lib/hooks/usePushNotifications.ts",
      "line": 1,
      "endLine": 367,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "usePushNotifications",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PushNotificationState",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UsePushNotificationsReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:getVapidPublicKey:39",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:sendSubscriptionToServer:54",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:removeSubscriptionFromServer:76",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:arrayBufferToBase64:96",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:urlBase64ToUint8Array:106",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:getDeviceName:117",
        "file:web/src/lib/hooks/usePushNotifications.ts:fn:usePushNotifications:132"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:getVapidPublicKey:39": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:getVapidPublicKey:39",
      "type": "function",
      "name": "getVapidPublicKey",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 39,
      "endLine": 52,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "Promise<string>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Fetches VAPID public key from API endpoint.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function getVapidPublicKey(): Promise<string | null> {\n  try {\n    const response = await fetch(`${API_BASE}/vapid-key`);\n    if (!response.ok) {\n      console.error('Failed to get VAPID key:', response.status);\n      return null;\n    }\n    const data = await response.json();\n    return data.publicKey;\n  } catch (error) {\n    console.error('Error fetching VAPID key:', error);\n    return null;\n  }\n}",
      "references": [
        "fetch",
        "API_BASE",
        "response",
        "console",
        "data",
        "error"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:sendSubscriptionToServer:54": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:sendSubscriptionToServer:54",
      "type": "function",
      "name": "sendSubscriptionToServer",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 54,
      "endLine": 74,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "subscription",
          "type": "PushSubscription",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Sends push subscription to server via POST fetch and returns success boolean",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function sendSubscriptionToServer(subscription: PushSubscription): Promise<boolean> {\n  try {\n    const response = await fetch(`${API_BASE}/subscribe`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        endpoint: subscription.endpoint,\n        p256dh: arrayBufferToBase64(subscription.getKey('p256dh')),\n        auth: arrayBufferToBase64(subscription.getKey('auth')),\n        user_agent: navigator.userAgent,\n        device_name: getDeviceName(),\n      }),\n    });\n    return response.ok;\n  } catch (error) {\n    console.error('Error sending subscription to server:', error);\n    return false;\n  }\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "arrayBufferToBase64",
        "navigator",
        "getDeviceName",
        "response",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:removeSubscriptionFromServer:76": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:removeSubscriptionFromServer:76",
      "type": "function",
      "name": "removeSubscriptionFromServer",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 76,
      "endLine": 90,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "endpoint",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Promise<boolean>",
      "isExported": false,
      "isAsync": true,
      "behavioral": {
        "summary": "Removes push notification subscription from server via DELETE API request",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "async function removeSubscriptionFromServer(endpoint: string): Promise<boolean> {\n  try {\n    const response = await fetch(`${API_BASE}/unsubscribe`, {\n      method: 'DELETE',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ endpoint }),\n    });\n    return response.ok;\n  } catch (error) {\n    console.error('Error removing subscription from server:', error);\n    return false;\n  }\n}",
      "references": [
        "fetch",
        "API_BASE",
        "JSON",
        "response",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:arrayBufferToBase64:96": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:arrayBufferToBase64:96",
      "type": "function",
      "name": "arrayBufferToBase64",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 96,
      "endLine": 104,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buffer",
          "type": "ArrayBuffer",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts ArrayBuffer to base64-encoded string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function arrayBufferToBase64(buffer: ArrayBuffer | null): string {\n  if (!buffer) return '';\n  const bytes = new Uint8Array(buffer);\n  let binary = '';\n  for (let i = 0; i < bytes.byteLength; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binary);\n}",
      "references": [
        "Uint8Array",
        "i",
        "bytes",
        "binary",
        "String",
        "btoa"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:urlBase64ToUint8Array:106": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:urlBase64ToUint8Array:106",
      "type": "function",
      "name": "urlBase64ToUint8Array",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 106,
      "endLine": 115,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "base64String",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "ArrayBuffer",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts URL-safe base64 string to Uint8Array buffer.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function urlBase64ToUint8Array(base64String: string): ArrayBuffer {\n  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');\n  const rawData = atob(base64);\n  const outputArray = new Uint8Array(rawData.length);\n  for (let i = 0; i < rawData.length; ++i) {\n    outputArray[i] = rawData.charCodeAt(i);\n  }\n  return outputArray.buffer;\n}",
      "references": [
        "padding",
        "atob",
        "base64",
        "Uint8Array",
        "rawData",
        "i",
        "outputArray"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:getDeviceName:117": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:getDeviceName:117",
      "type": "function",
      "name": "getDeviceName",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 117,
      "endLine": 126,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Detects device name from navigator.userAgent regex patterns.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getDeviceName(): string {\n  const ua = navigator.userAgent;\n  if (/iPhone/.test(ua)) return 'iPhone';\n  if (/iPad/.test(ua)) return 'iPad';\n  if (/Android/.test(ua)) return 'Android';\n  if (/Windows/.test(ua)) return 'Windows';\n  if (/Mac/.test(ua)) return 'Mac';\n  if (/Linux/.test(ua)) return 'Linux';\n  return 'Unknown Device';\n}",
      "references": [
        "navigator",
        "ua"
      ]
    },
    "file:web/src/lib/hooks/usePushNotifications.ts:fn:usePushNotifications:132": {
      "id": "file:web/src/lib/hooks/usePushNotifications.ts:fn:usePushNotifications:132",
      "type": "function",
      "name": "usePushNotifications",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications.ts",
      "line": 132,
      "endLine": 366,
      "parentFileId": "file:web/src/lib/hooks/usePushNotifications.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/usePushNotifications\").UsePushNotificationsReturn",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook managing push notification support, permissions, service worker registration, and subscription status",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function usePushNotifications(): UsePushNotificationsReturn {\n  const [state, setState] = useState<PushNotificationState>({\n    isSupported: false,\n    isRegistered: false,\n    permission: 'default',\n    isSubscribed: false,\n    isLoading: true,\n    error: null,\n  });\n\n  // Check initial state on mount\n  useEffect(() => {\n    async function checkState() {\n      // Check if push is supported\n      const isSupported = 'serviceWorker' in navigator && 'PushManager' in window;\n\n      if (!isSupported) {\n        setState({\n          isSupported: false,\n          isRegistered: false,\n          permission: 'denied',\n          isSubscribed: false,\n          isLoading: false,\n          error: 'Push notifications are not supported in this browser',\n        });\n        return;\n      }\n\n      // Check permission\n      const permission = Notification.permission;\n\n      // Check if service worker is registered\n      let registration: ServiceWorkerRegistration | undefined;\n      try {\n        registration = await navigator.serviceWorker.getRegistration();\n      } catch (e) {\n        console.error('Error getting service worker registration:', e);\n      }\n\n      // Check if subscribed\n      let isSubscribed = false;\n      if (registration) {\n        try {\n          const subscription = await registration.pushManager.getSubscription();\n          isSubscribed = subscription !== null;\n        } catch (e) {\n          console.error('Error checking push subscription:', e);\n        }\n      }\n\n      setState({\n        isSupported: true,\n        isRegistered: registration !== undefined,\n        permission,\n        isSubscribed,\n        isLoading: false,\n        error: null,\n      });\n    }\n\n    checkState();\n  }, []);\n\n  // Register service worker if not already registered\n  useEffect(() => {\n    if (!state.isSupported || state.isRegistered || state.isLoading) return;\n\n    async function registerServiceWorker() {\n      try {\n        const registration = await navigator.serviceWorker.register('/sw.js');\n        console.log('Service worker registered:', registration.scope);\n        setState((prev) => ({ ...prev, isRegistered: true }));\n      } catch (error) {\n        console.error('Service worker registration failed:', error);\n        setState((prev) => ({\n          ...prev,\n          error: 'Failed to register service worker',\n        }));\n      }\n    }\n\n    registerServiceWorker();\n  }, [state.isSupported, state.isRegistered, state.isLoading]);\n\n  // Request notification permission\n  const requestPermission = useCallback(async (): Promise<NotificationPermission> => {\n    if (!state.isSupported) {\n      return 'denied';\n    }\n\n    try {\n      const permission = await Notification.requestPermission();\n      setState((prev) => ({ ...prev, permission }));\n      return permission;\n    } catch (error) {\n      console.error('Error requesting permission:', error);\n      setState((prev) => ({ ...prev, error: 'Failed to request permission' }));\n      return 'denied';\n    }\n  }, [state.isSupported]);\n\n  // Subscribe to push notifications\n  const subscribe = useCallback(async (): Promise<boolean> => {\n    if (!state.isSupported || !state.isRegistered) {\n      setState((prev) => ({ ...prev, error: 'Service worker not ready' }));\n      return false;\n    }\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      // Ensure we have permission\n      if (state.permission !== 'granted') {\n        const permission = await requestPermission();\n        if (permission !== 'granted') {\n          setState((prev) => ({\n            ...prev,\n            isLoading: false,\n            error: 'Notification permission denied',\n          }));\n          return false;\n        }\n      }\n\n      // Get VAPID public key from server\n      const vapidPublicKey = await getVapidPublicKey();\n      if (!vapidPublicKey) {\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: 'Push notifications not configured on server',\n        }));\n        return false;\n      }\n\n      // Get service worker registration\n      const registration = await navigator.serviceWorker.ready;\n\n      // Subscribe to push\n      const subscription = await registration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: urlBase64ToUint8Array(vapidPublicKey),\n      });\n\n      // Send subscription to server\n      const success = await sendSubscriptionToServer(subscription);\n      if (!success) {\n        // Unsubscribe locally if server registration failed\n        await subscription.unsubscribe();\n        setState((prev) => ({\n          ...prev,\n          isLoading: false,\n          error: 'Failed to register subscription with server',\n        }));\n        return false;\n      }\n\n      setState((prev) => ({\n        ...prev,\n        isSubscribed: true,\n        isLoading: false,\n        error: null,\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error subscribing to push:', error);\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: error instanceof Error ? error.message : 'Failed to subscribe',\n      }));\n      return false;\n    }\n  }, [state.isSupported, state.isRegistered, state.permission, requestPermission]);\n\n  // Unsubscribe from push notifications\n  const unsubscribe = useCallback(async (): Promise<boolean> => {\n    if (!state.isSupported) {\n      return false;\n    }\n\n    setState((prev) => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      const subscription = await registration.pushManager.getSubscription();\n\n      if (subscription) {\n        // Remove from server first\n        await removeSubscriptionFromServer(subscription.endpoint);\n        // Then unsubscribe locally\n        await subscription.unsubscribe();\n      }\n\n      setState((prev) => ({\n        ...prev,\n        isSubscribed: false,\n        isLoading: false,\n        error: null,\n      }));\n      return true;\n    } catch (error) {\n      console.error('Error unsubscribing from push:', error);\n      setState((prev) => ({\n        ...prev,\n        isLoading: false,\n        error: error instanceof Error ? error.message : 'Failed to unsubscribe',\n      }));\n      return false;\n    }\n  }, [state.isSupported]);\n\n  // Get current subscription\n  const getSubscription = useCallback(async (): Promise<PushSubscription | null> => {\n    if (!state.isSupported) {\n      return null;\n    }\n\n    try {\n      const registration = await navigator.serviceWorker.ready;\n      return await registration.pushManager.getSubscription();\n    } catch (error) {\n      console.error('Error getting subscription:', error);\n      return null;\n    }\n  }, [state.isSupported]);\n\n  return {\n    ...state,\n    requestPermission,\n    subscribe,\n    unsubscribe,\n    getSubscription,\n  };\n}",
      "references": [
        "state",
        "setState",
        "useState",
        "useEffect",
        "navigator",
        "window",
        "isSupported",
        "Notification",
        "registration",
        "console",
        "e",
        "isSubscribed",
        "subscription",
        "permission",
        "checkState",
        "prev",
        "error",
        "registerServiceWorker",
        "useCallback",
        "requestPermission",
        "getVapidPublicKey",
        "vapidPublicKey",
        "urlBase64ToUint8Array",
        "sendSubscriptionToServer",
        "success",
        "Error",
        "removeSubscriptionFromServer",
        "subscribe",
        "unsubscribe",
        "getSubscription"
      ]
    },
    "file:web/src/lib/hooks/useSpeechRecognition.ts": {
      "id": "file:web/src/lib/hooks/useSpeechRecognition.ts",
      "type": "file",
      "name": "useSpeechRecognition.ts",
      "filePath": "web/src/lib/hooks/useSpeechRecognition.ts",
      "line": 1,
      "endLine": 201,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useSpeechRecognition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseSpeechRecognitionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseSpeechRecognitionReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:useSpeechRecognition:55",
        "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:getErrorMessage:181"
      ],
      "classes": [],
      "topLevelReferences": [
        "global"
      ]
    },
    "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:useSpeechRecognition:55": {
      "id": "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:useSpeechRecognition:55",
      "type": "function",
      "name": "useSpeechRecognition",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useSpeechRecognition.ts",
      "line": 55,
      "endLine": 179,
      "parentFileId": "file:web/src/lib/hooks/useSpeechRecognition.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useSpeechRecognition\").UseSpeechRecognitionOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useSpeechRecognition\").UseSpeechRecognitionReturn",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook for Web Speech API recognition with transcript states and event handlers",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useSpeechRecognition(\n  options: UseSpeechRecognitionOptions = {}\n): UseSpeechRecognitionReturn {\n  const {\n    continuous = false,\n    interimResults = true,\n    lang = 'en-US',\n    onResult,\n    onError,\n  } = options;\n\n  const [isListening, setIsListening] = useState(false);\n  const [isSupported, setIsSupported] = useState(false);\n  const [transcript, setTranscript] = useState('');\n  const [interimTranscript, setInterimTranscript] = useState('');\n  const [error, setError] = useState<string | null>(null);\n\n  const recognitionRef = useRef<SpeechRecognition | null>(null);\n\n  // Check for browser support\n  useEffect(() => {\n    const SpeechRecognitionAPI =\n      typeof window !== 'undefined'\n        ? window.SpeechRecognition || window.webkitSpeechRecognition\n        : null;\n\n    setIsSupported(!!SpeechRecognitionAPI);\n\n    if (SpeechRecognitionAPI) {\n      recognitionRef.current = new SpeechRecognitionAPI();\n      recognitionRef.current.continuous = continuous;\n      recognitionRef.current.interimResults = interimResults;\n      recognitionRef.current.lang = lang;\n    }\n\n    return () => {\n      if (recognitionRef.current) {\n        recognitionRef.current.abort();\n      }\n    };\n  }, [continuous, interimResults, lang]);\n\n  // Set up event handlers\n  useEffect(() => {\n    const recognition = recognitionRef.current;\n    if (!recognition) return;\n\n    recognition.onstart = () => {\n      setIsListening(true);\n      setError(null);\n    };\n\n    recognition.onend = () => {\n      setIsListening(false);\n    };\n\n    recognition.onresult = (event: SpeechRecognitionEvent) => {\n      let finalTranscript = '';\n      let interim = '';\n\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        if (result.isFinal) {\n          finalTranscript += result[0].transcript;\n        } else {\n          interim += result[0].transcript;\n        }\n      }\n\n      if (finalTranscript) {\n        setTranscript((prev) => prev + finalTranscript);\n        setInterimTranscript('');\n        onResult?.(finalTranscript, true);\n      } else {\n        setInterimTranscript(interim);\n        onResult?.(interim, false);\n      }\n    };\n\n    recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      const errorMessage = getErrorMessage(event.error);\n      setError(errorMessage);\n      setIsListening(false);\n      onError?.(errorMessage);\n    };\n  }, [onResult, onError]);\n\n  const startListening = useCallback(() => {\n    const recognition = recognitionRef.current;\n    if (!recognition || isListening) return;\n\n    setError(null);\n    setInterimTranscript('');\n\n    try {\n      recognition.start();\n    } catch (err) {\n      // Handle if already started\n      console.error('Speech recognition start error:', err);\n    }\n  }, [isListening]);\n\n  const stopListening = useCallback(() => {\n    const recognition = recognitionRef.current;\n    if (!recognition || !isListening) return;\n\n    recognition.stop();\n  }, [isListening]);\n\n  const resetTranscript = useCallback(() => {\n    setTranscript('');\n    setInterimTranscript('');\n  }, []);\n\n  return {\n    isListening,\n    isSupported,\n    transcript,\n    interimTranscript,\n    error,\n    startListening,\n    stopListening,\n    resetTranscript,\n  };\n}",
      "references": [
        "continuous",
        "interimResults",
        "lang",
        "onResult",
        "onError",
        "isListening",
        "setIsListening",
        "useState",
        "isSupported",
        "setIsSupported",
        "transcript",
        "setTranscript",
        "interimTranscript",
        "setInterimTranscript",
        "error",
        "setError",
        "useRef",
        "useEffect",
        "window",
        "SpeechRecognitionAPI",
        "recognitionRef",
        "recognition",
        "event",
        "i",
        "result",
        "finalTranscript",
        "interim",
        "prev",
        "getErrorMessage",
        "errorMessage",
        "useCallback",
        "console",
        "err",
        "startListening",
        "stopListening",
        "resetTranscript"
      ]
    },
    "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:getErrorMessage:181": {
      "id": "file:web/src/lib/hooks/useSpeechRecognition.ts:fn:getErrorMessage:181",
      "type": "function",
      "name": "getErrorMessage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useSpeechRecognition.ts",
      "line": 181,
      "endLine": 200,
      "parentFileId": "file:web/src/lib/hooks/useSpeechRecognition.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "error",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Maps speech recognition error codes to user-friendly messages.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getErrorMessage(error: string): string {\n  switch (error) {\n    case 'no-speech':\n      return 'No speech detected. Please try again.';\n    case 'audio-capture':\n      return 'No microphone found. Please check your audio settings.';\n    case 'not-allowed':\n      return 'Microphone access denied. Please allow microphone access.';\n    case 'network':\n      return 'Network error. Please check your connection.';\n    case 'aborted':\n      return 'Speech recognition was aborted.';\n    case 'language-not-supported':\n      return 'Language not supported.';\n    case 'service-not-allowed':\n      return 'Speech recognition service not allowed.';\n    default:\n      return `Speech recognition error: ${error}`;\n  }\n}",
      "references": []
    },
    "file:web/src/lib/hooks/useSummaries.ts": {
      "id": "file:web/src/lib/hooks/useSummaries.ts",
      "type": "file",
      "name": "useSummaries.ts",
      "filePath": "web/src/lib/hooks/useSummaries.ts",
      "line": 1,
      "endLine": 30,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQuery",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/summaries",
          "items": [
            {
              "name": "fetchSummaries",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "fetchSummaryStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useSummaries",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useSummaryStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaries:10",
        "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaryStats:22"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaries:10": {
      "id": "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaries:10",
      "type": "function",
      "name": "useSummaries",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useSummaries.ts",
      "line": 10,
      "endLine": 17,
      "parentFileId": "file:web/src/lib/hooks/useSummaries.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "nonEmptyOnly",
          "type": "boolean",
          "isOptional": true,
          "defaultValue": "true"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<LivingSummary[], Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook using useQuery to fetch and cache living summaries (non-empty optional)",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useSummaries(nonEmptyOnly = true) {\n  return useQuery<LivingSummary[]>({\n    queryKey: ['summaries', { nonEmptyOnly }],\n    queryFn: () => fetchSummaries(nonEmptyOnly),\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchSummaries"
      ]
    },
    "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaryStats:22": {
      "id": "file:web/src/lib/hooks/useSummaries.ts:fn:useSummaryStats:22",
      "type": "function",
      "name": "useSummaryStats",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useSummaries.ts",
      "line": 22,
      "endLine": 29,
      "parentFileId": "file:web/src/lib/hooks/useSummaries.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@tanstack+react-query@5.90.12_react@19.2.3/node_modules/@tanstack/react-query/build/legacy/types\").UseQueryResult<unknown, Error>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React Query hook fetching summary stats via fetchSummaryStats with 5min stale time.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useSummaryStats() {\n  return useQuery({\n    queryKey: ['summaries', 'stats'],\n    queryFn: fetchSummaryStats,\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    refetchOnWindowFocus: false,\n  });\n}",
      "references": [
        "useQuery",
        "fetchSummaryStats"
      ]
    },
    "file:web/src/lib/hooks/useVillageLayout.ts": {
      "id": "file:web/src/lib/hooks/useVillageLayout.ts",
      "type": "file",
      "name": "useVillageLayout.ts",
      "filePath": "web/src/lib/hooks/useVillageLayout.ts",
      "line": 1,
      "endLine": 196,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./useGraphData",
          "items": [
            {
              "name": "useGraphVisualization",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/village",
          "items": [
            {
              "name": "buildVillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createEmptyLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateProps",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "generateVillagers",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayoutOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageProp",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageVillager",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageSelection",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "useVillageLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useVillageSelection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "UseVillageLayoutOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseVillageLayoutResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageLayout:62",
        "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageSelection:157"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageLayout:62": {
      "id": "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageLayout:62",
      "type": "function",
      "name": "useVillageLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useVillageLayout.ts",
      "line": 62,
      "endLine": 145,
      "parentFileId": "file:web/src/lib/hooks/useVillageLayout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useVillageLayout\").UseVillageLayoutOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useVillageLayout\").UseVillageLayoutResult",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook fetching graph data to compute village layout, props, and villagers",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function useVillageLayout(\n  options: UseVillageLayoutOptions = {}\n): UseVillageLayoutResult {\n  const {\n    enabled = true,\n    maxBuildings = 120,\n    hexSize = 2,\n    minSalience = 0,\n    districtSpacing = 1.5,\n  } = options;\n\n  // Fetch graph visualization data\n  const {\n    data: graphData,\n    isLoading,\n    isFetching,\n    isError,\n    error,\n    refetch,\n  } = useGraphVisualization({\n    // Request enough nodes to fill the village\n    // Don't set entityLimit - layout algorithm filters for memories\n    memoryLimit: maxBuildings,\n    minSalience,\n    includeEdges: true,\n    enabled,\n  });\n\n  // Memoize layout transformation\n  const layout = useMemo(() => {\n    console.log('[VillageLayout] graphData:', graphData ? {\n      nodeCount: graphData.nodes.length,\n      linkCount: graphData.links.length,\n      sampleNode: graphData.nodes[0],\n    } : 'null');\n\n    if (!graphData) {\n      console.log('[VillageLayout] No graphData, returning empty layout');\n      return createEmptyLayout();\n    }\n\n    const result = buildVillageLayout(graphData, {\n      maxBuildings,\n      hexSize,\n      minSalience,\n      districtSpacing,\n    });\n\n    console.log('[VillageLayout] Layout result:', {\n      buildings: result.buildings.length,\n      roads: result.roads.length,\n      stats: result.stats,\n    });\n\n    return result;\n  }, [graphData, maxBuildings, hexSize, minSalience, districtSpacing]);\n\n  // Generate props based on layout (memoized separately)\n  const props = useMemo(() => {\n    if (layout.buildings.length === 0) return [];\n    return generateProps(layout);\n  }, [layout]);\n\n  // Generate villagers from entities (memoized)\n  const villagers = useMemo(() => {\n    if (!graphData || layout.buildings.length === 0) return [];\n    return generateVillagers(graphData, layout);\n  }, [graphData, layout]);\n\n  // Determine if empty (after loading)\n  const isEmpty = !isLoading && !isError && layout.buildings.length === 0;\n\n  return {\n    layout,\n    props,\n    villagers,\n    isLoading,\n    isFetching,\n    isError,\n    error: error as Error | null,\n    isEmpty,\n    refetch,\n  };\n}",
      "references": [
        "enabled",
        "maxBuildings",
        "hexSize",
        "minSalience",
        "districtSpacing",
        "data",
        "graphData",
        "isLoading",
        "isFetching",
        "isError",
        "error",
        "refetch",
        "useGraphVisualization",
        "useMemo",
        "console",
        "createEmptyLayout",
        "buildVillageLayout",
        "result",
        "layout",
        "generateProps",
        "generateVillagers",
        "props",
        "villagers",
        "isEmpty"
      ]
    },
    "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageSelection:157": {
      "id": "file:web/src/lib/hooks/useVillageLayout.ts:fn:useVillageSelection:157",
      "type": "function",
      "name": "useVillageSelection",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useVillageLayout.ts",
      "line": 157,
      "endLine": 195,
      "parentFileId": "file:web/src/lib/hooks/useVillageLayout.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ selection: VillageSelection; selectBuilding: (buildingId: string, memoryId: string) => void; hoverBuilding: (buildingId: string) => void; clearSelection: () => void; isSelected: boolean; isHovered: boolean; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom React hook managing village building selection and hover state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.208Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function useVillageSelection() {\n  const [selection, setSelection] = useState<VillageSelection>({\n    buildingId: null,\n    memoryId: null,\n    hoveredBuildingId: null,\n  });\n\n  const selectBuilding = useCallback((buildingId: string | null, memoryId: string | null) => {\n    setSelection(prev => ({\n      ...prev,\n      buildingId,\n      memoryId,\n    }));\n  }, []);\n\n  const hoverBuilding = useCallback((buildingId: string | null) => {\n    setSelection(prev => ({\n      ...prev,\n      hoveredBuildingId: buildingId,\n    }));\n  }, []);\n\n  const clearSelection = useCallback(() => {\n    setSelection({\n      buildingId: null,\n      memoryId: null,\n      hoveredBuildingId: null,\n    });\n  }, []);\n\n  return {\n    selection,\n    selectBuilding,\n    hoverBuilding,\n    clearSelection,\n    isSelected: selection.buildingId !== null,\n    isHovered: selection.hoveredBuildingId !== null,\n  };\n}",
      "references": [
        "selection",
        "setSelection",
        "useState",
        "useCallback",
        "prev",
        "buildingId",
        "memoryId",
        "selectBuilding",
        "hoverBuilding",
        "clearSelection"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts",
      "type": "file",
      "name": "useWebSocket.ts",
      "filePath": "web/src/lib/hooks/useWebSocket.ts",
      "line": 1,
      "endLine": 442,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "socket.io-client",
          "items": [
            {
              "name": "io",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Socket",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "useWebSocket",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getSocketInstance",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getConnectionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "joinConversationRoom",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "leaveConversationRoom",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "ChatChunkPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatContextPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatErrorPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatDonePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemoryCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectionStatusPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CommitmentCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ReminderCreatedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MessageSyncedPayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatMessagePayload",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UseWebSocketReturn",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocket:144",
        "file:web/src/lib/hooks/useWebSocket.ts:fn:useWebSocket:161",
        "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocketInstance:402",
        "file:web/src/lib/hooks/useWebSocket.ts:fn:getConnectionStatus:410",
        "file:web/src/lib/hooks/useWebSocket.ts:fn:joinConversationRoom:422",
        "file:web/src/lib/hooks/useWebSocket.ts:fn:leaveConversationRoom:434"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocket:144": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocket:144",
      "type": "function",
      "name": "getSocket",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 144,
      "endLine": 157,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/socket.io-client@4.8.3/node_modules/socket.io-client/build/esm/socket\").Socket<import(\"/home/ridgetop/projects/squire/node_modules/@socket.io/component-emitter/lib/cjs/index\").DefaultEventsMap, import(\"/home/ridgetop/projects/squire/node_modules/@socket.io/component-emitter/lib/cjs/index\").DefaultEventsMap>",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns singleton Socket instance, initializing with io() if not exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function getSocket(): Socket {\n  if (!socket) {\n    const url = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3000';\n    socket = io(url, {\n      autoConnect: false,\n      reconnection: true,\n      reconnectionAttempts: Infinity, // Never give up reconnecting\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 10000,\n      timeout: 10000,\n    });\n  }\n  return socket;\n}",
      "references": [
        "socket",
        "process",
        "io",
        "url"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:useWebSocket:161": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:useWebSocket:161",
      "type": "function",
      "name": "useWebSocket",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 161,
      "endLine": 394,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket\").UseWebSocketReturn",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React hook managing WebSocket connection state, latency, and errors via Socket.IO",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function useWebSocket(): UseWebSocketReturn {\n  const [isConnected, setIsConnected] = useState(false);\n  const [socketId, setSocketId] = useState<string | null>(null);\n  const [latency, setLatency] = useState<number | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  // Track if this hook instance is mounted\n  const isMounted = useRef(true);\n\n  useEffect(() => {\n    isMounted.current = true;\n    const sock = getSocket();\n    connectionCount++;\n\n    // Connect if not already connected\n    if (!sock.connected) {\n      sock.connect();\n    }\n\n    // Connection handlers\n    function handleConnect() {\n      if (isMounted.current) {\n        setIsConnected(true);\n        setSocketId(sock.id ?? null);\n        setError(null);\n        console.log('[WebSocket] Connected:', sock.id);\n      }\n    }\n\n    function handleDisconnect(reason: string) {\n      if (isMounted.current) {\n        setIsConnected(false);\n        setSocketId(null);\n        console.log('[WebSocket] Disconnected:', reason);\n      }\n    }\n\n    function handleConnectError(err: Error) {\n      if (isMounted.current) {\n        setError(err.message);\n        console.error('[WebSocket] Connection error:', err.message);\n      }\n    }\n\n    function handleConnectionStatus(payload: ConnectionStatusPayload) {\n      if (isMounted.current) {\n        setIsConnected(payload.connected);\n        if (payload.socketId) setSocketId(payload.socketId);\n        if (payload.latency !== undefined) setLatency(payload.latency);\n      }\n    }\n\n    // Register connection handlers\n    sock.on('connect', handleConnect);\n    sock.on('disconnect', handleDisconnect);\n    sock.on('connect_error', handleConnectError);\n    sock.on('connection:status', handleConnectionStatus);\n\n    // Set initial state if already connected\n    if (sock.connected) {\n      setIsConnected(true);\n      setSocketId(sock.id ?? null);\n    }\n\n    // Cleanup\n    return () => {\n      isMounted.current = false;\n      connectionCount--;\n\n      sock.off('connect', handleConnect);\n      sock.off('disconnect', handleDisconnect);\n      sock.off('connect_error', handleConnectError);\n      sock.off('connection:status', handleConnectionStatus);\n\n      // Only disconnect if no other hooks are using the socket\n      if (connectionCount === 0 && socket) {\n        socket.disconnect();\n        socket = null;\n      }\n    };\n  }, []);\n\n  // === ACTIONS ===\n\n  const sendChatMessage = useCallback((payload: ChatMessagePayload) => {\n    const sock = getSocket();\n    if (sock.connected) {\n      sock.emit('chat:message', payload);\n    } else {\n      console.error('[WebSocket] Cannot send message: not connected');\n    }\n  }, []);\n\n  const cancelChat = useCallback((conversationId: string) => {\n    const sock = getSocket();\n    if (sock.connected) {\n      sock.emit('chat:cancel', { conversationId });\n    }\n  }, []);\n\n  // === CONVERSATION ROOM ACTIONS (for cross-device sync) ===\n\n  const joinConversation = useCallback((conversationId: string) => {\n    const sock = getSocket();\n    if (sock.connected) {\n      sock.emit('conversation:join', { conversationId });\n      console.log('[WebSocket] Joined conversation room:', conversationId);\n    }\n  }, []);\n\n  const leaveConversation = useCallback((conversationId: string) => {\n    const sock = getSocket();\n    if (sock.connected) {\n      sock.emit('conversation:leave', { conversationId });\n      console.log('[WebSocket] Left conversation room:', conversationId);\n    }\n  }, []);\n\n  // === EVENT SUBSCRIPTIONS ===\n\n  const onChatChunk = useCallback((callback: (payload: ChatChunkPayload) => void) => {\n    const sock = getSocket();\n    sock.on('chat:chunk', callback);\n    return () => {\n      sock.off('chat:chunk', callback);\n    };\n  }, []);\n\n  const onChatContext = useCallback((callback: (payload: ChatContextPayload) => void) => {\n    const sock = getSocket();\n    sock.on('chat:context', callback);\n    return () => {\n      sock.off('chat:context', callback);\n    };\n  }, []);\n\n  const onChatError = useCallback((callback: (payload: ChatErrorPayload) => void) => {\n    const sock = getSocket();\n    sock.on('chat:error', callback);\n    return () => {\n      sock.off('chat:error', callback);\n    };\n  }, []);\n\n  const onChatDone = useCallback((callback: (payload: ChatDonePayload) => void) => {\n    const sock = getSocket();\n    sock.on('chat:done', callback);\n    return () => {\n      sock.off('chat:done', callback);\n    };\n  }, []);\n\n  const onMemoryCreated = useCallback((callback: (payload: MemoryCreatedPayload) => void) => {\n    const sock = getSocket();\n    sock.on('memory:created', callback);\n    return () => {\n      sock.off('memory:created', callback);\n    };\n  }, []);\n\n  const onInsightCreated = useCallback((callback: (payload: InsightCreatedPayload) => void) => {\n    const sock = getSocket();\n    sock.on('insight:created', callback);\n    return () => {\n      sock.off('insight:created', callback);\n    };\n  }, []);\n\n  const onCommitmentCreated = useCallback((callback: (payload: CommitmentCreatedPayload) => void) => {\n    const sock = getSocket();\n    sock.on('commitment:created', callback);\n    return () => {\n      sock.off('commitment:created', callback);\n    };\n  }, []);\n\n  const onReminderCreated = useCallback((callback: (payload: ReminderCreatedPayload) => void) => {\n    const sock = getSocket();\n    sock.on('reminder:created', callback);\n    return () => {\n      sock.off('reminder:created', callback);\n    };\n  }, []);\n\n  const onMessageSynced = useCallback((callback: (payload: MessageSyncedPayload) => void) => {\n    const sock = getSocket();\n    sock.on('message:synced', callback);\n    return () => {\n      sock.off('message:synced', callback);\n    };\n  }, []);\n\n  // === UTILITIES ===\n\n  const measureLatency = useCallback(async (): Promise<number> => {\n    const sock = getSocket();\n    if (!sock.connected) {\n      throw new Error('Not connected');\n    }\n\n    const start = performance.now();\n    await new Promise<void>((resolve) => {\n      sock.emit('ping', () => resolve());\n    });\n    const latencyMs = Math.round(performance.now() - start);\n\n    if (isMounted.current) {\n      setLatency(latencyMs);\n    }\n\n    return latencyMs;\n  }, []);\n\n  return {\n    isConnected,\n    socketId,\n    latency,\n    error,\n    sendChatMessage,\n    cancelChat,\n    joinConversation,\n    leaveConversation,\n    onChatChunk,\n    onChatContext,\n    onChatError,\n    onChatDone,\n    onMemoryCreated,\n    onInsightCreated,\n    onCommitmentCreated,\n    onReminderCreated,\n    onMessageSynced,\n    measureLatency,\n  };\n}",
      "references": [
        "isConnected",
        "setIsConnected",
        "useState",
        "socketId",
        "setSocketId",
        "latency",
        "setLatency",
        "error",
        "setError",
        "useRef",
        "useEffect",
        "isMounted",
        "getSocket",
        "connectionCount",
        "sock",
        "console",
        "reason",
        "err",
        "payload",
        "handleConnect",
        "handleDisconnect",
        "handleConnectError",
        "handleConnectionStatus",
        "socket",
        "useCallback",
        "conversationId",
        "callback",
        "Error",
        "performance",
        "Promise",
        "resolve",
        "Math",
        "start",
        "latencyMs",
        "sendChatMessage",
        "cancelChat",
        "joinConversation",
        "leaveConversation",
        "onChatChunk",
        "onChatContext",
        "onChatError",
        "onChatDone",
        "onMemoryCreated",
        "onInsightCreated",
        "onCommitmentCreated",
        "onReminderCreated",
        "onMessageSynced",
        "measureLatency"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocketInstance:402": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:getSocketInstance:402",
      "type": "function",
      "name": "getSocketInstance",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 402,
      "endLine": 404,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/socket.io-client@4.8.3/node_modules/socket.io-client/build/esm/socket\").Socket<import(\"/home/ridgetop/projects/squire/node_modules/@socket.io/component-emitter/lib/cjs/index\").DefaultEventsMap, import(\"/home/ridgetop/projects/squire/node_modules/@socket.io/component-emitter/lib/cjs/index\").DefaultEventsMap>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a Socket instance by calling getSocket().",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getSocketInstance(): Socket {\n  return getSocket();\n}",
      "references": [
        "getSocket"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:getConnectionStatus:410": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:getConnectionStatus:410",
      "type": "function",
      "name": "getConnectionStatus",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 410,
      "endLine": 416,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "{ connected: boolean; socketId: string; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns WebSocket connection status and socket ID from global socket.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getConnectionStatus(): { connected: boolean; socketId: string | null } {\n  const sock = socket;\n  return {\n    connected: sock?.connected ?? false,\n    socketId: sock?.id ?? null,\n  };\n}",
      "references": [
        "socket",
        "sock"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:joinConversationRoom:422": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:joinConversationRoom:422",
      "type": "function",
      "name": "joinConversationRoom",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 422,
      "endLine": 428,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Emits WebSocket event to join conversation room if connected",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function joinConversationRoom(conversationId: string): void {\n  const sock = getSocket();\n  if (sock.connected) {\n    sock.emit('conversation:join', { conversationId });\n    console.log('[WebSocket] Joined conversation room:', conversationId);\n  }\n}",
      "references": [
        "getSocket",
        "sock",
        "console"
      ]
    },
    "file:web/src/lib/hooks/useWebSocket.ts:fn:leaveConversationRoom:434": {
      "id": "file:web/src/lib/hooks/useWebSocket.ts:fn:leaveConversationRoom:434",
      "type": "function",
      "name": "leaveConversationRoom",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/hooks/useWebSocket.ts",
      "line": 434,
      "endLine": 440,
      "parentFileId": "file:web/src/lib/hooks/useWebSocket.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "conversationId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Emits WebSocket event to leave conversation room if socket connected",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function leaveConversationRoom(conversationId: string): void {\n  const sock = getSocket();\n  if (sock.connected) {\n    sock.emit('conversation:leave', { conversationId });\n    console.log('[WebSocket] Left conversation room:', conversationId);\n  }\n}",
      "references": [
        "getSocket",
        "sock",
        "console"
      ]
    },
    "file:web/src/lib/providers/QueryProvider.tsx": {
      "id": "file:web/src/lib/providers/QueryProvider.tsx",
      "type": "file",
      "name": "QueryProvider.tsx",
      "filePath": "web/src/lib/providers/QueryProvider.tsx",
      "line": 1,
      "endLine": 31,
      "imports": [
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "QueryClient",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "QueryClientProvider",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "QueryProvider",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/providers/QueryProvider.tsx:fn:QueryProvider:10"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/providers/QueryProvider.tsx:fn:QueryProvider:10": {
      "id": "file:web/src/lib/providers/QueryProvider.tsx:fn:QueryProvider:10",
      "type": "function",
      "name": "QueryProvider",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/providers/QueryProvider.tsx",
      "line": 10,
      "endLine": 30,
      "parentFileId": "file:web/src/lib/providers/QueryProvider.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ children }",
          "type": "QueryProviderProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Provides a configured QueryClient to React children via QueryClientProvider.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function QueryProvider({ children }: QueryProviderProps) {\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // Default stale time of 30 seconds\n            staleTime: 30 * 1000,\n            // Retry once on failure\n            retry: 1,\n            // Refetch on window focus for fresh data\n            refetchOnWindowFocus: true,\n          },\n        },\n      })\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n}",
      "references": [
        "queryClient",
        "useState",
        "QueryClient",
        "QueryClientProvider",
        "client",
        "children"
      ]
    },
    "file:web/src/lib/providers/WebSocketProvider.tsx": {
      "id": "file:web/src/lib/providers/WebSocketProvider.tsx",
      "type": "file",
      "name": "WebSocketProvider.tsx",
      "filePath": "web/src/lib/providers/WebSocketProvider.tsx",
      "line": 1,
      "endLine": 136,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ReactNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@tanstack/react-query",
          "items": [
            {
              "name": "useQueryClient",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useWebSocket",
          "items": [
            {
              "name": "useWebSocket",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useWebSocket",
          "items": [
            {
              "name": "joinConversationRoom",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores/chatStore",
          "items": [
            {
              "name": "initWebSocketListeners",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useChatStore",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "WebSocketProvider",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/providers/WebSocketProvider.tsx:fn:WebSocketProvider:26"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/providers/WebSocketProvider.tsx:fn:WebSocketProvider:26": {
      "id": "file:web/src/lib/providers/WebSocketProvider.tsx:fn:WebSocketProvider:26",
      "type": "function",
      "name": "WebSocketProvider",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/providers/WebSocketProvider.tsx",
      "line": 26,
      "endLine": 135,
      "parentFileId": "file:web/src/lib/providers/WebSocketProvider.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ children }",
          "type": "WebSocketProviderProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React provider initializing WebSocket listeners, chat history, and debounced graph query invalidation",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function WebSocketProvider({ children }: WebSocketProviderProps) {\n  const queryClient = useQueryClient();\n\n  // Initialize the socket connection and get event subscription methods\n  const { isConnected, onMemoryCreated, onInsightCreated } = useWebSocket();\n\n  // Initialize chat streaming listeners\n  useEffect(() => {\n    const cleanup = initWebSocketListeners();\n    return cleanup;\n  }, []);\n\n  // Load persisted chat history on mount\n  useEffect(() => {\n    useChatStore.getState().loadRecentConversation();\n  }, []);\n\n  // Debounced graph invalidation ref\n  const graphInvalidationTimer = useRef<NodeJS.Timeout | null>(null);\n  const pendingGraphInvalidation = useRef(false);\n\n  // Debounced function to invalidate graph queries\n  const invalidateGraphQueries = useCallback(() => {\n    // Mark that we have a pending invalidation\n    pendingGraphInvalidation.current = true;\n\n    // Clear existing timer if any\n    if (graphInvalidationTimer.current) {\n      clearTimeout(graphInvalidationTimer.current);\n    }\n\n    // Set new debounced timer\n    graphInvalidationTimer.current = setTimeout(() => {\n      if (pendingGraphInvalidation.current) {\n        if (process.env.NODE_ENV === 'development') {\n          console.log('[WebSocketProvider] Invalidating graph queries (debounced)');\n        }\n        // Invalidate all graph-related queries (visualization, stats, subgraphs)\n        queryClient.invalidateQueries({ queryKey: ['graph'] });\n        pendingGraphInvalidation.current = false;\n      }\n    }, GRAPH_INVALIDATION_DEBOUNCE);\n  }, [queryClient]);\n\n  // Cleanup debounce timer on unmount\n  useEffect(() => {\n    return () => {\n      if (graphInvalidationTimer.current) {\n        clearTimeout(graphInvalidationTimer.current);\n      }\n    };\n  }, []);\n\n  // Handle memory:created events - invalidate memory and graph queries\n  useEffect(() => {\n    const unsubscribe = onMemoryCreated((payload) => {\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[WebSocketProvider] memory:created', payload.memory.id);\n      }\n\n      // Invalidate all memory-related queries so lists refresh\n      queryClient.invalidateQueries({ queryKey: ['memories'] });\n\n      // Debounced invalidation of graph queries for Memory Village\n      // This prevents rapid rebuilds during consolidation bursts\n      invalidateGraphQueries();\n    });\n\n    return unsubscribe;\n  }, [onMemoryCreated, queryClient, invalidateGraphQueries]);\n\n  // Handle insight:created events - invalidate insight queries (P6-T5)\n  useEffect(() => {\n    const unsubscribe = onInsightCreated((payload) => {\n      if (process.env.NODE_ENV === 'development') {\n        console.log('[WebSocketProvider] insight:created', payload.insight.id);\n      }\n\n      // Invalidate all insight-related queries so lists refresh\n      queryClient.invalidateQueries({ queryKey: ['insights'] });\n    });\n\n    return unsubscribe;\n  }, [onInsightCreated, queryClient]);\n\n  // Track previous connection state to detect reconnections\n  const wasConnected = useRef(false);\n\n  // Rejoin conversation room on reconnection\n  useEffect(() => {\n    if (isConnected && !wasConnected.current) {\n      // Just connected (initial or reconnect)\n      const conversationId = useChatStore.getState().conversationId;\n      if (conversationId) {\n        console.log('[WebSocketProvider] Rejoining room after connect:', conversationId);\n        joinConversationRoom(conversationId);\n      }\n    }\n    wasConnected.current = isConnected;\n  }, [isConnected]);\n\n  // Log connection status in development\n  useEffect(() => {\n    if (process.env.NODE_ENV === 'development') {\n      console.log('[WebSocketProvider] Connected:', isConnected);\n    }\n  }, [isConnected]);\n\n  return <>{children}</>;\n}",
      "references": [
        "useQueryClient",
        "isConnected",
        "onMemoryCreated",
        "onInsightCreated",
        "useWebSocket",
        "useEffect",
        "initWebSocketListeners",
        "cleanup",
        "useChatStore",
        "useRef",
        "useCallback",
        "pendingGraphInvalidation",
        "graphInvalidationTimer",
        "clearTimeout",
        "setTimeout",
        "process",
        "console",
        "queryClient",
        "GRAPH_INVALIDATION_DEBOUNCE",
        "payload",
        "invalidateGraphQueries",
        "unsubscribe",
        "wasConnected",
        "conversationId",
        "joinConversationRoom",
        "children"
      ]
    },
    "file:web/src/lib/stores/cameraStore.ts": {
      "id": "file:web/src/lib/stores/cameraStore.ts",
      "type": "file",
      "name": "cameraStore.ts",
      "filePath": "web/src/lib/stores/cameraStore.ts",
      "line": 1,
      "endLine": 54,
      "imports": [
        {
          "source": "zustand",
          "items": [
            {
              "name": "create",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "zustand/middleware",
          "items": [
            {
              "name": "persist",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "CameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "useCameraStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useToggleCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useSetPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/lib/stores/cameraStore.ts:fn:useCameraMode:48",
        "file:web/src/lib/stores/cameraStore.ts:fn:useIsPointerLocked:49",
        "file:web/src/lib/stores/cameraStore.ts:fn:useToggleCameraMode:52",
        "file:web/src/lib/stores/cameraStore.ts:fn:useSetPointerLocked:53"
      ],
      "classes": [],
      "topLevelReferences": [
        "set",
        "mode",
        "state",
        "locked"
      ]
    },
    "file:web/src/lib/stores/cameraStore.ts:fn:useCameraMode:48": {
      "id": "file:web/src/lib/stores/cameraStore.ts:fn:useCameraMode:48",
      "type": "function",
      "name": "useCameraMode",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/cameraStore.ts",
      "line": 48,
      "endLine": 48,
      "parentFileId": "file:web/src/lib/stores/cameraStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/stores/cameraStore\").CameraMode",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning camera store's mode state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:24.209Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useCameraMode = () => useCameraStore((state) => state.mode);",
      "references": [
        "useCameraStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/cameraStore.ts:fn:useIsPointerLocked:49": {
      "id": "file:web/src/lib/stores/cameraStore.ts:fn:useIsPointerLocked:49",
      "type": "function",
      "name": "useIsPointerLocked",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/cameraStore.ts",
      "line": 49,
      "endLine": 49,
      "parentFileId": "file:web/src/lib/stores/cameraStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the isPointerLocked state from the camera store using a selector hook.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.126Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useIsPointerLocked = () => useCameraStore((state) => state.isPointerLocked);",
      "references": [
        "useCameraStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/cameraStore.ts:fn:useToggleCameraMode:52": {
      "id": "file:web/src/lib/stores/cameraStore.ts:fn:useToggleCameraMode:52",
      "type": "function",
      "name": "useToggleCameraMode",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/cameraStore.ts",
      "line": 52,
      "endLine": 52,
      "parentFileId": "file:web/src/lib/stores/cameraStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "() => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the toggleMode function from the camera store via Zustand hook.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.337Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useToggleCameraMode = () => useCameraStore((state) => state.toggleMode);",
      "references": [
        "useCameraStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/cameraStore.ts:fn:useSetPointerLocked:53": {
      "id": "file:web/src/lib/stores/cameraStore.ts:fn:useSetPointerLocked:53",
      "type": "function",
      "name": "useSetPointerLocked",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/cameraStore.ts",
      "line": 53,
      "endLine": 53,
      "parentFileId": "file:web/src/lib/stores/cameraStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(locked: boolean) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom hook returning camera store's setPointerLocked function",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:33.624Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useSetPointerLocked = () => useCameraStore((state) => state.setPointerLocked);",
      "references": [
        "useCameraStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts": {
      "id": "file:web/src/lib/stores/chatStore.ts",
      "type": "file",
      "name": "chatStore.ts",
      "filePath": "web/src/lib/stores/chatStore.ts",
      "line": 1,
      "endLine": 639,
      "imports": [
        {
          "source": "zustand",
          "items": [
            {
              "name": "create",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ChatMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ContextPackage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntitySummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/chat",
          "items": [
            {
              "name": "sendChatMessage",
              "alias": "sendChatMessageHttp",
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "prepareHistoryForApi",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatContextInfo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/context",
          "items": [
            {
              "name": "fetchContext",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/conversations",
          "items": [
            {
              "name": "fetchRecentConversation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createConversation",
              "alias": "apiCreateConversation",
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useWebSocket",
          "items": [
            {
              "name": "getSocketInstance",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getConnectionStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "joinConversationRoom",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "leaveConversationRoom",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatChunkPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatContextPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatDonePayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ChatErrorPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MessageSyncedPayload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/messageBackup",
          "items": [
            {
              "name": "savePendingMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "clearPendingMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getPendingMessages",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "clearAllPendingMessages",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/utils/messageBackup",
          "items": [
            {
              "name": "PendingMessage",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "initWebSocketListeners",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useChatStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsLoadingContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsChatBusy",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "PendingMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "@/lib/utils/messageBackup"
        }
      ],
      "functions": [
        "file:web/src/lib/stores/chatStore.ts:fn:clearOverlayCards:32",
        "file:web/src/lib/stores/chatStore.ts:fn:generateMessageId:40",
        "file:web/src/lib/stores/chatStore.ts:fn:generateConversationId:45",
        "file:web/src/lib/stores/chatStore.ts:fn:initWebSocketListeners:508",
        "file:web/src/lib/stores/chatStore.ts:fn:useIsLoading:630",
        "file:web/src/lib/stores/chatStore.ts:fn:useIsLoadingContext:631",
        "file:web/src/lib/stores/chatStore.ts:fn:useIsChatBusy:634"
      ],
      "classes": [],
      "topLevelReferences": [
        "messageData",
        "generateMessageId",
        "Date",
        "set",
        "state",
        "message",
        "msg",
        "id",
        "updates",
        "messages",
        "isLoading",
        "isLoadingContext",
        "isStreaming",
        "messageId",
        "error",
        "clearOverlayCards",
        "conversationId",
        "oldConversationId",
        "get",
        "generateConversationId",
        "conv",
        "console",
        "err",
        "streamingMessageId",
        "chunk",
        "pendingUserMessageId",
        "addMessage",
        "setLoading",
        "setLoadingContext",
        "setStreaming",
        "setError",
        "includeContext",
        "contextProfile",
        "options",
        "connected",
        "content",
        "userMessage",
        "contextPackage",
        "contextError",
        "useStreaming",
        "m",
        "assistantMessage",
        "currentMessages",
        "history",
        "socket",
        "response",
        "Error",
        "errorMsg",
        "hasLoadedInitial",
        "result",
        "conversation",
        "chatMessages",
        "orphaned"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:clearOverlayCards:32": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:clearOverlayCards:32",
      "type": "function",
      "name": "clearOverlayCards",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 32,
      "endLine": 36,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Clears overlay cards by calling clearCards on overlayStore state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.015Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function clearOverlayCards() {\n  // Dynamic require to break circular dependency\n  const { useOverlayStore } = require('./overlayStore');\n  useOverlayStore.getState().clearCards();\n}",
      "references": [
        "useOverlayStore",
        "require"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:generateMessageId:40": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:generateMessageId:40",
      "type": "function",
      "name": "generateMessageId",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 40,
      "endLine": 42,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a unique message ID using timestamp and random string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.015Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateMessageId(): string {\n  return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}",
      "references": [
        "Date",
        "Math"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:generateConversationId:45": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:generateConversationId:45",
      "type": "function",
      "name": "generateConversationId",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 45,
      "endLine": 47,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates a unique conversation ID using timestamp and random string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.015Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateConversationId(): string {\n  return `conv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}",
      "references": [
        "Date",
        "Math"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:initWebSocketListeners:508": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:initWebSocketListeners:508",
      "type": "function",
      "name": "initWebSocketListeners",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 508,
      "endLine": 627,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "() => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Initializes WebSocket listeners for chat events, updating global chat store state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.016Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function initWebSocketListeners(): () => void {\n  if (listenersInitialized) {\n    return cleanupFn || (() => {});\n  }\n\n  const socket = getSocketInstance();\n  const store = useChatStore.getState;\n\n  // Handle streaming chunks\n  function handleChatChunk(payload: ChatChunkPayload) {\n    const { conversationId, streamingMessageId } = store();\n    if (payload.conversationId === conversationId && streamingMessageId) {\n      store().appendToStreamingMessage(payload.chunk);\n    }\n  }\n\n  // Handle context info from server\n  function handleChatContext(payload: ChatContextPayload) {\n    const { conversationId } = store();\n    if (payload.conversationId !== conversationId) return;\n\n    // Convert to ScoredMemory format for overlay\n    const memories: ScoredMemory[] = payload.memories.map((m) => ({\n      id: m.id,\n      content: m.content,\n      created_at: new Date().toISOString(),\n      salience_score: m.salience,\n      current_strength: 1,\n      recency_score: 1,\n      final_score: m.salience,\n      token_estimate: Math.ceil(m.content.length / 4),\n      category: 'relevant' as const,\n    }));\n\n    const entities: EntitySummary[] = payload.entities.map((e) => ({\n      id: e.id,\n      name: e.name,\n      type: e.type as EntitySummary['type'],\n      mention_count: 1,\n    }));\n\n    // Memories and entities still parsed for potential future use\n    // but no longer pushed to overlay (removed: pushOverlayCards)\n  }\n\n  // Handle stream completion\n  function handleChatDone(payload: ChatDonePayload) {\n    const { conversationId } = store();\n    if (payload.conversationId === conversationId) {\n      store().finishStreaming(payload.usage);\n    }\n  }\n\n  // Handle stream error\n  function handleChatError(payload: ChatErrorPayload) {\n    const { conversationId } = store();\n    if (payload.conversationId === conversationId) {\n      store().handleStreamError(payload.error);\n    }\n  }\n\n  // Handle synced messages from other devices\n  function handleMessageSynced(payload: MessageSyncedPayload) {\n    const { conversationId, messages } = store();\n    const { connected, socketId } = getConnectionStatus();\n\n    // Ignore messages from ourselves\n    if (payload.originSocketId === socketId) {\n      return;\n    }\n\n    // Only add messages for the current conversation\n    if (payload.conversationId !== conversationId) {\n      return;\n    }\n\n    // Check if we already have this message (by ID)\n    const existingMessage = messages.find((m) => m.id === payload.message.id);\n    if (existingMessage) {\n      return;\n    }\n\n    console.log('[ChatStore] Synced message from another device:', payload.message.role);\n\n    // Add the synced message\n    useChatStore.setState((state) => ({\n      messages: [\n        ...state.messages,\n        {\n          id: payload.message.id,\n          role: payload.message.role,\n          content: payload.message.content,\n          timestamp: payload.message.timestamp,\n        },\n      ],\n    }));\n  }\n\n  // Register listeners\n  socket.on('chat:chunk', handleChatChunk);\n  socket.on('chat:context', handleChatContext);\n  socket.on('chat:done', handleChatDone);\n  socket.on('chat:error', handleChatError);\n  socket.on('message:synced', handleMessageSynced);\n\n  listenersInitialized = true;\n\n  // Cleanup function\n  cleanupFn = () => {\n    socket.off('chat:chunk', handleChatChunk);\n    socket.off('chat:context', handleChatContext);\n    socket.off('chat:done', handleChatDone);\n    socket.off('chat:error', handleChatError);\n    socket.off('message:synced', handleMessageSynced);\n    listenersInitialized = false;\n    cleanupFn = null;\n  };\n\n  return cleanupFn;\n}",
      "references": [
        "listenersInitialized",
        "cleanupFn",
        "getSocketInstance",
        "useChatStore",
        "conversationId",
        "streamingMessageId",
        "store",
        "payload",
        "m",
        "Date",
        "Math",
        "e",
        "messages",
        "connected",
        "socketId",
        "getConnectionStatus",
        "existingMessage",
        "console",
        "state",
        "socket",
        "handleChatChunk",
        "handleChatContext",
        "handleChatDone",
        "handleChatError",
        "handleMessageSynced"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:useIsLoading:630": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:useIsLoading:630",
      "type": "function",
      "name": "useIsLoading",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 630,
      "endLine": 630,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the isLoading state from the chat store.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useIsLoading = () => useChatStore((state) => state.isLoading);",
      "references": [
        "useChatStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:useIsLoadingContext:631": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:useIsLoadingContext:631",
      "type": "function",
      "name": "useIsLoadingContext",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 631,
      "endLine": 631,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning isLoadingContext from chat store state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.829Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useIsLoadingContext = () => useChatStore((state) => state.isLoadingContext);",
      "references": [
        "useChatStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/chatStore.ts:fn:useIsChatBusy:634": {
      "id": "file:web/src/lib/stores/chatStore.ts:fn:useIsChatBusy:634",
      "type": "function",
      "name": "useIsChatBusy",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/chatStore.ts",
      "line": 634,
      "endLine": 635,
      "parentFileId": "file:web/src/lib/stores/chatStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Hook returning true if chat store is loading, streaming, or has pending user message.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.632Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useIsChatBusy = () =>\n  useChatStore((state) => state.isLoading || state.isStreaming || state.pendingUserMessageId !== null);",
      "references": [
        "useChatStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts": {
      "id": "file:web/src/lib/stores/detailModalStore.ts",
      "type": "file",
      "name": "detailModalStore.ts",
      "filePath": "web/src/lib/stores/detailModalStore.ts",
      "line": 1,
      "endLine": 60,
      "imports": [
        {
          "source": "zustand",
          "items": [
            {
              "name": "create",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Belief",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Pattern",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Entity",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Insight",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LivingSummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "DetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "useDetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useDetailModalOpen",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenMemoryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenBeliefDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenPatternDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenEntityDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenInsightDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenSummaryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useCloseDetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailItem:49",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailModalOpen:50",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenMemoryDetail:53",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenBeliefDetail:54",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenPatternDetail:55",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenEntityDetail:56",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenInsightDetail:57",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenSummaryDetail:58",
        "file:web/src/lib/stores/detailModalStore.ts:fn:useCloseDetailModal:59"
      ],
      "classes": [],
      "topLevelReferences": [
        "set",
        "memory",
        "belief",
        "pattern",
        "entity",
        "insight",
        "summary"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailItem:49": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailItem:49",
      "type": "function",
      "name": "useDetailItem",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 49,
      "endLine": 49,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore\").DetailItem",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Zustand store selector returning the 'item' from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useDetailItem = () => useDetailModalStore((state) => state.item);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailModalOpen:50": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useDetailModalOpen:50",
      "type": "function",
      "name": "useDetailModalOpen",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 50,
      "endLine": 50,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning isOpen state from detailModalStore",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useDetailModalOpen = () => useDetailModalStore((state) => state.isOpen);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenMemoryDetail:53": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenMemoryDetail:53",
      "type": "function",
      "name": "useOpenMemoryDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 53,
      "endLine": 53,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(memory: Memory) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning openMemory state from detailModalStore",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenMemoryDetail = () => useDetailModalStore((state) => state.openMemory);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenBeliefDetail:54": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenBeliefDetail:54",
      "type": "function",
      "name": "useOpenBeliefDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 54,
      "endLine": 54,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(belief: Belief) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning openBelief state from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenBeliefDetail = () => useDetailModalStore((state) => state.openBelief);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenPatternDetail:55": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenPatternDetail:55",
      "type": "function",
      "name": "useOpenPatternDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 55,
      "endLine": 55,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(pattern: Pattern) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom hook selecting openPattern state from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenPatternDetail = () => useDetailModalStore((state) => state.openPattern);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenEntityDetail:56": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenEntityDetail:56",
      "type": "function",
      "name": "useOpenEntityDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 56,
      "endLine": 56,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(entity: Entity) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom hook selecting openEntity state from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenEntityDetail = () => useDetailModalStore((state) => state.openEntity);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenInsightDetail:57": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenInsightDetail:57",
      "type": "function",
      "name": "useOpenInsightDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 57,
      "endLine": 57,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(insight: Insight) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook to get openInsight state from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenInsightDetail = () => useDetailModalStore((state) => state.openInsight);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenSummaryDetail:58": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useOpenSummaryDetail:58",
      "type": "function",
      "name": "useOpenSummaryDetail",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 58,
      "endLine": 58,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(summary: LivingSummary) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook to get openSummary state from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOpenSummaryDetail = () => useDetailModalStore((state) => state.openSummary);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/detailModalStore.ts:fn:useCloseDetailModal:59": {
      "id": "file:web/src/lib/stores/detailModalStore.ts:fn:useCloseDetailModal:59",
      "type": "function",
      "name": "useCloseDetailModal",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/detailModalStore.ts",
      "line": 59,
      "endLine": 59,
      "parentFileId": "file:web/src/lib/stores/detailModalStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "() => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Custom hook returning the close function from detailModalStore.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useCloseDetailModal = () => useDetailModalStore((state) => state.close);",
      "references": [
        "useDetailModalStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/index.ts": {
      "id": "file:web/src/lib/stores/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/lib/stores/index.ts",
      "line": 1,
      "endLine": 40,
      "imports": [],
      "exports": [
        {
          "name": "useChatStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsLoadingContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "initWebSocketListeners",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "useOverlayStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayCards",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayVisible",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useActiveMessageId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useShowMemoriesForMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useHideMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useDismissCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "OverlayCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "useDetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useDetailModalOpen",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenMemoryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenBeliefDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenPatternDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenEntityDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenInsightDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOpenSummaryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useCloseDetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "useCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useIsPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useToggleCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useSetPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "CameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "useChatStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chatStore"
        },
        {
          "name": "useIsLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chatStore"
        },
        {
          "name": "useIsLoadingContext",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chatStore"
        },
        {
          "name": "initWebSocketListeners",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./chatStore"
        },
        {
          "name": "useOverlayStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useOverlayCards",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useOverlayVisible",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useOverlayLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useActiveMessageId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useShowMemoriesForMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useHideMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useDismissCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "OverlayCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./overlayStore"
        },
        {
          "name": "useDetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useDetailModalOpen",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenMemoryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenBeliefDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenPatternDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenEntityDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenInsightDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useOpenSummaryDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useCloseDetailModal",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "DetailItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./detailModalStore"
        },
        {
          "name": "useCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./cameraStore"
        },
        {
          "name": "useIsPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./cameraStore"
        },
        {
          "name": "useToggleCameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./cameraStore"
        },
        {
          "name": "useSetPointerLocked",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./cameraStore"
        },
        {
          "name": "CameraMode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./cameraStore"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/stores/overlayStore.ts": {
      "id": "file:web/src/lib/stores/overlayStore.ts",
      "type": "file",
      "name": "overlayStore.ts",
      "filePath": "web/src/lib/stores/overlayStore.ts",
      "line": 1,
      "endLine": 152,
      "imports": [
        {
          "source": "zustand",
          "items": [
            {
              "name": "create",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntitySummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/memories",
          "items": [
            {
              "name": "fetchMemoriesByIds",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "memoryToScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "OverlayCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "useOverlayStore",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayCards",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayVisible",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useOverlayLoading",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useActiveMessageId",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useShowMemoriesForMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useHideMemories",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "useDismissCard",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayCards:143",
        "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayVisible:144",
        "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayLoading:145",
        "file:web/src/lib/stores/overlayStore.ts:fn:useActiveMessageId:146",
        "file:web/src/lib/stores/overlayStore.ts:fn:useShowMemoriesForMessage:149",
        "file:web/src/lib/stores/overlayStore.ts:fn:useHideMemories:150",
        "file:web/src/lib/stores/overlayStore.ts:fn:useDismissCard:151"
      ],
      "classes": [],
      "topLevelReferences": [
        "activeMessageId",
        "isVisible",
        "get",
        "messageId",
        "set",
        "memoryIds",
        "memories",
        "memory",
        "Date",
        "cards",
        "console",
        "error",
        "state",
        "c",
        "id",
        "maxCards",
        "entities",
        "newCard",
        "Set",
        "existingIds",
        "m",
        "entitiesMap",
        "newCards",
        "visible"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayCards:143": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayCards:143",
      "type": "function",
      "name": "useOverlayCards",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 143,
      "endLine": 143,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore\").OverlayCard[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the cards from the overlay store state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOverlayCards = () => useOverlayStore((state) => state.cards);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayVisible:144": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayVisible:144",
      "type": "function",
      "name": "useOverlayVisible",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 144,
      "endLine": 144,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the visibility state of the overlay from the overlay store.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOverlayVisible = () => useOverlayStore((state) => state.isVisible);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayLoading:145": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useOverlayLoading:145",
      "type": "function",
      "name": "useOverlayLoading",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 145,
      "endLine": 145,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "boolean",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns the isLoading state from the overlay store using a selector.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useOverlayLoading = () => useOverlayStore((state) => state.isLoading);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useActiveMessageId:146": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useActiveMessageId:146",
      "type": "function",
      "name": "useActiveMessageId",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 146,
      "endLine": 146,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook returning activeMessageId from overlay store.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.320Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useActiveMessageId = () => useOverlayStore((state) => state.activeMessageId);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useShowMemoriesForMessage:149": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useShowMemoriesForMessage:149",
      "type": "function",
      "name": "useShowMemoriesForMessage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 149,
      "endLine": 149,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(messageId: string, memoryIds: string[]) => Promise<void>",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Selector hook for showMemoriesForMessage from overlay store.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.321Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useShowMemoriesForMessage = () => useOverlayStore((state) => state.showMemoriesForMessage);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useHideMemories:150": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useHideMemories:150",
      "type": "function",
      "name": "useHideMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 150,
      "endLine": 150,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "() => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Zustand selector hook returning overlay store's hideMemories state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.321Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useHideMemories = () => useOverlayStore((state) => state.hideMemories);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/stores/overlayStore.ts:fn:useDismissCard:151": {
      "id": "file:web/src/lib/stores/overlayStore.ts:fn:useDismissCard:151",
      "type": "function",
      "name": "useDismissCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/stores/overlayStore.ts",
      "line": 151,
      "endLine": 151,
      "parentFileId": "file:web/src/lib/stores/overlayStore.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "(id: string) => void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Zustand selector hook returning overlay store's dismissCard state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:25.321Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export const useDismissCard = () => useOverlayStore((state) => state.dismissCard);",
      "references": [
        "useOverlayStore",
        "state"
      ]
    },
    "file:web/src/lib/types/index.ts": {
      "id": "file:web/src/lib/types/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/lib/types/index.ts",
      "line": 1,
      "endLine": 854,
      "imports": [],
      "exports": [
        {
          "name": "Memory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "MemorySource",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "EmotionScores",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "Entity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "EntityMemoryMention",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ConnectedEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntityDetail",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "Belief",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BeliefCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Pattern",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PatternType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Insight",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "InsightType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "LivingSummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummaryCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ScoredMemory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EntitySummary",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "SummarySnapshot",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextPackage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChatMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "Conversation",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphNode",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GraphEdge",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "EdgeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "GraphData",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ApiResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PaginatedResponse",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "Commitment",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CommitmentStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ResolutionType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ResolutionDetection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CommitmentMatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ResolutionCandidate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ContextProfile",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GoogleAccount",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GoogleCalendar",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "GoogleConnectionStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CalendarEvent",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceFrequency",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DayOfWeek",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ParsedRecurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceOccurrence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrenceExpansion",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "RecurrencePresets",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "RecurrencePreset",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "RecurrenceFrequencyLabels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DayOfWeekLabels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "DayOfWeekShortLabels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "NoteSourceType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "NoteCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "Note",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateNoteInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "UpdateNoteInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListNotesOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ListSortOrder",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "List",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListItem",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListWithItems",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateListInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CreateListItemInput",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ListCompletionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentMimeType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentProcessingStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "DocumentMetadata",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedDocument",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentChunk",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentUploadResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentSearchResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ChunkingOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentSummaryResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DocumentAskResult",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactStatus",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FactType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FactEntityType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "FactDateType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "ExtractedFactEntity",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFactDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedRelationship",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "ExtractedFact",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionStats",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionBatch",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactExtractionOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "FactTypeLabels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FactStatusLabels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "FactStatusColors",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/types/village.ts": {
      "id": "file:web/src/lib/types/village.ts",
      "type": "file",
      "name": "village.ts",
      "filePath": "web/src/lib/types/village.ts",
      "line": 1,
      "endLine": 314,
      "imports": [
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "PropType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "BuildingType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "MemoryCategory",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "CATEGORY_TO_BUILDING",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "BUILDING_COLORS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "VillagePosition",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "HexCoord",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageBuilding",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageRoad",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DistrictConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageDistrict",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageLayoutOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageSelection",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "DISTRICT_LAYOUT",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "VillageProp",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageLayoutWithProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillagerType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "VillageVillager",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "VillageLayoutFull",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "CATEGORY_KEYWORDS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/colors.ts": {
      "id": "file:web/src/lib/utils/colors.ts",
      "type": "file",
      "name": "colors.ts",
      "filePath": "web/src/lib/utils/colors.ts",
      "line": 1,
      "endLine": 33,
      "imports": [
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "EntityType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "getEntityIcon",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntityTextClass",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/utils/colors.ts:fn:getEntityIcon:18",
        "file:web/src/lib/utils/colors.ts:fn:getEntityTextClass:22"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/colors.ts:fn:getEntityIcon:18": {
      "id": "file:web/src/lib/utils/colors.ts:fn:getEntityIcon:18",
      "type": "function",
      "name": "getEntityIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/colors.ts",
      "line": 18,
      "endLine": 20,
      "parentFileId": "file:web/src/lib/utils/colors.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "EntityType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns an icon string for a given EntityType, defaulting to ''.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.112Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getEntityIcon(type: EntityType): string {\n  return entityIcons[type] || '';\n}",
      "references": [
        "entityIcons"
      ]
    },
    "file:web/src/lib/utils/colors.ts:fn:getEntityTextClass:22": {
      "id": "file:web/src/lib/utils/colors.ts:fn:getEntityTextClass:22",
      "type": "function",
      "name": "getEntityTextClass",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/colors.ts",
      "line": 22,
      "endLine": 32,
      "parentFileId": "file:web/src/lib/utils/colors.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "type",
          "type": "EntityType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Returns a CSS text class string based on the given entity type.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.562Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getEntityTextClass(type: EntityType): string {\n  const entityColorMap: Record<EntityType, string> = {\n    person: 'entity-person',\n    organization: 'entity-organization',\n    location: 'entity-location',\n    project: 'entity-project',\n    concept: 'entity-concept',\n    event: 'entity-event',\n  };\n  return `text-${entityColorMap[type] || 'entity-concept'}`;\n}",
      "references": [
        "entityColorMap"
      ]
    },
    "file:web/src/lib/utils/export.ts": {
      "id": "file:web/src/lib/utils/export.ts",
      "type": "file",
      "name": "export.ts",
      "filePath": "web/src/lib/utils/export.ts",
      "line": 1,
      "endLine": 124,
      "imports": [
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "ScoredMemory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntitySummary",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "./formatting",
          "items": [
            {
              "name": "formatDateTime",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "exportMemoryAsMarkdown",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "exportMemoryAsText",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/utils/export.ts:fn:memoryToMarkdown:14",
        "file:web/src/lib/utils/export.ts:fn:memoryToText:60",
        "file:web/src/lib/utils/export.ts:fn:downloadAsFile:83",
        "file:web/src/lib/utils/export.ts:fn:exportMemoryAsMarkdown:104",
        "file:web/src/lib/utils/export.ts:fn:exportMemoryAsText:117"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/export.ts:fn:memoryToMarkdown:14": {
      "id": "file:web/src/lib/utils/export.ts:fn:memoryToMarkdown:14",
      "type": "function",
      "name": "memoryToMarkdown",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/export.ts",
      "line": 14,
      "endLine": 55,
      "parentFileId": "file:web/src/lib/utils/export.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "ScoredMemory",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entities",
          "type": "EntitySummary[]",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts ScoredMemory and optional entities to formatted Markdown string",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.258Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function memoryToMarkdown(\n  memory: ScoredMemory,\n  entities?: EntitySummary[]\n): string {\n  const lines: string[] = [];\n\n  lines.push('# Memory');\n  lines.push('');\n  lines.push(`**Date**: ${formatDateTime(memory.created_at)}`);\n  lines.push(`**Salience**: ${memory.salience_score.toFixed(1)}/10`);\n  lines.push(`**Category**: ${memory.category.replace('_', ' ')}`);\n  lines.push('');\n  lines.push('## Content');\n  lines.push('');\n  lines.push(memory.content);\n  lines.push('');\n\n  if (entities && entities.length > 0) {\n    lines.push('## Entities');\n    lines.push('');\n    entities.forEach((e) => {\n      lines.push(`- **${e.name}** (${e.type}) - ${e.mention_count} mentions`);\n    });\n    lines.push('');\n  }\n\n  lines.push('## Scores');\n  lines.push('');\n  lines.push(`- Salience: ${memory.salience_score.toFixed(2)}`);\n  lines.push(`- Strength: ${(memory.current_strength * 100).toFixed(0)}%`);\n  lines.push(`- Recency: ${(memory.recency_score * 100).toFixed(0)}%`);\n  if (memory.similarity !== undefined) {\n    lines.push(`- Similarity: ${(memory.similarity * 100).toFixed(0)}%`);\n  }\n  lines.push(`- Final Score: ${(memory.final_score * 100).toFixed(0)}%`);\n  lines.push('');\n\n  lines.push('---');\n  lines.push(`*Exported from Squire on ${formatDateTime(new Date().toISOString())}*`);\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "formatDateTime",
        "e",
        "Date"
      ]
    },
    "file:web/src/lib/utils/export.ts:fn:memoryToText:60": {
      "id": "file:web/src/lib/utils/export.ts:fn:memoryToText:60",
      "type": "function",
      "name": "memoryToText",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/export.ts",
      "line": 60,
      "endLine": 76,
      "parentFileId": "file:web/src/lib/utils/export.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "ScoredMemory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a ScoredMemory object into a human-readable text string for export.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.317Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function memoryToText(memory: ScoredMemory): string {\n  const lines: string[] = [];\n\n  lines.push('MEMORY');\n  lines.push('======');\n  lines.push('');\n  lines.push(`Date: ${formatDateTime(memory.created_at)}`);\n  lines.push(`Salience: ${memory.salience_score.toFixed(1)}/10`);\n  lines.push('');\n  lines.push('CONTENT');\n  lines.push('-------');\n  lines.push(memory.content);\n  lines.push('');\n  lines.push(`Exported from Squire on ${formatDateTime(new Date().toISOString())}`);\n\n  return lines.join('\\n');\n}",
      "references": [
        "lines",
        "formatDateTime",
        "Date"
      ]
    },
    "file:web/src/lib/utils/export.ts:fn:downloadAsFile:83": {
      "id": "file:web/src/lib/utils/export.ts:fn:downloadAsFile:83",
      "type": "function",
      "name": "downloadAsFile",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/export.ts",
      "line": 83,
      "endLine": 99,
      "parentFileId": "file:web/src/lib/utils/export.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "content",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "filename",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "mimeType",
          "type": "string",
          "isOptional": true,
          "defaultValue": "'text/plain'"
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Triggers browser download of content as a file with given filename and MIME type",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.579Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "function downloadAsFile(\n  content: string,\n  filename: string,\n  mimeType: string = 'text/plain'\n): void {\n  const blob = new Blob([content], { type: mimeType });\n  const url = URL.createObjectURL(blob);\n\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = filename;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n\n  URL.revokeObjectURL(url);\n}",
      "references": [
        "Blob",
        "URL",
        "blob",
        "document",
        "link",
        "url"
      ]
    },
    "file:web/src/lib/utils/export.ts:fn:exportMemoryAsMarkdown:104": {
      "id": "file:web/src/lib/utils/export.ts:fn:exportMemoryAsMarkdown:104",
      "type": "function",
      "name": "exportMemoryAsMarkdown",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/export.ts",
      "line": 104,
      "endLine": 112,
      "parentFileId": "file:web/src/lib/utils/export.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "ScoredMemory",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "entities",
          "type": "EntitySummary[]",
          "isOptional": true,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts memory to markdown and triggers browser download as .md file.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.027Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function exportMemoryAsMarkdown(\n  memory: ScoredMemory,\n  entities?: EntitySummary[]\n): void {\n  const content = memoryToMarkdown(memory, entities);\n  const date = new Date(memory.created_at).toISOString().split('T')[0];\n  const filename = `memory-${date}-${memory.id.slice(0, 8)}.md`;\n  downloadAsFile(content, filename, 'text/markdown');\n}",
      "references": [
        "memoryToMarkdown",
        "Date",
        "date",
        "downloadAsFile",
        "content",
        "filename"
      ]
    },
    "file:web/src/lib/utils/export.ts:fn:exportMemoryAsText:117": {
      "id": "file:web/src/lib/utils/export.ts:fn:exportMemoryAsText:117",
      "type": "function",
      "name": "exportMemoryAsText",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/export.ts",
      "line": 117,
      "endLine": 122,
      "parentFileId": "file:web/src/lib/utils/export.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "ScoredMemory",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Exports a scored memory as a downloadable text file with date and ID in filename.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.027Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function exportMemoryAsText(memory: ScoredMemory): void {\n  const content = memoryToText(memory);\n  const date = new Date(memory.created_at).toISOString().split('T')[0];\n  const filename = `memory-${date}-${memory.id.slice(0, 8)}.txt`;\n  downloadAsFile(content, filename, 'text/plain');\n}",
      "references": [
        "memoryToText",
        "Date",
        "date",
        "downloadAsFile",
        "content",
        "filename"
      ]
    },
    "file:web/src/lib/utils/formatting.ts": {
      "id": "file:web/src/lib/utils/formatting.ts",
      "type": "file",
      "name": "formatting.ts",
      "filePath": "web/src/lib/utils/formatting.ts",
      "line": 1,
      "endLine": 90,
      "imports": [],
      "exports": [
        {
          "name": "formatRelativeTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatDateTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "truncate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatSalience",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatConfidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "capitalize",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/utils/formatting.ts:fn:formatRelativeTime:6",
        "file:web/src/lib/utils/formatting.ts:fn:formatDate:34",
        "file:web/src/lib/utils/formatting.ts:fn:formatDateTime:43",
        "file:web/src/lib/utils/formatting.ts:fn:formatTime:57",
        "file:web/src/lib/utils/formatting.ts:fn:truncate:65",
        "file:web/src/lib/utils/formatting.ts:fn:formatSalience:71",
        "file:web/src/lib/utils/formatting.ts:fn:formatConfidence:78",
        "file:web/src/lib/utils/formatting.ts:fn:capitalize:87"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatRelativeTime:6": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatRelativeTime:6",
      "type": "function",
      "name": "formatRelativeTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 6,
      "endLine": 31,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string | Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a date into relative time string like 'just now', '2m ago', or '1y ago'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.027Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatRelativeTime(date: string | Date | null | undefined): string {\n  if (!date) return '';\n\n  const now = new Date();\n  const then = new Date(date);\n\n  // Check for invalid date\n  if (isNaN(then.getTime())) return '';\n\n  const diffMs = now.getTime() - then.getTime();\n  const diffSeconds = Math.floor(diffMs / 1000);\n  const diffMinutes = Math.floor(diffSeconds / 60);\n  const diffHours = Math.floor(diffMinutes / 60);\n  const diffDays = Math.floor(diffHours / 24);\n  const diffWeeks = Math.floor(diffDays / 7);\n  const diffMonths = Math.floor(diffDays / 30);\n  const diffYears = Math.floor(diffDays / 365);\n\n  if (diffSeconds < 60) return 'just now';\n  if (diffMinutes < 60) return `${diffMinutes}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n  if (diffWeeks < 4) return `${diffWeeks}w ago`;\n  if (diffMonths < 12) return `${diffMonths}mo ago`;\n  return `${diffYears}y ago`;\n}",
      "references": [
        "Date",
        "isNaN",
        "then",
        "now",
        "Math",
        "diffMs",
        "diffSeconds",
        "diffMinutes",
        "diffHours",
        "diffDays",
        "diffWeeks",
        "diffMonths",
        "diffYears"
      ]
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatDate:34": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatDate:34",
      "type": "function",
      "name": "formatDate",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 34,
      "endLine": 40,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string | Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a date string or Date object to 'MMM D, YYYY' format (en-US).",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.027Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatDate(date: string | Date): string {\n  return new Date(date).toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n  });\n}",
      "references": [
        "Date"
      ]
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatDateTime:43": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatDateTime:43",
      "type": "function",
      "name": "formatDateTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 43,
      "endLine": 54,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string | Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date/time to 'MMM D, YYYY, HH:MM' (en-US) or '' if invalid.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.028Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatDateTime(date: string | Date | null | undefined): string {\n  if (!date) return '';\n  const d = new Date(date);\n  if (isNaN(d.getTime())) return '';\n  return d.toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n  });\n}",
      "references": [
        "Date",
        "isNaN",
        "d"
      ]
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatTime:57": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatTime:57",
      "type": "function",
      "name": "formatTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 57,
      "endLine": 62,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string | Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a date to 2-digit hour:minute string in en-US locale",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.028Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatTime(date: string | Date): string {\n  return new Date(date).toLocaleTimeString('en-US', {\n    hour: '2-digit',\n    minute: '2-digit',\n  });\n}",
      "references": [
        "Date"
      ]
    },
    "file:web/src/lib/utils/formatting.ts:fn:truncate:65": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:truncate:65",
      "type": "function",
      "name": "truncate",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 65,
      "endLine": 68,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "text",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "maxLength",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Truncates string to maxLength chars, appending '...' if longer.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:27.028Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function truncate(text: string, maxLength: number): string {\n  if (text.length <= maxLength) return text;\n  return text.slice(0, maxLength - 3) + '...';\n}",
      "references": []
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatSalience:71": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatSalience:71",
      "type": "function",
      "name": "formatSalience",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 71,
      "endLine": 75,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "salience",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats salience score to 'X/10' string or '' if null/undefined/NaN.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.495Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatSalience(salience: number | null | undefined): string {\n  if (salience == null || isNaN(salience)) return '';\n  const level = Math.round(salience * 10);\n  return `${level}/10`;\n}",
      "references": [
        "isNaN",
        "Math",
        "level"
      ]
    },
    "file:web/src/lib/utils/formatting.ts:fn:formatConfidence:78": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:formatConfidence:78",
      "type": "function",
      "name": "formatConfidence",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 78,
      "endLine": 84,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "confidence",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts confidence score (0-1) to string label: 'Very High' to 'Very Low'.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.811Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function formatConfidence(confidence: number): string {\n  if (confidence >= 0.9) return 'Very High';\n  if (confidence >= 0.7) return 'High';\n  if (confidence >= 0.5) return 'Medium';\n  if (confidence >= 0.3) return 'Low';\n  return 'Very Low';\n}",
      "references": []
    },
    "file:web/src/lib/utils/formatting.ts:fn:capitalize:87": {
      "id": "file:web/src/lib/utils/formatting.ts:fn:capitalize:87",
      "type": "function",
      "name": "capitalize",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/formatting.ts",
      "line": 87,
      "endLine": 89,
      "parentFileId": "file:web/src/lib/utils/formatting.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "str",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Capitalizes the first letter of a string.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.687Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function capitalize(str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}",
      "references": []
    },
    "file:web/src/lib/utils/index.ts": {
      "id": "file:web/src/lib/utils/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/lib/utils/index.ts",
      "line": 1,
      "endLine": 4,
      "imports": [],
      "exports": [
        {
          "name": "getEntityIcon",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getEntityTextClass",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatRelativeTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatDate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatDateTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "truncate",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatSalience",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "formatConfidence",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "capitalize",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./colors"
        },
        {
          "name": "*",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./formatting"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/messageBackup.ts": {
      "id": "file:web/src/lib/utils/messageBackup.ts",
      "type": "file",
      "name": "messageBackup.ts",
      "filePath": "web/src/lib/utils/messageBackup.ts",
      "line": 1,
      "endLine": 75,
      "imports": [],
      "exports": [
        {
          "name": "savePendingMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearPendingMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPendingMessages",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "clearAllPendingMessages",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PendingMessage",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/utils/messageBackup.ts:fn:savePendingMessage:20",
        "file:web/src/lib/utils/messageBackup.ts:fn:clearPendingMessage:34",
        "file:web/src/lib/utils/messageBackup.ts:fn:getPendingMessages:52",
        "file:web/src/lib/utils/messageBackup.ts:fn:clearAllPendingMessages:66"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/utils/messageBackup.ts:fn:savePendingMessage:20": {
      "id": "file:web/src/lib/utils/messageBackup.ts:fn:savePendingMessage:20",
      "type": "function",
      "name": "savePendingMessage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup.ts",
      "line": 20,
      "endLine": 29,
      "parentFileId": "file:web/src/lib/utils/messageBackup.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "message",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup\").PendingMessage",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Appends a pending message to localStorage and logs the action.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function savePendingMessage(message: PendingMessage): void {\n  try {\n    const existing = getPendingMessages();\n    existing.push(message);\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\n    console.log('[MessageBackup] Saved pending message:', message.id);\n  } catch (error) {\n    console.error('[MessageBackup] Failed to save pending message:', error);\n  }\n}",
      "references": [
        "getPendingMessages",
        "existing",
        "localStorage",
        "STORAGE_KEY",
        "JSON",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/utils/messageBackup.ts:fn:clearPendingMessage:34": {
      "id": "file:web/src/lib/utils/messageBackup.ts:fn:clearPendingMessage:34",
      "type": "function",
      "name": "clearPendingMessage",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup.ts",
      "line": 34,
      "endLine": 47,
      "parentFileId": "file:web/src/lib/utils/messageBackup.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "messageId",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Removes a pending message by ID from browser localStorage.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function clearPendingMessage(messageId: string): void {\n  try {\n    const existing = getPendingMessages();\n    const filtered = existing.filter((m) => m.id !== messageId);\n    if (filtered.length === 0) {\n      localStorage.removeItem(STORAGE_KEY);\n    } else {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));\n    }\n    console.log('[MessageBackup] Cleared pending message:', messageId);\n  } catch (error) {\n    console.error('[MessageBackup] Failed to clear pending message:', error);\n  }\n}",
      "references": [
        "getPendingMessages",
        "existing",
        "m",
        "filtered",
        "localStorage",
        "STORAGE_KEY",
        "JSON",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/utils/messageBackup.ts:fn:getPendingMessages:52": {
      "id": "file:web/src/lib/utils/messageBackup.ts:fn:getPendingMessages:52",
      "type": "function",
      "name": "getPendingMessages",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup.ts",
      "line": 52,
      "endLine": 61,
      "parentFileId": "file:web/src/lib/utils/messageBackup.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup\").PendingMessage[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves pending messages from localStorage, parsing JSON or returning empty array on error",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function getPendingMessages(): PendingMessage[] {\n  try {\n    const stored = localStorage.getItem(STORAGE_KEY);\n    if (!stored) return [];\n    return JSON.parse(stored) as PendingMessage[];\n  } catch (error) {\n    console.error('[MessageBackup] Failed to get pending messages:', error);\n    return [];\n  }\n}",
      "references": [
        "localStorage",
        "STORAGE_KEY",
        "stored",
        "JSON",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/utils/messageBackup.ts:fn:clearAllPendingMessages:66": {
      "id": "file:web/src/lib/utils/messageBackup.ts:fn:clearAllPendingMessages:66",
      "type": "function",
      "name": "clearAllPendingMessages",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/utils/messageBackup.ts",
      "line": 66,
      "endLine": 73,
      "parentFileId": "file:web/src/lib/utils/messageBackup.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Clears pending messages from localStorage with error handling and logging",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function clearAllPendingMessages(): void {\n  try {\n    localStorage.removeItem(STORAGE_KEY);\n    console.log('[MessageBackup] Cleared all pending messages');\n  } catch (error) {\n    console.error('[MessageBackup] Failed to clear all pending messages:', error);\n  }\n}",
      "references": [
        "localStorage",
        "STORAGE_KEY",
        "console",
        "error"
      ]
    },
    "file:web/src/lib/village/beamShader.ts": {
      "id": "file:web/src/lib/village/beamShader.ts",
      "type": "file",
      "name": "beamShader.ts",
      "filePath": "web/src/lib/village/beamShader.ts",
      "line": 1,
      "endLine": 165,
      "imports": [
        {
          "source": "three",
          "items": [
            {
              "name": "THREE",
              "alias": null,
              "isDefault": false,
              "isNamespace": true
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "createBeamMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateBeamTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createOuterGlowMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BeamMaterialOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        }
      ],
      "functions": [
        "file:web/src/lib/village/beamShader.ts:fn:createBeamMaterial:100",
        "file:web/src/lib/village/beamShader.ts:fn:updateBeamTime:129",
        "file:web/src/lib/village/beamShader.ts:fn:updateBeamColor:138",
        "file:web/src/lib/village/beamShader.ts:fn:createOuterGlowMaterial:153"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/village/beamShader.ts:fn:createBeamMaterial:100": {
      "id": "file:web/src/lib/village/beamShader.ts:fn:createBeamMaterial:100",
      "type": "function",
      "name": "createBeamMaterial",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/beamShader.ts",
      "line": 100,
      "endLine": 123,
      "parentFileId": "file:web/src/lib/village/beamShader.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "options",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/village/beamShader\").BeamMaterialOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/materials/ShaderMaterial\").ShaderMaterial",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates a Three.js ShaderMaterial for beam effects with customizable uniforms.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function createBeamMaterial(options: BeamMaterialOptions = {}): THREE.ShaderMaterial {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  const color = opts.color instanceof THREE.Color\n    ? opts.color\n    : new THREE.Color(opts.color);\n\n  return new THREE.ShaderMaterial({\n    uniforms: {\n      uTime: { value: 0 },\n      uColor: { value: color },\n      uOpacity: { value: opts.opacity },\n      uFrequency: { value: opts.frequency },\n      uAmplitude: { value: opts.amplitude },\n      uPhase: { value: opts.phase },\n    },\n    vertexShader: beamVertexShader,\n    fragmentShader: beamFragmentShader,\n    transparent: true,\n    side: THREE.DoubleSide,\n    depthWrite: false, // Better blending for transparent beams\n    blending: THREE.NormalBlending,\n  });\n}",
      "references": [
        "DEFAULT_OPTIONS",
        "opts",
        "THREE",
        "color",
        "beamVertexShader",
        "beamFragmentShader"
      ]
    },
    "file:web/src/lib/village/beamShader.ts:fn:updateBeamTime:129": {
      "id": "file:web/src/lib/village/beamShader.ts:fn:updateBeamTime:129",
      "type": "function",
      "name": "updateBeamTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/beamShader.ts",
      "line": 129,
      "endLine": 133,
      "parentFileId": "file:web/src/lib/village/beamShader.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "material",
          "type": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/materials/ShaderMaterial\").ShaderMaterial",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "time",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Updates uTime uniform value in ShaderMaterial if it exists.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.259Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function updateBeamTime(material: THREE.ShaderMaterial, time: number): void {\n  if (material.uniforms.uTime) {\n    material.uniforms.uTime.value = time;\n  }\n}",
      "references": []
    },
    "file:web/src/lib/village/beamShader.ts:fn:updateBeamColor:138": {
      "id": "file:web/src/lib/village/beamShader.ts:fn:updateBeamColor:138",
      "type": "function",
      "name": "updateBeamColor",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/beamShader.ts",
      "line": 138,
      "endLine": 143,
      "parentFileId": "file:web/src/lib/village/beamShader.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "material",
          "type": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/materials/ShaderMaterial\").ShaderMaterial",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "color",
          "type": "string | import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/math/Color\").Color",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "void",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Updates uColor uniform of ShaderMaterial with given color.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:30.695Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function updateBeamColor(material: THREE.ShaderMaterial, color: THREE.Color | string): void {\n  if (material.uniforms.uColor) {\n    const c = color instanceof THREE.Color ? color : new THREE.Color(color);\n    material.uniforms.uColor.value = c;\n  }\n}",
      "references": [
        "THREE",
        "c"
      ]
    },
    "file:web/src/lib/village/beamShader.ts:fn:createOuterGlowMaterial:153": {
      "id": "file:web/src/lib/village/beamShader.ts:fn:createOuterGlowMaterial:153",
      "type": "function",
      "name": "createOuterGlowMaterial",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/beamShader.ts",
      "line": 153,
      "endLine": 164,
      "parentFileId": "file:web/src/lib/village/beamShader.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "color",
          "type": "string | import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/math/Color\").Color",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/node_modules/.pnpm/@types+three@0.182.0/node_modules/@types/three/src/materials/MeshBasicMaterial\").MeshBasicMaterial",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates THREE.MeshBasicMaterial for outer glow effect with given color.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.338Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function createOuterGlowMaterial(color: THREE.Color | string): THREE.MeshBasicMaterial {\n  const c = color instanceof THREE.Color ? color : new THREE.Color(color);\n\n  return new THREE.MeshBasicMaterial({\n    color: c,\n    transparent: true,\n    opacity: 0.15,\n    side: THREE.DoubleSide,\n    depthWrite: false,\n    blending: THREE.AdditiveBlending,\n  });\n}",
      "references": [
        "THREE",
        "c"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts": {
      "id": "file:web/src/lib/village/hexGrid.ts",
      "type": "file",
      "name": "hexGrid.ts",
      "filePath": "web/src/lib/village/hexGrid.ts",
      "line": 1,
      "endLine": 201,
      "imports": [
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "HexCoord",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillagePosition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "hexToWorld",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "worldToHex",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "spiralHexPositions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "calculateBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "hexAdd",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DEFAULT_HEX_SIZE",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/lib/village/hexGrid.ts:fn:hexToWorld:29",
        "file:web/src/lib/village/hexGrid.ts:fn:worldToHex:56",
        "file:web/src/lib/village/hexGrid.ts:fn:hexRound:71",
        "file:web/src/lib/village/hexGrid.ts:fn:spiralHexPositions:104",
        "file:web/src/lib/village/hexGrid.ts:fn:calculateBounds:161",
        "file:web/src/lib/village/hexGrid.ts:fn:hexAdd:193"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/village/hexGrid.ts:fn:hexToWorld:29": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:hexToWorld:29",
      "type": "function",
      "name": "hexToWorld",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 29,
      "endLine": 47,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "coord",
          "type": "HexCoord",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "hexSize",
          "type": "number",
          "isOptional": true,
          "defaultValue": "DEFAULT_HEX_SIZE"
        }
      ],
      "returnType": "VillagePosition",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts hex coordinates (q,r) to world position (x,z) using pointy-top layout formulas",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.338Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function hexToWorld(coord: HexCoord, hexSize: number = DEFAULT_HEX_SIZE): VillagePosition {\n  // Validate inputs\n  if (!coord || !Number.isFinite(coord.q) || !Number.isFinite(coord.r)) {\n    console.warn('[hexToWorld] Invalid coord:', coord);\n    return { x: 0, z: 0 };\n  }\n  if (!Number.isFinite(hexSize) || hexSize <= 0) {\n    console.warn('[hexToWorld] Invalid hexSize:', hexSize);\n    return { x: 0, z: 0 };\n  }\n\n  const { q, r } = coord;\n\n  // Pointy-top hex layout\n  const x = hexSize * (Math.sqrt(3) * q + (Math.sqrt(3) / 2) * r);\n  const z = hexSize * ((3 / 2) * r);\n\n  return { x, z };\n}",
      "references": [
        "Number",
        "console",
        "q",
        "r",
        "Math",
        "x",
        "z"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts:fn:worldToHex:56": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:worldToHex:56",
      "type": "function",
      "name": "worldToHex",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 56,
      "endLine": 65,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "position",
          "type": "VillagePosition",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "hexSize",
          "type": "number",
          "isOptional": true,
          "defaultValue": "DEFAULT_HEX_SIZE"
        }
      ],
      "returnType": "HexCoord",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Converts 2D world position (x,z) to nearest hex grid coordinate.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.338Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function worldToHex(position: VillagePosition, hexSize: number = DEFAULT_HEX_SIZE): HexCoord {\n  const { x, z } = position;\n\n  // Convert to fractional hex coordinates\n  const q = ((Math.sqrt(3) / 3) * x - (1 / 3) * z) / hexSize;\n  const r = ((2 / 3) * z) / hexSize;\n\n  // Round to nearest hex\n  return hexRound(q, r);\n}",
      "references": [
        "x",
        "z",
        "Math",
        "hexRound",
        "q",
        "r"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts:fn:hexRound:71": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:hexRound:71",
      "type": "function",
      "name": "hexRound",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 71,
      "endLine": 91,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "q",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "r",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "HexCoord",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Rounds axial hex coordinates (q, r) to nearest integer cube coordinates ensuring q + r + s = 0",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.338Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function hexRound(q: number, r: number): HexCoord {\n  // Convert to cube coordinates\n  const s = -q - r;\n\n  let rq = Math.round(q);\n  let rr = Math.round(r);\n  let rs = Math.round(s);\n\n  const qDiff = Math.abs(rq - q);\n  const rDiff = Math.abs(rr - r);\n  const sDiff = Math.abs(rs - s);\n\n  // Cube coordinates must sum to 0\n  if (qDiff > rDiff && qDiff > sDiff) {\n    rq = -rr - rs;\n  } else if (rDiff > sDiff) {\n    rr = -rq - rs;\n  }\n\n  return { q: rq, r: rr };\n}",
      "references": [
        "Math",
        "s",
        "rq",
        "rr",
        "rs",
        "qDiff",
        "rDiff",
        "sDiff"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts:fn:spiralHexPositions:104": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:spiralHexPositions:104",
      "type": "function",
      "name": "spiralHexPositions",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 104,
      "endLine": 152,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "count",
          "type": "number",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "HexCoord[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates spiral hexagonal grid positions from center up to given count",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:28.338Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function spiralHexPositions(count: number): HexCoord[] {\n  if (count <= 0) return [];\n\n  const positions: HexCoord[] = [{ q: 0, r: 0 }]; // Start at center\n\n  if (count === 1) return positions;\n\n  // Direction vectors for pointy-top hex (6 directions)\n  // Order: SE, SW, W, NW, NE, E (walking counterclockwise from East start)\n  const directions: HexCoord[] = [\n    { q: 0, r: 1 },   // SE\n    { q: -1, r: 1 },  // SW\n    { q: -1, r: 0 },  // W\n    { q: 0, r: -1 },  // NW\n    { q: 1, r: -1 },  // NE\n    { q: 1, r: 0 },   // E\n  ];\n\n  let current: HexCoord = { q: 0, r: 0 };\n  let ring = 1;\n\n  while (positions.length < count) {\n    // Move to the start of the next ring (East direction)\n    current = { q: current.q + 1, r: current.r };\n    // Push the starting position of this ring\n    positions.push({ ...current });\n    if (positions.length >= count) break;\n\n    // Walk around the ring (6 sides, each with 'ring' steps)\n    for (let side = 0; side < 6 && positions.length < count; side++) {\n      // Number of steps per side equals the ring number\n      // On first side, we already pushed the start, so start from step 1\n      const startStep = (side === 0) ? 1 : 0;\n      for (let step = startStep; step < ring && positions.length < count; step++) {\n        // Move in the current direction\n        const dir = directions[side];\n        current = { q: current.q + dir.q, r: current.r + dir.r };\n        positions.push({ ...current });\n      }\n    }\n\n    ring++;\n\n    // Safety limit to prevent infinite loops\n    if (ring > 20) break;\n  }\n\n  return positions.slice(0, count);\n}",
      "references": [
        "positions",
        "current",
        "side",
        "startStep",
        "step",
        "ring",
        "directions",
        "dir"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts:fn:calculateBounds:161": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:calculateBounds:161",
      "type": "function",
      "name": "calculateBounds",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 161,
      "endLine": 184,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "positions",
          "type": "VillagePosition[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "{ minX: number; maxX: number; minZ: number; maxZ: number; }",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Calculates min/max X and Z bounds for an array of village positions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:30.533Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function calculateBounds(positions: VillagePosition[]): {\n  minX: number;\n  maxX: number;\n  minZ: number;\n  maxZ: number;\n} {\n  if (positions.length === 0) {\n    return { minX: 0, maxX: 0, minZ: 0, maxZ: 0 };\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minZ = Infinity;\n  let maxZ = -Infinity;\n\n  for (const pos of positions) {\n    minX = Math.min(minX, pos.x);\n    maxX = Math.max(maxX, pos.x);\n    minZ = Math.min(minZ, pos.z);\n    maxZ = Math.max(maxZ, pos.z);\n  }\n\n  return { minX, maxX, minZ, maxZ };\n}",
      "references": [
        "minX",
        "Math",
        "pos",
        "maxX",
        "minZ",
        "maxZ"
      ]
    },
    "file:web/src/lib/village/hexGrid.ts:fn:hexAdd:193": {
      "id": "file:web/src/lib/village/hexGrid.ts:fn:hexAdd:193",
      "type": "function",
      "name": "hexAdd",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/hexGrid.ts",
      "line": 193,
      "endLine": 199,
      "parentFileId": "file:web/src/lib/village/hexGrid.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "a",
          "type": "HexCoord",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "b",
          "type": "HexCoord",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "HexCoord",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Adds two hexagonal coordinates (q,r) component-wise, warns on invalid input.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:31.385Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function hexAdd(a: HexCoord, b: HexCoord): HexCoord {\n  if (!a || !b) {\n    console.warn('[hexAdd] Invalid input:', { a, b });\n    return { q: 0, r: 0 };\n  }\n  return { q: a.q + b.q, r: a.r + b.r };\n}",
      "references": [
        "console"
      ]
    },
    "file:web/src/lib/village/index.ts": {
      "id": "file:web/src/lib/village/index.ts",
      "type": "file",
      "name": "index.ts",
      "filePath": "web/src/lib/village/index.ts",
      "line": 1,
      "endLine": 43,
      "imports": [],
      "exports": [
        {
          "name": "hexToWorld",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "worldToHex",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "spiralHexPositions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "calculateBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "hexAdd",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "DEFAULT_HEX_SIZE",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "buildVillageLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createEmptyLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateVillagers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BUILDING_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "preloadAllBuildingModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "PROP_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "getPropConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPropPath",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "preloadAllPropModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BuildingModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PropType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "PropModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "createBeamMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "updateBeamTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createOuterGlowMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BeamMaterialOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "hexToWorld",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "worldToHex",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "spiralHexPositions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "calculateBounds",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "hexAdd",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "DEFAULT_HEX_SIZE",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./hexGrid"
        },
        {
          "name": "buildVillageLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./layout"
        },
        {
          "name": "createEmptyLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./layout"
        },
        {
          "name": "generateProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./layout"
        },
        {
          "name": "generateVillagers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./layout"
        },
        {
          "name": "BUILDING_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "getModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "preloadAllBuildingModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "PROP_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "getPropConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "getPropPath",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "preloadAllPropModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "BuildingModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "PropType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "PropModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./models"
        },
        {
          "name": "createBeamMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./beamShader"
        },
        {
          "name": "updateBeamTime",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./beamShader"
        },
        {
          "name": "createOuterGlowMaterial",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "reexport",
          "source": "./beamShader"
        },
        {
          "name": "BeamMaterialOptions",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "reexport",
          "source": "./beamShader"
        }
      ],
      "functions": [],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/village/layout.ts": {
      "id": "file:web/src/lib/village/layout.ts",
      "type": "file",
      "name": "layout.ts",
      "filePath": "web/src/lib/village/layout.ts",
      "line": 1,
      "endLine": 690,
      "imports": [
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "ForceGraphData",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphLink",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "VillageLayout",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageBuilding",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageRoad",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageDistrict",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayoutOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemoryCategory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BuildingType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "HexCoord",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillagePosition",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageProp",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayoutWithProps",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageVillager",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillagerType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "VillageLayoutFull",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/village/models",
          "items": [
            {
              "name": "PropType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "DISTRICT_LAYOUT",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CATEGORY_TO_BUILDING",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BUILDING_COLORS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CATEGORY_KEYWORDS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "./hexGrid",
          "items": [
            {
              "name": "hexToWorld",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "worldToHex",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "hexAdd",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "spiralHexPositions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "calculateBounds",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_HEX_SIZE",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "buildVillageLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "createEmptyLayout",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateProps",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "generateVillagers",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/lib/village/layout.ts:fn:buildVillageLayout:61",
        "file:web/src/lib/village/layout.ts:fn:categorizeMemories:142",
        "file:web/src/lib/village/layout.ts:fn:classifyMemory:163",
        "file:web/src/lib/village/layout.ts:fn:placeBuildingsInDistricts:209",
        "file:web/src/lib/village/layout.ts:fn:generateRoads:298",
        "file:web/src/lib/village/layout.ts:fn:calculateDistricts:345",
        "file:web/src/lib/village/layout.ts:fn:createEmptyLayout:394",
        "file:web/src/lib/village/layout.ts:fn:generateValidHexTiles:431",
        "file:web/src/lib/village/layout.ts:fn:generateProps:470",
        "file:web/src/lib/village/layout.ts:fn:generateVillagers:600"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/lib/village/layout.ts:fn:buildVillageLayout:61": {
      "id": "file:web/src/lib/village/layout.ts:fn:buildVillageLayout:61",
      "type": "function",
      "name": "buildVillageLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 61,
      "endLine": 133,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "graphData",
          "type": "ForceGraphData",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "VillageLayoutOptions",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "VillageLayout",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Builds village layout from graph: filters/sorts memories, categorizes/places buildings, generates roads, computes bounds",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export function buildVillageLayout(\n  graphData: ForceGraphData,\n  options: VillageLayoutOptions = {}\n): VillageLayout {\n  // Filter out undefined values so they don't override defaults\n  const cleanOptions = Object.fromEntries(\n    Object.entries(options).filter(([_, v]) => v !== undefined)\n  );\n  const opts = { ...DEFAULT_OPTIONS, ...cleanOptions } as Required<VillageLayoutOptions>;\n\n  // Filter to memory nodes only (entities become decorations in Phase 3)\n  const memoryNodes = graphData.nodes.filter(node => node.type === 'memory');\n\n  console.log('[buildVillageLayout] Input:', {\n    totalNodes: graphData.nodes.length,\n    memoryNodes: memoryNodes.length,\n    nodeTypes: [...new Set(graphData.nodes.map(n => n.type))],\n  });\n\n  // Sort by salience (highest first) and filter by min salience\n  const sortedMemories = memoryNodes\n    .filter(node => {\n      const salience = (node.attributes?.salience as number) ?? 0.5;\n      return salience >= opts.minSalience;\n    })\n    .sort((a, b) => {\n      const salienceA = (a.attributes?.salience as number) ?? 0.5;\n      const salienceB = (b.attributes?.salience as number) ?? 0.5;\n      return salienceB - salienceA;\n    });\n\n  // Cap to max buildings\n  const memoriesSkipped = Math.max(0, sortedMemories.length - opts.maxBuildings);\n  const memoriesToPlace = sortedMemories.slice(0, opts.maxBuildings);\n\n  // Categorize memories into districts\n  const categorized = categorizeMemories(memoriesToPlace);\n\n  // Place buildings in districts\n  const buildings = placeBuildingsInDistricts(categorized, opts);\n\n  // Create building ID lookup for road generation\n  const buildingByMemoryId = new Map(buildings.map(b => [b.memoryId, b]));\n\n  // Generate roads from graph edges\n  const roads = generateRoads(graphData.links, buildingByMemoryId);\n\n  // Calculate district bounds\n  const districts = calculateDistricts(buildings);\n\n  // Calculate overall bounds\n  const allPositions = buildings.map(b => b.position);\n  const bounds = calculateBounds(allPositions);\n\n  // Add padding to bounds\n  const padding = opts.hexSize * 2;\n  bounds.minX -= padding;\n  bounds.maxX += padding;\n  bounds.minZ -= padding;\n  bounds.maxZ += padding;\n\n  return {\n    buildings,\n    roads,\n    districts,\n    bounds,\n    stats: {\n      totalBuildings: buildings.length,\n      totalRoads: roads.length,\n      memoriesSkipped,\n    },\n  };\n}",
      "references": [
        "Object",
        "_",
        "v",
        "DEFAULT_OPTIONS",
        "cleanOptions",
        "node",
        "console",
        "memoryNodes",
        "Set",
        "n",
        "salience",
        "opts",
        "a",
        "b",
        "salienceB",
        "salienceA",
        "Math",
        "sortedMemories",
        "categorizeMemories",
        "memoriesToPlace",
        "placeBuildingsInDistricts",
        "categorized",
        "Map",
        "buildings",
        "generateRoads",
        "buildingByMemoryId",
        "calculateDistricts",
        "calculateBounds",
        "allPositions",
        "bounds",
        "padding",
        "roads",
        "districts",
        "memoriesSkipped"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:categorizeMemories:142": {
      "id": "file:web/src/lib/village/layout.ts:fn:categorizeMemories:142",
      "type": "function",
      "name": "categorizeMemories",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 142,
      "endLine": 158,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "ForceGraphNode[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Map<MemoryCategory, ForceGraphNode[]>",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Categorizes ForceGraphNode memories into a Map by MemoryCategory using classifyMemory.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function categorizeMemories(\n  memories: ForceGraphNode[]\n): Map<MemoryCategory, ForceGraphNode[]> {\n  const categorized = new Map<MemoryCategory, ForceGraphNode[]>();\n\n  // Initialize all categories\n  for (const category of Object.keys(DISTRICT_LAYOUT) as MemoryCategory[]) {\n    categorized.set(category, []);\n  }\n\n  for (const memory of memories) {\n    const category = classifyMemory(memory);\n    categorized.get(category)!.push(memory);\n  }\n\n  return categorized;\n}",
      "references": [
        "Map",
        "Object",
        "DISTRICT_LAYOUT",
        "categorized",
        "category",
        "classifyMemory",
        "memory"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:classifyMemory:163": {
      "id": "file:web/src/lib/village/layout.ts:fn:classifyMemory:163",
      "type": "function",
      "name": "classifyMemory",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 163,
      "endLine": 200,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "memory",
          "type": "ForceGraphNode",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "MemoryCategory",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Classifies memory node into category by matching keywords in label, tags, content",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function classifyMemory(memory: ForceGraphNode): MemoryCategory {\n  const label = memory.label.toLowerCase();\n  const tags = (memory.attributes?.tags as string[]) ?? [];\n  const content = (memory.attributes?.content as string) ?? '';\n  const textToSearch = `${label} ${tags.join(' ')} ${content}`.toLowerCase();\n\n  // Check each category's keywords\n  let bestCategory: MemoryCategory = 'misc';\n  let bestScore = 0;\n\n  for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS) as [MemoryCategory, string[]][]) {\n    if (keywords.length === 0) continue; // Skip misc\n\n    let score = 0;\n    for (const keyword of keywords) {\n      if (textToSearch.includes(keyword)) {\n        score++;\n      }\n    }\n\n    if (score > bestScore) {\n      bestScore = score;\n      bestCategory = category;\n    }\n  }\n\n  // If no keywords matched, check tags for direct category matches\n  if (bestScore === 0) {\n    const tagStr = tags.join(' ').toLowerCase();\n    for (const category of Object.keys(DISTRICT_LAYOUT) as MemoryCategory[]) {\n      if (tagStr.includes(category)) {\n        return category;\n      }\n    }\n  }\n\n  return bestCategory;\n}",
      "references": [
        "label",
        "tags",
        "content",
        "category",
        "keywords",
        "Object",
        "CATEGORY_KEYWORDS",
        "textToSearch",
        "keyword",
        "score",
        "bestScore",
        "bestCategory",
        "DISTRICT_LAYOUT",
        "tagStr"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:placeBuildingsInDistricts:209": {
      "id": "file:web/src/lib/village/layout.ts:fn:placeBuildingsInDistricts:209",
      "type": "function",
      "name": "placeBuildingsInDistricts",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 209,
      "endLine": 289,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "categorized",
          "type": "Map<MemoryCategory, ForceGraphNode[]>",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "opts",
          "type": "VillageLayoutOptions",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "VillageBuilding[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Places categorized memories as buildings in hex districts using spiral positions and offsets",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function placeBuildingsInDistricts(\n  categorized: Map<MemoryCategory, ForceGraphNode[]>,\n  opts: Required<VillageLayoutOptions>\n): VillageBuilding[] {\n  const buildings: VillageBuilding[] = [];\n\n  for (const [category, memories] of categorized) {\n    if (memories.length === 0) continue;\n\n    // Get district center offset\n    const districtOffset = DISTRICT_LAYOUT[category];\n    if (!districtOffset) {\n      console.warn('[placeBuildingsInDistricts] No district offset for category:', category);\n      continue;\n    }\n\n    // Scale the district offset for spacing\n    const scaledOffset: HexCoord = {\n      q: Math.round(districtOffset.q * opts.districtSpacing),\n      r: Math.round(districtOffset.r * opts.districtSpacing),\n    };\n\n    // Generate spiral positions for this district\n    const spiralPositions = spiralHexPositions(memories.length);\n\n    console.log(`[placeBuildingsInDistricts] ${category}: ${memories.length} memories, ${spiralPositions.length} positions`);\n\n    for (let i = 0; i < memories.length; i++) {\n      const memory = memories[i];\n      const localHex = spiralPositions[i];\n\n      // Safety check for missing spiral position\n      if (!localHex) {\n        console.warn(`[placeBuildingsInDistricts] Missing spiral position at index ${i} for ${category}`);\n        continue;\n      }\n\n      // Combine district offset with local position\n      const hexCoord = hexAdd(scaledOffset, localHex);\n      const position = hexToWorld(hexCoord, opts.hexSize);\n\n      // Validate position\n      if (!Number.isFinite(position.x) || !Number.isFinite(position.z)) {\n        console.warn('[placeBuildingsInDistricts] NaN position:', {\n          memoryId: memory.id,\n          category,\n          index: i,\n          localHex,\n          scaledOffset,\n          hexCoord,\n          position,\n          hexSize: opts.hexSize,\n        });\n        continue;\n      }\n\n      // Extract memory attributes\n      const salience = (memory.attributes?.salience as number) ?? 0.5;\n      const emotionalValence = (memory.attributes?.emotionalValence as number) ?? 0;\n\n      // Determine building type\n      const buildingType: BuildingType = CATEGORY_TO_BUILDING[category];\n\n      buildings.push({\n        id: `building-${memory.id}`,\n        memoryId: memory.id,\n        position,\n        hexCoord,\n        buildingType,\n        category,\n        label: memory.label,\n        salience,\n        emotionalValence,\n        color: BUILDING_COLORS[buildingType],\n        district: category,\n      });\n    }\n  }\n\n  return buildings;\n}",
      "references": [
        "category",
        "memories",
        "DISTRICT_LAYOUT",
        "districtOffset",
        "console",
        "Math",
        "spiralHexPositions",
        "spiralPositions",
        "i",
        "localHex",
        "hexAdd",
        "scaledOffset",
        "hexToWorld",
        "hexCoord",
        "Number",
        "position",
        "memory",
        "CATEGORY_TO_BUILDING",
        "buildings",
        "buildingType",
        "salience",
        "emotionalValence",
        "BUILDING_COLORS"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:generateRoads:298": {
      "id": "file:web/src/lib/village/layout.ts:fn:generateRoads:298",
      "type": "function",
      "name": "generateRoads",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 298,
      "endLine": 336,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "edges",
          "type": "ForceGraphLink[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "buildingByMemoryId",
          "type": "Map<string, VillageBuilding>",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "VillageRoad[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates unique roads from graph edges between placed buildings, avoiding duplicates.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateRoads(\n  edges: ForceGraphLink[],\n  buildingByMemoryId: Map<string, VillageBuilding>\n): VillageRoad[] {\n  const roads: VillageRoad[] = [];\n  const roadSet = new Set<string>(); // Prevent duplicate roads\n\n  for (const edge of edges) {\n    // Get source and target as strings (may be objects after force graph processing)\n    const sourceId = typeof edge.source === 'string' ? edge.source : (edge.source as { id: string }).id;\n    const targetId = typeof edge.target === 'string' ? edge.target : (edge.target as { id: string }).id;\n\n    const fromBuilding = buildingByMemoryId.get(sourceId);\n    const toBuilding = buildingByMemoryId.get(targetId);\n\n    // Only create roads between placed buildings\n    if (!fromBuilding || !toBuilding) continue;\n\n    // Skip self-loops\n    if (fromBuilding.id === toBuilding.id) continue;\n\n    // Create unique road ID (sorted to prevent duplicates)\n    const roadKey = [fromBuilding.id, toBuilding.id].sort().join('-');\n    if (roadSet.has(roadKey)) continue;\n    roadSet.add(roadKey);\n\n    roads.push({\n      id: `road-${roadKey}`,\n      fromId: fromBuilding.id,\n      toId: toBuilding.id,\n      fromPosition: fromBuilding.position,\n      toPosition: toBuilding.position,\n      weight: edge.weight,\n      edgeType: edge.type,\n    });\n  }\n\n  return roads;\n}",
      "references": [
        "Set",
        "edge",
        "sourceId",
        "targetId",
        "fromBuilding",
        "toBuilding",
        "roadSet",
        "roadKey",
        "roads"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:calculateDistricts:345": {
      "id": "file:web/src/lib/village/layout.ts:fn:calculateDistricts:345",
      "type": "function",
      "name": "calculateDistricts",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 345,
      "endLine": 385,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buildings",
          "type": "VillageBuilding[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "VillageDistrict[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Groups village buildings by category and computes district centers and bounds.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function calculateDistricts(buildings: VillageBuilding[]): VillageDistrict[] {\n  const districtBuildings = new Map<MemoryCategory, VillageBuilding[]>();\n\n  // Group buildings by district\n  for (const building of buildings) {\n    const category = building.category;\n    if (!districtBuildings.has(category)) {\n      districtBuildings.set(category, []);\n    }\n    districtBuildings.get(category)!.push(building);\n  }\n\n  // Calculate district info\n  const districts: VillageDistrict[] = [];\n\n  for (const [category, districtBldgs] of districtBuildings) {\n    if (districtBldgs.length === 0) continue;\n\n    // Calculate center (average position)\n    const sumX = districtBldgs.reduce((sum, b) => sum + b.position.x, 0);\n    const sumZ = districtBldgs.reduce((sum, b) => sum + b.position.z, 0);\n\n    const center: VillagePosition = {\n      x: sumX / districtBldgs.length,\n      z: sumZ / districtBldgs.length,\n    };\n\n    // Calculate bounds\n    const positions = districtBldgs.map(b => b.position);\n    const bounds = calculateBounds(positions);\n\n    districts.push({\n      category,\n      center,\n      buildingCount: districtBldgs.length,\n      bounds,\n    });\n  }\n\n  return districts;\n}",
      "references": [
        "Map",
        "building",
        "districtBuildings",
        "category",
        "districtBldgs",
        "sum",
        "b",
        "sumX",
        "sumZ",
        "calculateBounds",
        "positions",
        "districts",
        "center",
        "bounds"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:createEmptyLayout:394": {
      "id": "file:web/src/lib/village/layout.ts:fn:createEmptyLayout:394",
      "type": "function",
      "name": "createEmptyLayout",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 394,
      "endLine": 406,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "VillageLayout",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Creates and returns an empty VillageLayout object with default bounds and stats.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.070Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function createEmptyLayout(): VillageLayout {\n  return {\n    buildings: [],\n    roads: [],\n    districts: [],\n    bounds: { minX: -10, maxX: 10, minZ: -10, maxZ: 10 },\n    stats: {\n      totalBuildings: 0,\n      totalRoads: 0,\n      memoriesSkipped: 0,\n    },\n  };\n}",
      "references": []
    },
    "file:web/src/lib/village/layout.ts:fn:generateValidHexTiles:431": {
      "id": "file:web/src/lib/village/layout.ts:fn:generateValidHexTiles:431",
      "type": "function",
      "name": "generateValidHexTiles",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 431,
      "endLine": 465,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "layout",
          "type": "VillageLayout",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "hexSize",
          "type": "number",
          "isOptional": true,
          "defaultValue": "DEFAULT_HEX_SIZE"
        }
      ],
      "returnType": "Set<string>",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates set of valid hex tile strings from village layout districts and center area.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.797Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function generateValidHexTiles(layout: VillageLayout, hexSize: number = DEFAULT_HEX_SIZE): Set<string> {\n  const validTiles = new Set<string>();\n  const padding = 1; // Same as VillageGround\n  \n  // Add tiles for each district\n  for (const district of layout.districts) {\n    const { minX, maxX, minZ, maxZ } = district.bounds;\n    const minHex = worldToHex({ x: minX, z: minZ }, hexSize);\n    const maxHex = worldToHex({ x: maxX, z: maxZ }, hexSize);\n    \n    for (let q = minHex.q - padding; q <= maxHex.q + padding; q++) {\n      for (let r = minHex.r - padding; r <= maxHex.r + padding; r++) {\n        const worldPos = hexToWorld({ q, r }, hexSize);\n        const inBounds =\n          worldPos.x >= minX - hexSize * 2 &&\n          worldPos.x <= maxX + hexSize * 2 &&\n          worldPos.z >= minZ - hexSize * 2 &&\n          worldPos.z <= maxZ + hexSize * 2;\n        if (inBounds) {\n          validTiles.add(`${q},${r}`);\n        }\n      }\n    }\n  }\n  \n  // Add center connector tiles\n  const centerRange = 3;\n  for (let q = -centerRange; q <= centerRange; q++) {\n    for (let r = -centerRange; r <= centerRange; r++) {\n      validTiles.add(`${q},${r}`);\n    }\n  }\n  \n  return validTiles;\n}",
      "references": [
        "Set",
        "minX",
        "maxX",
        "minZ",
        "maxZ",
        "district",
        "worldToHex",
        "minHex",
        "padding",
        "q",
        "maxHex",
        "r",
        "hexToWorld",
        "worldPos",
        "inBounds",
        "validTiles",
        "centerRange"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:generateProps:470": {
      "id": "file:web/src/lib/village/layout.ts:fn:generateProps:470",
      "type": "function",
      "name": "generateProps",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 470,
      "endLine": 580,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "layout",
          "type": "VillageLayout",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "options",
          "type": "{ propsPerBuilding?: number; treeDensity?: number; }",
          "isOptional": true,
          "defaultValue": "{}"
        }
      ],
      "returnType": "VillageProp[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates village props around buildings on valid hex tiles, avoiding overlaps.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.172Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function generateProps(\n  layout: VillageLayout,\n  options: { propsPerBuilding?: number; treeDensity?: number } = {}\n): VillageProp[] {\n  const { propsPerBuilding = 2, treeDensity = 0.3 } = options;\n  const props: VillageProp[] = [];\n  const occupiedPositions = new Set<string>();\n  const hexSize = DEFAULT_HEX_SIZE;\n  \n  // Generate valid hex tiles to constrain prop placement\n  const validHexTiles = generateValidHexTiles(layout, hexSize);\n\n  // Track building positions to avoid overlap\n  layout.buildings.forEach((b) => {\n    occupiedPositions.add(`${Math.round(b.position.x)},${Math.round(b.position.z)}`);\n  });\n\n  const isOccupied = (x: number, z: number): boolean => {\n    const key = `${Math.round(x)},${Math.round(z)}`;\n    return occupiedPositions.has(key);\n  };\n\n  const addOccupied = (x: number, z: number): void => {\n    occupiedPositions.add(`${Math.round(x)},${Math.round(z)}`);\n  };\n  \n  // Check if position is on valid hex tile\n  const isOnValidTile = (x: number, z: number): boolean => {\n    const hex = worldToHex({ x, z }, hexSize);\n    return validHexTiles.has(`${hex.q},${hex.r}`);\n  };\n\n  // 1. Add decoration props near each building (district-specific)\n  layout.buildings.forEach((building, buildingIdx) => {\n    for (let i = 0; i < propsPerBuilding; i++) {\n      const angle = (Math.PI * 2 * i) / propsPerBuilding + buildingIdx * 0.5;\n      const distance = 1.5 + Math.random() * 0.5;\n      const x = building.position.x + Math.cos(angle) * distance;\n      const z = building.position.z + Math.sin(angle) * distance;\n\n      if (isOccupied(x, z) || !isOnValidTile(x, z)) continue;\n\n      // Use district-specific props for variety\n      const districtProps = DISTRICT_PROPS[building.category] ?? DECOR_TYPES;\n      const propType = districtProps[(buildingIdx + i) % districtProps.length];\n      props.push({\n        id: `prop-${building.id}-${i}`,\n        propType,\n        position: { x, z },\n        rotation: Math.random() * Math.PI * 2,\n        scale: 0.8 + Math.random() * 0.4,\n      });\n      addOccupied(x, z);\n    }\n  });\n\n  // 2. Add trees and rocks on valid hex tiles (edge areas of districts)\n  // Convert valid tiles to array for sampling\n  const validTileArray = Array.from(validHexTiles).map(key => {\n    const [q, r] = key.split(',').map(Number);\n    return hexToWorld({ q, r }, hexSize);\n  });\n  \n  // Shuffle for random distribution (seeded by layout size for consistency)\n  const shuffled = [...validTileArray].sort(() => Math.random() - 0.5);\n  \n  // Place trees on valid tiles (no offset - place at hex centers only)\n  const numTrees = Math.floor(layout.buildings.length * treeDensity * 1.5);\n  let treeCount = 0;\n  for (let i = 0; i < shuffled.length && treeCount < numTrees; i++) {\n    const pos = shuffled[i];\n    // Use hex center position directly - no offset that could push off tile\n    const x = pos.x;\n    const z = pos.z;\n    \n    if (isOccupied(x, z) || !isOnValidTile(x, z)) continue;\n    \n    props.push({\n      id: `tree-${treeCount}`,\n      propType: TREE_TYPES[treeCount % TREE_TYPES.length],\n      position: { x, z },\n      rotation: Math.random() * Math.PI * 2,\n      scale: 0.9 + Math.random() * 0.3,\n    });\n    addOccupied(x, z);\n    treeCount++;\n  }\n\n  // 3. Add scattered rocks on valid tiles (hex centers only)\n  const numRocks = Math.floor(layout.buildings.length * 0.15);\n  let rockCount = 0;\n  for (let i = shuffled.length - 1; i >= 0 && rockCount < numRocks; i--) {\n    const pos = shuffled[i];\n    const x = pos.x;\n    const z = pos.z;\n\n    if (isOccupied(x, z) || !isOnValidTile(x, z)) continue;\n\n    props.push({\n      id: `rock-${rockCount}`,\n      propType: ROCK_TYPES[rockCount % ROCK_TYPES.length],\n      position: { x, z },\n      rotation: Math.random() * Math.PI * 2,\n      scale: 0.7 + Math.random() * 0.6,\n    });\n    addOccupied(x, z);\n    rockCount++;\n  }\n\n  return props;\n}",
      "references": [
        "propsPerBuilding",
        "treeDensity",
        "Set",
        "DEFAULT_HEX_SIZE",
        "generateValidHexTiles",
        "hexSize",
        "occupiedPositions",
        "Math",
        "b",
        "x",
        "z",
        "key",
        "worldToHex",
        "validHexTiles",
        "hex",
        "i",
        "buildingIdx",
        "building",
        "angle",
        "distance",
        "isOccupied",
        "isOnValidTile",
        "DISTRICT_PROPS",
        "DECOR_TYPES",
        "districtProps",
        "props",
        "propType",
        "addOccupied",
        "Array",
        "q",
        "r",
        "Number",
        "hexToWorld",
        "validTileArray",
        "shuffled",
        "treeCount",
        "numTrees",
        "pos",
        "TREE_TYPES",
        "rockCount",
        "numRocks",
        "ROCK_TYPES"
      ]
    },
    "file:web/src/lib/village/layout.ts:fn:generateVillagers:600": {
      "id": "file:web/src/lib/village/layout.ts:fn:generateVillagers:600",
      "type": "function",
      "name": "generateVillagers",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/layout.ts",
      "line": 600,
      "endLine": 688,
      "parentFileId": "file:web/src/lib/village/layout.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "graphData",
          "type": "ForceGraphData",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "layout",
          "type": "VillageLayout",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "VillageVillager[]",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Generates VillageVillager[] from graph entity nodes and their memory-linked buildings in layout",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.026Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function generateVillagers(\n  graphData: ForceGraphData,\n  layout: VillageLayout\n): VillageVillager[] {\n  const villagers: VillageVillager[] = [];\n  \n  // Get entity nodes\n  const entityNodes = graphData.nodes.filter(node => node.type === 'entity');\n  \n  // Build lookup for memory -> building\n  const buildingByMemoryId = new Map(layout.buildings.map(b => [b.memoryId, b]));\n  \n  // Build lookup for entity -> connected memories (from edges)\n  const entityToMemories = new Map<string, string[]>();\n  \n  graphData.links.forEach(link => {\n    const sourceId = typeof link.source === 'string' ? link.source : (link.source as { id: string }).id;\n    const targetId = typeof link.target === 'string' ? link.target : (link.target as { id: string }).id;\n    \n    // Find edges connecting entities to memories\n    const sourceNode = graphData.nodes.find(n => n.id === sourceId);\n    const targetNode = graphData.nodes.find(n => n.id === targetId);\n    \n    if (sourceNode?.type === 'entity' && targetNode?.type === 'memory') {\n      const list = entityToMemories.get(sourceId) ?? [];\n      list.push(targetId);\n      entityToMemories.set(sourceId, list);\n    } else if (targetNode?.type === 'entity' && sourceNode?.type === 'memory') {\n      const list = entityToMemories.get(targetId) ?? [];\n      list.push(sourceId);\n      entityToMemories.set(targetId, list);\n    }\n  });\n  \n  // Place villagers near their most connected building\n  entityNodes.forEach((entity, idx) => {\n    const connectedMemoryIds = entityToMemories.get(entity.id) ?? [];\n    \n    // Find the building with the most connections to this entity\n    let bestBuilding: VillageBuilding | null = null;\n    let maxConnections = 0;\n    \n    const buildingConnections = new Map<string, number>();\n    connectedMemoryIds.forEach(memId => {\n      const building = buildingByMemoryId.get(memId);\n      if (building) {\n        const count = (buildingConnections.get(building.id) ?? 0) + 1;\n        buildingConnections.set(building.id, count);\n        if (count > maxConnections) {\n          maxConnections = count;\n          bestBuilding = building;\n        }\n      }\n    });\n    \n    // If no connected building, place near a random building\n    if (!bestBuilding && layout.buildings.length > 0) {\n      bestBuilding = layout.buildings[idx % layout.buildings.length];\n    }\n    \n    if (!bestBuilding) return;\n    \n    // Position villager offset from building\n    const angle = (idx * 137.5 * Math.PI / 180); // Golden angle for distribution\n    const distance = 2 + (idx % 3) * 0.5;\n    const position: VillagePosition = {\n      x: bestBuilding.position.x + Math.cos(angle) * distance,\n      z: bestBuilding.position.z + Math.sin(angle) * distance,\n    };\n    \n    // Determine villager type from entity type\n    const entityType = (entity.attributes?.entity_type as string) ?? 'person';\n    const villagerType = ENTITY_TYPE_TO_VILLAGER[entityType] ?? 'peasant';\n    \n    villagers.push({\n      id: `villager-${entity.id}`,\n      entityId: entity.id,\n      name: entity.label,\n      entityType,\n      villagerType,\n      position,\n      rotation: Math.random() * Math.PI * 2,\n      nearBuildingId: bestBuilding.id,\n    });\n  });\n  \n  // Cap villagers for performance (max 30)\n  return villagers.slice(0, 30);\n}",
      "references": [
        "node",
        "Map",
        "b",
        "link",
        "n",
        "sourceId",
        "targetId",
        "sourceNode",
        "targetNode",
        "entityToMemories",
        "list",
        "entityNodes",
        "entity",
        "connectedMemoryIds",
        "buildingByMemoryId",
        "memId",
        "building",
        "buildingConnections",
        "count",
        "maxConnections",
        "bestBuilding",
        "idx",
        "Math",
        "angle",
        "distance",
        "ENTITY_TYPE_TO_VILLAGER",
        "entityType",
        "villagers",
        "villagerType",
        "position"
      ]
    },
    "file:web/src/lib/village/models.ts": {
      "id": "file:web/src/lib/village/models.ts",
      "type": "file",
      "name": "models.ts",
      "filePath": "web/src/lib/village/models.ts",
      "line": 1,
      "endLine": 285,
      "imports": [
        {
          "source": "@react-three/drei",
          "items": [
            {
              "name": "useGLTF",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types/village",
          "items": [
            {
              "name": "BuildingType",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "getModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "preloadAllBuildingModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPropConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "getPropPath",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "preloadAllPropModels",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "function"
        },
        {
          "name": "BuildingModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "BUILDING_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        },
        {
          "name": "PropType",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "type"
        },
        {
          "name": "PropModelConfig",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": true,
          "kind": "interface"
        },
        {
          "name": "PROP_MODEL_CONFIGS",
          "alias": null,
          "isDefault": false,
          "isTypeOnly": false,
          "kind": "variable"
        }
      ],
      "functions": [
        "file:web/src/lib/village/models.ts:fn:getModelPath:122",
        "file:web/src/lib/village/models.ts:fn:getModelConfig:129",
        "file:web/src/lib/village/models.ts:fn:preloadAllBuildingModels:143",
        "file:web/src/lib/village/models.ts:fn:getPropConfig:265",
        "file:web/src/lib/village/models.ts:fn:getPropPath:272",
        "file:web/src/lib/village/models.ts:fn:preloadAllPropModels:279"
      ],
      "classes": [],
      "topLevelReferences": [
        "MODELS_BASE_PATH",
        "Math",
        "PROPS_BASE_PATH"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:getModelPath:122": {
      "id": "file:web/src/lib/village/models.ts:fn:getModelPath:122",
      "type": "function",
      "name": "getModelPath",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 122,
      "endLine": 124,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buildingType",
          "type": "BuildingType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves model path for a building type from BUILDING_MODEL_CONFIGS.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:31.495Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function getModelPath(buildingType: BuildingType): string {\n  return BUILDING_MODEL_CONFIGS[buildingType].path;\n}",
      "references": [
        "BUILDING_MODEL_CONFIGS"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:getModelConfig:129": {
      "id": "file:web/src/lib/village/models.ts:fn:getModelConfig:129",
      "type": "function",
      "name": "getModelConfig",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 129,
      "endLine": 131,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "buildingType",
          "type": "BuildingType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/village/models\").BuildingModelConfig",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves BuildingModelConfig for a given BuildingType from BUILDING_MODEL_CONFIGS.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.579Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getModelConfig(buildingType: BuildingType): BuildingModelConfig {\n  return BUILDING_MODEL_CONFIGS[buildingType];\n}",
      "references": [
        "BUILDING_MODEL_CONFIGS"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:preloadAllBuildingModels:143": {
      "id": "file:web/src/lib/village/models.ts:fn:preloadAllBuildingModels:143",
      "type": "function",
      "name": "preloadAllBuildingModels",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 143,
      "endLine": 148,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Preloads GLTF models for all building types using useGLTF.preload.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.579Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function preloadAllBuildingModels(): void {\n  ALL_BUILDING_TYPES.forEach((type) => {\n    const path = getModelPath(type);\n    useGLTF.preload(path);\n  });\n}",
      "references": [
        "ALL_BUILDING_TYPES",
        "getModelPath",
        "useGLTF",
        "path"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:getPropConfig:265": {
      "id": "file:web/src/lib/village/models.ts:fn:getPropConfig:265",
      "type": "function",
      "name": "getPropConfig",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 265,
      "endLine": 267,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "propType",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/village/models\").PropType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "import(\"/home/ridgetop/projects/squire/web/src/lib/village/models\").PropModelConfig",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves PropModelConfig for a given PropType from PROP_MODEL_CONFIGS.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:32.316Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getPropConfig(propType: PropType): PropModelConfig {\n  return PROP_MODEL_CONFIGS[propType];\n}",
      "references": [
        "PROP_MODEL_CONFIGS"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:getPropPath:272": {
      "id": "file:web/src/lib/village/models.ts:fn:getPropPath:272",
      "type": "function",
      "name": "getPropPath",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 272,
      "endLine": 274,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [
        {
          "name": "propType",
          "type": "import(\"/home/ridgetop/projects/squire/web/src/lib/village/models\").PropType",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Retrieves the path for a given PropType from PROP_MODEL_CONFIGS.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:31.733Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export function getPropPath(propType: PropType): string {\n  return PROP_MODEL_CONFIGS[propType].path;\n}",
      "references": [
        "PROP_MODEL_CONFIGS"
      ]
    },
    "file:web/src/lib/village/models.ts:fn:preloadAllPropModels:279": {
      "id": "file:web/src/lib/village/models.ts:fn:preloadAllPropModels:279",
      "type": "function",
      "name": "preloadAllPropModels",
      "filePath": "/home/ridgetop/projects/squire/web/src/lib/village/models.ts",
      "line": 279,
      "endLine": 283,
      "parentFileId": "file:web/src/lib/village/models.ts",
      "parentClassId": null,
      "params": [],
      "returnType": "void",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Preloads all GLTF models for property types using useGLTF.preload.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:34.425Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": true,
          "hasSideEffects": true
        }
      },
      "source": "export function preloadAllPropModels(): void {\n  ALL_PROP_TYPES.forEach((type) => {\n    useGLTF.preload(getPropPath(type));\n  });\n}",
      "references": [
        "ALL_PROP_TYPES",
        "useGLTF",
        "getPropPath"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx": {
      "id": "file:web/src/app/app/calendar/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/calendar/page.tsx",
      "line": 1,
      "endLine": 774,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "CalendarEvent",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "CalendarPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/calendar/page.tsx:fn:formatTime:13",
        "file:web/src/app/app/calendar/page.tsx:fn:formatDateShort:19",
        "file:web/src/app/app/calendar/page.tsx:fn:isSameDay:23",
        "file:web/src/app/app/calendar/page.tsx:fn:isToday:29",
        "file:web/src/app/app/calendar/page.tsx:fn:EventCard:39",
        "file:web/src/app/app/calendar/page.tsx:fn:EventDetailsPanel:119",
        "file:web/src/app/app/calendar/page.tsx:fn:CalendarPage:238"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx:fn:formatTime:13": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:formatTime:13",
      "type": "function",
      "name": "formatTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 13,
      "endLine": 17,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "allDay",
          "type": "boolean",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date string to time or 'All day' if allDay is true",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.811Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatTime(dateStr: string, allDay: boolean): string {\n  if (allDay) return 'All day';\n  const date = new Date(dateStr);\n  return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });\n}",
      "references": [
        "Date",
        "date"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx:fn:formatDateShort:19": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:formatDateShort:19",
      "type": "function",
      "name": "formatDateShort",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 19,
      "endLine": 21,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a Date to short month and numeric day string in en-US locale.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.811Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDateShort(date: Date): string {\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n}",
      "references": []
    },
    "file:web/src/app/app/calendar/page.tsx:fn:isSameDay:23": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:isSameDay:23",
      "type": "function",
      "name": "isSameDay",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 23,
      "endLine": 27,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "d1",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "d2",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if two Date objects represent the same day by comparing year, month, and date.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function isSameDay(d1: Date, d2: Date): boolean {\n  return d1.getFullYear() === d2.getFullYear() &&\n    d1.getMonth() === d2.getMonth() &&\n    d1.getDate() === d2.getDate();\n}",
      "references": []
    },
    "file:web/src/app/app/calendar/page.tsx:fn:isToday:29": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:isToday:29",
      "type": "function",
      "name": "isToday",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 29,
      "endLine": 31,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "Date",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "boolean",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Checks if given date is the same day as today.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function isToday(date: Date): boolean {\n  return isSameDay(date, new Date());\n}",
      "references": [
        "isSameDay",
        "Date"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx:fn:EventCard:39": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:EventCard:39",
      "type": "function",
      "name": "EventCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 39,
      "endLine": 112,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ event, compact = false, onClick }",
          "type": "EventCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a styled event card component for calendar display with compact/detailed views",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EventCard({ event, compact = false, onClick }: EventCardProps) {\n  const isGoogle = event.source === 'google';\n  const color = event.color || (isGoogle ? '#4285f4' : '#3b82f6');\n\n  // Recurrence icon\n  const RecurrenceIcon = () => (\n    <svg className=\"w-3 h-3 text-gray-400 flex-shrink-0\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" aria-label=\"Recurring event\">\n      <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n    </svg>\n  );\n\n  if (compact) {\n    return (\n      <button\n        onClick={() => onClick(event)}\n        className=\"w-full text-left px-1.5 py-0.5 text-xs rounded truncate hover:opacity-80 transition-opacity flex items-center gap-1\"\n        style={{ backgroundColor: color + '30', color: color, borderLeft: `2px solid ${color}` }}\n      >\n        {event.isRecurring && <RecurrenceIcon />}\n        <span className=\"truncate\">{event.title}</span>\n      </button>\n    );\n  }\n\n  return (\n    <button\n      onClick={() => onClick(event)}\n      className=\"w-full text-left p-2 rounded-lg hover:opacity-80 transition-opacity group\"\n      style={{ backgroundColor: color + '20', borderLeft: `3px solid ${color}` }}\n    >\n      <div className=\"flex items-start justify-between gap-2\">\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"font-medium text-white text-sm truncate flex items-center gap-1.5\">\n            {event.isRecurring && <RecurrenceIcon />}\n            {event.title}\n          </div>\n          <div className=\"text-xs text-gray-400 mt-0.5\">\n            {formatTime(event.start, event.allDay)}\n            {event.location && <span className=\"ml-2\">@ {event.location}</span>}\n          </div>\n        </div>\n        <div className=\"flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity\">\n          {isGoogle && event.htmlLink && (\n            <a\n              href={event.htmlLink}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              onClick={(e) => e.stopPropagation()}\n              className=\"p-1 rounded hover:bg-white/10\"\n              title=\"Open in Google Calendar\"\n            >\n              <svg className=\"w-3.5 h-3.5 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14\" />\n              </svg>\n            </a>\n          )}\n        </div>\n      </div>\n      <div className=\"flex items-center gap-2 mt-1\">\n        <span className={`text-xs px-1.5 py-0.5 rounded ${\n          isGoogle ? 'bg-blue-500/20 text-blue-300' : 'bg-purple-500/20 text-purple-300'\n        }`}>\n          {isGoogle ? (event.googleCalendarName || 'Google') : 'Squire'}\n        </span>\n        {event.isRecurring && (\n          <span className=\"text-xs text-gray-500\">Recurring</span>\n        )}\n        {event.status && event.status !== 'open' && event.status !== 'confirmed' && (\n          <span className=\"text-xs text-gray-500\">{event.status}</span>\n        )}\n      </div>\n    </button>\n  );\n}",
      "references": [
        "event",
        "isGoogle",
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "aria-label",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "compact",
        "button",
        "onClick",
        "style",
        "color",
        "RecurrenceIcon",
        "span",
        "div",
        "formatTime",
        "a",
        "href",
        "target",
        "rel",
        "e",
        "title"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx:fn:EventDetailsPanel:119": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:EventDetailsPanel:119",
      "type": "function",
      "name": "EventDetailsPanel",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 119,
      "endLine": 236,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ event, onClose }",
          "type": "EventDetailsPanelProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a modal panel for displaying calendar event details.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function EventDetailsPanel({ event, onClose }: EventDetailsPanelProps) {\n  if (!event) return null;\n\n  const isGoogle = event.source === 'google';\n  const color = event.color || (isGoogle ? '#4285f4' : '#3b82f6');\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/50\" onClick={onClose}>\n      <div\n        className=\"bg-gray-900 border border-white/10 rounded-xl w-full max-w-md shadow-2xl\"\n        onClick={(e) => e.stopPropagation()}\n      >\n        <div className=\"p-4 border-b border-white/10\" style={{ borderLeftColor: color, borderLeftWidth: '4px' }}>\n          <div className=\"flex items-start justify-between\">\n            <div className=\"flex-1\">\n              <h2 className=\"text-lg font-semibold text-white\">{event.title}</h2>\n              <div className=\"flex items-center gap-2 mt-1\">\n                <span className={`text-xs px-2 py-0.5 rounded ${\n                  isGoogle ? 'bg-blue-500/20 text-blue-300' : 'bg-purple-500/20 text-purple-300'\n                }`}>\n                  {isGoogle ? (event.googleCalendarName || 'Google Calendar') : 'Squire Commitment'}\n                </span>\n              </div>\n            </div>\n            <button onClick={onClose} className=\"p-1 rounded hover:bg-white/10\">\n              <svg className=\"w-5 h-5 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          </div>\n        </div>\n\n        <div className=\"p-4 space-y-4\">\n          <div className=\"flex items-start gap-3\">\n            <svg className=\"w-5 h-5 text-gray-400 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n            </svg>\n            <div>\n              <div className=\"text-white\">\n                {new Date(event.start).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}\n              </div>\n              <div className=\"text-gray-400 text-sm\">\n                {event.allDay ? 'All day' : (\n                  <>\n                    {formatTime(event.start, false)}\n                    {event.end && ` - ${formatTime(event.end, false)}`}\n                  </>\n                )}\n              </div>\n            </div>\n          </div>\n\n          {event.location && (\n            <div className=\"flex items-start gap-3\">\n              <svg className=\"w-5 h-5 text-gray-400 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 11a3 3 0 11-6 0 3 3 0 016 0z\" />\n              </svg>\n              <div className=\"text-white\">{event.location}</div>\n            </div>\n          )}\n\n          {event.description && (\n            <div className=\"flex items-start gap-3\">\n              <svg className=\"w-5 h-5 text-gray-400 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 12h16M4 18h7\" />\n              </svg>\n              <div className=\"text-gray-300 text-sm whitespace-pre-wrap\">{event.description}</div>\n            </div>\n          )}\n\n          {event.isRecurring && (\n            <div className=\"flex items-start gap-3\">\n              <svg className=\"w-5 h-5 text-gray-400 mt-0.5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n              </svg>\n              <div>\n                <div className=\"text-white\">Recurring event</div>\n                {event.isOccurrence && event.occurrenceIndex !== undefined && (\n                  <div className=\"text-gray-400 text-sm\">\n                    Occurrence #{event.occurrenceIndex + 1}\n                  </div>\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n\n        <div className=\"p-4 border-t border-white/10 flex gap-2\">\n          {isGoogle && event.htmlLink && (\n            <a\n              href={event.htmlLink}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"flex-1 px-4 py-2 bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 rounded-lg text-center text-sm font-medium transition-colors\"\n            >\n              Open in Google Calendar\n            </a>\n          )}\n          {!isGoogle && event.commitmentId && (\n            <a\n              href={`/app/commitments?id=${event.commitmentId}`}\n              className=\"flex-1 px-4 py-2 bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 rounded-lg text-center text-sm font-medium transition-colors\"\n            >\n              View Commitment\n            </a>\n          )}\n          <button\n            onClick={onClose}\n            className=\"px-4 py-2 bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg text-sm transition-colors\"\n          >\n            Close\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "event",
        "isGoogle",
        "div",
        "className",
        "onClick",
        "onClose",
        "e",
        "style",
        "color",
        "h2",
        "span",
        "button",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "Date",
        "formatTime",
        "a",
        "href",
        "target",
        "rel"
      ]
    },
    "file:web/src/app/app/calendar/page.tsx:fn:CalendarPage:238": {
      "id": "file:web/src/app/app/calendar/page.tsx:fn:CalendarPage:238",
      "type": "function",
      "name": "CalendarPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/calendar/page.tsx",
      "line": 238,
      "endLine": 773,
      "parentFileId": "file:web/src/app/app/calendar/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for calendar page that fetches and displays events in week or month view",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function CalendarPage() {\n  const [viewMode, setViewMode] = useState<ViewMode>('week');\n  const [currentDate, setCurrentDate] = useState(new Date());\n  const [events, setEvents] = useState<CalendarEvent[]>([]);\n  const [loading, setLoading] = useState(true);\n\n  const [selectedEvent, setSelectedEvent] = useState<CalendarEvent | null>(null);\n  const [showAddModal, setShowAddModal] = useState(false);\n  const [newEvent, setNewEvent] = useState({ title: '', description: '', startDate: '', startTime: '', endTime: '', allDay: false });\n  const [creating, setCreating] = useState(false);\n\n  useEffect(() => {\n    const controller = new AbortController();\n\n    const fetchEvents = async () => {\n      setLoading(true);\n      try {\n        let url: string;\n        if (viewMode === 'week') {\n          url = `${API_URL}/api/calendar/week?date=${currentDate.toISOString().split('T')[0]}`;\n        } else {\n          url = `${API_URL}/api/calendar/month?year=${currentDate.getFullYear()}&month=${currentDate.getMonth() + 1}`;\n        }\n\n        const res = await fetch(url, { signal: controller.signal });\n        const data = await res.json();\n\n        // Flatten the days object into an array of events\n        const allEvents: CalendarEvent[] = [];\n        if (data.days) {\n          Object.values(data.days as Record<string, CalendarEvent[]>).forEach((dayEvents) => {\n            allEvents.push(...dayEvents);\n          });\n        }\n\n        setEvents(allEvents);\n        setLoading(false);\n      } catch (err) {\n        // Ignore abort errors - they're expected when navigating quickly\n        // Don't change loading state on abort - let the next fetch handle it\n        if (err instanceof Error && err.name === 'AbortError') {\n          return;\n        }\n        console.error('Failed to fetch calendar events:', err);\n        setEvents([]);\n        setLoading(false);\n      }\n    };\n\n    fetchEvents();\n\n    return () => controller.abort();\n  }, [viewMode, currentDate]);\n\n  // Keep fetchEvents for manual refresh (e.g., after creating event)\n  const fetchEvents = useCallback(async () => {\n    setLoading(true);\n    try {\n      let url: string;\n      if (viewMode === 'week') {\n        url = `${API_URL}/api/calendar/week?date=${currentDate.toISOString().split('T')[0]}`;\n      } else {\n        url = `${API_URL}/api/calendar/month?year=${currentDate.getFullYear()}&month=${currentDate.getMonth() + 1}`;\n      }\n\n      const res = await fetch(url);\n      const data = await res.json();\n\n      const allEvents: CalendarEvent[] = [];\n      if (data.days) {\n        Object.values(data.days as Record<string, CalendarEvent[]>).forEach((dayEvents) => {\n          allEvents.push(...dayEvents);\n        });\n      }\n\n      setEvents(allEvents);\n    } catch (err) {\n      console.error('Failed to fetch events:', err);\n      setEvents([]);\n    } finally {\n      setLoading(false);\n    }\n  }, [viewMode, currentDate]);\n\n  const navigatePrev = () => {\n    const newDate = new Date(currentDate);\n    if (viewMode === 'week') {\n      newDate.setDate(newDate.getDate() - 7);\n    } else {\n      newDate.setMonth(newDate.getMonth() - 1);\n    }\n    setCurrentDate(newDate);\n  };\n\n  const navigateNext = () => {\n    const newDate = new Date(currentDate);\n    if (viewMode === 'week') {\n      newDate.setDate(newDate.getDate() + 7);\n    } else {\n      newDate.setMonth(newDate.getMonth() + 1);\n    }\n    setCurrentDate(newDate);\n  };\n\n  const goToToday = () => {\n    setCurrentDate(new Date());\n  };\n\n  const handleCreateEvent = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!newEvent.title.trim() || !newEvent.startDate) return;\n\n    setCreating(true);\n    try {\n      let dueAt: Date;\n      let durationMinutes: number | undefined;\n\n      if (newEvent.allDay) {\n        dueAt = new Date(newEvent.startDate + 'T00:00:00');\n      } else {\n        if (!newEvent.startTime) {\n          alert('Start time is required for non-all-day events');\n          setCreating(false);\n          return;\n        }\n        dueAt = new Date(newEvent.startDate + 'T' + newEvent.startTime);\n        if (newEvent.endTime) {\n          const endDate = new Date(newEvent.startDate + 'T' + newEvent.endTime);\n          durationMinutes = Math.round((endDate.getTime() - dueAt.getTime()) / 60000);\n          if (durationMinutes <= 0) durationMinutes = 60;\n        }\n      }\n\n      const res = await fetch(`${API_URL}/api/commitments`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          title: newEvent.title,\n          description: newEvent.description || undefined,\n          due_at: dueAt.toISOString(),\n          all_day: newEvent.allDay,\n          duration_minutes: durationMinutes,\n          timezone: 'America/New_York',\n          source_type: 'manual',\n        }),\n      });\n      if (!res.ok) {\n        const err = await res.json();\n        throw new Error(err.error || 'Failed to create event');\n      }\n      setNewEvent({ title: '', description: '', startDate: '', startTime: '', endTime: '', allDay: false });\n      setShowAddModal(false);\n      fetchEvents();\n    } catch (err) {\n      console.error('Failed to create event:', err);\n      alert(err instanceof Error ? err.message : 'Failed to create event');\n    } finally {\n      setCreating(false);\n    }\n  };\n\n  // Calculate week start (Sunday) for week view\n  const weekStart = new Date(currentDate);\n  weekStart.setDate(weekStart.getDate() - weekStart.getDay());\n  weekStart.setHours(0, 0, 0, 0);\n\n  // Calculate month start for month view\n  const monthStart = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);\n  const daysInMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();\n  const firstDayOfWeek = monthStart.getDay();\n\n  const getEventsForDay = (date: Date): CalendarEvent[] => {\n    return events.filter(e => isSameDay(new Date(e.start), date))\n      .sort((a, b) => {\n        if (a.allDay && !b.allDay) return -1;\n        if (!a.allDay && b.allDay) return 1;\n        return new Date(a.start).getTime() - new Date(b.start).getTime();\n      });\n  };\n\n  const renderWeekView = () => {\n    const days = [];\n    for (let i = 0; i < 7; i++) {\n      const day = new Date(weekStart);\n      day.setDate(day.getDate() + i);\n      const dayEvents = getEventsForDay(day);\n      const today = isToday(day);\n\n      days.push(\n        <div key={i} className={`flex-1 min-w-0 ${i < 6 ? 'border-r border-white/5' : ''}`}>\n          <div className={`sticky top-0 p-2 text-center border-b border-white/10 ${\n            today ? 'bg-blue-500/10' : 'bg-gray-900/50'\n          }`}>\n            <div className={`text-xs font-medium ${today ? 'text-blue-400' : 'text-gray-400'}`}>\n              {WEEKDAYS[i]}\n            </div>\n            <div className={`text-lg font-semibold ${today ? 'text-blue-400' : 'text-white'}`}>\n              {day.getDate()}\n            </div>\n          </div>\n          <div className=\"p-1 space-y-1 min-h-[400px]\">\n            {dayEvents.length === 0 && (\n              <div className=\"text-xs text-gray-600 text-center py-4\">No events</div>\n            )}\n            {dayEvents.map(event => (\n              <EventCard key={event.id} event={event} onClick={setSelectedEvent} />\n            ))}\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex border border-white/10 rounded-lg overflow-hidden bg-gray-900/30\">\n        {days}\n      </div>\n    );\n  };\n\n  const renderMonthView = () => {\n    const cells = [];\n\n    // Empty cells for days before month start\n    for (let i = 0; i < firstDayOfWeek; i++) {\n      cells.push(\n        <div key={`empty-${i}`} className=\"border border-white/5 bg-gray-900/20 min-h-[100px]\" />\n      );\n    }\n\n    // Days of the month\n    for (let day = 1; day <= daysInMonth; day++) {\n      const date = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);\n      const dayEvents = getEventsForDay(date);\n      const today = isToday(date);\n\n      cells.push(\n        <div\n          key={day}\n          className={`border border-white/5 min-h-[100px] p-1 ${\n            today ? 'bg-blue-500/5' : 'bg-gray-900/30'\n          }`}\n        >\n          <div className={`text-sm font-medium mb-1 ${today ? 'text-blue-400' : 'text-gray-400'}`}>\n            {day}\n          </div>\n          <div className=\"space-y-0.5\">\n            {dayEvents.slice(0, 3).map(event => (\n              <EventCard key={event.id} event={event} compact onClick={setSelectedEvent} />\n            ))}\n            {dayEvents.length > 3 && (\n              <button\n                onClick={() => {\n                  // Could expand to show all events\n                }}\n                className=\"text-xs text-gray-500 hover:text-gray-400 pl-1\"\n              >\n                +{dayEvents.length - 3} more\n              </button>\n            )}\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"grid grid-cols-7 rounded-lg overflow-hidden border border-white/10\">\n        {/* Header */}\n        {WEEKDAYS.map(day => (\n          <div key={day} className=\"text-center text-xs font-medium text-gray-400 py-2 bg-gray-900/50 border-b border-white/10\">\n            {day}\n          </div>\n        ))}\n        {cells}\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6\">\n      <div className=\"max-w-7xl mx-auto\">\n        {/* Header */}\n        <div className=\"mb-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-white\">Calendar</h1>\n            <p className=\"text-gray-400 text-sm\">\n              {viewMode === 'week'\n                ? `${formatDateShort(weekStart)} - ${formatDateShort(new Date(weekStart.getTime() + 6 * 24 * 60 * 60 * 1000))}`\n                : `${MONTHS[currentDate.getMonth()]} ${currentDate.getFullYear()}`\n              }\n            </p>\n          </div>\n\n          <div className=\"flex items-center gap-4\">\n            {/* Legend */}\n            <div className=\"hidden sm:flex items-center gap-4 text-xs\">\n              <div className=\"flex items-center gap-1.5\">\n                <div className=\"w-3 h-3 rounded-full bg-purple-500\" />\n                <span className=\"text-gray-400\">Squire</span>\n              </div>\n              <div className=\"flex items-center gap-1.5\">\n                <div className=\"w-3 h-3 rounded-full bg-blue-500\" />\n                <span className=\"text-gray-400\">Google</span>\n              </div>\n              <div className=\"flex items-center gap-1.5\">\n                <svg className=\"w-3 h-3 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n                </svg>\n                <span className=\"text-gray-400\">Recurring</span>\n              </div>\n            </div>\n\n            {/* View Toggle */}\n            <div className=\"flex rounded-lg border border-white/10 overflow-hidden\">\n              <button\n                onClick={() => setViewMode('week')}\n                className={`px-3 py-1.5 text-sm font-medium transition-colors ${\n                  viewMode === 'week'\n                    ? 'bg-white/10 text-white'\n                    : 'text-gray-400 hover:text-white hover:bg-white/5'\n                }`}\n              >\n                Week\n              </button>\n              <button\n                onClick={() => setViewMode('month')}\n                className={`px-3 py-1.5 text-sm font-medium transition-colors ${\n                  viewMode === 'month'\n                    ? 'bg-white/10 text-white'\n                    : 'text-gray-400 hover:text-white hover:bg-white/5'\n                }`}\n              >\n                Month\n              </button>\n            </div>\n\n            {/* Navigation */}\n            <div className=\"flex items-center gap-1\">\n              <button\n                onClick={goToToday}\n                className=\"px-3 py-1.5 text-sm rounded-lg border border-white/10 text-gray-300 hover:bg-white/5 transition-colors\"\n              >\n                Today\n              </button>\n              <button\n                onClick={navigatePrev}\n                className=\"p-1.5 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 hover:text-white transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\n                </svg>\n              </button>\n              <button\n                onClick={navigateNext}\n                className=\"p-1.5 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 hover:text-white transition-colors\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M9 5l7 7-7 7\" />\n                </svg>\n              </button>\n            </div>\n\n            {/* Add Event Button */}\n            <button\n              onClick={() => setShowAddModal(true)}\n              className=\"px-3 py-1.5 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-sm font-medium flex items-center gap-1.5\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n              </svg>\n              Add Event\n            </button>\n\n            {/* Settings Link */}\n            <a\n              href=\"/app/settings/integrations\"\n              className=\"p-1.5 rounded-lg border border-white/10 text-gray-400 hover:bg-white/5 hover:text-white transition-colors\"\n              title=\"Manage Integrations\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\" />\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\" />\n              </svg>\n            </a>\n          </div>\n        </div>\n\n        {/* Calendar View */}\n        {loading ? (\n          <div className=\"flex items-center justify-center py-24\">\n            <div className=\"w-10 h-10 border-2 border-blue-500 border-t-transparent rounded-full animate-spin\" />\n          </div>\n        ) : viewMode === 'week' ? (\n          renderWeekView()\n        ) : (\n          renderMonthView()\n        )}\n\n        {/* Empty State */}\n        {!loading && events.length === 0 && (\n          <div className=\"text-center py-12 mt-6\">\n            <div className=\"w-16 h-16 mx-auto mb-4 rounded-full bg-gray-500/10 flex items-center justify-center\">\n              <svg className=\"w-8 h-8 text-gray-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z\" />\n              </svg>\n            </div>\n            <h3 className=\"text-lg font-medium text-white mb-2\">No events this {viewMode}</h3>\n            <p className=\"text-gray-400 text-sm mb-6\">\n              Create commitments in chat or connect Google Calendar to see events here\n            </p>\n            <div className=\"flex gap-3 justify-center\">\n              <a\n                href=\"/app/chat\"\n                className=\"px-4 py-2 bg-purple-500/20 hover:bg-purple-500/30 text-purple-400 rounded-lg text-sm font-medium transition-colors\"\n              >\n                Go to Chat\n              </a>\n              <a\n                href=\"/app/settings/integrations\"\n                className=\"px-4 py-2 bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 rounded-lg text-sm font-medium transition-colors\"\n              >\n                Connect Google Calendar\n              </a>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Event Details Panel */}\n      <EventDetailsPanel event={selectedEvent} onClose={() => setSelectedEvent(null)} />\n\n      {/* Add Event Modal */}\n      {showAddModal && (\n        <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4\">\n          <div className=\"bg-gray-800 rounded-xl border border-white/10 w-full max-w-md\">\n            <div className=\"p-4 border-b border-white/10 flex items-center justify-between\">\n              <h2 className=\"text-lg font-semibold text-white\">Add Event</h2>\n              <button\n                onClick={() => setShowAddModal(false)}\n                className=\"p-1 hover:bg-white/10 rounded text-gray-400 hover:text-white\"\n              >\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              </button>\n            </div>\n            <form onSubmit={handleCreateEvent} className=\"p-4 space-y-4\">\n              <div>\n                <label className=\"block text-sm font-medium text-gray-300 mb-1\">Title *</label>\n                <input\n                  type=\"text\"\n                  value={newEvent.title}\n                  onChange={(e) => setNewEvent({ ...newEvent, title: e.target.value })}\n                  placeholder=\"Event title\"\n                  className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500\"\n                  required\n                />\n              </div>\n              <div>\n                <label className=\"block text-sm font-medium text-gray-300 mb-1\">Date *</label>\n                <input\n                  type=\"date\"\n                  value={newEvent.startDate}\n                  onChange={(e) => setNewEvent({ ...newEvent, startDate: e.target.value })}\n                  className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:border-blue-500\"\n                  required\n                />\n              </div>\n              <div className=\"flex items-center gap-3\">\n                <input\n                  type=\"checkbox\"\n                  id=\"allDay\"\n                  checked={newEvent.allDay}\n                  onChange={(e) => setNewEvent({ ...newEvent, allDay: e.target.checked })}\n                  className=\"w-4 h-4 rounded border-white/20 bg-white/5\"\n                />\n                <label htmlFor=\"allDay\" className=\"text-sm text-gray-300\">All day event</label>\n              </div>\n              {!newEvent.allDay && (\n                <div className=\"grid grid-cols-2 gap-3\">\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-300 mb-1\">Start Time *</label>\n                    <input\n                      type=\"time\"\n                      value={newEvent.startTime}\n                      onChange={(e) => setNewEvent({ ...newEvent, startTime: e.target.value })}\n                      className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:border-blue-500\"\n                      required={!newEvent.allDay}\n                    />\n                  </div>\n                  <div>\n                    <label className=\"block text-sm font-medium text-gray-300 mb-1\">End Time</label>\n                    <input\n                      type=\"time\"\n                      value={newEvent.endTime}\n                      onChange={(e) => setNewEvent({ ...newEvent, endTime: e.target.value })}\n                      className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:border-blue-500\"\n                    />\n                  </div>\n                </div>\n              )}\n              <div>\n                <label className=\"block text-sm font-medium text-gray-300 mb-1\">Description (optional)</label>\n                <textarea\n                  value={newEvent.description}\n                  onChange={(e) => setNewEvent({ ...newEvent, description: e.target.value })}\n                  placeholder=\"Event details...\"\n                  rows={3}\n                  className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 resize-none\"\n                />\n              </div>\n              <div className=\"flex gap-3 pt-2\">\n                <button\n                  type=\"button\"\n                  onClick={() => setShowAddModal(false)}\n                  className=\"flex-1 px-4 py-2 bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg transition-colors\"\n                >\n                  Cancel\n                </button>\n                <button\n                  type=\"submit\"\n                  disabled={creating || !newEvent.title.trim() || !newEvent.startDate}\n                  className=\"flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-500/50 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center justify-center gap-2\"\n                >\n                  {creating && (\n                    <span className=\"w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin\" />\n                  )}\n                  {creating ? 'Creating...' : 'Create Event'}\n                </button>\n              </div>\n            </form>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "viewMode",
        "setViewMode",
        "useState",
        "currentDate",
        "setCurrentDate",
        "Date",
        "events",
        "setEvents",
        "loading",
        "setLoading",
        "selectedEvent",
        "setSelectedEvent",
        "showAddModal",
        "setShowAddModal",
        "newEvent",
        "setNewEvent",
        "creating",
        "setCreating",
        "useEffect",
        "AbortController",
        "url",
        "API_URL",
        "fetch",
        "controller",
        "res",
        "data",
        "Object",
        "allEvents",
        "dayEvents",
        "err",
        "Error",
        "console",
        "fetchEvents",
        "useCallback",
        "newDate",
        "e",
        "dueAt",
        "alert",
        "durationMinutes",
        "Math",
        "endDate",
        "JSON",
        "weekStart",
        "monthStart",
        "isSameDay",
        "date",
        "a",
        "b",
        "i",
        "day",
        "getEventsForDay",
        "isToday",
        "days",
        "div",
        "key",
        "className",
        "today",
        "WEEKDAYS",
        "EventCard",
        "event",
        "onClick",
        "firstDayOfWeek",
        "cells",
        "daysInMonth",
        "compact",
        "button",
        "h1",
        "p",
        "formatDateShort",
        "MONTHS",
        "span",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "goToToday",
        "navigatePrev",
        "navigateNext",
        "href",
        "title",
        "renderWeekView",
        "renderMonthView",
        "h3",
        "EventDetailsPanel",
        "onClose",
        "h2",
        "form",
        "onSubmit",
        "handleCreateEvent",
        "label",
        "input",
        "value",
        "onChange",
        "placeholder",
        "required",
        "id",
        "checked",
        "htmlFor",
        "textarea",
        "rows",
        "disabled"
      ]
    },
    "file:web/src/app/app/chat/page.tsx": {
      "id": "file:web/src/app/app/chat/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/chat/page.tsx",
      "line": 1,
      "endLine": 6,
      "imports": [
        {
          "source": "@/components/chat",
          "items": [
            {
              "name": "ChatWindow",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ChatPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/chat/page.tsx:fn:ChatPage:3"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/chat/page.tsx:fn:ChatPage:3": {
      "id": "file:web/src/app/app/chat/page.tsx:fn:ChatPage:3",
      "type": "function",
      "name": "ChatPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/chat/page.tsx",
      "line": 3,
      "endLine": 5,
      "parentFileId": "file:web/src/app/app/chat/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders the ChatWindow component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function ChatPage() {\n  return <ChatWindow />;\n}",
      "references": [
        "ChatWindow"
      ]
    },
    "file:web/src/app/app/commitments/page.tsx": {
      "id": "file:web/src/app/app/commitments/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/commitments/page.tsx",
      "line": 1,
      "endLine": 279,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Commitment",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CommitmentStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "CommitmentsPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/commitments/page.tsx:fn:formatDate:24",
        "file:web/src/app/app/commitments/page.tsx:fn:CommitmentCard:38",
        "file:web/src/app/app/commitments/page.tsx:fn:CommitmentsPage:103"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:web/src/app/app/commitments/page.tsx:fn:formatDate:24": {
      "id": "file:web/src/app/app/commitments/page.tsx:fn:formatDate:24",
      "type": "function",
      "name": "formatDate",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/commitments/page.tsx",
      "line": 24,
      "endLine": 36,
      "parentFileId": "file:web/src/app/app/commitments/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date string into human-readable due date status relative to today",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDate(dateStr: string | null): string {\n  if (!dateStr) return 'No due date';\n  const date = new Date(dateStr);\n  const now = new Date();\n  const diff = date.getTime() - now.getTime();\n  const days = Math.ceil(diff / (1000 * 60 * 60 * 24));\n\n  if (days < 0) return `Overdue by ${Math.abs(days)} day${Math.abs(days) !== 1 ? 's' : ''}`;\n  if (days === 0) return 'Due today';\n  if (days === 1) return 'Due tomorrow';\n  if (days < 7) return `Due in ${days} days`;\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });\n}",
      "references": [
        "Date",
        "date",
        "now",
        "Math",
        "diff",
        "days"
      ]
    },
    "file:web/src/app/app/commitments/page.tsx:fn:CommitmentCard:38": {
      "id": "file:web/src/app/app/commitments/page.tsx:fn:CommitmentCard:38",
      "type": "function",
      "name": "CommitmentCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/commitments/page.tsx",
      "line": 38,
      "endLine": 101,
      "parentFileId": "file:web/src/app/app/commitments/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  commitment,\n  onResolve,\n  onSnooze\n}",
          "type": "{ commitment: Commitment; onResolve: (id: string, type: string) => void; onSnooze: (id: string) => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a React card component for displaying commitment details with status, dates, and action buttons.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function CommitmentCard({\n  commitment,\n  onResolve,\n  onSnooze\n}: {\n  commitment: Commitment;\n  onResolve: (id: string, type: string) => void;\n  onSnooze: (id: string) => void;\n}) {\n  const isOverdue = commitment.due_at && new Date(commitment.due_at) < new Date() &&\n    commitment.status !== 'completed' && commitment.status !== 'canceled';\n\n  return (\n    <div className={`p-4 rounded-lg border ${isOverdue ? 'border-red-500/50 bg-red-500/5' : 'border-white/10 bg-white/5'} hover:bg-white/10 transition-colors`}>\n      <div className=\"flex items-start justify-between gap-3\">\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"flex items-center gap-2 mb-1\">\n            <span className={`px-2 py-0.5 text-xs rounded border ${statusColors[commitment.status]}`}>\n              {statusIcons[commitment.status]} {commitment.status.replace('_', ' ')}\n            </span>\n            {commitment.source_type === 'chat' && (\n              <span className=\"text-xs text-gray-500\">from chat</span>\n            )}\n          </div>\n          <h3 className=\"font-medium text-white truncate\">{commitment.title}</h3>\n          {commitment.description && (\n            <p className=\"text-sm text-gray-400 mt-1 line-clamp-2\">{commitment.description}</p>\n          )}\n          <div className=\"flex items-center justify-between mt-2\">\n            <p className={`text-xs ${isOverdue ? 'text-red-400' : 'text-gray-500'}`}>\n              {formatDate(commitment.due_at)}\n            </p>\n            <p className=\"text-xs text-gray-600\" title=\"Extracted at\">\n              {new Date(commitment.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}{' '}\n              {new Date(commitment.created_at).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}\n            </p>\n          </div>\n        </div>\n        {commitment.status !== 'completed' && commitment.status !== 'canceled' && (\n          <div className=\"flex gap-1\">\n            <button\n              onClick={() => onResolve(commitment.id, 'completed')}\n              className=\"p-2 rounded hover:bg-green-500/20 text-green-400 transition-colors\"\n              title=\"Mark complete\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n              </svg>\n            </button>\n            <button\n              onClick={() => onSnooze(commitment.id)}\n              className=\"p-2 rounded hover:bg-purple-500/20 text-purple-400 transition-colors\"\n              title=\"Snooze 1 day\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n              </svg>\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "commitment",
        "Date",
        "div",
        "className",
        "isOverdue",
        "span",
        "statusColors",
        "statusIcons",
        "h3",
        "p",
        "formatDate",
        "title",
        "button",
        "onClick",
        "onResolve",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "onSnooze"
      ]
    },
    "file:web/src/app/app/commitments/page.tsx:fn:CommitmentsPage:103": {
      "id": "file:web/src/app/app/commitments/page.tsx:fn:CommitmentsPage:103",
      "type": "function",
      "name": "CommitmentsPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/commitments/page.tsx",
      "line": 103,
      "endLine": 278,
      "parentFileId": "file:web/src/app/app/commitments/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for displaying, filtering, and managing commitments via API.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function CommitmentsPage() {\n  const [commitments, setCommitments] = useState<Commitment[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [statusFilter, setStatusFilter] = useState<CommitmentStatus | null>('open');\n  const [stats, setStats] = useState<Record<CommitmentStatus, number>>({ open: 0, in_progress: 0, completed: 0, canceled: 0, snoozed: 0 });\n\n  const fetchCommitments = async () => {\n    try {\n      const params = new URLSearchParams();\n      if (statusFilter) {\n        params.set('status', statusFilter);\n        if (statusFilter === 'completed' || statusFilter === 'canceled') {\n          params.set('include_resolved', 'true');\n        }\n      } else {\n        params.set('include_resolved', 'true');\n      }\n\n      const res = await fetch(`${API_URL}/api/commitments?${params}`);\n      const data = await res.json();\n      setCommitments(data.commitments || []);\n    } catch (err) {\n      console.error('Failed to fetch commitments:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchStats = async () => {\n    try {\n      const res = await fetch(`${API_URL}/api/commitments/stats`);\n      const data = await res.json();\n      setStats(data);\n    } catch (err) {\n      console.error('Failed to fetch stats:', err);\n    }\n  };\n\n  useEffect(() => {\n    fetchCommitments();\n    fetchStats();\n  }, [statusFilter]);\n\n  const handleResolve = async (id: string, resolutionType: string) => {\n    try {\n      await fetch(`${API_URL}/api/commitments/${id}/resolve`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ resolution_type: resolutionType }),\n      });\n      fetchCommitments();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to resolve:', err);\n    }\n  };\n\n  const handleSnooze = async (id: string) => {\n    const tomorrow = new Date();\n    tomorrow.setDate(tomorrow.getDate() + 1);\n    tomorrow.setHours(9, 0, 0, 0);\n\n    try {\n      await fetch(`${API_URL}/api/commitments/${id}/snooze`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ snooze_until: tomorrow.toISOString() }),\n      });\n      fetchCommitments();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to snooze:', err);\n    }\n  };\n\n  const handleStatusClick = (status: CommitmentStatus) => {\n    setStatusFilter(statusFilter === status ? null : status);\n  };\n\n  const totalCount = stats.open + stats.in_progress + stats.completed + stats.snoozed;\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6\">\n      <div className=\"max-w-3xl mx-auto\">\n        {/* Header */}\n        <div className=\"mb-8\">\n          <h1 className=\"text-2xl font-bold text-white mb-2\">Commitments</h1>\n          <p className=\"text-gray-400\">Track your goals, tasks, and promises</p>\n        </div>\n\n        {/* Stats - Clickable Filters */}\n        <div className=\"grid grid-cols-4 gap-3 mb-6\">\n          <button\n            onClick={() => handleStatusClick('open')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'open'\n                ? 'bg-blue-500/30 border-blue-400 ring-2 ring-blue-400/50'\n                : 'bg-blue-500/10 border-blue-500/20 hover:bg-blue-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-blue-400\">{stats.open}</div>\n            <div className=\"text-xs text-gray-400\">Open</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('in_progress')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'in_progress'\n                ? 'bg-yellow-500/30 border-yellow-400 ring-2 ring-yellow-400/50'\n                : 'bg-yellow-500/10 border-yellow-500/20 hover:bg-yellow-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-yellow-400\">{stats.in_progress}</div>\n            <div className=\"text-xs text-gray-400\">In Progress</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('completed')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'completed'\n                ? 'bg-green-500/30 border-green-400 ring-2 ring-green-400/50'\n                : 'bg-green-500/10 border-green-500/20 hover:bg-green-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-green-400\">{stats.completed}</div>\n            <div className=\"text-xs text-gray-400\">Completed</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('snoozed')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'snoozed'\n                ? 'bg-purple-500/30 border-purple-400 ring-2 ring-purple-400/50'\n                : 'bg-purple-500/10 border-purple-500/20 hover:bg-purple-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-purple-400\">{stats.snoozed}</div>\n            <div className=\"text-xs text-gray-400\">Snoozed</div>\n          </button>\n        </div>\n\n        {/* Show All button when filtered */}\n        {statusFilter && (\n          <div className=\"mb-4\">\n            <button\n              onClick={() => setStatusFilter(null)}\n              className=\"text-sm text-gray-400 hover:text-white transition-colors\"\n            >\n              Show all ({totalCount})\n            </button>\n          </div>\n        )}\n\n        {/* List */}\n        {loading ? (\n          <div className=\"text-center py-12 text-gray-400\">Loading...</div>\n        ) : commitments.length === 0 ? (\n          <div className=\"text-center py-12\">\n            <div className=\"text-gray-500 mb-2\">No commitments found</div>\n            <p className=\"text-sm text-gray-600\">\n              Commitments are created automatically when you mention goals or tasks in chat\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-3\">\n            {commitments.map((c) => (\n              <CommitmentCard\n                key={c.id}\n                commitment={c}\n                onResolve={handleResolve}\n                onSnooze={handleSnooze}\n              />\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "commitments",
        "setCommitments",
        "useState",
        "loading",
        "setLoading",
        "statusFilter",
        "setStatusFilter",
        "stats",
        "setStats",
        "URLSearchParams",
        "params",
        "fetch",
        "API_URL",
        "res",
        "data",
        "console",
        "err",
        "useEffect",
        "fetchCommitments",
        "fetchStats",
        "id",
        "JSON",
        "resolutionType",
        "Date",
        "tomorrow",
        "status",
        "div",
        "className",
        "h1",
        "p",
        "button",
        "onClick",
        "handleStatusClick",
        "totalCount",
        "CommitmentCard",
        "key",
        "c",
        "commitment",
        "onResolve",
        "handleResolve",
        "onSnooze",
        "handleSnooze"
      ]
    },
    "file:web/src/app/app/dashboard/page.tsx": {
      "id": "file:web/src/app/app/dashboard/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/dashboard/page.tsx",
      "line": 1,
      "endLine": 261,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/dashboard",
          "items": [
            {
              "name": "DashboardPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "StatsCard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LivingSummaryPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TodayPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BeliefsPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "PatternsPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EntitiesPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "InsightsPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DetailModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "BottomSheet",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExpandedBeliefsList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExpandedPatternsList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ExpandedInsightsList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/notes",
          "items": [
            {
              "name": "PinnedNotesPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/lists",
          "items": [
            {
              "name": "ActiveListsPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useOpenMemoryDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOpenBeliefDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOpenPatternDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOpenEntityDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOpenInsightDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useOpenSummaryDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useBeliefStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "usePatternStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DashboardPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/dashboard/page.tsx:fn:DashboardPage:82"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/app/app/dashboard/page.tsx:fn:DashboardPage:82": {
      "id": "file:web/src/app/app/dashboard/page.tsx:fn:DashboardPage:82",
      "type": "function",
      "name": "DashboardPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/dashboard/page.tsx",
      "line": 82,
      "endLine": 260,
      "parentFileId": "file:web/src/app/app/dashboard/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders dashboard with stats, expandable panels, and modals for memories, beliefs, patterns, entities",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function DashboardPage() {\n  // Expanded panel state\n  const [expandedPanel, setExpandedPanel] = useState<ExpandedPanel>(null);\n\n  // Detail modal actions\n  const openMemory = useOpenMemoryDetail();\n  const openBelief = useOpenBeliefDetail();\n  const openPattern = useOpenPatternDetail();\n  const openEntity = useOpenEntityDetail();\n  const openInsight = useOpenInsightDetail();\n  const openSummary = useOpenSummaryDetail();\n\n  // Stats data\n  const { data: memoriesData } = useMemories({ limit: 1 }); // Just need total count\n  const { data: beliefStats } = useBeliefStats();\n  const { data: patternStats } = usePatternStats();\n  const { data: entitiesData } = useEntities({ limit: 1 }); // Just need total count\n\n  // Panel expansion handlers\n  const closeExpanded = () => setExpandedPanel(null);\n\n  return (\n    <div className=\"h-full flex flex-col p-6 overflow-auto\">\n      {/* Detail Modal */}\n      <DetailModal />\n\n      {/* Expanded Panel Bottom Sheets */}\n      <BottomSheet\n        isOpen={expandedPanel === 'beliefs'}\n        onClose={closeExpanded}\n        title=\"All Beliefs\"\n        icon={icons.heart}\n        accentColor=\"text-accent-gold\"\n      >\n        <ExpandedBeliefsList onBeliefClick={(belief) => { closeExpanded(); openBelief(belief); }} />\n      </BottomSheet>\n\n      <BottomSheet\n        isOpen={expandedPanel === 'patterns'}\n        onClose={closeExpanded}\n        title=\"All Patterns\"\n        icon={icons.chartBar}\n        accentColor=\"text-accent-purple\"\n      >\n        <ExpandedPatternsList onPatternClick={(pattern) => { closeExpanded(); openPattern(pattern); }} />\n      </BottomSheet>\n\n      <BottomSheet\n        isOpen={expandedPanel === 'insights'}\n        onClose={closeExpanded}\n        title=\"All Insights\"\n        icon={icons.lightbulb}\n        accentColor=\"text-warning\"\n      >\n        <ExpandedInsightsList onInsightClick={(insight) => { closeExpanded(); openInsight(insight); }} />\n      </BottomSheet>\n      {/* Page Header */}\n      <div className=\"mb-6 animate-fade-in\">\n        <h1 className=\"text-2xl font-bold text-foreground mb-1\">Dashboard</h1>\n        <p className=\"text-foreground-muted text-sm\">\n          Your memory at a glance  summaries, beliefs, patterns, and insights\n        </p>\n      </div>\n\n      {/* Stats Row */}\n      <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-6\">\n        <StatsCard\n          label=\"Memories\"\n          value={memoriesData?.total ?? '--'}\n          icon={icons.brain}\n          accent=\"primary\"\n        />\n        <StatsCard\n          label=\"Beliefs\"\n          value={beliefStats?.total ?? '--'}\n          icon={icons.heart}\n          accent=\"gold\"\n        />\n        <StatsCard\n          label=\"Patterns\"\n          value={patternStats?.total ?? '--'}\n          icon={icons.chartBar}\n          accent=\"purple\"\n        />\n        <StatsCard\n          label=\"Entities\"\n          value={entitiesData?.total ?? '--'}\n          icon={icons.users}\n          accent=\"success\"\n        />\n      </div>\n\n      {/* Main Dashboard Grid */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 min-h-0\">\n        {/* Row 1: Living Summary (2 cols) + Today (1 col) */}\n        <DashboardPanel\n          title=\"Living Summary\"\n          icon={icons.document}\n          accent=\"primary\"\n          className=\"lg:col-span-2 min-h-[280px]\"\n        >\n          <LivingSummaryPanel onSummaryClick={openSummary} />\n        </DashboardPanel>\n\n        <DashboardPanel\n          title=\"Today\"\n          icon={icons.clock}\n          accent=\"gold\"\n          className=\"min-h-[280px]\"\n        >\n          <TodayPanel onMemoryClick={openMemory} />\n        </DashboardPanel>\n\n        {/* Row 2: Pinned Notes (1 col) + Beliefs + Patterns (2 cols) */}\n        <DashboardPanel\n          title=\"Pinned Notes\"\n          icon={icons.document}\n          accent=\"gold\"\n          className=\"min-h-[260px]\"\n        >\n          <PinnedNotesPanel limit={4} />\n        </DashboardPanel>\n\n        <DashboardPanel\n          title=\"Active Lists\"\n          icon={icons.sparkles}\n          accent=\"primary\"\n          className=\"min-h-[260px]\"\n        >\n          <ActiveListsPanel limit={4} />\n        </DashboardPanel>\n\n        {/* Beliefs + Patterns + Insights - Expandable */}\n        <DashboardPanel\n          title=\"Beliefs\"\n          icon={icons.heart}\n          accent=\"gold\"\n          className=\"min-h-[260px]\"\n          expandable\n          onHeaderClick={() => setExpandedPanel('beliefs')}\n        >\n          <BeliefsPanel onBeliefClick={openBelief} limit={4} />\n        </DashboardPanel>\n\n        <DashboardPanel\n          title=\"Patterns\"\n          icon={icons.chartBar}\n          accent=\"purple\"\n          className=\"min-h-[260px]\"\n          expandable\n          onHeaderClick={() => setExpandedPanel('patterns')}\n        >\n          <PatternsPanel onPatternClick={openPattern} limit={4} />\n        </DashboardPanel>\n\n        <DashboardPanel\n          title=\"Insights\"\n          icon={icons.lightbulb}\n          accent=\"warning\"\n          className=\"min-h-[260px]\"\n          expandable\n          onHeaderClick={() => setExpandedPanel('insights')}\n        >\n          <InsightsPanel onInsightClick={openInsight} limit={4} />\n        </DashboardPanel>\n\n        {/* Row 3: Entities (full width) */}\n        <DashboardPanel\n          title=\"Entities\"\n          icon={icons.network}\n          accent=\"success\"\n          className=\"lg:col-span-3 min-h-[240px]\"\n        >\n          <EntitiesPanel onEntityClick={openEntity} />\n        </DashboardPanel>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "expandedPanel",
        "setExpandedPanel",
        "useState",
        "useOpenMemoryDetail",
        "useOpenBeliefDetail",
        "useOpenPatternDetail",
        "useOpenEntityDetail",
        "useOpenInsightDetail",
        "useOpenSummaryDetail",
        "data",
        "memoriesData",
        "useMemories",
        "beliefStats",
        "useBeliefStats",
        "patternStats",
        "usePatternStats",
        "entitiesData",
        "useEntities",
        "div",
        "className",
        "DetailModal",
        "BottomSheet",
        "isOpen",
        "onClose",
        "closeExpanded",
        "title",
        "icon",
        "icons",
        "accentColor",
        "ExpandedBeliefsList",
        "onBeliefClick",
        "openBelief",
        "belief",
        "ExpandedPatternsList",
        "onPatternClick",
        "openPattern",
        "pattern",
        "ExpandedInsightsList",
        "onInsightClick",
        "openInsight",
        "insight",
        "h1",
        "p",
        "StatsCard",
        "label",
        "value",
        "accent",
        "DashboardPanel",
        "LivingSummaryPanel",
        "onSummaryClick",
        "openSummary",
        "TodayPanel",
        "onMemoryClick",
        "openMemory",
        "PinnedNotesPanel",
        "limit",
        "ActiveListsPanel",
        "expandable",
        "onHeaderClick",
        "BeliefsPanel",
        "PatternsPanel",
        "InsightsPanel",
        "EntitiesPanel",
        "onEntityClick",
        "openEntity"
      ]
    },
    "file:web/src/app/app/documents/page.tsx": {
      "id": "file:web/src/app/app/documents/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/documents/page.tsx",
      "line": 1,
      "endLine": 249,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "StoredDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/documents",
          "items": [
            {
              "name": "listDocuments",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteDocument",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/documents/DocumentList",
          "items": [
            {
              "name": "DocumentList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/documents/DocumentUpload",
          "items": [
            {
              "name": "DocumentUpload",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/documents/DocumentDetail",
          "items": [
            {
              "name": "DocumentDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/documents/DocumentSearch",
          "items": [
            {
              "name": "DocumentSearch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/documents/FactReviewPanel",
          "items": [
            {
              "name": "FactReviewPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "DocumentsPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/documents/page.tsx:fn:DocumentsPage:12"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/documents/page.tsx:fn:DocumentsPage:12": {
      "id": "file:web/src/app/app/documents/page.tsx:fn:DocumentsPage:12",
      "type": "function",
      "name": "DocumentsPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/documents/page.tsx",
      "line": 12,
      "endLine": 248,
      "parentFileId": "file:web/src/app/app/documents/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React page component for documents: lists, filters, deletes, and handles uploads",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": true,
          "databaseWrite": true,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function DocumentsPage() {\n  const [documents, setDocuments] = useState<StoredDocument[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [uploadOpen, setUploadOpen] = useState(false);\n  const [selectedDocument, setSelectedDocument] = useState<StoredDocument | null>(null);\n  const [viewMode, setViewMode] = useState<'grid' | 'list'>('list');\n  const [filterStatus, setFilterStatus] = useState<'all' | 'completed' | 'pending' | 'failed'>('all');\n  const [activeTab, setActiveTab] = useState<'library' | 'search'>('library');\n  const [reviewDocument, setReviewDocument] = useState<StoredDocument | null>(null);\n\n  const loadDocuments = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const options: { processingStatus?: 'completed' | 'pending' | 'failed' } = {};\n      if (filterStatus !== 'all') {\n        options.processingStatus = filterStatus;\n      }\n\n      const { documents: docs } = await listDocuments({\n        ...options,\n        limit: 100,\n      });\n      setDocuments(docs);\n    } catch (err) {\n      console.error('Failed to load documents:', err);\n      setError('Failed to load documents');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [filterStatus]);\n\n  useEffect(() => {\n    loadDocuments();\n  }, [loadDocuments]);\n\n  const handleUploadSuccess = () => {\n    // Reload documents after successful upload\n    loadDocuments();\n  };\n\n  const handleDelete = async (document: StoredDocument) => {\n    if (!confirm(`Delete \"${document.name || document.filename}\"? This cannot be undone.`)) {\n      return;\n    }\n\n    try {\n      await deleteDocument(document.id);\n      setDocuments((prev) => prev.filter((d) => d.id !== document.id));\n      if (selectedDocument?.id === document.id) {\n        setSelectedDocument(null);\n      }\n    } catch (err) {\n      console.error('Failed to delete document:', err);\n      alert('Failed to delete document');\n    }\n  };\n\n  const handleSelect = (document: StoredDocument) => {\n    setSelectedDocument(document);\n  };\n\n  const handleCloseDetail = () => {\n    setSelectedDocument(null);\n  };\n\n  const handleOpenReview = (document: StoredDocument) => {\n    setReviewDocument(document);\n  };\n\n  const handleCloseReview = () => {\n    setReviewDocument(null);\n  };\n\n  return (\n    <div className=\"p-6 max-w-7xl mx-auto\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-6\">\n        <div>\n          <h1 className=\"text-2xl font-bold text-foreground\">Documents</h1>\n          <p className=\"text-sm text-foreground-muted mt-1\">\n            Upload and search your documents with AI-powered indexing\n          </p>\n        </div>\n\n        <div className=\"flex items-center gap-3\">\n          {/* View Mode Toggle */}\n          <div className=\"flex items-center bg-background-tertiary rounded-lg p-1\">\n            <button\n              onClick={() => setViewMode('list')}\n              className={`p-1.5 rounded transition-colors ${\n                viewMode === 'list'\n                  ? 'bg-background text-foreground'\n                  : 'text-foreground-muted hover:text-foreground'\n              }`}\n              title=\"List view\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6h16M4 10h16M4 14h16M4 18h16\" />\n              </svg>\n            </button>\n            <button\n              onClick={() => setViewMode('grid')}\n              className={`p-1.5 rounded transition-colors ${\n                viewMode === 'grid'\n                  ? 'bg-background text-foreground'\n                  : 'text-foreground-muted hover:text-foreground'\n              }`}\n              title=\"Grid view\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z\" />\n              </svg>\n            </button>\n          </div>\n\n          {/* Upload Button */}\n          <button\n            onClick={() => setUploadOpen(true)}\n            className=\"\n              inline-flex items-center gap-2 px-4 py-2 rounded-lg\n              bg-primary text-white\n              hover:bg-primary/90 transition-colors\n            \"\n          >\n            <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\" />\n            </svg>\n            Upload\n          </button>\n        </div>\n      </div>\n\n      {/* Tab Navigation */}\n      <div className=\"flex items-center gap-4 mb-6 border-b border-glass-border\">\n        <button\n          onClick={() => setActiveTab('library')}\n          className={`\n            px-4 py-2 text-sm font-medium transition-colors border-b-2 -mb-px\n            ${activeTab === 'library'\n              ? 'text-primary border-primary'\n              : 'text-foreground-muted border-transparent hover:text-foreground'\n            }\n          `}\n        >\n          Library\n        </button>\n        <button\n          onClick={() => setActiveTab('search')}\n          className={`\n            px-4 py-2 text-sm font-medium transition-colors border-b-2 -mb-px\n            ${activeTab === 'search'\n              ? 'text-primary border-primary'\n              : 'text-foreground-muted border-transparent hover:text-foreground'\n            }\n          `}\n        >\n          Search\n        </button>\n      </div>\n\n      {/* Filters (Library tab only) */}\n      {activeTab === 'library' && (\n        <div className=\"flex items-center gap-2 mb-6\">\n          <span className=\"text-sm text-foreground-muted\">Filter:</span>\n          {(['all', 'completed', 'pending', 'failed'] as const).map((status) => (\n            <button\n              key={status}\n              onClick={() => setFilterStatus(status)}\n              className={`\n                px-3 py-1.5 rounded-lg text-sm transition-colors\n                ${filterStatus === status\n                  ? 'bg-primary text-white'\n                  : 'bg-background-tertiary text-foreground-muted hover:text-foreground'\n                }\n              `}\n            >\n              {status.charAt(0).toUpperCase() + status.slice(1)}\n            </button>\n          ))}\n        </div>\n      )}\n\n      {/* Error state */}\n      {error && (\n        <div className=\"mb-6 p-4 rounded-lg bg-red-500/10 border border-red-500/30 text-red-400\">\n          {error}\n          <button\n            onClick={loadDocuments}\n            className=\"ml-2 underline hover:no-underline\"\n          >\n            Retry\n          </button>\n        </div>\n      )}\n\n      {/* Content */}\n      {activeTab === 'library' ? (\n        <DocumentList\n          documents={documents}\n          isLoading={isLoading}\n          onSelect={handleSelect}\n          onDelete={handleDelete}\n          selectedId={selectedDocument?.id}\n          viewMode={viewMode}\n        />\n      ) : (\n        <DocumentSearch />\n      )}\n\n      {/* Upload modal */}\n      <DocumentUpload\n        isOpen={uploadOpen}\n        onClose={() => setUploadOpen(false)}\n        onSuccess={handleUploadSuccess}\n      />\n\n      {/* Document detail panel */}\n      <DocumentDetail\n        document={selectedDocument}\n        isOpen={!!selectedDocument}\n        onClose={handleCloseDetail}\n        onDelete={selectedDocument ? () => handleDelete(selectedDocument) : undefined}\n        onReviewFacts={selectedDocument ? () => handleOpenReview(selectedDocument) : undefined}\n      />\n\n      {/* Fact review panel */}\n      <FactReviewPanel\n        document={reviewDocument}\n        isOpen={!!reviewDocument}\n        onClose={handleCloseReview}\n      />\n    </div>\n  );\n}",
      "references": [
        "documents",
        "setDocuments",
        "useState",
        "isLoading",
        "setIsLoading",
        "error",
        "setError",
        "uploadOpen",
        "setUploadOpen",
        "selectedDocument",
        "setSelectedDocument",
        "viewMode",
        "setViewMode",
        "filterStatus",
        "setFilterStatus",
        "activeTab",
        "setActiveTab",
        "reviewDocument",
        "setReviewDocument",
        "useCallback",
        "options",
        "docs",
        "listDocuments",
        "console",
        "err",
        "useEffect",
        "loadDocuments",
        "confirm",
        "document",
        "deleteDocument",
        "prev",
        "d",
        "alert",
        "div",
        "className",
        "h1",
        "p",
        "button",
        "onClick",
        "title",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "span",
        "key",
        "status",
        "DocumentList",
        "onSelect",
        "handleSelect",
        "onDelete",
        "handleDelete",
        "selectedId",
        "DocumentSearch",
        "DocumentUpload",
        "isOpen",
        "onClose",
        "onSuccess",
        "handleUploadSuccess",
        "DocumentDetail",
        "handleCloseDetail",
        "onReviewFacts",
        "handleOpenReview",
        "FactReviewPanel",
        "handleCloseReview"
      ]
    },
    "file:web/src/app/app/graph/page.tsx": {
      "id": "file:web/src/app/app/graph/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/graph/page.tsx",
      "line": 1,
      "endLine": 568,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/dynamic",
          "items": [
            {
              "name": "dynamic",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useEntities",
          "items": [
            {
              "name": "useTopEntities",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useGraphData",
          "items": [
            {
              "name": "useEntitySubgraph",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useGraphStats",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useGraphVisualization",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/graph",
          "items": [
            {
              "name": "ForceGraphNode",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ForceGraphLink",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/components/graph",
          "items": [
            {
              "name": "GraphControls",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GraphContextMenu",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "SelectionDetailsPanel",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GraphFilters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GraphDisplayOptions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_GRAPH_FILTERS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "DEFAULT_DISPLAY_OPTIONS",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks",
          "items": [
            {
              "name": "useGraphInteractions",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "GraphPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/graph/page.tsx:fn:GraphPage:83"
      ],
      "classes": [],
      "topLevelReferences": [
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/app/app/graph/page.tsx:fn:GraphPage:83": {
      "id": "file:web/src/app/app/graph/page.tsx:fn:GraphPage:83",
      "type": "function",
      "name": "GraphPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/graph/page.tsx",
      "line": 83,
      "endLine": 567,
      "parentFileId": "file:web/src/app/app/graph/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering interactive force-directed graph with entity data fetching and controls",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function GraphPage() {\n  const graphRef = useRef<ForceGraphMethods>(undefined);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const hasInitialZoomRef = useRef(false);\n\n  // State\n  const [selectedEntityId, setSelectedEntityId] = useState<string | null>(null);\n  const [hoveredNode, setHoveredNode] = useState<GraphNodeWithPosition | null>(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  const [showControls, setShowControls] = useState(false);\n  const [filters, setFilters] = useState<GraphFilters>(DEFAULT_GRAPH_FILTERS);\n  const [displayOptions, setDisplayOptions] = useState<GraphDisplayOptions>(DEFAULT_DISPLAY_OPTIONS);\n\n  // Data fetching\n  const { data: stats, isLoading: statsLoading } = useGraphStats();\n  const { data: entities, isLoading: entitiesLoading } = useTopEntities(20);\n\n  // Full visualization (when no entity selected)\n  const { data: fullGraphData, isLoading: fullGraphLoading } = useGraphVisualization({\n    nodeLimit: filters.entityLimit + filters.memoryLimit,\n    entityLimit: filters.entityLimit,\n    memoryLimit: filters.memoryLimit,\n    minSalience: filters.minSalience,\n    entityTypes: filters.entityTypes.length < 6 ? filters.entityTypes : undefined,\n    enabled: !selectedEntityId, // Only fetch when no entity is selected\n  });\n\n  // Entity subgraph (when entity is selected)\n  const { data: entityGraphData, isLoading: entityGraphLoading } = useEntitySubgraph(selectedEntityId, {\n    memoryLimit: 30,\n    entityLimit: 15,\n  });\n\n  // Choose which data to display\n  const graphData = selectedEntityId ? entityGraphData : fullGraphData;\n  const graphLoading = selectedEntityId ? entityGraphLoading : fullGraphLoading;\n\n  // CRITICAL: Memoize the graphData passed to ForceGraph2D\n  // Without this, every render creates new object references, causing ForceGraph to restart simulation\n  const stableGraphData = useMemo(() => {\n    if (!graphData) return null;\n    return {\n      nodes: graphData.nodes.map(n => ({ ...n })),\n      links: graphData.links.map(l => ({ ...l })),\n    };\n  }, [graphData]);\n\n  // Graph interactions\n  const {\n    state: interactionState,\n    handlers: interactionHandlers,\n    getNodeOpacity,\n    getLinkOpacity,\n  } = useGraphInteractions({\n    graphData: graphData ?? null,\n    onEntityClick: (entityId) => setSelectedEntityId(entityId),\n    onZoomToNode: (node) => {\n      if (graphRef.current && node) {\n        // Zoom to and center on the node\n        graphRef.current.centerAt(\n          (node as GraphNodeWithPosition).x,\n          (node as GraphNodeWithPosition).y,\n          500\n        );\n        graphRef.current.zoom(2.5, 500);\n      }\n    },\n  });\n\n  // Reset zoom ref when graph data source changes (entity selected/deselected)\n  useEffect(() => {\n    hasInitialZoomRef.current = false;\n  }, [selectedEntityId]);\n\n  // Handle container resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        setDimensions({\n          width: rect.width,\n          height: rect.height,\n        });\n      }\n    };\n\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n\n  // Node click handler\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const handleNodeClick = useCallback((node: any, event: MouseEvent) => {\n    interactionHandlers.handleNodeClick(node as ForceGraphNode, event);\n  }, [interactionHandlers]);\n\n  // Node right-click handler\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const handleNodeRightClick = useCallback((node: any, event: MouseEvent) => {\n    interactionHandlers.handleNodeRightClick(node as ForceGraphNode, event);\n  }, [interactionHandlers]);\n\n  // Node hover handlers\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const handleNodeHover = useCallback((node: any) => {\n    setHoveredNode(node as GraphNodeWithPosition | null);\n    interactionHandlers.handleNodeHover(node as ForceGraphNode | null);\n  }, [interactionHandlers]);\n\n  // Custom node rendering\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const nodeCanvasObject = useCallback((node: any, ctx: CanvasRenderingContext2D, globalScale: number) => {\n    const label = node.label || '';\n    const fontSize = 12 / globalScale;\n    const nodeSize = (node.val || 4) / globalScale * 2;\n    const opacity = getNodeOpacity(node.id);\n    const isSelected = interactionState.selectedNode?.id === node.id;\n\n    ctx.globalAlpha = opacity;\n\n    // Draw node circle\n    ctx.beginPath();\n    ctx.arc(node.x || 0, node.y || 0, nodeSize, 0, 2 * Math.PI);\n    ctx.fillStyle = node.color || '#64748b';\n    ctx.fill();\n\n    // Draw border if hovered or selected\n    if (hoveredNode?.id === node.id || isSelected) {\n      ctx.strokeStyle = isSelected ? '#22d3ee' : '#fff';\n      ctx.lineWidth = (isSelected ? 3 : 2) / globalScale;\n      ctx.stroke();\n    }\n\n    // Draw label (when labels are enabled or zoom is sufficient)\n    if (displayOptions.showLabels && globalScale > 0.5) {\n      ctx.font = `${fontSize}px Inter, sans-serif`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillStyle = '#e2e8f0';\n      ctx.fillText(label.slice(0, 20), node.x || 0, (node.y || 0) + nodeSize + fontSize);\n    }\n\n    ctx.globalAlpha = 1;\n  }, [hoveredNode, getNodeOpacity, interactionState.selectedNode, displayOptions.showLabels]);\n\n  // Zoom controls\n  const handleZoomIn = useCallback(() => {\n    graphRef.current?.zoom(1.5, 400);\n  }, []);\n\n  const handleZoomOut = useCallback(() => {\n    graphRef.current?.zoom(0.67, 400);\n  }, []);\n\n  const handleCenter = useCallback(() => {\n    graphRef.current?.centerAt(0, 0, 400);\n    graphRef.current?.zoom(1, 400);\n  }, []);\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      {/* Header */}\n      <div className=\"flex-none px-6 py-4 border-b border-border\">\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h1 className=\"text-xl font-semibold text-foreground flex items-center gap-2\">\n              <span className=\"text-accent-magenta\">{icons.graph}</span>\n              Memory Graph\n            </h1>\n            <p className=\"text-sm text-foreground-muted mt-1\">\n              {selectedEntityId\n                ? 'Viewing connections for selected entity'\n                : 'Showing top entities and their memory connections'}\n            </p>\n          </div>\n\n          <div className=\"flex items-center gap-4\">\n            {/* Stats */}\n            {stats && !statsLoading && (\n              <div className=\"flex items-center gap-4 text-sm\">\n                <div className=\"flex items-center gap-1.5 text-foreground-muted\">\n                  <span className=\"text-blue-400\">{icons.memory}</span>\n                  <span>{stats.memoryCount} memories</span>\n                </div>\n                <div className=\"flex items-center gap-1.5 text-foreground-muted\">\n                  <span className=\"text-violet-400\">{icons.users}</span>\n                  <span>{stats.entityCount} entities</span>\n                </div>\n              </div>\n            )}\n\n            {/* Controls Toggle */}\n            <button\n              onClick={() => setShowControls(!showControls)}\n              className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-sm transition-colors ${\n                showControls\n                  ? 'bg-primary/20 text-primary border border-primary/30'\n                  : 'bg-surface-raised border border-border hover:bg-surface-sunken text-foreground-muted'\n              }`}\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4\" />\n              </svg>\n              Controls\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"flex-1 flex overflow-hidden\">\n        {/* Entity Sidebar */}\n        <div className=\"w-64 flex-none border-r border-border overflow-auto bg-surface-raised/50\">\n          <div className=\"p-4\">\n            <div className=\"flex items-center justify-between mb-3\">\n              <h2 className=\"text-sm font-medium text-foreground\">\n                {selectedEntityId ? 'Entity Focus' : 'Full Graph'}\n              </h2>\n              {selectedEntityId && (\n                <button\n                  onClick={() => setSelectedEntityId(null)}\n                  className=\"text-xs text-foreground-muted hover:text-foreground transition-colors\"\n                >\n                  Show All\n                </button>\n              )}\n            </div>\n\n            {entitiesLoading ? (\n              <div className=\"space-y-2\">\n                {Array.from({ length: 8 }).map((_, i) => (\n                  <div key={i} className=\"h-10 rounded bg-surface-sunken animate-pulse\" />\n                ))}\n              </div>\n            ) : entities?.entities && entities.entities.length > 0 ? (\n              <div className=\"space-y-1\">\n                {entities.entities.map((entity) => (\n                  <button\n                    key={entity.id}\n                    onClick={() => setSelectedEntityId(entity.id)}\n                    className={`w-full text-left px-3 py-2 rounded-lg transition-colors text-sm ${\n                      selectedEntityId === entity.id\n                        ? 'bg-primary/20 text-primary border border-primary/30'\n                        : 'hover:bg-surface-sunken text-foreground-muted hover:text-foreground'\n                    }`}\n                  >\n                    <div className=\"flex items-center gap-2\">\n                      <span\n                        className=\"w-2 h-2 rounded-full flex-none\"\n                        style={{ backgroundColor: entityTypeColors[entity.type] || '#64748b' }}\n                      />\n                      <span className=\"truncate\">{entity.name}</span>\n                    </div>\n                    <div className=\"text-xs text-foreground-muted mt-0.5 pl-4\">\n                      {entity.mention_count} mentions\n                    </div>\n                  </button>\n                ))}\n              </div>\n            ) : (\n              <p className=\"text-sm text-foreground-muted\">No entities found</p>\n            )}\n          </div>\n        </div>\n\n        {/* Graph Container */}\n        <div ref={containerRef} className=\"flex-1 relative bg-surface-sunken\">\n          {/* Zoom Controls */}\n          <div className=\"absolute top-4 right-4 z-10 flex flex-col gap-1\">\n            <button\n              onClick={handleZoomIn}\n              className=\"p-2 rounded-lg bg-surface-raised border border-border hover:bg-surface-sunken transition-colors\"\n              title=\"Zoom in\"\n            >\n              {icons.zoom}\n            </button>\n            <button\n              onClick={handleZoomOut}\n              className=\"p-2 rounded-lg bg-surface-raised border border-border hover:bg-surface-sunken transition-colors\"\n              title=\"Zoom out\"\n            >\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={1.5} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7\" />\n              </svg>\n            </button>\n            <button\n              onClick={handleCenter}\n              className=\"p-2 rounded-lg bg-surface-raised border border-border hover:bg-surface-sunken transition-colors\"\n              title=\"Center view\"\n            >\n              {icons.center}\n            </button>\n          </div>\n\n          {/* Hovered Node Info */}\n          {hoveredNode && (\n            <div className=\"absolute bottom-4 left-4 z-10 p-3 rounded-lg bg-surface-raised border border-border shadow-lg max-w-xs\">\n              <div className=\"text-sm font-medium text-foreground\">{hoveredNode.label}</div>\n              <div className=\"text-xs text-foreground-muted mt-1\">\n                Type: {hoveredNode.type}\n              </div>\n            </div>\n          )}\n\n          {/* Graph or Empty State */}\n          {graphLoading ? (\n            <div className=\"h-full flex items-center justify-center\">\n              <div className=\"flex flex-col items-center gap-3\">\n                <div className=\"w-8 h-8 border-2 border-primary border-t-transparent rounded-full animate-spin\" />\n                <p className=\"text-sm text-foreground-muted\">Loading graph...</p>\n              </div>\n            </div>\n          ) : stableGraphData && stableGraphData.nodes.length > 0 ? (\n            <ForceGraph2D\n              key={selectedEntityId || 'full-graph'}\n              ref={graphRef}\n              width={dimensions.width}\n              height={dimensions.height}\n              graphData={stableGraphData}\n              nodeId=\"id\"\n              nodeLabel=\"label\"\n              nodeVal=\"val\"\n              nodeColor=\"color\"\n              linkSource=\"source\"\n              linkTarget=\"target\"\n              linkColor=\"color\"\n              linkWidth={(link: unknown) => Math.max(1, ((link as { weight?: number }).weight || 0.5) * 3)}\n              linkLineDash={(link: unknown) => {\n                const opacity = getLinkOpacity(link as ForceGraphLink);\n                return opacity < 0.5 ? [2, 2] : [];\n              }}\n              linkDirectionalParticles={displayOptions.showParticles ? 2 : 0}\n              linkDirectionalParticleWidth={2}\n              onNodeClick={handleNodeClick}\n              onNodeRightClick={handleNodeRightClick}\n              onNodeHover={handleNodeHover}\n              onBackgroundClick={interactionHandlers.handleBackgroundClick}\n              nodeCanvasObject={nodeCanvasObject}\n              backgroundColor=\"transparent\"\n              cooldownTicks={100}\n              autoPauseRedraw={false}\n              enableNodeDrag={false}\n              onEngineStop={() => {\n                if (!hasInitialZoomRef.current) {\n                  hasInitialZoomRef.current = true;\n                  graphRef.current?.zoomToFit(400, 50);\n                }\n              }}\n            />\n          ) : null}\n\n          {/* Context Menu */}\n          {interactionState.contextMenuOpen && interactionState.contextMenuNode && interactionState.contextMenuPosition && (\n            <GraphContextMenu\n              node={interactionState.contextMenuNode}\n              position={interactionState.contextMenuPosition}\n              onClose={interactionHandlers.closeContextMenu}\n              onFocus={(node) => {\n                if (graphRef.current) {\n                  graphRef.current.centerAt(\n                    (node as GraphNodeWithPosition).x,\n                    (node as GraphNodeWithPosition).y,\n                    500\n                  );\n                  graphRef.current.zoom(2.5, 500);\n                }\n              }}\n              onViewDetails={(node) => {\n                if (node.type === 'entity') {\n                  setSelectedEntityId(node.id);\n                }\n              }}\n              onFindRelated={(node) => {\n                if (node.type === 'entity') {\n                  setSelectedEntityId(node.id);\n                }\n              }}\n            />\n          )}\n\n          {/* Empty State */}\n          {!graphLoading && (!graphData || graphData.nodes.length === 0) && (\n            <div className=\"h-full flex flex-col items-center justify-center text-center p-8\">\n              <div className=\"w-16 h-16 mx-auto rounded-full bg-accent-magenta/10 border border-accent-magenta/30 flex items-center justify-center mb-4\">\n                <span className=\"text-accent-magenta\">{icons.graph}</span>\n              </div>\n              <h2 className=\"text-lg font-medium text-foreground mb-2\">\n                No Graph Data\n              </h2>\n              <p className=\"text-sm text-foreground-muted max-w-sm\">\n                {selectedEntityId\n                  ? 'No connections found for this entity. Try selecting a different entity.'\n                  : 'No memories or entities found. Add some memories to see the graph visualization.'}\n              </p>\n            </div>\n          )}\n        </div>\n\n        {/* Right Panel: Controls or Selection Details */}\n        {(showControls || interactionState.selectedNode) && (\n          <div className=\"w-72 flex-none border-l border-border overflow-hidden bg-surface-raised/50 flex flex-col\">\n            {/* Panel Tabs */}\n            {showControls && interactionState.selectedNode && (\n              <div className=\"flex border-b border-border\">\n                <button\n                  onClick={() => setShowControls(true)}\n                  className={`flex-1 px-3 py-2 text-xs font-medium transition-colors ${\n                    showControls && !interactionState.selectedNode\n                      ? 'text-primary border-b-2 border-primary'\n                      : 'text-foreground-muted hover:text-foreground'\n                  }`}\n                >\n                  Controls\n                </button>\n                <button\n                  onClick={() => setShowControls(false)}\n                  className={`flex-1 px-3 py-2 text-xs font-medium transition-colors ${\n                    !showControls || interactionState.selectedNode\n                      ? 'text-primary border-b-2 border-primary'\n                      : 'text-foreground-muted hover:text-foreground'\n                  }`}\n                >\n                  Details\n                </button>\n              </div>\n            )}\n\n            {/* Panel Content */}\n            <div className=\"flex-1 overflow-auto\">\n              {showControls && !interactionState.selectedNode ? (\n                <GraphControls\n                  filters={filters}\n                  displayOptions={displayOptions}\n                  onFiltersChange={setFilters}\n                  onDisplayOptionsChange={setDisplayOptions}\n                />\n              ) : interactionState.selectedNode ? (\n                <SelectionDetailsPanel\n                  selectedNode={interactionState.selectedNode}\n                  graphData={graphData ?? null}\n                  onEntityClick={(entityId) => setSelectedEntityId(entityId)}\n                  onMemoryClick={() => {/* Could navigate to timeline */}}\n                  onClearSelection={interactionHandlers.clearSelection}\n                />\n              ) : (\n                <GraphControls\n                  filters={filters}\n                  displayOptions={displayOptions}\n                  onFiltersChange={setFilters}\n                  onDisplayOptionsChange={setDisplayOptions}\n                />\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Legend */}\n      <div className=\"flex-none px-6 py-3 border-t border-border bg-surface-raised/50\">\n        <div className=\"flex items-center justify-center gap-6 text-xs text-foreground-muted\">\n          <div className=\"flex items-center gap-1.5\">\n            <span className=\"w-3 h-3 rounded-full bg-violet-400\" />\n            <span>Entity</span>\n          </div>\n          <div className=\"flex items-center gap-1.5\">\n            <span className=\"w-3 h-3 rounded-full bg-blue-400\" />\n            <span>Memory</span>\n          </div>\n          <div className=\"flex items-center gap-1.5\">\n            <span className=\"w-6 h-0.5 bg-blue-500\" />\n            <span>Similar</span>\n          </div>\n          <div className=\"flex items-center gap-1.5\">\n            <span className=\"w-6 h-0.5 bg-violet-500\" />\n            <span>Mentions</span>\n          </div>\n          <div className=\"flex items-center gap-1.5\">\n            <span className=\"w-6 h-0.5 bg-amber-500\" />\n            <span>Co-occurs</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useRef",
        "selectedEntityId",
        "setSelectedEntityId",
        "useState",
        "hoveredNode",
        "setHoveredNode",
        "dimensions",
        "setDimensions",
        "showControls",
        "setShowControls",
        "filters",
        "setFilters",
        "DEFAULT_GRAPH_FILTERS",
        "displayOptions",
        "setDisplayOptions",
        "DEFAULT_DISPLAY_OPTIONS",
        "data",
        "stats",
        "isLoading",
        "statsLoading",
        "useGraphStats",
        "entities",
        "entitiesLoading",
        "useTopEntities",
        "fullGraphData",
        "fullGraphLoading",
        "useGraphVisualization",
        "entityGraphData",
        "entityGraphLoading",
        "useEntitySubgraph",
        "useMemo",
        "graphData",
        "n",
        "l",
        "state",
        "interactionState",
        "handlers",
        "interactionHandlers",
        "getNodeOpacity",
        "getLinkOpacity",
        "useGraphInteractions",
        "entityId",
        "graphRef",
        "node",
        "useEffect",
        "hasInitialZoomRef",
        "containerRef",
        "rect",
        "updateDimensions",
        "window",
        "useCallback",
        "event",
        "globalScale",
        "ctx",
        "opacity",
        "nodeSize",
        "Math",
        "isSelected",
        "fontSize",
        "label",
        "div",
        "className",
        "h1",
        "span",
        "icons",
        "p",
        "button",
        "onClick",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h2",
        "Array",
        "key",
        "i",
        "entity",
        "style",
        "entityTypeColors",
        "ref",
        "handleZoomIn",
        "title",
        "handleZoomOut",
        "handleCenter",
        "graphLoading",
        "stableGraphData",
        "ForceGraph2D",
        "width",
        "height",
        "nodeId",
        "nodeLabel",
        "nodeVal",
        "nodeColor",
        "linkSource",
        "linkTarget",
        "linkColor",
        "linkWidth",
        "link",
        "linkLineDash",
        "linkDirectionalParticles",
        "linkDirectionalParticleWidth",
        "onNodeClick",
        "handleNodeClick",
        "onNodeRightClick",
        "handleNodeRightClick",
        "onNodeHover",
        "handleNodeHover",
        "onBackgroundClick",
        "nodeCanvasObject",
        "backgroundColor",
        "cooldownTicks",
        "autoPauseRedraw",
        "enableNodeDrag",
        "onEngineStop",
        "GraphContextMenu",
        "position",
        "onClose",
        "onFocus",
        "onViewDetails",
        "onFindRelated",
        "GraphControls",
        "onFiltersChange",
        "onDisplayOptionsChange",
        "SelectionDetailsPanel",
        "selectedNode",
        "onEntityClick",
        "onMemoryClick",
        "onClearSelection"
      ]
    },
    "file:web/src/app/app/lists/page.tsx": {
      "id": "file:web/src/app/app/lists/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/lists/page.tsx",
      "line": 1,
      "endLine": 191,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Suspense",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/navigation",
          "items": [
            {
              "name": "useSearchParams",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRouter",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "List",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateListInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/lists",
          "items": [
            {
              "name": "fetchLists",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "archiveList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/lists",
          "items": [
            {
              "name": "ListsList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListEditor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "ListDetailView",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "ListsPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/lists/page.tsx:fn:ListsPageContent:15",
        "file:web/src/app/app/lists/page.tsx:fn:ListsPage:184"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/lists/page.tsx:fn:ListsPageContent:15": {
      "id": "file:web/src/app/app/lists/page.tsx:fn:ListsPageContent:15",
      "type": "function",
      "name": "ListsPageContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/lists/page.tsx",
      "line": 15,
      "endLine": 182,
      "parentFileId": "file:web/src/app/app/lists/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for lists page: loads, displays, edits, creates lists with detail view",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function ListsPageContent() {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const openListId = searchParams.get('open');\n\n  const [lists, setLists] = useState<List[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [editorOpen, setEditorOpen] = useState(false);\n  const [editingList, setEditingList] = useState<List | null>(null);\n  const [detailListId, setDetailListId] = useState<string | null>(openListId);\n\n  const loadLists = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const data = await fetchLists({ limit: 100 });\n      setLists(data);\n    } catch (err) {\n      console.error('Failed to load lists:', err);\n      setError('Failed to load lists');\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadLists();\n  }, [loadLists]);\n\n  useEffect(() => {\n    if (openListId) {\n      setDetailListId(openListId);\n    }\n  }, [openListId]);\n\n  const handleOpen = (list: List) => {\n    setDetailListId(list.id);\n    router.push(`/app/lists?open=${list.id}`, { scroll: false });\n  };\n\n  const handleCloseDetail = () => {\n    setDetailListId(null);\n    router.push('/app/lists', { scroll: false });\n  };\n\n  const handleEdit = (list: List) => {\n    setEditingList(list);\n    setEditorOpen(true);\n  };\n\n  const handleEditFromDetail = () => {\n    if (detailListId) {\n      const list = lists.find((l) => l.id === detailListId);\n      if (list) {\n        handleEdit(list);\n      }\n    }\n  };\n\n  const handleCreateNew = () => {\n    setEditingList(null);\n    setEditorOpen(true);\n  };\n\n  const handleSave = async (input: CreateListInput, listId?: string) => {\n    if (listId) {\n      const updated = await updateList(listId, input);\n      setLists((prev) =>\n        prev.map((l) => (l.id === listId ? updated : l))\n      );\n    } else {\n      const created = await createList(input);\n      setLists((prev) => [created, ...prev]);\n    }\n  };\n\n  const handleArchive = async (list: List) => {\n    if (!confirm('Archive this list?')) return;\n    try {\n      await archiveList(list.id);\n      setLists((prev) => prev.filter((l) => l.id !== list.id));\n    } catch (err) {\n      console.error('Failed to archive list:', err);\n    }\n  };\n\n  const handleDelete = async (list: List) => {\n    if (!confirm('Permanently delete this list? This cannot be undone.')) return;\n    try {\n      await deleteList(list.id);\n      setLists((prev) => prev.filter((l) => l.id !== list.id));\n    } catch (err) {\n      console.error('Failed to delete list:', err);\n    }\n  };\n\n  return (\n    <div className=\"p-6 max-w-7xl mx-auto\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-6\">\n        <div>\n          <h1 className=\"text-2xl font-bold text-foreground\">Lists</h1>\n          <p className=\"text-sm text-foreground-muted mt-1\">\n            Organize tasks and track progress\n          </p>\n        </div>\n        <button\n          onClick={handleCreateNew}\n          className=\"\n            inline-flex items-center gap-2 px-4 py-2 rounded-lg\n            bg-primary text-white\n            hover:bg-primary/90 transition-colors\n          \"\n        >\n          <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n          </svg>\n          New List\n        </button>\n      </div>\n\n      {/* Error state */}\n      {error && (\n        <div className=\"mb-6 p-4 rounded-lg bg-red-500/10 border border-red-500/30 text-red-400\">\n          {error}\n          <button\n            onClick={loadLists}\n            className=\"ml-2 underline hover:no-underline\"\n          >\n            Retry\n          </button>\n        </div>\n      )}\n\n      {/* Lists grid */}\n      <ListsList\n        lists={lists}\n        isLoading={isLoading}\n        onOpen={handleOpen}\n        onEdit={handleEdit}\n        onArchive={handleArchive}\n        onDelete={handleDelete}\n      />\n\n      {/* List editor modal */}\n      <ListEditor\n        list={editingList}\n        isOpen={editorOpen}\n        onClose={() => {\n          setEditorOpen(false);\n          setEditingList(null);\n        }}\n        onSave={handleSave}\n      />\n\n      {/* List detail slide-out */}\n      {detailListId && (\n        <ListDetailView\n          listId={detailListId}\n          isOpen={!!detailListId}\n          onClose={handleCloseDetail}\n          onEdit={handleEditFromDetail}\n        />\n      )}\n    </div>\n  );\n}",
      "references": [
        "useRouter",
        "useSearchParams",
        "searchParams",
        "lists",
        "setLists",
        "useState",
        "isLoading",
        "setIsLoading",
        "error",
        "setError",
        "editorOpen",
        "setEditorOpen",
        "editingList",
        "setEditingList",
        "detailListId",
        "setDetailListId",
        "openListId",
        "useCallback",
        "fetchLists",
        "data",
        "console",
        "err",
        "useEffect",
        "loadLists",
        "list",
        "router",
        "l",
        "handleEdit",
        "listId",
        "updateList",
        "input",
        "prev",
        "updated",
        "createList",
        "created",
        "confirm",
        "archiveList",
        "deleteList",
        "div",
        "className",
        "h1",
        "p",
        "button",
        "onClick",
        "handleCreateNew",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "ListsList",
        "onOpen",
        "handleOpen",
        "onEdit",
        "onArchive",
        "handleArchive",
        "onDelete",
        "handleDelete",
        "ListEditor",
        "isOpen",
        "onClose",
        "onSave",
        "handleSave",
        "ListDetailView",
        "handleCloseDetail",
        "handleEditFromDetail"
      ]
    },
    "file:web/src/app/app/lists/page.tsx:fn:ListsPage:184": {
      "id": "file:web/src/app/app/lists/page.tsx:fn:ListsPage:184",
      "type": "function",
      "name": "ListsPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/lists/page.tsx",
      "line": 184,
      "endLine": 190,
      "parentFileId": "file:web/src/app/app/lists/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders Suspense wrapper around ListsPageContent with loading fallback.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.812Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function ListsPage() {\n  return (\n    <Suspense fallback={<div className=\"p-6\">Loading...</div>}>\n      <ListsPageContent />\n    </Suspense>\n  );\n}",
      "references": [
        "Suspense",
        "fallback",
        "div",
        "className",
        "ListsPageContent"
      ]
    },
    "file:web/src/app/app/notes/page.tsx": {
      "id": "file:web/src/app/app/notes/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/notes/page.tsx",
      "line": 1,
      "endLine": 158,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Note",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "CreateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "UpdateNoteInput",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        },
        {
          "source": "@/lib/api/notes",
          "items": [
            {
              "name": "fetchNotes",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "createNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "updateNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "archiveNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "deleteNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "pinNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "unpinNote",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/notes/NotesList",
          "items": [
            {
              "name": "NotesList",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/notes/NoteEditor",
          "items": [
            {
              "name": "NoteEditor",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "NotesPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/notes/page.tsx:fn:NotesPage:17"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/notes/page.tsx:fn:NotesPage:17": {
      "id": "file:web/src/app/app/notes/page.tsx:fn:NotesPage:17",
      "type": "function",
      "name": "NotesPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/notes/page.tsx",
      "line": 17,
      "endLine": 157,
      "parentFileId": "file:web/src/app/app/notes/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React page component for listing, editing, pinning, archiving notes with CRUD ops",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function NotesPage() {\n  const [notes, setNotes] = useState<Note[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [editorOpen, setEditorOpen] = useState(false);\n  const [editingNote, setEditingNote] = useState<Note | null>(null);\n\n  const loadNotes = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      const data = await fetchNotes({ limit: 100 });\n      setNotes(data);\n    } catch (err) {\n      console.error('Failed to load notes:', err);\n      setError('Failed to load notes');\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    loadNotes();\n  }, [loadNotes]);\n\n  const handleEdit = (note: Note) => {\n    setEditingNote(note);\n    setEditorOpen(true);\n  };\n\n  const handleCreateNew = () => {\n    setEditingNote(null);\n    setEditorOpen(true);\n  };\n\n  const handleSave = async (input: CreateNoteInput | UpdateNoteInput, noteId?: string) => {\n    if (noteId) {\n      const updated = await updateNote(noteId, input as UpdateNoteInput);\n      setNotes((prev) =>\n        prev.map((n) => (n.id === noteId ? updated : n))\n      );\n    } else {\n      const created = await createNote(input as CreateNoteInput);\n      setNotes((prev) => [created, ...prev]);\n    }\n  };\n\n  const handlePin = async (note: Note) => {\n    try {\n      const updated = note.is_pinned\n        ? await unpinNote(note.id)\n        : await pinNote(note.id);\n      setNotes((prev) =>\n        prev.map((n) => (n.id === note.id ? updated : n))\n      );\n    } catch (err) {\n      console.error('Failed to toggle pin:', err);\n    }\n  };\n\n  const handleArchive = async (note: Note) => {\n    if (!confirm('Archive this note?')) return;\n    try {\n      await archiveNote(note.id);\n      setNotes((prev) => prev.filter((n) => n.id !== note.id));\n    } catch (err) {\n      console.error('Failed to archive note:', err);\n    }\n  };\n\n  const handleDelete = async (note: Note) => {\n    if (!confirm('Permanently delete this note? This cannot be undone.')) return;\n    try {\n      await deleteNote(note.id);\n      setNotes((prev) => prev.filter((n) => n.id !== note.id));\n    } catch (err) {\n      console.error('Failed to delete note:', err);\n    }\n  };\n\n  return (\n    <div className=\"p-6 max-w-7xl mx-auto\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between mb-6\">\n        <div>\n          <h1 className=\"text-2xl font-bold text-foreground\">Notes</h1>\n          <p className=\"text-sm text-foreground-muted mt-1\">\n            Capture and organize your thoughts\n          </p>\n        </div>\n        <button\n          onClick={handleCreateNew}\n          className=\"\n            inline-flex items-center gap-2 px-4 py-2 rounded-lg\n            bg-primary text-white\n            hover:bg-primary/90 transition-colors\n          \"\n        >\n          <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n            <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n          </svg>\n          New Note\n        </button>\n      </div>\n\n      {/* Error state */}\n      {error && (\n        <div className=\"mb-6 p-4 rounded-lg bg-red-500/10 border border-red-500/30 text-red-400\">\n          {error}\n          <button\n            onClick={loadNotes}\n            className=\"ml-2 underline hover:no-underline\"\n          >\n            Retry\n          </button>\n        </div>\n      )}\n\n      {/* Notes list */}\n      <NotesList\n        notes={notes}\n        isLoading={isLoading}\n        onEdit={handleEdit}\n        onPin={handlePin}\n        onArchive={handleArchive}\n        onDelete={handleDelete}\n      />\n\n      {/* Note editor modal */}\n      <NoteEditor\n        note={editingNote}\n        isOpen={editorOpen}\n        onClose={() => {\n          setEditorOpen(false);\n          setEditingNote(null);\n        }}\n        onSave={handleSave}\n      />\n    </div>\n  );\n}",
      "references": [
        "notes",
        "setNotes",
        "useState",
        "isLoading",
        "setIsLoading",
        "error",
        "setError",
        "editorOpen",
        "setEditorOpen",
        "editingNote",
        "setEditingNote",
        "useCallback",
        "fetchNotes",
        "data",
        "console",
        "err",
        "useEffect",
        "loadNotes",
        "note",
        "noteId",
        "updateNote",
        "input",
        "prev",
        "n",
        "updated",
        "createNote",
        "created",
        "unpinNote",
        "pinNote",
        "confirm",
        "archiveNote",
        "deleteNote",
        "div",
        "className",
        "h1",
        "p",
        "button",
        "onClick",
        "handleCreateNew",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "NotesList",
        "onEdit",
        "handleEdit",
        "onPin",
        "handlePin",
        "onArchive",
        "handleArchive",
        "onDelete",
        "handleDelete",
        "NoteEditor",
        "isOpen",
        "onClose",
        "onSave",
        "handleSave"
      ]
    },
    "file:web/src/app/app/reminders/page.tsx": {
      "id": "file:web/src/app/app/reminders/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/reminders/page.tsx",
      "line": 1,
      "endLine": 574,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/notifications",
          "items": [
            {
              "name": "PushPermission",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "RemindersPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/reminders/page.tsx:fn:formatScheduledTime:43",
        "file:web/src/app/app/reminders/page.tsx:fn:formatFullDateTime:62",
        "file:web/src/app/app/reminders/page.tsx:fn:ReminderCard:75",
        "file:web/src/app/app/reminders/page.tsx:fn:RemindersPage:274"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:web/src/app/app/reminders/page.tsx:fn:formatScheduledTime:43": {
      "id": "file:web/src/app/app/reminders/page.tsx:fn:formatScheduledTime:43",
      "type": "function",
      "name": "formatScheduledTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/reminders/page.tsx",
      "line": 43,
      "endLine": 60,
      "parentFileId": "file:web/src/app/app/reminders/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats scheduled date string relative to now (e.g., 'In X min', 'X min ago').",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatScheduledTime(dateStr: string): string {\n  const date = new Date(dateStr);\n  const now = new Date();\n  const diff = date.getTime() - now.getTime();\n  const minutes = Math.round(diff / (1000 * 60));\n\n  if (minutes < 0) {\n    const pastMinutes = Math.abs(minutes);\n    if (pastMinutes < 60) return `${pastMinutes} min ago`;\n    if (pastMinutes < 1440) return `${Math.round(pastMinutes / 60)} hr ago`;\n    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' });\n  }\n\n  if (minutes < 1) return 'Now';\n  if (minutes < 60) return `In ${minutes} min`;\n  if (minutes < 1440) return `In ${Math.round(minutes / 60)} hr`;\n  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' });\n}",
      "references": [
        "Date",
        "date",
        "now",
        "Math",
        "diff",
        "minutes",
        "pastMinutes"
      ]
    },
    "file:web/src/app/app/reminders/page.tsx:fn:formatFullDateTime:62": {
      "id": "file:web/src/app/app/reminders/page.tsx:fn:formatFullDateTime:62",
      "type": "function",
      "name": "formatFullDateTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/reminders/page.tsx",
      "line": 62,
      "endLine": 73,
      "parentFileId": "file:web/src/app/app/reminders/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats a date string to full locale string with weekday, date, time, and timezone",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatFullDateTime(dateStr: string): string {\n  const date = new Date(dateStr);\n  return date.toLocaleString('en-US', {\n    weekday: 'long',\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    timeZoneName: 'short',\n  });\n}",
      "references": [
        "Date",
        "date"
      ]
    },
    "file:web/src/app/app/reminders/page.tsx:fn:ReminderCard:75": {
      "id": "file:web/src/app/app/reminders/page.tsx:fn:ReminderCard:75",
      "type": "function",
      "name": "ReminderCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/reminders/page.tsx",
      "line": 75,
      "endLine": 272,
      "parentFileId": "file:web/src/app/app/reminders/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  reminder,\n  onSnooze,\n  onAcknowledge,\n  onCancel,\n}",
          "type": "{ reminder: Reminder; onSnooze: (id: string, minutes: number) => void; onAcknowledge: (id: string) => void; onCancel: (id: string) => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an expandable reminder card UI component with status and actions.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function ReminderCard({\n  reminder,\n  onSnooze,\n  onAcknowledge,\n  onCancel,\n}: {\n  reminder: Reminder;\n  onSnooze: (id: string, minutes: number) => void;\n  onAcknowledge: (id: string) => void;\n  onCancel: (id: string) => void;\n}) {\n  const [expanded, setExpanded] = useState(false);\n  const isPast = new Date(reminder.scheduled_for) < new Date();\n  const canAct = reminder.status === 'pending' || reminder.status === 'sent';\n\n  // Check if body is long enough to warrant expansion\n  const hasLongBody = reminder.body && reminder.body.length > 100;\n  const isExpandable = hasLongBody || reminder.commitment_id;\n\n  const handleCardClick = (e: React.MouseEvent) => {\n    // Don't toggle if clicking on action buttons\n    if ((e.target as HTMLElement).closest('button')) return;\n    if (isExpandable) {\n      setExpanded(!expanded);\n    }\n  };\n\n  return (\n    <div\n      onClick={handleCardClick}\n      className={`p-4 rounded-lg border transition-all duration-200 ${\n        isPast && canAct ? 'border-yellow-500/50 bg-yellow-500/5' : 'border-white/10 bg-white/5'\n      } ${isExpandable ? 'cursor-pointer hover:bg-white/10' : ''} ${expanded ? 'bg-white/10' : ''}`}\n    >\n      <div className=\"flex items-start justify-between gap-3\">\n        <div className=\"flex-1 min-w-0\">\n          <div className=\"flex items-center gap-2 mb-1\">\n            <span className={`px-2 py-0.5 text-xs rounded border ${statusColors[reminder.status]}`}>\n              {statusIcons[reminder.status]} {reminder.status}\n            </span>\n            <span className=\"text-xs text-gray-500\">{reminder.channel}</span>\n            {isExpandable && (\n              <span className=\"text-xs text-gray-600\">\n                {expanded ? '' : ''}\n              </span>\n            )}\n          </div>\n          <h3 className={`font-medium text-white ${expanded ? '' : 'truncate'}`}>\n            {reminder.title || 'Commitment Reminder'}\n          </h3>\n          {reminder.body && (\n            <p className={`text-sm text-gray-400 mt-1 ${expanded ? 'whitespace-pre-wrap' : 'line-clamp-2'}`}>\n              {reminder.body}\n            </p>\n          )}\n          <div className=\"flex items-center justify-between mt-2\">\n            <p className={`text-xs ${isPast && canAct ? 'text-yellow-400' : 'text-gray-500'}`}>\n              {expanded ? formatFullDateTime(reminder.scheduled_for) : formatScheduledTime(reminder.scheduled_for)}\n            </p>\n            <p className=\"text-xs text-gray-600\" title=\"Extracted at\">\n              {new Date(reminder.created_at).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}{' '}\n              {new Date(reminder.created_at).toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}\n            </p>\n          </div>\n\n          {/* Expanded details */}\n          {expanded && (\n            <div className=\"mt-4 pt-4 border-t border-white/10 space-y-2\">\n              <div className=\"grid grid-cols-2 gap-2 text-xs\">\n                <div>\n                  <span className=\"text-gray-500\">Timezone:</span>{' '}\n                  <span className=\"text-gray-300\">{reminder.timezone}</span>\n                </div>\n                <div>\n                  <span className=\"text-gray-500\">Created:</span>{' '}\n                  <span className=\"text-gray-300\">\n                    {new Date(reminder.created_at).toLocaleDateString('en-US', {\n                      month: 'short',\n                      day: 'numeric',\n                      hour: 'numeric',\n                      minute: '2-digit',\n                    })}\n                  </span>\n                </div>\n                {reminder.sent_at && (\n                  <div>\n                    <span className=\"text-gray-500\">Sent:</span>{' '}\n                    <span className=\"text-gray-300\">\n                      {new Date(reminder.sent_at).toLocaleDateString('en-US', {\n                        month: 'short',\n                        day: 'numeric',\n                        hour: 'numeric',\n                        minute: '2-digit',\n                      })}\n                    </span>\n                  </div>\n                )}\n                {reminder.acknowledged_at && (\n                  <div>\n                    <span className=\"text-gray-500\">Acknowledged:</span>{' '}\n                    <span className=\"text-gray-300\">\n                      {new Date(reminder.acknowledged_at).toLocaleDateString('en-US', {\n                        month: 'short',\n                        day: 'numeric',\n                        hour: 'numeric',\n                        minute: '2-digit',\n                      })}\n                    </span>\n                  </div>\n                )}\n                {reminder.snoozed_until && (\n                  <div>\n                    <span className=\"text-gray-500\">Snoozed until:</span>{' '}\n                    <span className=\"text-purple-400\">\n                      {new Date(reminder.snoozed_until).toLocaleDateString('en-US', {\n                        month: 'short',\n                        day: 'numeric',\n                        hour: 'numeric',\n                        minute: '2-digit',\n                      })}\n                    </span>\n                  </div>\n                )}\n                {reminder.commitment_id && (\n                  <div className=\"col-span-2\">\n                    <span className=\"text-gray-500\">Linked to commitment:</span>{' '}\n                    <span className=\"text-blue-400 text-xs font-mono\">{reminder.commitment_id.slice(0, 8)}...</span>\n                  </div>\n                )}\n              </div>\n\n              {/* Extended snooze options when expanded */}\n              {canAct && (\n                <div className=\"pt-2\">\n                  <span className=\"text-xs text-gray-500 block mb-2\">Snooze for:</span>\n                  <div className=\"flex flex-wrap gap-2\">\n                    {[5, 15, 30, 60, 120, 1440].map((mins) => (\n                      <button\n                        key={mins}\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          onSnooze(reminder.id, mins);\n                        }}\n                        className=\"px-2 py-1 text-xs rounded bg-purple-500/10 text-purple-400 hover:bg-purple-500/20 border border-purple-500/30 transition-colors\"\n                      >\n                        {mins < 60 ? `${mins}m` : mins < 1440 ? `${mins / 60}h` : '1d'}\n                      </button>\n                    ))}\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n        {canAct && (\n          <div className=\"flex gap-1 shrink-0\">\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                onAcknowledge(reminder.id);\n              }}\n              className=\"p-2 rounded hover:bg-green-500/20 text-green-400 transition-colors\"\n              title=\"Acknowledge\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n              </svg>\n            </button>\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                onSnooze(reminder.id, 15);\n              }}\n              className=\"p-2 rounded hover:bg-purple-500/20 text-purple-400 transition-colors\"\n              title=\"Snooze 15 min\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n              </svg>\n            </button>\n            <button\n              onClick={(e) => {\n                e.stopPropagation();\n                onCancel(reminder.id);\n              }}\n              className=\"p-2 rounded hover:bg-red-500/20 text-red-400 transition-colors\"\n              title=\"Cancel\"\n            >\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "expanded",
        "setExpanded",
        "useState",
        "Date",
        "reminder",
        "hasLongBody",
        "e",
        "isExpandable",
        "div",
        "onClick",
        "handleCardClick",
        "className",
        "isPast",
        "canAct",
        "span",
        "statusColors",
        "statusIcons",
        "h3",
        "p",
        "formatFullDateTime",
        "formatScheduledTime",
        "title",
        "button",
        "key",
        "mins",
        "onSnooze",
        "onAcknowledge",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "onCancel"
      ]
    },
    "file:web/src/app/app/reminders/page.tsx:fn:RemindersPage:274": {
      "id": "file:web/src/app/app/reminders/page.tsx:fn:RemindersPage:274",
      "type": "function",
      "name": "RemindersPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/reminders/page.tsx",
      "line": 274,
      "endLine": 573,
      "parentFileId": "file:web/src/app/app/reminders/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for reminders page: fetches lists/stats, handles snooze/acknowledge via API.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function RemindersPage() {\n  const [reminders, setReminders] = useState<Reminder[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [statusFilter, setStatusFilter] = useState<ReminderStatus | null>('pending');\n  const [stats, setStats] = useState<Record<ReminderStatus, number>>({\n    pending: 0, sent: 0, acknowledged: 0, snoozed: 0, canceled: 0, failed: 0\n  });\n  const [showAddModal, setShowAddModal] = useState(false);\n  const [newReminder, setNewReminder] = useState({ title: '', body: '', scheduledFor: '' });\n  const [creating, setCreating] = useState(false);\n\n  const fetchReminders = async () => {\n    try {\n      const params = new URLSearchParams();\n      if (statusFilter) {\n        params.set('status', statusFilter);\n      }\n\n      const res = await fetch(`${API_URL}/api/reminders?${params}`);\n      const data = await res.json();\n      setReminders(data.reminders || []);\n    } catch (err) {\n      console.error('Failed to fetch reminders:', err);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const fetchStats = async () => {\n    try {\n      const res = await fetch(`${API_URL}/api/reminders/stats`);\n      const data = await res.json();\n      setStats(data.by_status || data);\n    } catch (err) {\n      console.error('Failed to fetch stats:', err);\n    }\n  };\n\n  useEffect(() => {\n    fetchReminders();\n    fetchStats();\n  }, [statusFilter]);\n\n  const handleSnooze = async (id: string, minutes: number) => {\n    try {\n      await fetch(`${API_URL}/api/reminders/${id}/snooze`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ snooze_minutes: minutes }),\n      });\n      fetchReminders();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to snooze:', err);\n    }\n  };\n\n  const handleAcknowledge = async (id: string) => {\n    try {\n      await fetch(`${API_URL}/api/reminders/${id}/acknowledge`, {\n        method: 'POST',\n      });\n      fetchReminders();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to acknowledge:', err);\n    }\n  };\n\n  const handleCancel = async (id: string) => {\n    try {\n      await fetch(`${API_URL}/api/reminders/${id}/cancel`, {\n        method: 'POST',\n      });\n      fetchReminders();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to cancel:', err);\n    }\n  };\n\n  const handleCreateReminder = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!newReminder.title.trim() || !newReminder.scheduledFor) return;\n\n    setCreating(true);\n    try {\n      const res = await fetch(`${API_URL}/api/reminders/standalone`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          title: newReminder.title,\n          body: newReminder.body || undefined,\n          scheduled_at: new Date(newReminder.scheduledFor).toISOString(),\n          timezone: 'America/New_York',\n        }),\n      });\n      if (!res.ok) {\n        const err = await res.json();\n        throw new Error(err.error || 'Failed to create reminder');\n      }\n      setNewReminder({ title: '', body: '', scheduledFor: '' });\n      setShowAddModal(false);\n      fetchReminders();\n      fetchStats();\n    } catch (err) {\n      console.error('Failed to create reminder:', err);\n      alert(err instanceof Error ? err.message : 'Failed to create reminder');\n    } finally {\n      setCreating(false);\n    }\n  };\n\n  const handleStatusClick = (status: ReminderStatus) => {\n    setStatusFilter(statusFilter === status ? null : status);\n  };\n\n  const totalCount = stats.pending + stats.snoozed + stats.acknowledged + stats.sent;\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6\">\n      <div className=\"max-w-3xl mx-auto\">\n        {/* Header */}\n        <div className=\"mb-6 flex items-start justify-between\">\n          <div>\n            <h1 className=\"text-2xl font-bold text-white mb-2\">Reminders</h1>\n            <p className=\"text-gray-400\">Your scheduled reminders and notifications</p>\n          </div>\n          <button\n            onClick={() => setShowAddModal(true)}\n            className=\"px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-sm font-medium flex items-center gap-2\"\n          >\n            <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n            </svg>\n            Add Reminder\n          </button>\n        </div>\n\n        {/* Push Notification Permission */}\n        <PushPermission className=\"mb-6\" />\n\n        {/* Stats - Clickable Filters */}\n        <div className=\"grid grid-cols-4 gap-3 mb-6\">\n          <button\n            onClick={() => handleStatusClick('pending')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'pending'\n                ? 'bg-blue-500/30 border-blue-400 ring-2 ring-blue-400/50'\n                : 'bg-blue-500/10 border-blue-500/20 hover:bg-blue-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-blue-400\">{stats.pending}</div>\n            <div className=\"text-xs text-gray-400\">Pending</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('snoozed')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'snoozed'\n                ? 'bg-purple-500/30 border-purple-400 ring-2 ring-purple-400/50'\n                : 'bg-purple-500/10 border-purple-500/20 hover:bg-purple-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-purple-400\">{stats.snoozed}</div>\n            <div className=\"text-xs text-gray-400\">Snoozed</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('acknowledged')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'acknowledged'\n                ? 'bg-green-500/30 border-green-400 ring-2 ring-green-400/50'\n                : 'bg-green-500/10 border-green-500/20 hover:bg-green-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-green-400\">{stats.acknowledged}</div>\n            <div className=\"text-xs text-gray-400\">Done</div>\n          </button>\n          <button\n            onClick={() => handleStatusClick('sent')}\n            className={`p-3 rounded-lg border transition-all text-left ${\n              statusFilter === 'sent'\n                ? 'bg-yellow-500/30 border-yellow-400 ring-2 ring-yellow-400/50'\n                : 'bg-yellow-500/10 border-yellow-500/20 hover:bg-yellow-500/20'\n            }`}\n          >\n            <div className=\"text-2xl font-bold text-yellow-400\">{stats.sent}</div>\n            <div className=\"text-xs text-gray-400\">Sent</div>\n          </button>\n        </div>\n\n        {/* Show All button when filtered */}\n        {statusFilter && (\n          <div className=\"mb-4\">\n            <button\n              onClick={() => setStatusFilter(null)}\n              className=\"text-sm text-gray-400 hover:text-white transition-colors\"\n            >\n              Show all ({totalCount})\n            </button>\n          </div>\n        )}\n\n        {/* List */}\n        {loading ? (\n          <div className=\"text-center py-12 text-gray-400\">Loading...</div>\n        ) : reminders.length === 0 ? (\n          <div className=\"text-center py-12\">\n            <div className=\"text-gray-500 mb-2\">No reminders found</div>\n            <p className=\"text-sm text-gray-600\">\n              Say &quot;remind me in X minutes to...&quot; in chat to create reminders\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-3\">\n            {reminders.map((r) => (\n              <ReminderCard\n                key={r.id}\n                reminder={r}\n                onSnooze={handleSnooze}\n                onAcknowledge={handleAcknowledge}\n                onCancel={handleCancel}\n              />\n            ))}\n          </div>\n        )}\n\n        {/* Add Reminder Modal */}\n        {showAddModal && (\n          <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4\">\n            <div className=\"bg-gray-800 rounded-xl border border-white/10 w-full max-w-md\">\n              <div className=\"p-4 border-b border-white/10 flex items-center justify-between\">\n                <h2 className=\"text-lg font-semibold text-white\">Add Reminder</h2>\n                <button\n                  onClick={() => setShowAddModal(false)}\n                  className=\"p-1 hover:bg-white/10 rounded text-gray-400 hover:text-white\"\n                >\n                  <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                  </svg>\n                </button>\n              </div>\n              <form onSubmit={handleCreateReminder} className=\"p-4 space-y-4\">\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-300 mb-1\">Title *</label>\n                  <input\n                    type=\"text\"\n                    value={newReminder.title}\n                    onChange={(e) => setNewReminder({ ...newReminder, title: e.target.value })}\n                    placeholder=\"What do you need to remember?\"\n                    className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500\"\n                    required\n                  />\n                </div>\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-300 mb-1\">When *</label>\n                  <input\n                    type=\"datetime-local\"\n                    value={newReminder.scheduledFor}\n                    onChange={(e) => setNewReminder({ ...newReminder, scheduledFor: e.target.value })}\n                    className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white focus:outline-none focus:border-blue-500\"\n                    required\n                  />\n                </div>\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-300 mb-1\">Notes (optional)</label>\n                  <textarea\n                    value={newReminder.body}\n                    onChange={(e) => setNewReminder({ ...newReminder, body: e.target.value })}\n                    placeholder=\"Additional details...\"\n                    rows={3}\n                    className=\"w-full px-3 py-2 bg-white/5 border border-white/10 rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 resize-none\"\n                  />\n                </div>\n                <div className=\"flex gap-3 pt-2\">\n                  <button\n                    type=\"button\"\n                    onClick={() => setShowAddModal(false)}\n                    className=\"flex-1 px-4 py-2 bg-white/5 hover:bg-white/10 text-gray-300 rounded-lg transition-colors\"\n                  >\n                    Cancel\n                  </button>\n                  <button\n                    type=\"submit\"\n                    disabled={creating || !newReminder.title.trim() || !newReminder.scheduledFor}\n                    className=\"flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-500/50 disabled:cursor-not-allowed text-white rounded-lg transition-colors flex items-center justify-center gap-2\"\n                  >\n                    {creating && (\n                      <span className=\"w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin\" />\n                    )}\n                    {creating ? 'Creating...' : 'Create Reminder'}\n                  </button>\n                </div>\n              </form>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "reminders",
        "setReminders",
        "useState",
        "loading",
        "setLoading",
        "statusFilter",
        "setStatusFilter",
        "stats",
        "setStats",
        "showAddModal",
        "setShowAddModal",
        "newReminder",
        "setNewReminder",
        "creating",
        "setCreating",
        "URLSearchParams",
        "params",
        "fetch",
        "API_URL",
        "res",
        "data",
        "console",
        "err",
        "useEffect",
        "fetchReminders",
        "fetchStats",
        "id",
        "JSON",
        "minutes",
        "e",
        "Date",
        "Error",
        "alert",
        "status",
        "div",
        "className",
        "h1",
        "p",
        "button",
        "onClick",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "PushPermission",
        "handleStatusClick",
        "totalCount",
        "ReminderCard",
        "key",
        "r",
        "reminder",
        "onSnooze",
        "handleSnooze",
        "onAcknowledge",
        "handleAcknowledge",
        "onCancel",
        "handleCancel",
        "h2",
        "form",
        "onSubmit",
        "handleCreateReminder",
        "label",
        "input",
        "value",
        "onChange",
        "placeholder",
        "required",
        "textarea",
        "rows",
        "disabled",
        "span"
      ]
    },
    "file:web/src/app/app/settings/page.tsx": {
      "id": "file:web/src/app/app/settings/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/settings/page.tsx",
      "line": 1,
      "endLine": 217,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useConsolidation",
          "items": [
            {
              "name": "useConsolidation",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "formatConsolidationResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useNavigationGuard",
          "items": [
            {
              "name": "useConsolidationNavigationGuard",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/api/consolidation",
          "items": [
            {
              "name": "ConsolidationResult",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "SettingsPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/settings/page.tsx:fn:SettingsPage:8"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/settings/page.tsx:fn:SettingsPage:8": {
      "id": "file:web/src/app/app/settings/page.tsx:fn:SettingsPage:8",
      "type": "function",
      "name": "SettingsPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/page.tsx",
      "line": 8,
      "endLine": 216,
      "parentFileId": "file:web/src/app/app/settings/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders settings page with consolidation trigger, state, navigation guard.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function SettingsPage() {\n  const consolidation = useConsolidation();\n  const [lastResult, setLastResult] = useState<ConsolidationResult | null>(null);\n\n  // Prevent navigation during consolidation\n  useConsolidationNavigationGuard(consolidation.isPending);\n\n  const handleSleep = async () => {\n    try {\n      const result = await consolidation.mutateAsync();\n      setLastResult(result);\n    } catch {\n      // Error handled by mutation\n    }\n  };\n\n  return (\n    <div className=\"h-full flex flex-col items-center justify-center p-8\">\n      <div className=\"text-center space-y-6 animate-fade-in max-w-lg\">\n        {/* Header */}\n        <div className=\"space-y-4\">\n          <div className=\"w-16 h-16 mx-auto rounded-full bg-foreground-muted/10 border border-foreground-muted/30 flex items-center justify-center\">\n            <svg\n              className=\"w-8 h-8 text-foreground-muted\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z\"\n              />\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M15 12a3 3 0 11-6 0 3 3 0 016 0z\"\n              />\n            </svg>\n          </div>\n          <h1 className=\"text-2xl font-bold text-foreground\">Settings</h1>\n          <p className=\"text-foreground-muted\">\n            Configure your Squire experience.\n          </p>\n        </div>\n\n        {/* Sleep/Consolidate Section */}\n        <div className=\"glass rounded-xl p-6 space-y-4\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"w-10 h-10 rounded-full bg-accent-purple/20 flex items-center justify-center\">\n              <svg\n                className=\"w-5 h-5 text-accent-purple\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z\"\n                />\n              </svg>\n            </div>\n            <div className=\"text-left\">\n              <h2 className=\"font-semibold text-foreground\">Sleep & Consolidate</h2>\n              <p className=\"text-sm text-foreground-muted\">\n                Process conversations into memories\n              </p>\n            </div>\n          </div>\n\n          <p className=\"text-sm text-foreground-muted text-left\">\n            This extracts memorable information from your chat history,\n            strengthens important memories, and discovers patterns.\n            Happens automatically after 1 hour of inactivity.\n          </p>\n\n          <button\n            onClick={handleSleep}\n            disabled={consolidation.isPending}\n            className={`\n              w-full px-4 py-3 rounded-lg font-medium\n              flex items-center justify-center gap-2\n              transition-all duration-200\n              ${consolidation.isPending\n                ? 'bg-accent-purple/30 text-foreground-muted cursor-not-allowed'\n                : 'bg-accent-purple hover:bg-accent-purple/90 text-white'\n              }\n            `}\n          >\n            {consolidation.isPending ? (\n              <>\n                <span className=\"flex gap-1\">\n                  <span className=\"w-2 h-2 bg-white/50 rounded-full animate-bounce\" style={{ animationDelay: '0ms' }} />\n                  <span className=\"w-2 h-2 bg-white/50 rounded-full animate-bounce\" style={{ animationDelay: '150ms' }} />\n                  <span className=\"w-2 h-2 bg-white/50 rounded-full animate-bounce\" style={{ animationDelay: '300ms' }} />\n                </span>\n                <span>Consolidating...</span>\n              </>\n            ) : (\n              <>\n                <svg\n                  className=\"w-5 h-5\"\n                  fill=\"none\"\n                  stroke=\"currentColor\"\n                  viewBox=\"0 0 24 24\"\n                >\n                  <path\n                    strokeLinecap=\"round\"\n                    strokeLinejoin=\"round\"\n                    strokeWidth={2}\n                    d=\"M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z\"\n                  />\n                </svg>\n                <span>Sleep Now</span>\n              </>\n            )}\n          </button>\n\n          {/* Success Result */}\n          {lastResult && consolidation.isSuccess && (\n            <div className=\"bg-accent-success/10 border border-accent-success/30 rounded-lg p-3 text-left\">\n              <div className=\"flex items-center gap-2 text-accent-success font-medium text-sm mb-1\">\n                <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                </svg>\n                Consolidation Complete\n              </div>\n              <p className=\"text-sm text-foreground-muted\">\n                {formatConsolidationResult(lastResult)}\n              </p>\n              <p className=\"text-xs text-foreground-muted/70 mt-1\">\n                Completed in {(lastResult.durationMs / 1000).toFixed(1)}s\n              </p>\n            </div>\n          )}\n\n          {/* Error Result */}\n          {consolidation.isError && (\n            <div className=\"bg-red-500/10 border border-red-500/30 rounded-lg p-3 text-left\">\n              <div className=\"flex items-center gap-2 text-red-400 font-medium text-sm mb-1\">\n                <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n                Consolidation Failed\n              </div>\n              <p className=\"text-sm text-foreground-muted\">\n                {consolidation.error instanceof Error\n                  ? consolidation.error.message\n                  : 'An unexpected error occurred'}\n              </p>\n            </div>\n          )}\n        </div>\n\n        {/* Integrations Section */}\n        <div className=\"glass rounded-xl p-6 space-y-4\">\n          <a\n            href=\"/app/settings/integrations\"\n            className=\"flex items-center gap-3 hover:bg-background-tertiary p-3 -m-3 rounded-lg transition-colors\"\n          >\n            <div className=\"w-10 h-10 rounded-full bg-blue-500/20 flex items-center justify-center\">\n              <svg\n                className=\"w-5 h-5 text-blue-400\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1\"\n                />\n              </svg>\n            </div>\n            <div className=\"text-left flex-1\">\n              <h2 className=\"font-semibold text-foreground\">Integrations</h2>\n              <p className=\"text-sm text-foreground-muted\">\n                Connect Google Calendar and other services\n              </p>\n            </div>\n            <svg\n              className=\"w-5 h-5 text-foreground-muted\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n            >\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M9 5l7 7-7 7\"\n              />\n            </svg>\n          </a>\n        </div>\n\n        {/* Placeholder for other settings */}\n        <p className=\"text-foreground-muted/50 text-sm\">\n          More settings coming soon: profiles, preferences, and API keys.\n        </p>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useConsolidation",
        "lastResult",
        "setLastResult",
        "useState",
        "useConsolidationNavigationGuard",
        "consolidation",
        "result",
        "div",
        "className",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "h1",
        "p",
        "h2",
        "button",
        "onClick",
        "handleSleep",
        "disabled",
        "span",
        "style",
        "formatConsolidationResult",
        "Error",
        "a",
        "href"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx": {
      "id": "file:web/src/app/app/timeline/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/timeline/page.tsx",
      "line": 1,
      "endLine": 687,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Suspense",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/navigation",
          "items": [
            {
              "name": "useSearchParams",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "framer-motion",
          "items": [
            {
              "name": "motion",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/hooks/useMemories",
          "items": [
            {
              "name": "useInfiniteMemories",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemorySearch",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/timeline",
          "items": [
            {
              "name": "TimelineFilters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "LoadMoreTrigger",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "EndOfTimeline",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "defaultFilters",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "getDateRangeBounds",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "TimelineFilterState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/components/dashboard",
          "items": [
            {
              "name": "DetailModal",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/stores",
          "items": [
            {
              "name": "useOpenMemoryDetail",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "Memory",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "MemorySource",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "TimelinePage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/timeline/page.tsx:fn:formatRelativeTime:75",
        "file:web/src/app/app/timeline/page.tsx:fn:formatDateHeader:98",
        "file:web/src/app/app/timeline/page.tsx:fn:groupMemoriesByDate:116",
        "file:web/src/app/app/timeline/page.tsx:fn:applyFilters:131",
        "file:web/src/app/app/timeline/page.tsx:fn:TimelineSkeleton:154",
        "file:web/src/app/app/timeline/page.tsx:fn:TimelineEmpty:190",
        "file:web/src/app/app/timeline/page.tsx:fn:NoResultsState:205",
        "file:web/src/app/app/timeline/page.tsx:fn:MemoryCard:261",
        "file:web/src/app/app/timeline/page.tsx:fn:DateSection:445",
        "file:web/src/app/app/timeline/page.tsx:fn:TimelineContent:480",
        "file:web/src/app/app/timeline/page.tsx:fn:TimelinePage:680",
        "file:web/src/app/app/timeline/page.tsx:fn:ChevronIcon:224"
      ],
      "classes": [],
      "topLevelReferences": [
        "svg",
        "className",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "icons",
        "index"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:formatRelativeTime:75": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:formatRelativeTime:75",
      "type": "function",
      "name": "formatRelativeTime",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 75,
      "endLine": 95,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date string to relative time (e.g., '2h ago') or short date if older.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatRelativeTime(date: string | null | undefined): string {\n  if (!date) return '';\n\n  const now = new Date();\n  const then = new Date(date);\n\n  // Check for invalid date\n  if (isNaN(then.getTime())) return '';\n\n  const diffMs = now.getTime() - then.getTime();\n  const diffMins = Math.floor(diffMs / (1000 * 60));\n  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));\n  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\n\n  if (diffMins < 1) return 'Just now';\n  if (diffMins < 60) return `${diffMins}m ago`;\n  if (diffHours < 24) return `${diffHours}h ago`;\n  if (diffDays < 7) return `${diffDays}d ago`;\n\n  return then.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n}",
      "references": [
        "Date",
        "isNaN",
        "then",
        "now",
        "Math",
        "diffMs",
        "diffMins",
        "diffHours",
        "diffDays"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:formatDateHeader:98": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:formatDateHeader:98",
      "type": "function",
      "name": "formatDateHeader",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 98,
      "endLine": 113,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "date",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date string to 'Today', 'Yesterday', or locale date with weekday/month/day/year if needed",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDateHeader(date: string): string {\n  const d = new Date(date);\n  const today = new Date();\n  const yesterday = new Date(today);\n  yesterday.setDate(yesterday.getDate() - 1);\n\n  if (d.toDateString() === today.toDateString()) return 'Today';\n  if (d.toDateString() === yesterday.toDateString()) return 'Yesterday';\n\n  return d.toLocaleDateString('en-US', {\n    weekday: 'long',\n    month: 'long',\n    day: 'numeric',\n    year: d.getFullYear() !== today.getFullYear() ? 'numeric' : undefined,\n  });\n}",
      "references": [
        "Date",
        "today",
        "yesterday",
        "d"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:groupMemoriesByDate:116": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:groupMemoriesByDate:116",
      "type": "function",
      "name": "groupMemoriesByDate",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 116,
      "endLine": 128,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "Memory[]",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Map<string, Memory[]>",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Groups memories by creation date into Map<string, Memory[]>",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function groupMemoriesByDate(memories: Memory[]): Map<string, Memory[]> {\n  const groups = new Map<string, Memory[]>();\n\n  memories.forEach(memory => {\n    const date = new Date(memory.created_at).toDateString();\n    if (!groups.has(date)) {\n      groups.set(date, []);\n    }\n    groups.get(date)!.push(memory);\n  });\n\n  return groups;\n}",
      "references": [
        "Map",
        "Date",
        "memory",
        "groups",
        "date"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:applyFilters:131": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:applyFilters:131",
      "type": "function",
      "name": "applyFilters",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 131,
      "endLine": 151,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "memories",
          "type": "Memory[]",
          "isOptional": false,
          "defaultValue": null
        },
        {
          "name": "filters",
          "type": "TimelineFilterState",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "Memory[]",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Filters memories array by source, date range start, and minimum salience.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function applyFilters(memories: Memory[], filters: TimelineFilterState): Memory[] {\n  let filtered = [...memories];\n\n  // Filter by source\n  if (filters.sources.length > 0) {\n    filtered = filtered.filter(m => filters.sources.includes(m.source));\n  }\n\n  // Filter by date range\n  const { start } = getDateRangeBounds(filters.dateRange);\n  if (start) {\n    filtered = filtered.filter(m => new Date(m.created_at) >= start);\n  }\n\n  // Filter by salience\n  if (filters.minSalience > 0) {\n    filtered = filtered.filter(m => (m.salience ?? 0) >= filters.minSalience);\n  }\n\n  return filtered;\n}",
      "references": [
        "filtered",
        "m",
        "start",
        "getDateRangeBounds",
        "Date"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:TimelineSkeleton:154": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:TimelineSkeleton:154",
      "type": "function",
      "name": "TimelineSkeleton",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 154,
      "endLine": 187,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a skeleton loader UI for a timeline with date header and memory cards.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function TimelineSkeleton() {\n  return (\n    <div className=\"space-y-6\">\n      {/* Date header skeleton */}\n      <div className=\"h-6 w-32 bg-surface-elevated rounded animate-pulse\" />\n\n      {/* Memory cards skeleton */}\n      {[...Array(5)].map((_, i) => (\n        <div\n          key={i}\n          className=\"flex gap-4 animate-pulse\"\n          style={{ animationDelay: `${i * 100}ms` }}\n        >\n          {/* Timeline dot */}\n          <div className=\"flex flex-col items-center\">\n            <div className=\"w-3 h-3 rounded-full bg-surface-elevated\" />\n            <div className=\"w-0.5 flex-1 bg-surface-elevated/50 mt-2\" />\n          </div>\n\n          {/* Card */}\n          <div className=\"flex-1 bg-surface-elevated rounded-lg p-4 space-y-2\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"w-4 h-4 rounded bg-border\" />\n              <div className=\"h-4 w-20 bg-border rounded\" />\n              <div className=\"h-3 w-12 bg-border/50 rounded ml-auto\" />\n            </div>\n            <div className=\"h-4 w-full bg-border rounded\" />\n            <div className=\"h-4 w-3/4 bg-border/50 rounded\" />\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "Array",
        "key",
        "i",
        "style"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:TimelineEmpty:190": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:TimelineEmpty:190",
      "type": "function",
      "name": "TimelineEmpty",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 190,
      "endLine": 202,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders an empty timeline UI with icon, title, and description.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function TimelineEmpty() {\n  return (\n    <div className=\"flex-1 flex flex-col items-center justify-center p-8 text-center animate-fade-in\">\n      <div className=\"w-20 h-20 rounded-full bg-accent-gold/10 border border-accent-gold/30 flex items-center justify-center mb-4\">\n        <span className=\"text-accent-gold\">{icons.sparkles}</span>\n      </div>\n      <h2 className=\"text-lg font-semibold text-foreground mb-2\">No memories yet</h2>\n      <p className=\"text-foreground-muted max-w-md\">\n        Your timeline will fill up as you create memories through conversations, observations, and document imports.\n      </p>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "span",
        "icons",
        "h2",
        "p"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:NoResultsState:205": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:NoResultsState:205",
      "type": "function",
      "name": "NoResultsState",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 205,
      "endLine": 221,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ isSearch }",
          "type": "{ isSearch: boolean; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a no-results UI state for search or filters in timeline page",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.813Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function NoResultsState({ isSearch }: { isSearch: boolean }) {\n  return (\n    <div className=\"flex-1 flex flex-col items-center justify-center p-8 text-center animate-fade-in\">\n      <div className=\"w-20 h-20 rounded-full bg-surface-elevated border border-border/50 flex items-center justify-center mb-4\">\n        <span className=\"text-foreground-muted\">{icons.searchEmpty}</span>\n      </div>\n      <h2 className=\"text-lg font-semibold text-foreground mb-2\">\n        {isSearch ? 'No matching memories' : 'No memories match filters'}\n      </h2>\n      <p className=\"text-foreground-muted max-w-md\">\n        {isSearch\n          ? 'Try adjusting your search terms or clearing filters.'\n          : 'Try adjusting your filters to see more memories.'}\n      </p>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "span",
        "icons",
        "h2",
        "isSearch",
        "p"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:MemoryCard:261": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:MemoryCard:261",
      "type": "function",
      "name": "MemoryCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 261,
      "endLine": 432,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ memory, isLast, isExpanded, isFocused, animationIndex, onClick, onToggleExpand, searchQuery }",
          "type": "MemoryCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering a memory card with search highlighting, expansion toggle, and scroll-to-view effect.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function MemoryCard({ memory, isLast, isExpanded, isFocused, animationIndex, onClick, onToggleExpand, searchQuery }: MemoryCardProps) {\n  const cardRef = useRef<HTMLDivElement>(null);\n  const config = sourceConfig[memory.source] || sourceConfig.system;\n  const salience = memory.salience ?? 0;\n  const isHighSalience = salience >= 7;\n\n  // Check if content is long enough to need expansion\n  const isLongContent = memory.content.length > 200;\n  const hasMoreEntities = memory.entities && memory.entities.length > 3;\n  const isExpandable = isLongContent || hasMoreEntities;\n\n  // Scroll into view when focused\n  useEffect(() => {\n    if (isFocused && cardRef.current) {\n      cardRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });\n    }\n  }, [isFocused]);\n\n  // Highlight search terms in content\n  const highlightContent = (content: string, query: string) => {\n    if (!query || query.length < 2) return content;\n\n    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')})`, 'gi');\n    const parts = content.split(regex);\n\n    return parts.map((part, i) =>\n      regex.test(part) ? (\n        <mark key={i} className=\"bg-accent-gold/30 text-foreground rounded px-0.5\">\n          {part}\n        </mark>\n      ) : (\n        part\n      )\n    );\n  };\n\n  // Handle expand toggle (prevent card click)\n  const handleExpandClick = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    onToggleExpand?.(memory.id);\n  };\n\n  return (\n    <motion.div\n      ref={cardRef}\n      className=\"flex gap-4 group\"\n      onClick={() => onClick?.(memory)}\n      variants={cardVariants}\n      initial=\"hidden\"\n      animate=\"visible\"\n      custom={animationIndex}\n      layout\n    >\n      {/* Timeline connector */}\n      <div className=\"flex flex-col items-center\">\n        {/* Dot with source color */}\n        <div\n          className={`\n            w-3 h-3 rounded-full border-2 transition-transform duration-200\n            ${isHighSalience ? 'scale-125' : ''}\n            ${config.color === 'primary' ? 'border-accent-primary bg-accent-primary/30' : ''}\n            ${config.color === 'purple' ? 'border-accent-purple bg-accent-purple/30' : ''}\n            ${config.color === 'gold' ? 'border-accent-gold bg-accent-gold/30' : ''}\n            ${config.color === 'info' ? 'border-accent-info bg-accent-info/30' : ''}\n            ${config.color === 'muted' ? 'border-foreground-muted bg-foreground-muted/30' : ''}\n            group-hover:scale-150\n          `}\n        />\n        {/* Connecting line */}\n        {!isLast && (\n          <div className=\"w-0.5 flex-1 bg-border/50 mt-2\" />\n        )}\n      </div>\n\n      {/* Memory card */}\n      <motion.div\n        className={`\n          flex-1 mb-4 bg-surface-elevated rounded-lg p-4 border transition-all duration-200\n          hover:border-border hover:bg-surface-hover\n          ${onClick ? 'cursor-pointer' : ''}\n          ${isFocused\n            ? 'border-accent-primary ring-2 ring-accent-primary/30 bg-accent-primary/5'\n            : 'border-border/50'}\n        `}\n        layout\n        transition={{ duration: 0.2 }}\n      >\n        {/* Header row */}\n        <div className=\"flex items-center gap-2 mb-2\">\n          {/* Source icon */}\n          <span className={`\n            ${config.color === 'primary' ? 'text-accent-primary' : ''}\n            ${config.color === 'purple' ? 'text-accent-purple' : ''}\n            ${config.color === 'gold' ? 'text-accent-gold' : ''}\n            ${config.color === 'info' ? 'text-accent-info' : ''}\n            ${config.color === 'muted' ? 'text-foreground-muted' : ''}\n          `}>\n            {config.icon}\n          </span>\n\n          {/* Source label */}\n          <span className=\"text-xs text-foreground-muted font-medium\">\n            {config.label}\n          </span>\n\n          {/* Salience indicator */}\n          {isHighSalience && (\n            <span className=\"flex items-center gap-1 text-xs text-accent-gold\">\n              <span className=\"w-1.5 h-1.5 rounded-full bg-accent-gold\" />\n              {salience.toFixed(1)}\n            </span>\n          )}\n\n          {/* Timestamp */}\n          <span className=\"text-xs text-foreground-muted ml-auto\">\n            {formatRelativeTime(memory.created_at)}\n          </span>\n\n          {/* Expand/collapse button */}\n          {isExpandable && (\n            <button\n              onClick={handleExpandClick}\n              className=\"p-1 -m-1 rounded hover:bg-surface transition-colors text-foreground-muted hover:text-foreground\"\n              title={isExpanded ? 'Collapse' : 'Expand'}\n            >\n              <ChevronIcon expanded={isExpanded} />\n            </button>\n          )}\n        </div>\n\n        {/* Content */}\n        <p className={`text-sm text-foreground leading-relaxed ${isExpanded ? '' : 'line-clamp-3'}`}>\n          {searchQuery ? highlightContent(memory.content, searchQuery) : memory.content}\n        </p>\n\n        {/* Entities preview (if any) */}\n        {memory.entities && memory.entities.length > 0 && (\n          <div className=\"flex gap-1.5 mt-3 flex-wrap\">\n            {(isExpanded ? memory.entities : memory.entities.slice(0, 3)).map((entity) => (\n              <span\n                key={entity.id}\n                className=\"px-2 py-0.5 text-xs rounded-full bg-surface border border-border text-foreground-muted\"\n              >\n                {entity.name}\n              </span>\n            ))}\n            {!isExpanded && memory.entities.length > 3 && (\n              <span className=\"px-2 py-0.5 text-xs text-foreground-muted\">\n                +{memory.entities.length - 3}\n              </span>\n            )}\n          </div>\n        )}\n\n        {/* Expanded footer with action hint */}\n        {isExpanded && (\n          <div className=\"mt-3 pt-3 border-t border-border/50 flex items-center justify-between\">\n            <span className=\"text-xs text-foreground-muted\">\n              Click to view full details\n            </span>\n            <button\n              onClick={handleExpandClick}\n              className=\"text-xs text-accent-primary hover:underline\"\n            >\n              Collapse\n            </button>\n          </div>\n        )}\n      </motion.div>\n    </motion.div>\n  );\n}",
      "references": [
        "useRef",
        "sourceConfig",
        "memory",
        "salience",
        "isLongContent",
        "hasMoreEntities",
        "useEffect",
        "isFocused",
        "cardRef",
        "query",
        "content",
        "RegExp",
        "regex",
        "parts",
        "part",
        "mark",
        "key",
        "i",
        "className",
        "e",
        "onToggleExpand",
        "motion",
        "ref",
        "onClick",
        "variants",
        "cardVariants",
        "initial",
        "animate",
        "custom",
        "animationIndex",
        "layout",
        "div",
        "isHighSalience",
        "config",
        "isLast",
        "transition",
        "span",
        "formatRelativeTime",
        "isExpandable",
        "button",
        "handleExpandClick",
        "title",
        "isExpanded",
        "ChevronIcon",
        "expanded",
        "p",
        "searchQuery",
        "highlightContent",
        "entity"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:DateSection:445": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:DateSection:445",
      "type": "function",
      "name": "DateSection",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 445,
      "endLine": 478,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ date, memories, expandedIds, focusedId, onMemoryClick, onToggleExpand, searchQuery }",
          "type": "DateSectionProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders sticky date header and list of MemoryCard components for timeline.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function DateSection({ date, memories, expandedIds, focusedId, onMemoryClick, onToggleExpand, searchQuery }: DateSectionProps) {\n  return (\n    <div className=\"mb-8\">\n      {/* Date header */}\n      <motion.div\n        className=\"sticky top-0 z-10 bg-background/95 backdrop-blur-sm py-2 mb-4\"\n        initial={{ opacity: 0, y: -10 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ duration: 0.3 }}\n      >\n        <h3 className=\"text-sm font-semibold text-foreground-muted\">\n          {formatDateHeader(date)}\n        </h3>\n      </motion.div>\n\n      {/* Memories */}\n      <div className=\"pl-2\">\n        {memories.map((memory, idx) => (\n          <MemoryCard\n            key={memory.id}\n            memory={memory}\n            isLast={idx === memories.length - 1}\n            isExpanded={expandedIds.has(memory.id)}\n            isFocused={focusedId === memory.id}\n            animationIndex={idx}\n            onClick={onMemoryClick}\n            onToggleExpand={onToggleExpand}\n            searchQuery={searchQuery}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "motion",
        "initial",
        "animate",
        "transition",
        "h3",
        "formatDateHeader",
        "date",
        "memories",
        "MemoryCard",
        "key",
        "memory",
        "isLast",
        "idx",
        "isExpanded",
        "expandedIds",
        "isFocused",
        "focusedId",
        "animationIndex",
        "onClick",
        "onMemoryClick",
        "onToggleExpand",
        "searchQuery"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:TimelineContent:480": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:TimelineContent:480",
      "type": "function",
      "name": "TimelineContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 480,
      "endLine": 677,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for timeline of memories with filters, search, infinite scroll, and deep linking.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function TimelineContent() {\n  // URL search params for deep linking\n  const searchParams = useSearchParams();\n  const memoryParam = searchParams.get('memory');\n\n  // Filter state\n  const [filters, setFilters] = useState<TimelineFilterState>(defaultFilters);\n\n  // Expanded cards state\n  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set());\n\n  // Focused memory state (from URL param)\n  const [focusedId, setFocusedId] = useState<string | null>(null);\n\n  // Detail modal action\n  const openMemory = useOpenMemoryDetail();\n\n  // Handle URL param for deep linking\n  useEffect(() => {\n    if (memoryParam) {\n      setFocusedId(memoryParam);\n      // Clear focus highlight after 3 seconds\n      const timer = setTimeout(() => setFocusedId(null), 3000);\n      return () => clearTimeout(timer);\n    }\n  }, [memoryParam]);\n\n  // Check if searching (semantic search mode)\n  const isSearchMode = filters.searchQuery.length >= 3;\n\n  // Check if any filters are active (excluding search)\n  const hasActiveFilters =\n    filters.sources.length > 0 ||\n    filters.dateRange !== 'all' ||\n    filters.minSalience > 0;\n\n  // Infinite scroll for browsing mode\n  const {\n    data: infiniteData,\n    isLoading: isLoadingMemories,\n    isFetchingNextPage,\n    hasNextPage,\n    fetchNextPage,\n    error: memoriesError,\n  } = useInfiniteMemories({ pageSize: 30 });\n\n  // Semantic search (only when search query is long enough)\n  const {\n    data: searchResults,\n    isLoading: isSearching,\n  } = useMemorySearch(filters.searchQuery, { limit: 50 });\n\n  // Flatten infinite pages into single array\n  const allMemories = useMemo(() => {\n    if (!infiniteData?.pages) return [];\n    return infiniteData.pages.flatMap(page => page.memories);\n  }, [infiniteData?.pages]);\n\n  // Get total count from first page\n  const totalCount = infiniteData?.pages?.[0]?.total ?? 0;\n\n  // Determine which memories to display\n  const displayMemories = useMemo(() => {\n    if (isSearchMode && searchResults) {\n      // In search mode, use search results then apply additional filters\n      return applyFilters(searchResults, { ...filters, searchQuery: '' });\n    }\n\n    // In browse mode, apply filters if any are active\n    if (hasActiveFilters) {\n      return applyFilters(allMemories, filters);\n    }\n\n    // No filters - show all paginated memories\n    return allMemories;\n  }, [isSearchMode, searchResults, allMemories, filters, hasActiveFilters]);\n\n  // Group memories by date\n  const groupedMemories = useMemo(\n    () => groupMemoriesByDate(displayMemories),\n    [displayMemories]\n  );\n\n  // Handle memory click - opens detail modal\n  const handleMemoryClick = useCallback((memory: Memory) => {\n    openMemory(memory);\n  }, [openMemory]);\n\n  // Handle expand/collapse toggle\n  const handleToggleExpand = useCallback((memoryId: string) => {\n    setExpandedIds(prev => {\n      const next = new Set(prev);\n      if (next.has(memoryId)) {\n        next.delete(memoryId);\n      } else {\n        next.add(memoryId);\n      }\n      return next;\n    });\n  }, []);\n\n  // Load more handler for infinite scroll\n  const handleLoadMore = useCallback(() => {\n    if (!isFetchingNextPage && hasNextPage) {\n      fetchNextPage();\n    }\n  }, [fetchNextPage, hasNextPage, isFetchingNextPage]);\n\n  // Loading state (only for initial load)\n  const isLoading = isLoadingMemories || (isSearchMode && isSearching);\n\n  // Error state\n  const error = memoriesError;\n\n  // Check for empty base data vs no results from filters\n  const hasNoBaseData = !isLoadingMemories && allMemories.length === 0;\n  const hasNoFilterResults = displayMemories.length === 0 && !hasNoBaseData;\n\n  // Determine if we should show infinite scroll controls\n  // Only in browse mode without client-side filters (which break pagination)\n  const showInfiniteScroll = !isSearchMode && !hasActiveFilters;\n\n  return (\n    <div className=\"h-full flex flex-col p-6 overflow-hidden\">\n      {/* Detail Modal */}\n      <DetailModal />\n\n      {/* Page Header */}\n      <div className=\"mb-6 animate-fade-in flex-shrink-0\">\n        <div className=\"flex items-center gap-3 mb-1\">\n          <span className=\"text-accent-gold\">{icons.clock}</span>\n          <h1 className=\"text-2xl font-bold text-foreground\">Timeline</h1>\n        </div>\n        <p className=\"text-foreground-muted text-sm\">\n          Your memories in chronological order  scroll through time\n        </p>\n      </div>\n\n      {/* Filter Bar */}\n      <div className=\"flex-shrink-0\">\n        <TimelineFilters\n          filters={filters}\n          onFiltersChange={setFilters}\n          isSearching={isSearchMode && isSearching}\n          resultCount={displayMemories.length}\n        />\n      </div>\n\n      {/* Main Timeline Content */}\n      <div className=\"flex-1 overflow-y-auto min-h-0\">\n        {isLoading ? (\n          <TimelineSkeleton />\n        ) : error ? (\n          <div className=\"flex-1 flex items-center justify-center p-8\">\n            <div className=\"text-center text-status-error\">\n              <p className=\"font-medium\">Failed to load memories</p>\n              <p className=\"text-sm text-foreground-muted mt-1\">\n                {error instanceof Error ? error.message : 'Unknown error'}\n              </p>\n            </div>\n          </div>\n        ) : hasNoBaseData ? (\n          <TimelineEmpty />\n        ) : hasNoFilterResults ? (\n          <NoResultsState isSearch={isSearchMode} />\n        ) : (\n          <div className=\"animate-fade-in\">\n            {Array.from(groupedMemories.entries()).map(([date, memories]) => (\n              <DateSection\n                key={date}\n                date={date}\n                memories={memories}\n                expandedIds={expandedIds}\n                focusedId={focusedId}\n                onMemoryClick={handleMemoryClick}\n                onToggleExpand={handleToggleExpand}\n                searchQuery={isSearchMode ? filters.searchQuery : undefined}\n              />\n            ))}\n\n            {/* Infinite scroll controls */}\n            {showInfiniteScroll && (\n              hasNextPage ? (\n                <LoadMoreTrigger\n                  onLoadMore={handleLoadMore}\n                  hasMore={hasNextPage}\n                  isLoading={isFetchingNextPage}\n                />\n              ) : displayMemories.length > 0 ? (\n                <EndOfTimeline totalCount={totalCount} />\n              ) : null\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useSearchParams",
        "searchParams",
        "filters",
        "setFilters",
        "useState",
        "defaultFilters",
        "expandedIds",
        "setExpandedIds",
        "Set",
        "focusedId",
        "setFocusedId",
        "useOpenMemoryDetail",
        "useEffect",
        "memoryParam",
        "setTimeout",
        "clearTimeout",
        "timer",
        "data",
        "infiniteData",
        "isLoading",
        "isLoadingMemories",
        "isFetchingNextPage",
        "hasNextPage",
        "fetchNextPage",
        "error",
        "memoriesError",
        "useInfiniteMemories",
        "searchResults",
        "isSearching",
        "useMemorySearch",
        "useMemo",
        "page",
        "isSearchMode",
        "applyFilters",
        "hasActiveFilters",
        "allMemories",
        "groupMemoriesByDate",
        "displayMemories",
        "useCallback",
        "openMemory",
        "memory",
        "prev",
        "next",
        "memoryId",
        "hasNoBaseData",
        "div",
        "className",
        "DetailModal",
        "span",
        "icons",
        "h1",
        "p",
        "TimelineFilters",
        "onFiltersChange",
        "resultCount",
        "TimelineSkeleton",
        "Error",
        "TimelineEmpty",
        "hasNoFilterResults",
        "NoResultsState",
        "isSearch",
        "Array",
        "groupedMemories",
        "date",
        "memories",
        "DateSection",
        "key",
        "onMemoryClick",
        "handleMemoryClick",
        "onToggleExpand",
        "handleToggleExpand",
        "searchQuery",
        "showInfiniteScroll",
        "LoadMoreTrigger",
        "onLoadMore",
        "handleLoadMore",
        "hasMore",
        "EndOfTimeline",
        "totalCount"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:TimelinePage:680": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:TimelinePage:680",
      "type": "function",
      "name": "TimelinePage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 680,
      "endLine": 686,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders Suspense-wrapped TimelineContent with TimelineSkeleton fallback.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function TimelinePage() {\n  return (\n    <Suspense fallback={<TimelineSkeleton />}>\n      <TimelineContent />\n    </Suspense>\n  );\n}",
      "references": [
        "Suspense",
        "fallback",
        "TimelineSkeleton",
        "TimelineContent"
      ]
    },
    "file:web/src/app/app/timeline/page.tsx:fn:ChevronIcon:224": {
      "id": "file:web/src/app/app/timeline/page.tsx:fn:ChevronIcon:224",
      "type": "function",
      "name": "ChevronIcon",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/timeline/page.tsx",
      "line": 224,
      "endLine": 233,
      "parentFileId": "file:web/src/app/app/timeline/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ expanded }",
          "type": "{ expanded: boolean; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a rotatable chevron SVG icon based on expanded prop.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "const ChevronIcon = ({ expanded }: { expanded: boolean }) => (\n  <svg\n    className={`w-4 h-4 transition-transform duration-200 ${expanded ? 'rotate-180' : ''}`}\n    fill=\"none\"\n    stroke=\"currentColor\"\n    viewBox=\"0 0 24 24\"\n  >\n    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n  </svg>\n);",
      "references": [
        "svg",
        "className",
        "expanded",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d"
      ]
    },
    "file:web/src/app/app/village/error.tsx": {
      "id": "file:web/src/app/app/village/error.tsx",
      "type": "file",
      "name": "error.tsx",
      "filePath": "web/src/app/app/village/error.tsx",
      "line": 1,
      "endLine": 48,
      "imports": [],
      "exports": [
        {
          "name": "VillageError",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/village/error.tsx:fn:VillageError:3"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/village/error.tsx:fn:VillageError:3": {
      "id": "file:web/src/app/app/village/error.tsx:fn:VillageError:3",
      "type": "function",
      "name": "VillageError",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/village/error.tsx",
      "line": 3,
      "endLine": 47,
      "parentFileId": "file:web/src/app/app/village/error.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{\n  error,\n  reset,\n}",
          "type": "{ error: Error & { digest?: string; }; reset: () => void; }",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders error UI for village with WebGL detection, retry button, and 2D graph link",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function VillageError({\n  error,\n  reset,\n}: {\n  error: Error & { digest?: string };\n  reset: () => void;\n}) {\n  const isWebGLError =\n    error.message.includes('WebGL') ||\n    error.message.includes('context') ||\n    error.message.includes('THREE') ||\n    error.message.includes('gl');\n\n  return (\n    <div className=\"flex h-full w-full flex-col items-center justify-center gap-4 bg-background p-8\">\n      <div className=\"text-4xl\">\n        {isWebGLError ? '' : ''}\n      </div>\n      <h2 className=\"text-xl font-semibold text-foreground\">\n        {isWebGLError\n          ? '3D visualization not supported'\n          : 'Something went wrong'}\n      </h2>\n      <p className=\"max-w-md text-center text-foreground-muted\">\n        {isWebGLError\n          ? 'Your browser or device may not support WebGL graphics. Try using a modern browser like Chrome, Firefox, or Edge.'\n          : error.message}\n      </p>\n      <div className=\"flex gap-3\">\n        <button\n          onClick={reset}\n          className=\"rounded-lg bg-primary px-4 py-2 text-sm font-medium text-background transition-colors hover:bg-primary/90\"\n        >\n          Try again\n        </button>\n        <a\n          href=\"/app/graph\"\n          className=\"rounded-lg border border-border px-4 py-2 text-sm font-medium text-foreground transition-colors hover:bg-background-secondary\"\n        >\n          Use 2D graph instead\n        </a>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "error",
        "div",
        "className",
        "isWebGLError",
        "h2",
        "p",
        "button",
        "onClick",
        "reset",
        "a",
        "href"
      ]
    },
    "file:web/src/app/app/village/loading.tsx": {
      "id": "file:web/src/app/app/village/loading.tsx",
      "type": "file",
      "name": "loading.tsx",
      "filePath": "web/src/app/app/village/loading.tsx",
      "line": 1,
      "endLine": 11,
      "imports": [],
      "exports": [
        {
          "name": "VillageLoading",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/village/loading.tsx:fn:VillageLoading:1"
      ],
      "classes": [],
      "topLevelReferences": []
    },
    "file:web/src/app/app/village/loading.tsx:fn:VillageLoading:1": {
      "id": "file:web/src/app/app/village/loading.tsx:fn:VillageLoading:1",
      "type": "function",
      "name": "VillageLoading",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/village/loading.tsx",
      "line": 1,
      "endLine": 10,
      "parentFileId": "file:web/src/app/app/village/loading.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a centered loading spinner and 'Loading village...' text.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function VillageLoading() {\n  return (\n    <div className=\"flex h-full w-full items-center justify-center bg-background\">\n      <div className=\"flex flex-col items-center gap-3\">\n        <div className=\"h-8 w-8 animate-spin rounded-full border-2 border-primary border-t-transparent\" />\n        <span className=\"text-foreground-muted\">Loading village...</span>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "span"
      ]
    },
    "file:web/src/app/app/village/page.tsx": {
      "id": "file:web/src/app/app/village/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/village/page.tsx",
      "line": 1,
      "endLine": 27,
      "imports": [
        {
          "source": "next/dynamic",
          "items": [
            {
              "name": "dynamic",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "VillagePage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/village/page.tsx:fn:VillagePage:20"
      ],
      "classes": [],
      "topLevelReferences": [
        "div",
        "className",
        "span"
      ]
    },
    "file:web/src/app/app/village/page.tsx:fn:VillagePage:20": {
      "id": "file:web/src/app/app/village/page.tsx:fn:VillagePage:20",
      "type": "function",
      "name": "VillagePage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/village/page.tsx",
      "line": 20,
      "endLine": 26,
      "parentFileId": "file:web/src/app/app/village/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a full-screen VillageScene React component.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function VillagePage() {\n  return (\n    <div className=\"h-full w-full\">\n      <VillageScene />\n    </div>\n  );\n}",
      "references": [
        "div",
        "className",
        "VillageScene"
      ]
    },
    "file:web/src/app/app/graph/test/page.tsx": {
      "id": "file:web/src/app/app/graph/test/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/graph/test/page.tsx",
      "line": 1,
      "endLine": 223,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useRef",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useMemo",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/dynamic",
          "items": [
            {
              "name": "dynamic",
              "alias": null,
              "isDefault": true,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        }
      ],
      "exports": [
        {
          "name": "GraphTestPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/graph/test/page.tsx:fn:GraphTestPage:46"
      ],
      "classes": [],
      "topLevelReferences": [
        "div",
        "className"
      ]
    },
    "file:web/src/app/app/graph/test/page.tsx:fn:GraphTestPage:46": {
      "id": "file:web/src/app/app/graph/test/page.tsx:fn:GraphTestPage:46",
      "type": "function",
      "name": "GraphTestPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/graph/test/page.tsx",
      "line": 46,
      "endLine": 222,
      "parentFileId": "file:web/src/app/app/graph/test/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "React component rendering a testable ForceGraph with resize handling and state.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "export default function GraphTestPage() {\n  const graphRef = useRef<ForceGraphMethods>(undefined);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const hasInitialZoomRef = useRef(false);\n  \n  const [testLevel, setTestLevel] = useState<TestLevel>(1);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 600 });\n  const [hoveredNode, setHoveredNode] = useState<string | null>(null);\n  const [hoverCount, setHoverCount] = useState(0);\n  const [zoomFitCount, setZoomFitCount] = useState(0);\n\n  // Handle container resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        setDimensions({ width: rect.width, height: rect.height });\n      }\n    };\n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n\n  // Reset zoom ref when test level changes\n  useEffect(() => {\n    hasInitialZoomRef.current = false;\n    setHoverCount(0);\n    setZoomFitCount(0);\n  }, [testLevel]);\n\n  // MEMOIZE graphData so it doesn't recreate on every render\n  const graphData = useMemo(() => ({\n    nodes: TEST_DATA.nodes.map(n => ({ ...n })),\n    links: TEST_DATA.links.map(l => ({ ...l })),\n  }), []); // Empty deps = only create once\n\n  const testDescriptions: Record<TestLevel, string> = {\n    1: 'Bare minimum - no callbacks at all',\n    2: 'Add onEngineStop with zoomToFit (once via ref)',\n    3: 'Add onNodeHover (updates React state)',\n    4: 'Add nodeCanvasObject (custom canvas rendering)',\n    5: 'Add linkLineDash (callback depending on hover state)',\n  };\n\n  // Build props based on test level\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const getGraphProps = (): Record<string, any> => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const props: Record<string, any> = {\n      ref: graphRef,\n      width: dimensions.width,\n      height: dimensions.height,\n      graphData: graphData,\n      nodeId: 'id',\n      nodeLabel: 'label',\n      nodeVal: 'val',\n      nodeColor: 'color',\n      linkSource: 'source',\n      linkTarget: 'target',\n      linkColor: 'color',\n      backgroundColor: 'transparent',\n      cooldownTicks: 100,\n    };\n\n    if (testLevel >= 2) {\n      props.onEngineStop = () => {\n        if (!hasInitialZoomRef.current) {\n          hasInitialZoomRef.current = true;\n          setZoomFitCount(c => c + 1);\n          graphRef.current?.zoomToFit(400, 50);\n        }\n      };\n    }\n\n    if (testLevel >= 3) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props.onNodeHover = (node: any) => {\n        setHoveredNode(node?.id || null);\n        setHoverCount(c => c + 1);\n      };\n    }\n\n    if (testLevel >= 4) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props.nodeCanvasObject = (node: any, ctx: CanvasRenderingContext2D, globalScale: number) => {\n        const label = node.label || '';\n        const fontSize = 12 / globalScale;\n        const nodeSize = (node.val || 4) / globalScale * 2;\n\n        // Draw node circle\n        ctx.beginPath();\n        ctx.arc(node.x || 0, node.y || 0, nodeSize, 0, 2 * Math.PI);\n        ctx.fillStyle = node.color || '#64748b';\n        ctx.fill();\n\n        // Highlight if hovered (THIS IS THE KEY - depends on hoveredNode state)\n        if (hoveredNode === node.id) {\n          ctx.strokeStyle = '#fff';\n          ctx.lineWidth = 2 / globalScale;\n          ctx.stroke();\n        }\n\n        // Draw label\n        if (globalScale > 0.5) {\n          ctx.font = `${fontSize}px Inter, sans-serif`;\n          ctx.textAlign = 'center';\n          ctx.textBaseline = 'middle';\n          ctx.fillStyle = '#e2e8f0';\n          ctx.fillText(label, node.x || 0, (node.y || 0) + nodeSize + fontSize);\n        }\n      };\n    }\n\n    if (testLevel >= 5) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      props.linkLineDash = (link: any) => {\n        // This depends on hoveredNode state\n        if (!hoveredNode) return [];\n        const isConnected = link.source?.id === hoveredNode || link.target?.id === hoveredNode ||\n                           link.source === hoveredNode || link.target === hoveredNode;\n        return isConnected ? [] : [2, 2];\n      };\n    }\n\n    return props;\n  };\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      {/* Header */}\n      <div className=\"flex-none px-6 py-4 border-b border-border bg-surface-raised\">\n        <h1 className=\"text-xl font-semibold text-foreground mb-2\">\n           Graph Rendering Bug Test\n        </h1>\n        <p className=\"text-sm text-foreground-muted\">\n          Test Level {testLevel}: {testDescriptions[testLevel]}\n        </p>\n      </div>\n\n      {/* Controls */}\n      <div className=\"flex-none px-6 py-3 border-b border-border bg-surface-sunken flex items-center gap-4\">\n        <span className=\"text-sm text-foreground-muted\">Test Level:</span>\n        {([1, 2, 3, 4, 5] as TestLevel[]).map(level => (\n          <button\n            key={level}\n            onClick={() => setTestLevel(level)}\n            className={`px-3 py-1.5 rounded text-sm font-medium transition-colors ${\n              testLevel === level\n                ? 'bg-primary text-white'\n                : 'bg-surface-raised border border-border hover:bg-surface-sunken text-foreground-muted'\n            }`}\n          >\n            {level}\n          </button>\n        ))}\n        \n        <div className=\"ml-auto flex items-center gap-4 text-xs text-foreground-muted\">\n          <span>Hovers: {hoverCount}</span>\n          <span>ZoomFits: {zoomFitCount}</span>\n          <span>Hovered: {hoveredNode || 'none'}</span>\n        </div>\n      </div>\n\n      {/* Graph */}\n      <div ref={containerRef} className=\"flex-1 bg-surface-sunken\">\n        <ForceGraph2D {...getGraphProps()} />\n      </div>\n\n      {/* Instructions */}\n      <div className=\"flex-none px-6 py-3 border-t border-border bg-surface-raised text-sm text-foreground-muted\">\n        <strong>Instructions:</strong> Start at Level 1 and hover over nodes. If no bug, move to Level 2, etc. \n        The bug should appear at some level, identifying the problematic feature.\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useRef",
        "testLevel",
        "setTestLevel",
        "useState",
        "dimensions",
        "setDimensions",
        "hoveredNode",
        "setHoveredNode",
        "hoverCount",
        "setHoverCount",
        "zoomFitCount",
        "setZoomFitCount",
        "useEffect",
        "containerRef",
        "rect",
        "updateDimensions",
        "window",
        "hasInitialZoomRef",
        "useMemo",
        "TEST_DATA",
        "n",
        "l",
        "graphRef",
        "graphData",
        "props",
        "c",
        "node",
        "globalScale",
        "ctx",
        "nodeSize",
        "Math",
        "fontSize",
        "label",
        "link",
        "isConnected",
        "div",
        "className",
        "h1",
        "p",
        "testDescriptions",
        "span",
        "button",
        "key",
        "level",
        "onClick",
        "ref",
        "ForceGraph2D",
        "getGraphProps",
        "strong"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx",
      "type": "file",
      "name": "page.tsx",
      "filePath": "web/src/app/app/settings/integrations/page.tsx",
      "line": 1,
      "endLine": 465,
      "imports": [
        {
          "source": "react",
          "items": [
            {
              "name": "useState",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useEffect",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "useCallback",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "Suspense",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "next/navigation",
          "items": [
            {
              "name": "useSearchParams",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": false
        },
        {
          "source": "@/lib/types",
          "items": [
            {
              "name": "GoogleAccount",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GoogleCalendar",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            },
            {
              "name": "GoogleConnectionStatus",
              "alias": null,
              "isDefault": false,
              "isNamespace": false
            }
          ],
          "isTypeOnly": true
        }
      ],
      "exports": [
        {
          "name": "IntegrationsPage",
          "alias": null,
          "isDefault": true,
          "isTypeOnly": false,
          "kind": "function"
        }
      ],
      "functions": [
        "file:web/src/app/app/settings/integrations/page.tsx:fn:formatDate:9",
        "file:web/src/app/app/settings/integrations/page.tsx:fn:AccountCard:28",
        "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsContent:210",
        "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsLoading:441",
        "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsPage:458"
      ],
      "classes": [],
      "topLevelReferences": [
        "process"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx:fn:formatDate:9": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx:fn:formatDate:9",
      "type": "function",
      "name": "formatDate",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/integrations/page.tsx",
      "line": 9,
      "endLine": 17,
      "parentFileId": "file:web/src/app/app/settings/integrations/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "dateStr",
          "type": "string",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "string",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Formats date string to 'en-US' locale (month short, day num, hour num, min 2-digit) or 'Never' if null",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function formatDate(dateStr: string | null): string {\n  if (!dateStr) return 'Never';\n  return new Date(dateStr).toLocaleString('en-US', {\n    month: 'short',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n  });\n}",
      "references": [
        "Date"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx:fn:AccountCard:28": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx:fn:AccountCard:28",
      "type": "function",
      "name": "AccountCard",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/integrations/page.tsx",
      "line": 28,
      "endLine": 208,
      "parentFileId": "file:web/src/app/app/settings/integrations/page.tsx",
      "parentClassId": null,
      "params": [
        {
          "name": "{ account, calendars, onDisconnect, onSync, onCalendarUpdate, syncing }",
          "type": "AccountCardProps",
          "isOptional": false,
          "defaultValue": null
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for Google account integration card with calendar loading, toggling, and default setting",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function AccountCard({ account, calendars, onDisconnect, onSync, onCalendarUpdate, syncing }: AccountCardProps) {\n  const [showCalendars, setShowCalendars] = useState(false);\n  const [loadingCalendars, setLoadingCalendars] = useState(false);\n  const [calendarList, setCalendarList] = useState<GoogleCalendar[]>(calendars);\n\n  const loadCalendars = async () => {\n    if (calendarList.length > 0) {\n      setShowCalendars(!showCalendars);\n      return;\n    }\n    setLoadingCalendars(true);\n    try {\n      const res = await fetch(`${API_URL}/api/integrations/google/calendars/${account.id}`);\n      const data = await res.json();\n      setCalendarList(data.calendars || []);\n      setShowCalendars(true);\n    } catch (err) {\n      console.error('Failed to load calendars:', err);\n    } finally {\n      setLoadingCalendars(false);\n    }\n  };\n\n  const handleCalendarToggle = async (cal: GoogleCalendar) => {\n    const newEnabled = !cal.sync_enabled;\n    try {\n      await fetch(`${API_URL}/api/integrations/google/calendars/settings/${cal.id}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ sync_enabled: newEnabled }),\n      });\n      setCalendarList(prev =>\n        prev.map(c => c.id === cal.id ? { ...c, sync_enabled: newEnabled } : c)\n      );\n      onCalendarUpdate(cal.id, { sync_enabled: newEnabled });\n    } catch (err) {\n      console.error('Failed to update calendar:', err);\n    }\n  };\n\n  const handleSetDefault = async (cal: GoogleCalendar) => {\n    try {\n      await fetch(`${API_URL}/api/integrations/google/calendars/settings/${cal.id}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ is_default_for_push: true }),\n      });\n      setCalendarList(prev =>\n        prev.map(c => ({ ...c, is_default_for_push: c.id === cal.id }))\n      );\n    } catch (err) {\n      console.error('Failed to set default calendar:', err);\n    }\n  };\n\n  return (\n    <div className=\"border border-white/10 rounded-lg bg-white/5 overflow-hidden\">\n      <div className=\"p-4\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"w-10 h-10 rounded-full bg-blue-500/20 flex items-center justify-center\">\n              <svg className=\"w-5 h-5 text-blue-400\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                <path d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\" />\n                <path d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\" />\n                <path d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z\" />\n                <path d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\" />\n              </svg>\n            </div>\n            <div>\n              <div className=\"font-medium text-white\">{account.email}</div>\n              {account.display_name && (\n                <div className=\"text-sm text-gray-400\">{account.display_name}</div>\n              )}\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <span className={`px-2 py-1 text-xs rounded ${\n              account.sync_enabled\n                ? 'bg-green-500/20 text-green-400'\n                : 'bg-gray-500/20 text-gray-400'\n            }`}>\n              {account.sync_enabled ? 'Syncing' : 'Paused'}\n            </span>\n          </div>\n        </div>\n\n        <div className=\"mt-3 flex items-center gap-2 text-sm text-gray-500\">\n          <span>Last synced: {formatDate(account.last_full_sync_at)}</span>\n          <span>|</span>\n          <span>Connected: {formatDate(account.created_at)}</span>\n        </div>\n\n        <div className=\"mt-4 flex gap-2\">\n          <button\n            onClick={loadCalendars}\n            disabled={loadingCalendars}\n            className=\"px-3 py-1.5 text-sm rounded bg-white/5 hover:bg-white/10 text-gray-300 transition-colors flex items-center gap-1\"\n          >\n            {loadingCalendars ? (\n              <span className=\"w-4 h-4 border-2 border-gray-500 border-t-transparent rounded-full animate-spin\" />\n            ) : (\n              <svg className={`w-4 h-4 transition-transform ${showCalendars ? 'rotate-180' : ''}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\n              </svg>\n            )}\n            {showCalendars ? 'Hide' : 'Show'} Calendars\n          </button>\n          <button\n            onClick={() => onSync(account.id)}\n            disabled={syncing}\n            className=\"px-3 py-1.5 text-sm rounded bg-blue-500/20 hover:bg-blue-500/30 text-blue-400 transition-colors flex items-center gap-1\"\n          >\n            {syncing ? (\n              <span className=\"w-4 h-4 border-2 border-blue-400 border-t-transparent rounded-full animate-spin\" />\n            ) : (\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\" />\n              </svg>\n            )}\n            Sync Now\n          </button>\n          <button\n            onClick={() => onDisconnect(account.id)}\n            className=\"px-3 py-1.5 text-sm rounded bg-red-500/20 hover:bg-red-500/30 text-red-400 transition-colors\"\n          >\n            Disconnect\n          </button>\n        </div>\n      </div>\n\n      {showCalendars && calendarList.length > 0 && (\n        <div className=\"border-t border-white/10 p-4 space-y-2\">\n          <div className=\"text-sm font-medium text-gray-400 mb-3\">Calendars</div>\n          {calendarList.map(cal => (\n            <div\n              key={cal.id}\n              className=\"flex items-center justify-between p-2 rounded bg-white/5 hover:bg-white/10 transition-colors\"\n            >\n              <div className=\"flex items-center gap-3\">\n                <div\n                  className=\"w-3 h-3 rounded-full\"\n                  style={{ backgroundColor: cal.background_color || '#4285f4' }}\n                />\n                <div>\n                  <div className=\"text-sm text-white\">{cal.name}</div>\n                  {cal.is_primary && (\n                    <span className=\"text-xs text-gray-500\">Primary</span>\n                  )}\n                </div>\n              </div>\n              <div className=\"flex items-center gap-2\">\n                {cal.is_default_for_push && (\n                  <span className=\"text-xs px-2 py-0.5 rounded bg-purple-500/20 text-purple-400\">\n                    Push Target\n                  </span>\n                )}\n                {!cal.is_default_for_push && cal.sync_enabled && (\n                  <button\n                    onClick={() => handleSetDefault(cal)}\n                    className=\"text-xs text-gray-500 hover:text-purple-400 transition-colors\"\n                  >\n                    Set as Push Target\n                  </button>\n                )}\n                <label className=\"relative inline-flex items-center cursor-pointer\">\n                  <input\n                    type=\"checkbox\"\n                    checked={cal.sync_enabled}\n                    onChange={() => handleCalendarToggle(cal)}\n                    className=\"sr-only peer\"\n                  />\n                  <div className=\"w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-500\"></div>\n                </label>\n              </div>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}",
      "references": [
        "showCalendars",
        "setShowCalendars",
        "useState",
        "loadingCalendars",
        "setLoadingCalendars",
        "calendarList",
        "setCalendarList",
        "calendars",
        "fetch",
        "API_URL",
        "account",
        "res",
        "data",
        "console",
        "err",
        "cal",
        "JSON",
        "newEnabled",
        "prev",
        "c",
        "onCalendarUpdate",
        "div",
        "className",
        "svg",
        "viewBox",
        "fill",
        "path",
        "d",
        "span",
        "formatDate",
        "button",
        "onClick",
        "loadCalendars",
        "disabled",
        "stroke",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "onSync",
        "syncing",
        "onDisconnect",
        "key",
        "style",
        "handleSetDefault",
        "label",
        "input",
        "checked",
        "onChange",
        "handleCalendarToggle"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsContent:210": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsContent:210",
      "type": "function",
      "name": "IntegrationsContent",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/integrations/page.tsx",
      "line": 210,
      "endLine": 439,
      "parentFileId": "file:web/src/app/app/settings/integrations/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "React component for managing Google integrations: fetches status, handles OAuth connect/disconnect",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": true,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": true
        }
      },
      "source": "function IntegrationsContent() {\n  const searchParams = useSearchParams();\n  const [status, setStatus] = useState<GoogleConnectionStatus | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [syncing, setSyncing] = useState<string | null>(null);\n  const [message, setMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);\n\n  const fetchStatus = useCallback(async () => {\n    try {\n      const res = await fetch(`${API_URL}/api/integrations/google/status`);\n      const data = await res.json();\n      setStatus(data);\n    } catch (err) {\n      console.error('Failed to fetch status:', err);\n      setStatus({ configured: false, accounts: [], error: 'Failed to connect to server' });\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  useEffect(() => {\n    fetchStatus();\n\n    // Check for OAuth callback results\n    const connected = searchParams.get('connected');\n    const error = searchParams.get('error');\n\n    if (connected) {\n      setMessage({ type: 'success', text: `Connected ${connected} successfully!` });\n      // Clean URL\n      window.history.replaceState({}, '', '/app/settings/integrations');\n    } else if (error) {\n      setMessage({ type: 'error', text: `Connection failed: ${error}` });\n      window.history.replaceState({}, '', '/app/settings/integrations');\n    }\n  }, [fetchStatus, searchParams]);\n\n  const handleConnect = () => {\n    // Redirect to OAuth\n    window.location.href = `${API_URL}/api/integrations/google/auth`;\n  };\n\n  const handleDisconnect = async (accountId: string) => {\n    if (!confirm('Are you sure you want to disconnect this Google account? This will remove all synced calendars and events.')) {\n      return;\n    }\n\n    try {\n      await fetch(`${API_URL}/api/integrations/google/disconnect/${accountId}`, {\n        method: 'DELETE',\n      });\n      await fetchStatus();\n      setMessage({ type: 'success', text: 'Account disconnected' });\n    } catch (err) {\n      console.error('Failed to disconnect:', err);\n      setMessage({ type: 'error', text: 'Failed to disconnect account' });\n    }\n  };\n\n  const handleSync = async (accountId: string) => {\n    setSyncing(accountId);\n    try {\n      await fetch(`${API_URL}/api/integrations/google/sync/${accountId}`, {\n        method: 'POST',\n      });\n      await fetchStatus();\n      setMessage({ type: 'success', text: 'Sync completed!' });\n    } catch (err) {\n      console.error('Failed to sync:', err);\n      setMessage({ type: 'error', text: 'Sync failed' });\n    } finally {\n      setSyncing(null);\n    }\n  };\n\n  const handleCalendarUpdate = () => {\n    // Refresh status after calendar changes\n    fetchStatus();\n  };\n\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6\">\n      <div className=\"max-w-3xl mx-auto\">\n        {/* Header */}\n        <div className=\"mb-8\">\n          <div className=\"flex items-center gap-2 text-sm text-gray-400 mb-4\">\n            <a href=\"/app/settings\" className=\"hover:text-white transition-colors\">Settings</a>\n            <span>/</span>\n            <span className=\"text-white\">Integrations</span>\n          </div>\n          <h1 className=\"text-2xl font-bold text-white mb-2\">Integrations</h1>\n          <p className=\"text-gray-400\">Connect external services to sync calendars and data</p>\n        </div>\n\n        {/* Message Toast */}\n        {message && (\n          <div className={`mb-6 p-4 rounded-lg flex items-center justify-between ${\n            message.type === 'success'\n              ? 'bg-green-500/10 border border-green-500/30 text-green-400'\n              : 'bg-red-500/10 border border-red-500/30 text-red-400'\n          }`}>\n            <div className=\"flex items-center gap-2\">\n              {message.type === 'success' ? (\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M5 13l4 4L19 7\" />\n                </svg>\n              ) : (\n                <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n                </svg>\n              )}\n              {message.text}\n            </div>\n            <button onClick={() => setMessage(null)} className=\"p-1 hover:bg-white/10 rounded\">\n              <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          </div>\n        )}\n\n        {/* Google Calendar Section */}\n        <div className=\"space-y-6\">\n          <div className=\"p-6 rounded-xl border border-white/10 bg-white/5\">\n            <div className=\"flex items-center gap-4 mb-6\">\n              <div className=\"w-12 h-12 rounded-full bg-blue-500/20 flex items-center justify-center\">\n                <svg className=\"w-6 h-6\" viewBox=\"0 0 24 24\">\n                  <path fill=\"#4285F4\" d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\" />\n                  <path fill=\"#34A853\" d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\" />\n                  <path fill=\"#FBBC05\" d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z\" />\n                  <path fill=\"#EA4335\" d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\" />\n                </svg>\n              </div>\n              <div className=\"flex-1\">\n                <h2 className=\"text-lg font-semibold text-white\">Google Calendar</h2>\n                <p className=\"text-sm text-gray-400\">\n                  Sync your Google Calendar events with Squire for a unified view\n                </p>\n              </div>\n              {status?.configured && (\n                <button\n                  onClick={handleConnect}\n                  className=\"px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors text-sm font-medium flex items-center gap-2\"\n                >\n                  <svg className=\"w-4 h-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v16m8-8H4\" />\n                  </svg>\n                  Add Account\n                </button>\n              )}\n            </div>\n\n            {loading ? (\n              <div className=\"flex items-center justify-center py-12\">\n                <div className=\"w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin\" />\n              </div>\n            ) : !status?.configured ? (\n              <div className=\"text-center py-8\">\n                <div className=\"w-16 h-16 mx-auto mb-4 rounded-full bg-yellow-500/10 flex items-center justify-center\">\n                  <svg className=\"w-8 h-8 text-yellow-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\" />\n                  </svg>\n                </div>\n                <h3 className=\"text-lg font-medium text-white mb-2\">Not Configured</h3>\n                <p className=\"text-gray-400 text-sm max-w-md mx-auto\">\n                  Google Calendar integration requires configuration.\n                  Set <code className=\"px-1.5 py-0.5 rounded bg-white/10 text-xs\">GOOGLE_CLIENT_ID</code> and{' '}\n                  <code className=\"px-1.5 py-0.5 rounded bg-white/10 text-xs\">GOOGLE_CLIENT_SECRET</code> in the server environment.\n                </p>\n              </div>\n            ) : status.accounts.length === 0 ? (\n              <div className=\"text-center py-8\">\n                <div className=\"w-16 h-16 mx-auto mb-4 rounded-full bg-gray-500/10 flex items-center justify-center\">\n                  <svg className=\"w-8 h-8 text-gray-400\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1\" />\n                  </svg>\n                </div>\n                <h3 className=\"text-lg font-medium text-white mb-2\">No Accounts Connected</h3>\n                <p className=\"text-gray-400 text-sm mb-6\">\n                  Connect your Google account to sync calendar events with Squire\n                </p>\n                <button\n                  onClick={handleConnect}\n                  className=\"px-6 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors font-medium flex items-center gap-2 mx-auto\"\n                >\n                  <svg className=\"w-5 h-5\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n                    <path d=\"M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z\" />\n                    <path d=\"M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z\" />\n                    <path d=\"M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z\" />\n                    <path d=\"M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z\" />\n                  </svg>\n                  Connect Google Account\n                </button>\n              </div>\n            ) : (\n              <div className=\"space-y-4\">\n                {status.accounts.map(account => (\n                  <AccountCard\n                    key={account.id}\n                    account={account}\n                    calendars={[]}\n                    onDisconnect={handleDisconnect}\n                    onSync={handleSync}\n                    onCalendarUpdate={handleCalendarUpdate}\n                    syncing={syncing === account.id}\n                  />\n                ))}\n              </div>\n            )}\n          </div>\n\n          {/* Future Integrations Placeholder */}\n          <div className=\"p-6 rounded-xl border border-white/5 bg-white/[0.02]\">\n            <div className=\"flex items-center gap-4\">\n              <div className=\"w-12 h-12 rounded-full bg-gray-500/10 flex items-center justify-center\">\n                <svg className=\"w-6 h-6 text-gray-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 6v6m0 0v6m0-6h6m-6 0H6\" />\n                </svg>\n              </div>\n              <div>\n                <h3 className=\"text-lg font-medium text-gray-400\">More Integrations Coming Soon</h3>\n                <p className=\"text-sm text-gray-500\">Apple Calendar, Outlook, and more</p>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "useSearchParams",
        "status",
        "setStatus",
        "useState",
        "loading",
        "setLoading",
        "syncing",
        "setSyncing",
        "message",
        "setMessage",
        "useCallback",
        "fetch",
        "API_URL",
        "res",
        "data",
        "console",
        "err",
        "useEffect",
        "fetchStatus",
        "searchParams",
        "connected",
        "window",
        "error",
        "confirm",
        "accountId",
        "div",
        "className",
        "a",
        "href",
        "span",
        "h1",
        "p",
        "svg",
        "fill",
        "stroke",
        "viewBox",
        "path",
        "strokeLinecap",
        "strokeLinejoin",
        "strokeWidth",
        "d",
        "button",
        "onClick",
        "h2",
        "handleConnect",
        "h3",
        "code",
        "AccountCard",
        "key",
        "account",
        "calendars",
        "onDisconnect",
        "handleDisconnect",
        "onSync",
        "handleSync",
        "onCalendarUpdate",
        "handleCalendarUpdate"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsLoading:441": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsLoading:441",
      "type": "function",
      "name": "IntegrationsLoading",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/integrations/page.tsx",
      "line": 441,
      "endLine": 456,
      "parentFileId": "file:web/src/app/app/settings/integrations/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": false,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders a loading screen with skeleton placeholders and spinner for integrations page",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "function IntegrationsLoading() {\n  return (\n    <div className=\"min-h-screen bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6\">\n      <div className=\"max-w-3xl mx-auto\">\n        <div className=\"mb-8\">\n          <div className=\"h-4 w-32 bg-gray-700 rounded mb-4\" />\n          <div className=\"h-8 w-48 bg-gray-700 rounded mb-2\" />\n          <div className=\"h-4 w-64 bg-gray-700 rounded\" />\n        </div>\n        <div className=\"flex items-center justify-center py-24\">\n          <div className=\"w-8 h-8 border-2 border-blue-500 border-t-transparent rounded-full animate-spin\" />\n        </div>\n      </div>\n    </div>\n  );\n}",
      "references": [
        "div",
        "className"
      ]
    },
    "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsPage:458": {
      "id": "file:web/src/app/app/settings/integrations/page.tsx:fn:IntegrationsPage:458",
      "type": "function",
      "name": "IntegrationsPage",
      "filePath": "/home/ridgetop/projects/squire/web/src/app/app/settings/integrations/page.tsx",
      "line": 458,
      "endLine": 464,
      "parentFileId": "file:web/src/app/app/settings/integrations/page.tsx",
      "parentClassId": null,
      "params": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "isAsync": false,
      "behavioral": {
        "summary": "Renders IntegrationsContent in Suspense with IntegrationsLoading fallback.",
        "source": "ai",
        "analyzedAt": "2026-01-17T03:22:29.814Z",
        "flags": {
          "databaseRead": false,
          "databaseWrite": false,
          "httpCall": false,
          "fileRead": false,
          "fileWrite": false,
          "sendsNotification": false,
          "modifiesGlobalState": false,
          "hasSideEffects": false
        }
      },
      "source": "export default function IntegrationsPage() {\n  return (\n    <Suspense fallback={<IntegrationsLoading />}>\n      <IntegrationsContent />\n    </Suspense>\n  );\n}",
      "references": [
        "Suspense",
        "fallback",
        "IntegrationsLoading",
        "IntegrationsContent"
      ]
    }
  },
  "connections": [],
  "warnings": [
    {
      "id": "5dad142d-2b6e-4408-b5d3-0d44c404d351",
      "category": "circular_dependency",
      "level": "warning",
      "title": "Circular import: storyEngine.ts  storyCache.ts  storyEngine.ts",
      "description": "These files form a circular dependency chain. This can cause issues with module initialization order and makes the codebase harder to understand.",
      "affectedNodes": [
        "file:src/services/storyEngine.ts",
        "file:src/services/storyCache.ts"
      ],
      "suggestion": {
        "summary": "Break the cycle by extracting shared code into a separate module",
        "reasoning": "Circular dependencies can cause runtime issues and make refactoring difficult. Extract the shared functionality into a new file that both modules can import.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "95649209-3311-4928-9a46-d0ed80fd4ab6",
      "category": "circular_dependency",
      "level": "warning",
      "title": "Circular import: village.ts  models.ts  village.ts",
      "description": "These files form a circular dependency chain. This can cause issues with module initialization order and makes the codebase harder to understand.",
      "affectedNodes": [
        "file:web/src/lib/types/village.ts",
        "file:web/src/lib/village/models.ts"
      ],
      "suggestion": {
        "summary": "Break the cycle by extracting shared code into a separate module",
        "reasoning": "Circular dependencies can cause runtime issues and make refactoring difficult. Extract the shared functionality into a new file that both modules can import.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bacd83b7-8346-49fc-87a9-9819b5a45ac2",
      "category": "orphaned_code",
      "level": "info",
      "title": "Potentially unused function: NoteCardCompact",
      "description": "The function \"NoteCardCompact\" in /home/ridgetop/projects/squire/web/src/components/notes/NoteCard.tsx is not exported and may not be called from anywhere. Consider removing it if unused, or export it if needed elsewhere.",
      "affectedNodes": [
        "file:web/src/components/notes/NoteCard.tsx:fn:NoteCardCompact:167"
      ],
      "suggestion": {
        "summary": "Remove if unused, or export if needed",
        "reasoning": "Dead code increases maintenance burden and can confuse developers. If the function is needed, consider exporting it.",
        "codeExample": "export function NoteCardCompact(...) { ... }",
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6d0b7fde-63bf-4774-993b-4cd122dd902b",
      "category": "orphaned_code",
      "level": "info",
      "title": "Potentially unused function: DistrictGround",
      "description": "The function \"DistrictGround\" in /home/ridgetop/projects/squire/web/src/components/village/DistrictGround.tsx is not exported and may not be called from anywhere. Consider removing it if unused, or export it if needed elsewhere.",
      "affectedNodes": [
        "file:web/src/components/village/DistrictGround.tsx:fn:DistrictGround:81"
      ],
      "suggestion": {
        "summary": "Remove if unused, or export if needed",
        "reasoning": "Dead code increases maintenance burden and can confuse developers. If the function is needed, consider exporting it.",
        "codeExample": "export function DistrictGround(...) { ... }",
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2e25e0dc-0263-4d3f-855f-afce861c9908",
      "category": "orphaned_code",
      "level": "info",
      "title": "Potentially unused function: Fireflies",
      "description": "The function \"Fireflies\" in /home/ridgetop/projects/squire/web/src/components/village/DreamParticles.tsx is not exported and may not be called from anywhere. Consider removing it if unused, or export it if needed elsewhere.",
      "affectedNodes": [
        "file:web/src/components/village/DreamParticles.tsx:fn:Fireflies:209"
      ],
      "suggestion": {
        "summary": "Remove if unused, or export if needed",
        "reasoning": "Dead code increases maintenance burden and can confuse developers. If the function is needed, consider exporting it.",
        "codeExample": "export function Fireflies(...) { ... }",
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "30fc71d4-ad39-476c-aebc-7a262e937cc4",
      "category": "orphaned_code",
      "level": "info",
      "title": "Potentially unused function: updateBeamColor",
      "description": "The function \"updateBeamColor\" in /home/ridgetop/projects/squire/web/src/lib/village/beamShader.ts is not exported and may not be called from anywhere. Consider removing it if unused, or export it if needed elsewhere.",
      "affectedNodes": [
        "file:web/src/lib/village/beamShader.ts:fn:updateBeamColor:138"
      ],
      "suggestion": {
        "summary": "Remove if unused, or export if needed",
        "reasoning": "Dead code increases maintenance burden and can confuse developers. If the function is needed, consider exporting it.",
        "codeExample": "export function updateBeamColor(...) { ... }",
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "dc1fdf9b-7401-471c-abc7-e85b16882e0f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: app",
      "description": "The export \"app\" in src/api/server.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/api/server.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "da952aac-2d7b-45ed-94f6-134cfa00c1c2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: setGoogleSync",
      "description": "The export \"setGoogleSync\" in src/services/commitments.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/commitments.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "33096ab3-bf02-4d3d-a43e-b675e2b22452",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: expandCommitmentOccurrences",
      "description": "The export \"expandCommitmentOccurrences\" in src/services/commitments.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/commitments.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1d2e060e-6cc9-4888-8e44-7bbd5674b6d6",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: isRecurring",
      "description": "The export \"isRecurring\" in src/services/commitments.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/commitments.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "422ea732-5440-47c2-afbf-a919e04d4245",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getPendingCandidates",
      "description": "The export \"getPendingCandidates\" in src/services/commitments.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/commitments.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "f7b7909d-c65a-4d84-a3c9-14d168859a33",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getConversationByClientId",
      "description": "The export \"getConversationByClientId\" in src/services/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2b799a42-f275-40b3-9edf-af2bc11a5f01",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deleteConversation",
      "description": "The export \"deleteConversation\" in src/services/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "68520a32-eb33-436d-9e0c-28172556ca08",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getMessagesUsingMemory",
      "description": "The export \"getMessagesUsingMemory\" in src/services/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6e13537c-5955-4240-a409-a3aa50ee9a48",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getMemoriesUsedInConversation",
      "description": "The export \"getMemoriesUsedInConversation\" in src/services/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "081396dc-ca86-423d-aff3-b3f60ab4c09b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getConversationStats",
      "description": "The export \"getConversationStats\" in src/services/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "dec12996-ad25-41c3-836f-ff58a38296a4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getEdgesForMemory",
      "description": "The export \"getEdgesForMemory\" in src/services/edges.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/edges.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e8318151-022c-44fc-9c92-489690c0b94a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: countEdgesForMemory",
      "description": "The export \"countEdgesForMemory\" in src/services/edges.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/edges.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ba586568-f9c7-4323-b5f2-662b9ffad148",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: findConnectedCluster",
      "description": "The export \"findConnectedCluster\" in src/services/edges.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/edges.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d2ea9603-cb66-4408-b615-1a6bb888075a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: extractEntities",
      "description": "The export \"extractEntities\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "30feb4d3-7847-49b3-a00d-1175348a4f0e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: validateEntityType",
      "description": "The export \"validateEntityType\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "248ab429-0b21-45e2-ae65-243b14a3102d",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: extractEntitiesWithLLM",
      "description": "The export \"extractEntitiesWithLLM\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "267b3dfa-94a8-4893-a297-efb89357a363",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getOrCreateEntity",
      "description": "The export \"getOrCreateEntity\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "606422bb-3fa8-4b5a-99ea-26a2a008bf92",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: createMention",
      "description": "The export \"createMention\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "dab6f81e-8fc2-48d5-bc85-1b4ad3470386",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: createMentionWithRelationship",
      "description": "The export \"createMentionWithRelationship\" in src/services/entities.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6f1c0543-358d-4aba-b1e5-31c2c6d67342",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: generateInsights",
      "description": "The export \"generateInsights\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "dd078faa-d97e-4dd4-a915-70dd1cd52296",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: findSimilarInsight",
      "description": "The export \"findSimilarInsight\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ba5f5612-0f1b-4800-bbf9-6688a5a503a0",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: createInsight",
      "description": "The export \"createInsight\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e514c8d0-765d-4220-9047-9bb824133b27",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: validateInsight",
      "description": "The export \"validateInsight\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "21549cdc-5e86-4755-9869-0a94b0d1d699",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: markStaleInsights",
      "description": "The export \"markStaleInsights\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "aea8606c-67a1-43e4-a4ba-978daef82fa1",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: linkSource",
      "description": "The export \"linkSource\" in src/services/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2596fa6f-a93e-4be8-8ced-07d412a74d7d",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getObjectByHash",
      "description": "The export \"getObjectByHash\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d2193bdd-9958-4f0c-8d44-7dfef0219550",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: updateProcessingStatus",
      "description": "The export \"updateProcessingStatus\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9630c483-347f-4eb5-8a98-51a1f144bcbe",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: STORAGE_TYPES",
      "description": "The export \"STORAGE_TYPES\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9da09223-22bf-4bfb-8bc8-0763d9d4b406",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: OBJECT_SOURCES",
      "description": "The export \"OBJECT_SOURCES\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ae732aae-48de-4ddc-9312-675f4d8a1177",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DETECTION_METHODS",
      "description": "The export \"DETECTION_METHODS\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9318193a-6fde-4837-9853-35f740d0a4a6",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: TAG_SOURCES",
      "description": "The export \"TAG_SOURCES\" in src/services/objects.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e5322ef4-cba7-4d03-a832-8c2e170c20e6",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: unsubscribeById",
      "description": "The export \"unsubscribeById\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "90a365d5-37af-4df0-ab87-b1dbb8cb7119",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deactivateSubscription",
      "description": "The export \"deactivateSubscription\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6589b80c-4b68-4c03-a238-cbcf0e71dea7",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: reactivateSubscription",
      "description": "The export \"reactivateSubscription\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "559d46fa-b82d-41e5-942c-4d3cb5bad6b5",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getSubscription",
      "description": "The export \"getSubscription\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "76291a37-ac26-47e2-b5ad-7c74947819c2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getActiveSubscriptions",
      "description": "The export \"getActiveSubscriptions\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ec2b4a79-dcc9-4798-a0e6-03579da2a925",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: sendToSubscription",
      "description": "The export \"sendToSubscription\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "69da7af5-8099-49cc-a866-3154d96afa85",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: sendToAll",
      "description": "The export \"sendToAll\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "deafa316-9b69-417b-9d59-caf3deed63d7",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: sendById",
      "description": "The export \"sendById\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "738ee773-ede0-4e95-a662-2c5b7c896488",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: sendSimpleNotification",
      "description": "The export \"sendSimpleNotification\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bd732add-90cf-4301-83f6-ff4e40526732",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: cleanupStaleSubscriptions",
      "description": "The export \"cleanupStaleSubscriptions\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "332919ce-b478-4d73-bb89-ac2c18d71eab",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: updateDeviceName",
      "description": "The export \"updateDeviceName\" in src/services/push.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/push.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c9a58045-48b3-417f-aecb-54dde8513ac3",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: checkReinforcementBatch",
      "description": "The export \"checkReinforcementBatch\" in src/services/reinforcement.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/reinforcement.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c711b368-61c5-4b4b-8160-245ae1e13585",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: promoteToSolid",
      "description": "The export \"promoteToSolid\" in src/services/reinforcement.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/reinforcement.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "0772c692-37f5-49fa-a456-3a634ce7a54d",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: demoteToHypothesis",
      "description": "The export \"demoteToHypothesis\" in src/services/reinforcement.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/reinforcement.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1e19e225-3398-4952-aeb6-a0f283eec52e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getTierStats",
      "description": "The export \"getTierStats\" in src/services/reinforcement.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/reinforcement.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "85d39233-5e27-4927-883c-a70ceb6dd2e4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: start",
      "description": "The export \"start\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "fb05cc41-4b95-4341-a8cb-e997f3599ea9",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: stop",
      "description": "The export \"stop\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c15c10ba-0b4a-41d1-ac2f-9f93300ce5ed",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: isRunning",
      "description": "The export \"isRunning\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8141383b-ebf9-4e88-af2c-f1c46024e9aa",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getStats",
      "description": "The export \"getStats\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d2a9c0b4-a5f1-4f09-aefe-794f848c7bf8",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: resetStats",
      "description": "The export \"resetStats\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9953b739-4ffd-42bc-a6e6-3430de14aba4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: runOnce",
      "description": "The export \"runOnce\" in src/services/scheduler.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/scheduler.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8a1b1b10-8e25-4408-9831-f4e2b5018be1",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: broadcastMemoryCreated",
      "description": "The export \"broadcastMemoryCreated\" in src/api/socket/handlers.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/api/socket/handlers.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "a482bbfb-ae0c-47ba-a061-4e467eb8e5f6",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: broadcastInsightCreated",
      "description": "The export \"broadcastInsightCreated\" in src/api/socket/handlers.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/api/socket/handlers.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "75997679-19de-4ffa-9a1f-16938f3d84c2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: extractEphemeral",
      "description": "The export \"extractEphemeral\" in src/services/documents/ephemeral.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/ephemeral.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "067f8820-65dd-46f1-b3e2-afe8714e6d9d",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: clearCaches",
      "description": "The export \"clearCaches\" in src/services/documents/ephemeral.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/ephemeral.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "3ca18994-de08-49bb-af8c-3607b421a540",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: clearDocumentCache",
      "description": "The export \"clearDocumentCache\" in src/services/documents/ephemeral.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/ephemeral.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "cda0aad6-fb0e-447c-9d32-b5e46fbcb7fd",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: extractDocument",
      "description": "The export \"extractDocument\" in src/services/documents/extractor.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/extractor.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "572e919c-6984-4545-ba31-8c39f14f0561",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: extractFromFile",
      "description": "The export \"extractFromFile\" in src/services/documents/extractor.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/extractor.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "71b36ba8-fda2-49fb-b8e0-183511efbe58",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: searchDocuments",
      "description": "The export \"searchDocuments\" in src/services/documents/search.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/search.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c6fc4d12-fbb2-43f0-8735-e3f156815ccc",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deleteEventFromGoogle",
      "description": "The export \"deleteEventFromGoogle\" in src/services/google/events.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/google/events.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9dfb7f50-abdc-4645-a875-90ff93ed9163",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getEvents",
      "description": "The export \"getEvents\" in src/services/google/events.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/google/events.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2ce56363-dd66-41ec-9e75-63cc6194bc08",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: linkEventToCommitment",
      "description": "The export \"linkEventToCommitment\" in src/services/google/events.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/google/events.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "0f912e69-4aa1-48b4-8f1e-c285fcbb744a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: detectConflict",
      "description": "The export \"detectConflict\" in src/services/google/events.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/google/events.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6be8e22b-c487-4de8-abbb-842e7b54a1e7",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: generateChunkEmbeddings",
      "description": "The export \"generateChunkEmbeddings\" in src/services/documents/chunker/chunkEmbedding.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkEmbedding.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8d49332a-e98a-4015-90c2-f626b87f39d4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: embedAndStoreChunks",
      "description": "The export \"embedAndStoreChunks\" in src/services/documents/chunker/chunkEmbedding.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkEmbedding.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1123a958-c8e1-4699-85d2-1f864f3c6fbc",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: storeChunks",
      "description": "The export \"storeChunks\" in src/services/documents/chunker/chunkStorage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkStorage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "36833045-7ed4-47a5-bea0-7b35788b1399",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deleteChunksByObjectId",
      "description": "The export \"deleteChunksByObjectId\" in src/services/documents/chunker/chunkStorage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkStorage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "7d28ef44-829d-4859-b2fd-9040fa5df493",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: searchChunksByText",
      "description": "The export \"searchChunksByText\" in src/services/documents/chunker/chunkStorage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkStorage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "efd61210-aae9-4a91-aab4-22a70c37dd10",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getChunkStats",
      "description": "The export \"getChunkStats\" in src/services/documents/chunker/chunkStorage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/chunkStorage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "fc855f73-b1c0-4f32-8fb3-ff3c41a8a36b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fixedChunker",
      "description": "The export \"fixedChunker\" in src/services/documents/chunker/fixedChunker.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/fixedChunker.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "29135020-22f7-4f08-abe8-f64bff1bd4cd",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: hybridChunker",
      "description": "The export \"hybridChunker\" in src/services/documents/chunker/hybridChunker.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/hybridChunker.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2e4e65bc-cbff-469e-b8ff-6e6ed19f7927",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: semanticChunker",
      "description": "The export \"semanticChunker\" in src/services/documents/chunker/semanticChunker.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/semanticChunker.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "87b8881a-d605-45dc-a76d-afe944a7e872",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: chunkToRow",
      "description": "The export \"chunkToRow\" in src/services/documents/chunker/types.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/types.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9c8238af-16b6-4f6d-bfd2-9518d3327f6f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: CHUNKING_STRATEGIES",
      "description": "The export \"CHUNKING_STRATEGIES\" in src/services/documents/chunker/types.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/types.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "f1f8584b-689c-429a-8d52-6178fc5430ce",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: CHUNKING_ERROR_CODES",
      "description": "The export \"CHUNKING_ERROR_CODES\" in src/services/documents/chunker/types.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/chunker/types.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "a5eb66c8-7c9f-4ef7-af95-e9a14fd144c4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: storeFact",
      "description": "The export \"storeFact\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9ffae160-afd6-4fda-ad0e-9547cf6cdf3f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getFactsByChunk",
      "description": "The export \"getFactsByChunk\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e4502c74-66a7-44d8-958e-38e7bd5e3f8e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: linkFactToMemory",
      "description": "The export \"linkFactToMemory\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "4814e705-553d-40ad-aedc-afbc7b93ec8c",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: mergeFacts",
      "description": "The export \"mergeFacts\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "4c673445-023b-4c4e-b251-1080c3330d91",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deleteFactsByDocument",
      "description": "The export \"deleteFactsByDocument\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "cd83766d-8d17-414b-aa36-c2f6a548f3a2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: deleteFactsByChunk",
      "description": "The export \"deleteFactsByChunk\" in src/services/documents/factExtraction/storage.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "95771007-f30b-4b5c-a4bc-069acf1fbcc3",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: MemoryCard",
      "description": "The export \"MemoryCard\" in web/src/components/cards/MemoryCard.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/cards/MemoryCard.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bce7e15a-511c-43bf-9af0-ce8bc55a4cfd",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ContextualMemoryOverlayStack",
      "description": "The export \"ContextualMemoryOverlayStack\" in web/src/components/chat/ContextualMemoryOverlayStack.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/chat/ContextualMemoryOverlayStack.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d8bbecac-ffd5-4309-910c-ef5b9287ab08",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: BeliefsPanel",
      "description": "The export \"BeliefsPanel\" in web/src/components/dashboard/BeliefsPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/BeliefsPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "dd5cf068-d046-428b-81b7-6a16b72a3d07",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: BottomSheet",
      "description": "The export \"BottomSheet\" in web/src/components/dashboard/BottomSheet.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/BottomSheet.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e4e97da4-ef54-4832-a556-5f431f8762ae",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DashboardPanel",
      "description": "The export \"DashboardPanel\" in web/src/components/dashboard/DashboardPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/DashboardPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "89814d07-aa62-4085-bb74-83f1ec4cbee2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DetailModal",
      "description": "The export \"DetailModal\" in web/src/components/dashboard/DetailModal.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/DetailModal.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "69d5c29e-bb46-432e-b892-521584b943d8",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: EntitiesPanel",
      "description": "The export \"EntitiesPanel\" in web/src/components/dashboard/EntitiesPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/EntitiesPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "45705cac-ea1f-4a48-9942-aef64e0175fb",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: InsightsPanel",
      "description": "The export \"InsightsPanel\" in web/src/components/dashboard/InsightsPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/InsightsPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2904427c-e907-48e7-8658-40ba78e28ea8",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: LivingSummaryPanel",
      "description": "The export \"LivingSummaryPanel\" in web/src/components/dashboard/LivingSummaryPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/LivingSummaryPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "729fe5e7-b19b-49ef-957d-ab3da2349ab3",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: PatternsPanel",
      "description": "The export \"PatternsPanel\" in web/src/components/dashboard/PatternsPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/PatternsPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "3ad595c5-869d-4cab-98cb-506b196671ee",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: TodayPanel",
      "description": "The export \"TodayPanel\" in web/src/components/dashboard/TodayPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/dashboard/TodayPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ae563fcb-4813-4f11-a969-b99b768ded1c",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DocumentCard",
      "description": "The export \"DocumentCard\" in web/src/components/documents/DocumentCard.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/DocumentCard.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "a61fd1b8-acad-4632-84a3-c65efccffd1e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DocumentDetail",
      "description": "The export \"DocumentDetail\" in web/src/components/documents/DocumentDetail.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/DocumentDetail.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "3d4dbe24-aa56-4149-bd85-85a87e9ce54c",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DocumentList",
      "description": "The export \"DocumentList\" in web/src/components/documents/DocumentList.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/DocumentList.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "da40df0b-cdfe-40e2-af42-5c4e87b7c783",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DocumentSearch",
      "description": "The export \"DocumentSearch\" in web/src/components/documents/DocumentSearch.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/DocumentSearch.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "7ae1e3be-b687-4a15-bdb5-0c2795fb7685",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DocumentUpload",
      "description": "The export \"DocumentUpload\" in web/src/components/documents/DocumentUpload.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/DocumentUpload.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "a2aac242-0510-4b93-9a0e-326494ef1e20",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: FactReviewCard",
      "description": "The export \"FactReviewCard\" in web/src/components/documents/FactReviewCard.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/FactReviewCard.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "0c5acb35-d21f-4ac3-bc59-94cb0ddc1b1a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: FactReviewList",
      "description": "The export \"FactReviewList\" in web/src/components/documents/FactReviewList.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/FactReviewList.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "7850b5e0-69ef-4454-bb2f-77d4e50ed90b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: FactReviewPanel",
      "description": "The export \"FactReviewPanel\" in web/src/components/documents/FactReviewPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/documents/FactReviewPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8abb9d88-504a-42f3-bab1-60818d015235",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: GraphContextMenu",
      "description": "The export \"GraphContextMenu\" in web/src/components/graph/GraphContextMenu.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/graph/GraphContextMenu.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d8168650-c75d-4424-8497-242ea7c66cf2",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: GraphControls",
      "description": "The export \"GraphControls\" in web/src/components/graph/GraphControls.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/graph/GraphControls.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "28134036-47c9-404b-8398-40f49f00c82b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: SelectionDetailsPanel",
      "description": "The export \"SelectionDetailsPanel\" in web/src/components/graph/SelectionDetailsPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/graph/SelectionDetailsPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b4701598-492a-4247-9cde-663a31021d5a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: OverlayPortal",
      "description": "The export \"OverlayPortal\" in web/src/components/layout/OverlayPortal.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/layout/OverlayPortal.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "825df9f0-bce6-485b-be78-b941bfd2db40",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ActiveListsPanel",
      "description": "The export \"ActiveListsPanel\" in web/src/components/lists/ActiveListsPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ActiveListsPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "768d3ce8-3d5a-4a83-9203-7531c4f3b19e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListCard",
      "description": "The export \"ListCard\" in web/src/components/lists/ListCard.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListCard.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "de9567a2-9896-433e-ad1d-574800df5338",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListDetailView",
      "description": "The export \"ListDetailView\" in web/src/components/lists/ListDetailView.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListDetailView.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "77028a0b-9d9e-4da9-b917-48ef770a8aed",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListEditor",
      "description": "The export \"ListEditor\" in web/src/components/lists/ListEditor.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListEditor.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bf21d348-b9fe-4a5a-93f5-73c680f77f4e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListItemRow",
      "description": "The export \"ListItemRow\" in web/src/components/lists/ListItemRow.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListItemRow.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "56ba42a4-806e-44b5-b809-3b362382e887",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListsList",
      "description": "The export \"ListsList\" in web/src/components/lists/ListsList.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListsList.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "90fed971-b52d-4140-9d35-4712f2cb58a0",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: ListView",
      "description": "The export \"ListView\" in web/src/components/lists/ListView.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/lists/ListView.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "cd2d19b1-8992-4737-be97-0c27f1d01c8b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: EntityPicker",
      "description": "The export \"EntityPicker\" in web/src/components/notes/EntityPicker.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notes/EntityPicker.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d9bcb0a8-5c78-4c85-aa11-632e85321c7f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: NoteCard",
      "description": "The export \"NoteCard\" in web/src/components/notes/NoteCard.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notes/NoteCard.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "350ba7cc-415e-4ece-9980-b3c4d035f6fa",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: NoteEditor",
      "description": "The export \"NoteEditor\" in web/src/components/notes/NoteEditor.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notes/NoteEditor.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ab8f07b4-7a91-4a1b-8c9e-9266921b92e4",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: NotesList",
      "description": "The export \"NotesList\" in web/src/components/notes/NotesList.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notes/NotesList.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2ac978d8-5d29-4301-a2a0-5bd5fafa63ef",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: PinnedNotesPanel",
      "description": "The export \"PinnedNotesPanel\" in web/src/components/notes/PinnedNotesPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notes/PinnedNotesPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6be0f1fb-ebe0-4d2c-bce4-c1cce11a52f5",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: PushPermission",
      "description": "The export \"PushPermission\" in web/src/components/notifications/PushPermission.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/notifications/PushPermission.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b263e1de-2bb5-40cf-ae50-effaddd7fc68",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: AuroraSky",
      "description": "The export \"AuroraSky\" in web/src/components/village/AuroraSky.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/AuroraSky.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "50b0f7d3-4eef-407b-b9c3-33c575411191",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: BuildingsLayer",
      "description": "The export \"BuildingsLayer\" in web/src/components/village/Building.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/Building.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "05bfc8bc-abc6-4cb6-adb1-6e31d763aad7",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: BuildingModel",
      "description": "The export \"BuildingModel\" in web/src/components/village/BuildingModel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/BuildingModel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "638bd433-55fa-41d7-bed8-595bb46be5f0",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: VillageGround",
      "description": "The export \"VillageGround\" in web/src/components/village/DistrictGround.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/DistrictGround.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "93ec812b-f2e0-49b8-99ae-7f1d619d6e79",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DreamEffects",
      "description": "The export \"DreamEffects\" in web/src/components/village/DreamEffects.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/DreamEffects.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b5d52a65-759b-4e72-b47d-056c155c3089",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DreamEffects",
      "description": "The export \"DreamEffects\" in web/src/components/village/DreamEffects.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/DreamEffects.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "cf2b0271-ff7e-4349-a7ce-aa435982deb5",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DreamLighting",
      "description": "The export \"DreamLighting\" in web/src/components/village/DreamLighting.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/DreamLighting.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "f2bb4cc4-ca51-42f4-ac1e-4c1fb94bcd32",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: DreamParticles",
      "description": "The export \"DreamParticles\" in web/src/components/village/DreamParticles.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/DreamParticles.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "4aa046f7-6418-4be1-9dc4-55794738fdc9",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: FirstPersonControls",
      "description": "The export \"FirstPersonControls\" in web/src/components/village/FirstPersonControls.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/FirstPersonControls.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1685bc04-342b-4ea9-8ac9-b75c275d8a2a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: GroundMist",
      "description": "The export \"GroundMist\" in web/src/components/village/GroundMist.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/GroundMist.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "aa04d769-2aad-42ee-876f-4c13170849fa",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: HexTilesLayer",
      "description": "The export \"HexTilesLayer\" in web/src/components/village/HexTile.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/HexTile.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "92672941-72d9-4116-b0e1-3f0dfeb568cf",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: PropsLayer",
      "description": "The export \"PropsLayer\" in web/src/components/village/InstancedProps.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/InstancedProps.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9224ffa8-fc74-417e-a12d-9a094946d15a",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: LightBeamsLayer",
      "description": "The export \"LightBeamsLayer\" in web/src/components/village/LightBeamRoad.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/LightBeamRoad.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b0d9b0cd-8869-41bb-9a2c-687de1107bca",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: MemoryPanel",
      "description": "The export \"MemoryPanel\" in web/src/components/village/MemoryPanel.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/MemoryPanel.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1b06b83f-bb7f-4e01-8172-e5beb1509f89",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: MistPuffs",
      "description": "The export \"MistPuffs\" in web/src/components/village/MistPuffs.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/MistPuffs.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "57e3c915-6181-43c8-8c41-60adb84bc031",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: RoadsLayer",
      "description": "The export \"RoadsLayer\" in web/src/components/village/Road.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/Road.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "5be135c0-4369-4f80-a406-97ca1fd14a1f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: RoadsLayer",
      "description": "The export \"RoadsLayer\" in web/src/components/village/Road.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/Road.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c1636cf5-4ded-4be9-9742-8de9bd4f86d3",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: VillageCanvas",
      "description": "The export \"VillageCanvas\" in web/src/components/village/VillageCanvas.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/VillageCanvas.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "1f8c8893-6a41-4fda-bd19-9477f93a5d6b",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: VillagersLayer",
      "description": "The export \"VillagersLayer\" in web/src/components/village/Villager.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/Villager.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "c7b9e866-2bdf-48cd-84c5-3fb959ab0195",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: VillageScene",
      "description": "The export \"VillageScene\" in web/src/components/village/VillageScene.tsx is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/components/village/VillageScene.tsx"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "23417350-d881-4285-85ed-78dd1ee87abb",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchBelief",
      "description": "The export \"fetchBelief\" in web/src/lib/api/beliefs.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/beliefs.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6df6a21d-d286-4293-80dd-4b7f7be8da48",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchBeliefsByCategory",
      "description": "The export \"fetchBeliefsByCategory\" in web/src/lib/api/beliefs.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/beliefs.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6e8c169c-bf4d-43ff-aca0-7c0c139677e8",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchBeliefConflicts",
      "description": "The export \"fetchBeliefConflicts\" in web/src/lib/api/beliefs.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/beliefs.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ba3fbcab-a244-4eff-a9ee-9706317f9560",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getConsolidationStats",
      "description": "The export \"getConsolidationStats\" in web/src/lib/api/consolidation.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/consolidation.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "da84c70f-efac-42ae-9092-a4d7737c8420",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: listContextProfiles",
      "description": "The export \"listContextProfiles\" in web/src/lib/api/context.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/context.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "147b3a47-1cbb-4691-9255-bcfb7eddeecd",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: updateConversation",
      "description": "The export \"updateConversation\" in web/src/lib/api/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bcf98c65-b858-4539-a754-22bafb688595",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: archiveConversation",
      "description": "The export \"archiveConversation\" in web/src/lib/api/conversations.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/conversations.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "334b700f-e612-4ca6-845b-ca9e4fd604dc",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: getDocument",
      "description": "The export \"getDocument\" in web/src/lib/api/documents.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/documents.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "522f8ea5-ce77-4318-a7f6-189c5053236f",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchInsight",
      "description": "The export \"fetchInsight\" in web/src/lib/api/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "a132331e-696f-4534-b651-564bbff32d86",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchInsightStats",
      "description": "The export \"fetchInsightStats\" in web/src/lib/api/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9d9c7ace-329e-4a1c-b480-4be3aac46672",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: fetchInsightsByType",
      "description": "The export \"fetchInsightsByType\" in web/src/lib/api/insights.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/api/insights.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2760f071-10b5-43b1-a09f-e6fd1e800cc9",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useMemorySubgraph",
      "description": "The export \"useMemorySubgraph\" in web/src/lib/hooks/useGraphData.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/hooks/useGraphData.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8d4526ea-a9ba-418f-9667-273ab57b2b9e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useNavigationGuard",
      "description": "The export \"useNavigationGuard\" in web/src/lib/hooks/useNavigationGuard.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/hooks/useNavigationGuard.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8e73058d-94de-42f2-8473-1784c54fa2b8",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: usePattern",
      "description": "The export \"usePattern\" in web/src/lib/hooks/usePatterns.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/hooks/usePatterns.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b3ddbc2e-44e6-449b-b5ca-5a36ce837c13",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useSummaryStats",
      "description": "The export \"useSummaryStats\" in web/src/lib/hooks/useSummaries.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/hooks/useSummaries.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "94174cb8-c674-4fe4-9536-1ffea20e2b2e",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useCameraStore",
      "description": "The export \"useCameraStore\" in web/src/lib/stores/cameraStore.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/stores/cameraStore.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "473341a2-f894-4fee-b925-f3bea477cb90",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useIsLoading",
      "description": "The export \"useIsLoading\" in web/src/lib/stores/chatStore.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/stores/chatStore.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "5d025149-2c88-4008-a16b-4417e313c978",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useIsChatBusy",
      "description": "The export \"useIsChatBusy\" in web/src/lib/stores/chatStore.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/stores/chatStore.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8d2bb18b-c1da-4907-b74d-e15d5bf7da98",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: useOverlayStore",
      "description": "The export \"useOverlayStore\" in web/src/lib/stores/overlayStore.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/stores/overlayStore.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "def39898-eb49-4b8f-8100-1af262aa5504",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: formatDate",
      "description": "The export \"formatDate\" in web/src/lib/utils/formatting.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/utils/formatting.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "97dea8b1-eca2-4311-9808-818d79e1f48c",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: formatTime",
      "description": "The export \"formatTime\" in web/src/lib/utils/formatting.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/utils/formatting.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d51336a7-5e26-4f78-adaa-98ecca2d0c56",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: truncate",
      "description": "The export \"truncate\" in web/src/lib/utils/formatting.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/utils/formatting.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "94931152-5ecb-4682-b52f-715eb793e9b3",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: BUILDING_MODEL_CONFIGS",
      "description": "The export \"BUILDING_MODEL_CONFIGS\" in web/src/lib/village/models.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/village/models.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "6912ed82-28d0-44d5-a891-c95a20710bc5",
      "category": "unused_export",
      "level": "info",
      "title": "Unused export: PROP_MODEL_CONFIGS",
      "description": "The export \"PROP_MODEL_CONFIGS\" in web/src/lib/village/models.ts is not imported anywhere in the project. It may be dead code or intended for external use.",
      "affectedNodes": [
        "file:web/src/lib/village/models.ts"
      ],
      "suggestion": {
        "summary": "Remove export if unused, or document if public API",
        "reasoning": "Unused exports can indicate dead code. If this is part of a public API, consider documenting it.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "96883616-c57c-42db-89cc-2caa5ae80e4e",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: cli.ts (2711 lines)",
      "description": "The file src/cli.ts has 2711 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/cli.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "bf71696f-13cf-4aec-b964-a2fce1acd567",
      "category": "large_file",
      "level": "info",
      "title": "Large file: llm.ts (524 lines)",
      "description": "The file src/providers/llm.ts has 524 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/providers/llm.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "f47eee2f-3d0c-410b-bf0e-dc812240a7ec",
      "category": "large_file",
      "level": "info",
      "title": "Large file: beliefs.ts (686 lines)",
      "description": "The file src/services/beliefs.ts has 686 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/beliefs.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8b9164f5-7c15-4ea4-8fc7-b539a723273a",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: chatExtraction.ts (1992 lines)",
      "description": "The file src/services/chatExtraction.ts has 1992 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/chatExtraction.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "86de6661-8f6f-4dd2-a91d-3c658c5d5a45",
      "category": "large_file",
      "level": "info",
      "title": "Large file: commitments.ts (948 lines)",
      "description": "The file src/services/commitments.ts has 948 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/commitments.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "7347033a-263d-40af-9b9e-2d61d3867db2",
      "category": "large_file",
      "level": "info",
      "title": "Large file: consolidation.ts (558 lines)",
      "description": "The file src/services/consolidation.ts has 558 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/consolidation.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d317076d-201c-4160-9d32-1accbf702dbe",
      "category": "large_file",
      "level": "info",
      "title": "Large file: context.ts (890 lines)",
      "description": "The file src/services/context.ts has 890 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/context.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "ae8b8d9c-72f2-4b3c-91e0-2131116eddb3",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: entities.ts (1191 lines)",
      "description": "The file src/services/entities.ts has 1191 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/entities.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2f5b4c1f-bb27-4c86-a81a-8dca984a6840",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: graph.ts (1059 lines)",
      "description": "The file src/services/graph.ts has 1059 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/graph.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "71deddfb-fd6b-417b-814d-1560267b3c70",
      "category": "large_file",
      "level": "info",
      "title": "Large file: insights.ts (761 lines)",
      "description": "The file src/services/insights.ts has 761 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/insights.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "d2b8d8da-a4ff-4e1d-9287-097f29ec4760",
      "category": "large_file",
      "level": "info",
      "title": "Large file: lists.ts (837 lines)",
      "description": "The file src/services/lists.ts has 837 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/lists.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "30e5a044-fec7-4b2c-9c2f-904973e87e96",
      "category": "large_file",
      "level": "info",
      "title": "Large file: notes.ts (599 lines)",
      "description": "The file src/services/notes.ts has 599 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/notes.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "5bcd94aa-1b22-46ce-b6e3-0e9dc6429399",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: objects.ts (1043 lines)",
      "description": "The file src/services/objects.ts has 1043 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/objects.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "58165a3d-fa2b-4bc1-abb4-ef260c597af1",
      "category": "large_file",
      "level": "info",
      "title": "Large file: patterns.ts (567 lines)",
      "description": "The file src/services/patterns.ts has 567 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/patterns.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "cefaba4c-6440-4f23-9cf8-bb0e27e31f58",
      "category": "large_file",
      "level": "info",
      "title": "Large file: reminders.ts (626 lines)",
      "description": "The file src/services/reminders.ts has 626 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/reminders.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8df6c170-0e1c-46d0-9dc9-bad74d2cb38c",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: research.ts (1427 lines)",
      "description": "The file src/services/research.ts has 1427 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/research.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "f944a6eb-34b2-454c-928e-3acbc05bfee4",
      "category": "large_file",
      "level": "info",
      "title": "Large file: storyEngine.ts (512 lines)",
      "description": "The file src/services/storyEngine.ts has 512 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/storyEngine.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "e01c5421-7323-48dc-9192-edb790606a1f",
      "category": "large_file",
      "level": "info",
      "title": "Large file: summaries.ts (652 lines)",
      "description": "The file src/services/summaries.ts has 652 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/summaries.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9f2970ac-6e3a-42b7-ae8c-50f0399c693c",
      "category": "large_file",
      "level": "info",
      "title": "Large file: calendar.ts (617 lines)",
      "description": "The file src/tools/calendar.ts has 617 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/tools/calendar.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "830b6643-dc1c-4254-a707-73865f194a8f",
      "category": "large_file",
      "level": "info",
      "title": "Large file: lists.ts (577 lines)",
      "description": "The file src/tools/lists.ts has 577 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/tools/lists.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "530d7bda-8327-4d4a-8109-d5f45e5d2b50",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: documents.ts (1230 lines)",
      "description": "The file src/api/routes/documents.ts has 1230 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/routes/documents.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "37b4f103-3da9-43d8-9b2e-4453c338380f",
      "category": "large_file",
      "level": "info",
      "title": "Large file: graph.ts (521 lines)",
      "description": "The file src/api/routes/graph.ts has 521 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/routes/graph.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "082a61c6-f584-4b35-aae2-2eb8c7181208",
      "category": "large_file",
      "level": "info",
      "title": "Large file: lists.ts (626 lines)",
      "description": "The file src/api/routes/lists.ts has 626 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/routes/lists.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "fe6a1032-e973-43c4-9c53-bf62559c8b5f",
      "category": "large_file",
      "level": "info",
      "title": "Large file: objects.ts (760 lines)",
      "description": "The file src/api/routes/objects.ts has 760 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/routes/objects.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2d96fa95-2c72-4c06-8b0e-706e733398de",
      "category": "large_file",
      "level": "info",
      "title": "Large file: research.ts (574 lines)",
      "description": "The file src/api/routes/research.ts has 574 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/routes/research.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "4755ec8c-fff9-4fc4-9db7-d3c7fb1a4cb4",
      "category": "large_file",
      "level": "warning",
      "title": "Large file: handlers.ts (1193 lines)",
      "description": "The file src/api/socket/handlers.ts has 1193 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/api/socket/handlers.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "2e1bff92-6ce6-45e5-87c6-3af89d7132f3",
      "category": "large_file",
      "level": "info",
      "title": "Large file: events.ts (586 lines)",
      "description": "The file src/services/google/events.ts has 586 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/google/events.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "aa6febcb-fb55-484a-8870-4f4717ccda77",
      "category": "large_file",
      "level": "info",
      "title": "Large file: storage.ts (556 lines)",
      "description": "The file src/services/documents/factExtraction/storage.ts has 556 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:src/services/documents/factExtraction/storage.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b296d865-ee22-4aae-9582-caafb34deb0e",
      "category": "large_file",
      "level": "info",
      "title": "Large file: VillageCanvas.tsx (520 lines)",
      "description": "The file web/src/components/village/VillageCanvas.tsx has 520 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/components/village/VillageCanvas.tsx"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "0d50c7f1-b680-4220-bc74-4d3e42bec62e",
      "category": "large_file",
      "level": "info",
      "title": "Large file: chatStore.ts (639 lines)",
      "description": "The file web/src/lib/stores/chatStore.ts has 639 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/lib/stores/chatStore.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "5cc78a49-a082-479e-a486-411308f73844",
      "category": "large_file",
      "level": "info",
      "title": "Large file: index.ts (854 lines)",
      "description": "The file web/src/lib/types/index.ts has 854 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/lib/types/index.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "8c54b50e-e266-4b16-ba9f-3bca4b4df970",
      "category": "large_file",
      "level": "info",
      "title": "Large file: layout.ts (690 lines)",
      "description": "The file web/src/lib/village/layout.ts has 690 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/lib/village/layout.ts"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "b4d44515-abfe-44a7-a056-2247cb3e3456",
      "category": "large_file",
      "level": "info",
      "title": "Large file: page.tsx (774 lines)",
      "description": "The file web/src/app/app/calendar/page.tsx has 774 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/app/app/calendar/page.tsx"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "9e1c24d0-2af8-48bc-8079-b63d02f6c13b",
      "category": "large_file",
      "level": "info",
      "title": "Large file: page.tsx (568 lines)",
      "description": "The file web/src/app/app/graph/page.tsx has 568 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/app/app/graph/page.tsx"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "52cc814d-e71e-44a8-930f-087c1abba923",
      "category": "large_file",
      "level": "info",
      "title": "Large file: page.tsx (574 lines)",
      "description": "The file web/src/app/app/reminders/page.tsx has 574 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/app/app/reminders/page.tsx"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    },
    {
      "id": "afdb3ff6-5a56-4a4c-8a0d-48689f5958f0",
      "category": "large_file",
      "level": "info",
      "title": "Large file: page.tsx (687 lines)",
      "description": "The file web/src/app/app/timeline/page.tsx has 687 lines, exceeding the threshold of 500. Large files are harder to maintain and understand.",
      "affectedNodes": [
        "file:web/src/app/app/timeline/page.tsx"
      ],
      "suggestion": {
        "summary": "Consider splitting into smaller, focused modules",
        "reasoning": "Smaller files are easier to understand, test, and maintain. Look for logical groupings of functionality that could be extracted.",
        "codeExample": null,
        "autoFixable": false
      },
      "detectedAt": "2026-01-17T03:22:05.854Z"
    }
  ],
  "clusters": [],
  "errors": [
    {
      "filePath": "web/public/sw.js",
      "line": null,
      "message": "Failed to parse file: Cannot read properties of undefined (reading 'escapedName')",
      "recoverable": true
    },
    {
      "filePath": "web/scripts/gen-icons.js",
      "line": null,
      "message": "Failed to parse file: Cannot read properties of undefined (reading 'escapedName')",
      "recoverable": true
    }
  ]
}